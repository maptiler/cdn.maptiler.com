{"version":3,"file":"maptiler-marker-layout.umd.min.js","sources":["../src/markerlayout.ts"],"sourcesContent":["import type {\n  LngLatLike,\n  Map as MapSDK,\n  MapGeoJSONFeature,\n} from \"@maptiler/sdk\";\n\nimport packagejson from \"../package.json\";\n\n/**\n * How the markers are anchored to a given point\n */\nexport type MarkerAnchor = \"center\" | \"top\" | \"bottom\" | \"left\" | \"right\";\n\n/**\n * Minimalist set of properties that represent a marker\n */\nexport type AbstractMarker = {\n  /**\n   * Unique ID of a marker, most likely the ID of a geojson feature (from a vector tile)\n   */\n  id: number;\n\n  /**\n   * Position in screenspace of the top-left corner [x, y]\n   */\n  position: [number, number];\n\n  /**\n   * Size in screen space [width, height]\n   */\n  size: [number, number];\n\n  /**\n   * The feature represented by the marker\n   */\n  features: MapGeoJSONFeature[];\n\n  /**\n   * Size of each internal elements (useful for when a marker contain information about multiple feature)\n   */\n  internalElementSize: [number, number];\n};\n\n/**\n * Hash map of AbstractMarker where IDs are unique and likely to come from vector tiles\n */\nexport type MarkerMap = Map<number, AbstractMarker>;\n\n/**\n * Status of the marker compared to the previous status\n */\nexport type MarkerStatus = {\n  /**\n   * The markers that were added since the last update\n   */\n  new: MarkerMap;\n\n  /**\n   * The markers that were already present in the last update but had their position changed\n   */\n  updated: MarkerMap;\n\n  /**\n   * The markers that are no longer present since the last update\n   */\n  removed: MarkerMap;\n};\n\nexport type MarkerLayoutOptions = {\n  /**\n   * IDs of layers to query for vector features.\n   * Default: uses all the layers available\n   */\n  layers?: Array<string>;\n\n  /**\n   * Size of the markers on screen space [width, height].\n   * Default: `[150, 50]`\n   */\n  markerSize?: [number, number];\n\n  /**\n   * Maximum number of markers to keep.\n   * Default: no maximum\n   */\n  max?: number;\n\n  /**\n   * Position of the marker relative to its anchor point.\n   * Default: `\"center\"`\n   */\n  markerAnchor?: MarkerAnchor;\n\n  /**\n   * Offset to apply to the marker, in number of pixel, relative to its anchor position.\n   * First element of the array is the horizontal offset where negative shifts towards\n   * the left and positive shifts towards the right.\n   * Second element of the array is the vertical offset where negative shifts towards\n   * the top and positive shifts towards the bottom.\n   * Default: `[0, 0]`\n   */\n  offset?: [number, number];\n\n  /**\n   * A filter function can be provided. Each feature will be tested against this filter function,\n   * and the returned value can be `true` (the feature is kept) or `false` (the feature is discarded).\n   * Default: none\n   */\n  filter?: (feature: MapGeoJSONFeature) => boolean;\n\n  /**\n   * Property to sort the features by. If not provided, the features will not be sorted.\n   * Alternatively, the sorting property can be a function that takes the feature as\n   * argument and returns a number, aka. the sorting value (or rank)\n   * Default: not provided\n   */\n  sortingProperty?: string | ((feature: MapGeoJSONFeature) => number);\n\n  /**\n   * Sorting order, only relevant if the option `.sortingProperty` is provided, or else will be ignored.\n   * Default: `\"ascending\"`\n   */\n  sortingOrder?: \"ascending\" | \"descending\";\n\n  /**\n   * Property to group by. The property must be present in the `properties` object of the feature\n   * unless the value of `groupBy` is equal to `\"coordinates\"`, then the geometry coordinates are\n   * being used.\n   * Default: no grouping\n   */\n  groupBy?: string;\n\n  /**\n   * Markers can contain multiple features, this parameter can be set to have a strict limit.\n   * Default: `Infinity`\n   */\n  maxNbFeaturesPerMarker?: number;\n\n  /**\n   * When a marker contains multiple features, its size can get bigger. This number is the max ratio applied to the\n   * defined `markerSize`. Intentionnaly non-integer so that the user can see there is still half an element to\n   * show at the bottom and undestand they can scroll for more.\n   * Default: `2.5`\n   */\n  maxRatioUnitSize?: number;\n};\n\nexport type FeatureGroup = {\n  groupKey: string | number | boolean;\n  features: MapGeoJSONFeature[];\n};\n\nfunction computeFeatureGroupId(features: MapGeoJSONFeature[]): number {\n  const ids = features.map((f: MapGeoJSONFeature) => f.id);\n  ids.sort();\n  const idsStr = ids.join(\"_\");\n\n  let hash = 0;\n  for (let i = 0; i < idsStr.length; i++) {\n    const char = idsStr.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nfunction getPointfeatureCoordinateHash(feature: MapGeoJSONFeature): string {\n  if (feature.geometry.type !== \"Point\") {\n    return \"\";\n  }\n\n  const fArr = new Float32Array(feature.geometry.coordinates.slice(0, 2));\n  const uiArr = new Uint8Array(fArr.buffer);\n  return uiArr.join(\"_\");\n}\n\nfunction doesCollide(a: AbstractMarker, b: AbstractMarker): boolean {\n  return !(\n    b.position[0] > a.position[0] + a.size[0] ||\n    b.position[0] + b.size[0] < a.position[0] ||\n    b.position[1] > a.position[1] + a.size[1] ||\n    b.position[1] + b.size[1] < a.position[1]\n  );\n}\n\nfunction doesCollideWithAny(\n  marker: AbstractMarker,\n  manyMarkers: MarkerMap,\n): boolean {\n  const markers = manyMarkers.values();\n  for (const hitTestMarker of markers) {\n    if (doesCollide(marker, hitTestMarker)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport class MarkerLayout {\n  /**\n   * Style layer IDs to keep\n   */\n  private layers: Array<string> | undefined;\n  private markerSize: [number, number];\n  private markerAnchor: MarkerAnchor;\n  private map: MapSDK;\n  private lastStatus: MarkerStatus;\n  private max: number | null;\n  private offset: [number, number] = [0, 0];\n\n  /**\n   * This is a concat of lastStatus.new and lastStatus.updated\n   * only for optimisation purposes\n   */\n  private lastPresent: MarkerMap;\n  private filter: null | ((feature: MapGeoJSONFeature) => boolean) = null;\n  private groupBy: string | null = null;\n  private maxRatioUnitSize: number;\n  private sortingProperty: string | ((feature: MapGeoJSONFeature) => number) =\n    \"\";\n  private sortingOrder = 1;\n  private maxNbFeaturesPerMarker: number = Number.POSITIVE_INFINITY;\n\n  constructor(map: MapSDK, options: MarkerLayoutOptions = {}) {\n    map.telemetry.registerModule(packagejson.name, packagejson.version);\n\n    this.map = map;\n    this.layers = options.layers ?? undefined;\n    this.markerAnchor = options.markerAnchor ?? \"center\";\n    this.markerSize = options.markerSize ?? [150, 50];\n    this.max = options.max ?? null;\n    this.lastStatus = {\n      new: new Map<number, AbstractMarker>(),\n      updated: new Map<number, AbstractMarker>(),\n      removed: new Map<number, AbstractMarker>(),\n    };\n    this.lastPresent = new Map<number, AbstractMarker>();\n    this.filter = options.filter ?? null;\n    this.offset = options.offset ?? [0, 0];\n    this.groupBy = options.groupBy ?? null;\n    this.maxRatioUnitSize = options.maxRatioUnitSize ?? 2.5;\n    this.sortingProperty = options.sortingProperty ?? \"\";\n    this.maxNbFeaturesPerMarker =\n      options.maxNbFeaturesPerMarker ?? Number.POSITIVE_INFINITY;\n\n    if (\n      options.sortingOrder &&\n      ![\"ascending\", \"descending\"].includes(options.sortingOrder)\n    ) {\n      throw new Error(\n        \"The property `options.sortingOrder` must be 'ascending' or 'descending' if provided.\",\n      );\n    }\n\n    this.sortingOrder = options.sortingOrder === \"descending\" ? -1 : 1;\n  }\n\n  private computeAnchorOffset(nbFeatures = 1): [number, number] {\n    let anchorOffset: [number, number] = [0, 0];\n\n    if (this.markerAnchor === \"center\") {\n      anchorOffset = [\n        -this.markerSize[0] / 2,\n        (nbFeatures * -this.markerSize[1]) / 2,\n      ];\n    } else if (this.markerAnchor === \"top\") {\n      anchorOffset = [\n        -this.markerSize[0] / 2,\n        nbFeatures * -this.markerSize[1],\n      ];\n    } else if (this.markerAnchor === \"bottom\") {\n      anchorOffset = [-this.markerSize[0] / 2, 0];\n    } else if (this.markerAnchor === \"left\") {\n      anchorOffset = [\n        -this.markerSize[0],\n        (nbFeatures * -this.markerSize[1]) / 2,\n      ];\n    } else if (this.markerAnchor === \"right\") {\n      anchorOffset = [0, -this.markerSize[1]];\n    }\n\n    anchorOffset[0] += this.offset[0];\n    anchorOffset[1] += this.offset[1];\n\n    return anchorOffset;\n  }\n\n  /**\n   * Updates only the position of an abstract marker. Soft updates are convenients\n   * for updating already existing markers without the need to debounce\n   */\n  softUpdateAbstractMarker(abstractMarker: AbstractMarker) {\n    const lonLat = (abstractMarker.features[0].geometry as GeoJSON.Point)\n      .coordinates as LngLatLike;\n    const screenspacePosition = this.map.project(lonLat);\n    const nbFeatureToShow = Math.min(\n      abstractMarker.features.length,\n      this.maxRatioUnitSize,\n    );\n    const anchorOffset = this.computeAnchorOffset(nbFeatureToShow);\n    abstractMarker.position[0] = screenspacePosition.x + anchorOffset[0];\n    abstractMarker.position[1] = screenspacePosition.y + anchorOffset[1];\n  }\n\n  /**\n   * Update the marker positions.\n   */\n  update(): MarkerStatus | null {\n    if (!this.map) return null;\n\n    // Collecting the features displayed in the viewport\n    let features = this.map.queryRenderedFeatures(undefined, {\n      layers: this.layers,\n    });\n\n    // Keeping only points\n    features = features.filter((f) => f.geometry.type === \"Point\");\n\n    // filtering out with the custom filter function\n    if (typeof this.filter === \"function\") {\n      features = features.filter(this.filter);\n    }\n\n    if (this.sortingProperty) {\n      if (typeof this.sortingProperty === \"string\") {\n        const sortingProp = this.sortingProperty;\n        // sorting the features by a property (eg. rank)\n        features = features\n          .filter((feature) => feature.properties[sortingProp]) // the features must have the property to sort on\n          .sort(\n            (a, b) =>\n              (a.properties[sortingProp] > b.properties[sortingProp] ? 1 : -1) *\n              this.sortingOrder,\n          ); // actual sorting\n      } else if (typeof this.sortingProperty === \"function\") {\n        // In this part, this.sortingProperty is a function that returns the sorting rank\n        const getSortingValue = this.sortingProperty;\n        features = features.sort(\n          (a, b) =>\n            (getSortingValue(a) > getSortingValue(b) ? 1 : -1) *\n            this.sortingOrder,\n        ); // actual sorting\n      }\n    }\n\n    // The keys of these groups are the values of tyhe parameter we want to group by\n    // or the coordinate hash.\n    const groupMap = new Map<string, FeatureGroup>();\n\n    // Alongside the groupMap, FeatureGroups are also referenced in a list\n    // so that they can be addressed in a sorted way if a sorting property was defined\n    // or to conserve the encoding order.\n    let groupList: FeatureGroup[] = [];\n\n    // Group by coordinates\n    if (this.groupBy) {\n      for (let i = 0; i < features.length; i += 1) {\n        const feature = features[i];\n        const groupKey =\n          this.groupBy === \"coordinates\"\n            ? getPointfeatureCoordinateHash(feature)\n            : feature.properties[this.groupBy];\n\n        let group: FeatureGroup;\n\n        if (groupMap.has(groupKey)) {\n          group = groupMap.get(groupKey) as FeatureGroup;\n        } else {\n          group = {\n            groupKey,\n            features: [],\n          };\n          groupMap.set(groupKey, group);\n          groupList.push(group);\n        }\n\n        if (group.features.length < this.maxNbFeaturesPerMarker) {\n          group.features.push(feature);\n        }\n      }\n    }\n\n    // Do not group at all\n    else {\n      groupList = features.map((f: MapGeoJSONFeature) => ({\n        groupKey: f.id?.toString() as string,\n        features: [f],\n      }));\n      // the groupMap is ignored here because it's used only to create the grouping itself\n      // and is not reused afterwards\n    }\n\n    const newMarkers = new Map<number, AbstractMarker>();\n    const updatedMarkers = new Map<number, AbstractMarker>();\n    const newPresent = new Map<number, AbstractMarker>();\n\n    let featureCounter = 0;\n\n    for (let i = 0; i < groupList.length; i += 1) {\n      if (this.max && featureCounter >= this.max) {\n        break;\n      }\n\n      const group = groupList[i];\n      const nbFeatureToShow = Math.min(\n        group.features.length,\n        this.maxRatioUnitSize,\n      );\n      const anchorOffset = this.computeAnchorOffset(nbFeatureToShow);\n      const feature = group.features[0];\n\n      // The height of the marker is increased based on the number of features\n      // it contains, but we don't want the marker to be larger than this.maxRatioUnitSize\n      // the size of a \"unit\" marker (otherwise it could take the whole viewport)\n      const markerSize: [number, number] = [\n        this.markerSize[0],\n        this.markerSize[1] * nbFeatureToShow,\n      ];\n\n      const id: number = computeFeatureGroupId(group.features);\n      const lonLat = (feature.geometry as GeoJSON.Point)\n        .coordinates as LngLatLike;\n      const screenspacePosition = this.map.project(lonLat);\n      const marker: AbstractMarker = {\n        id,\n        position: [\n          screenspacePosition.x + anchorOffset[0],\n          screenspacePosition.y + anchorOffset[1],\n        ],\n        size: markerSize,\n        internalElementSize: [this.markerSize[0], this.markerSize[1]],\n        features: group.features,\n      };\n\n      if (doesCollideWithAny(marker, newPresent)) {\n        continue;\n      }\n\n      newPresent.set(id, marker);\n\n      // if current feature was previously in 'new', then it's updated\n      if (this.lastStatus.new.has(id)) {\n        updatedMarkers.set(id, marker);\n        this.lastPresent.delete(id);\n      }\n\n      // If current feature was previously in 'updated' , then it still is\n      else if (this.lastStatus.updated.has(id)) {\n        updatedMarkers.set(id, marker);\n        this.lastPresent.delete(id);\n      }\n\n      // If current feature was in previous updated/new, then it is new now\n      else {\n        newMarkers.set(id, marker);\n      }\n\n      featureCounter++;\n    }\n\n    // All the features of this updates that have been part of the previous update have been deleted from this.lastPresent\n    // This means that this.lastPresent is the new removedMarkers\n    this.lastStatus.removed = this.lastPresent;\n    this.lastPresent = newPresent;\n    this.lastStatus.new = newMarkers;\n    this.lastStatus.updated = updatedMarkers;\n\n    return this.lastStatus;\n  }\n\n  /**\n   * Reset the internal state, aka empties the `lastStatus` maps.\n   */\n  reset() {\n    this.lastPresent.clear();\n    this.lastStatus.new.clear();\n    this.lastStatus.updated.clear();\n    this.lastStatus.removed.clear();\n  }\n}\n"],"names":["computeFeatureGroupId","features","ids","f","idsStr","hash","i","char","getPointfeatureCoordinateHash","feature","fArr","doesCollide","a","b","doesCollideWithAny","marker","manyMarkers","markers","hitTestMarker","MarkerLayout","map","options","__publicField","packagejson","nbFeatures","anchorOffset","abstractMarker","lonLat","screenspacePosition","nbFeatureToShow","sortingProp","getSortingValue","groupMap","groupList","groupKey","group","_a","newMarkers","updatedMarkers","newPresent","featureCounter","markerSize","id"],"mappings":"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"}