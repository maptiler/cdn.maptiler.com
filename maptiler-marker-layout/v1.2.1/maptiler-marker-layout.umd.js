(function(h,a){typeof exports=="object"&&typeof module<"u"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(h=typeof globalThis<"u"?globalThis:h||self,a(h.maptilermarkerlayout={}))})(this,function(h){"use strict";var x=Object.defineProperty;var O=(h,a,m)=>a in h?x(h,a,{enumerable:!0,configurable:!0,writable:!0,value:m}):h[a]=m;var o=(h,a,m)=>O(h,typeof a!="symbol"?a+"":a,m);function a(n){const e=n.map(f=>f.id);e.sort();const t=e.join("_");let i=0;for(let f=0;f<t.length;f++){const p=t.charCodeAt(f);i=(i<<5)-i+p,i|=0}return i}function m(n){if(n.geometry.type!=="Point")return"";const e=new Float32Array(n.geometry.coordinates.slice(0,2));return new Uint8Array(e.buffer).join("_")}function k(n,e){return!(e.position[0]>n.position[0]+n.size[0]||e.position[0]+e.size[0]<n.position[0]||e.position[1]>n.position[1]+n.size[1]||e.position[1]+e.size[1]<n.position[1])}function P(n,e){const t=e.values();for(const i of t)if(k(n,i))return!0;return!1}class z{constructor(e,t={}){o(this,"layers");o(this,"markerSize");o(this,"markerAnchor");o(this,"map");o(this,"lastStatus");o(this,"max");o(this,"offset",[0,0]);o(this,"lastPresent");o(this,"filter",null);o(this,"groupBy",null);o(this,"maxRatioUnitSize");o(this,"sortingProperty","");o(this,"sortingOrder",1);o(this,"maxNbFeaturesPerMarker",Number.POSITIVE_INFINITY);if(this.map=e,this.layers=t.layers??void 0,this.markerAnchor=t.markerAnchor??"center",this.markerSize=t.markerSize??[150,50],this.max=t.max??null,this.lastStatus={new:new Map,updated:new Map,removed:new Map},this.lastPresent=new Map,this.filter=t.filter??null,this.offset=t.offset??[0,0],this.groupBy=t.groupBy??null,this.maxRatioUnitSize=t.maxRatioUnitSize??2.5,this.sortingProperty=t.sortingProperty??"",this.maxNbFeaturesPerMarker=t.maxNbFeaturesPerMarker??Number.POSITIVE_INFINITY,t.sortingOrder&&!["ascending","descending"].includes(t.sortingOrder))throw new Error("The property `options.sortingOrder` must be 'ascending' or 'descending' if provided.");this.sortingOrder=t.sortingOrder==="descending"?-1:1}computeAnchorOffset(e=1){let t=[0,0];return this.markerAnchor==="center"?t=[-this.markerSize[0]/2,e*-this.markerSize[1]/2]:this.markerAnchor==="top"?t=[-this.markerSize[0]/2,e*-this.markerSize[1]]:this.markerAnchor==="bottom"?t=[-this.markerSize[0]/2,0]:this.markerAnchor==="left"?t=[-this.markerSize[0],e*-this.markerSize[1]/2]:this.markerAnchor==="right"&&(t=[0,-this.markerSize[1]]),t[0]+=this.offset[0],t[1]+=this.offset[1],t}softUpdateAbstractMarker(e){const t=e.features[0].geometry.coordinates,i=this.map.project(t),f=Math.min(e.features.length,this.maxRatioUnitSize),p=this.computeAnchorOffset(f);e.position[0]=i.x+p[0],e.position[1]=i.y+p[1]}update(){if(!this.map)return null;let e=this.map.queryRenderedFeatures(void 0,{layers:this.layers});if(e=e.filter(r=>r.geometry.type==="Point"),typeof this.filter=="function"&&(e=e.filter(this.filter)),this.sortingProperty){if(typeof this.sortingProperty=="string"){const r=this.sortingProperty;e=e.filter(s=>s.properties[r]).sort((s,u)=>(s.properties[r]>u.properties[r]?1:-1)*this.sortingOrder)}else if(typeof this.sortingProperty=="function"){const r=this.sortingProperty;e=e.sort((s,u)=>(r(s)>r(u)?1:-1)*this.sortingOrder)}}const t=new Map;let i=[];if(this.groupBy)for(let r=0;r<e.length;r+=1){const s=e[r],u=this.groupBy==="coordinates"?m(s):s.properties[this.groupBy];let l;t.has(u)?l=t.get(u):(l={groupKey:u,features:[]},t.set(u,l),i.push(l)),l.features.length<this.maxNbFeaturesPerMarker&&l.features.push(s)}else i=e.map(r=>{var s;return{groupKey:(s=r.id)==null?void 0:s.toString(),features:[r]}});const f=new Map,p=new Map,g=new Map;let y=0;for(let r=0;r<i.length&&!(this.max&&y>=this.max);r+=1){const s=i[r],u=Math.min(s.features.length,this.maxRatioUnitSize),l=this.computeAnchorOffset(u),w=s.features[0],A=[this.markerSize[0],this.markerSize[1]*u],c=a(s.features),M=w.geometry.coordinates,S=this.map.project(M),d={id:c,position:[S.x+l[0],S.y+l[1]],size:A,internalElementSize:[this.markerSize[0],this.markerSize[1]],features:s.features};P(d,g)||(g.set(c,d),this.lastStatus.new.has(c)?(p.set(c,d),this.lastPresent.delete(c)):this.lastStatus.updated.has(c)?(p.set(c,d),this.lastPresent.delete(c)):f.set(c,d),y++)}return this.lastStatus.removed=this.lastPresent,this.lastPresent=g,this.lastStatus.new=f,this.lastStatus.updated=p,this.lastStatus}reset(){this.lastPresent.clear(),this.lastStatus.new.clear(),this.lastStatus.updated.clear(),this.lastStatus.removed.clear()}}h.MarkerLayout=z,Object.defineProperty(h,Symbol.toStringTag,{value:"Module"})});
