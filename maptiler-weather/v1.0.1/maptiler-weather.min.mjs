import{getIntersection as Ae,scaleFromCenter as Me,getArea as ee,getIntersectionArea as Ie}from"ol/extent.js";import{createXYZ as De}from"ol/tilegrid.js";import*as h from"three";import{OrthographicCamera as ze,Scene as Fe,RawShaderMaterial as Oe,GLSL3 as Ne,Vector2 as Ue,WebGLRenderTarget as he,LinearFilter as K,RGBAFormat as te,Mesh as Le,PlaneGeometry as $e,DataTexture as Ve,WebGLRenderer as Be}from"three";import We from"ol/structs/LRUCache.js";import{EventEmitter as Ge}from"events";var ve=(i=>(i[i.r=0]="r",i[i.g=1]="g",i[i.b=2]="b",i[i.a=3]="a",i))(ve||{});let oe=null,re=null;function ke(){return(!oe||!re)&&(oe=document.createElement("canvas"),re=oe.getContext("webgl2")),re}function L(i){var e;return`vec4(${(i[0]/255).toFixed(3)},${(i[1]/255).toFixed(3)},${(i[2]/255).toFixed(3)},${(((e=i[3])!=null?e:255)/255).toFixed(3)})`}function je(i){var e;return[i[0]/255,i[1]/255,i[2]/255,((e=i[3])!=null?e:255)/255]}function me(i){return 180/Math.PI*Math.log(Math.tan(Math.PI/4+i*Math.PI/360))/360}function ie(i,e){return[i/360,me(e)]}function de(i){const e=Math.PI,t=Math.atan,o=Math.exp,r=o(i*2*e);return(t(r)-e/4)*360/e}function Ze(i,e){const t=-.5*(i/e*2-1);return de(t)}const pe=6378137,j=2*Math.PI*pe;function V(i,e){return ie(i,e).map(t=>t*j)}function xe(i,e,t){const o=Math.floor(e*i.width),r=Math.floor(t*i.height),n=ke();if(n==null)throw new Error("Failed to obtain WebGL2 context");n.activeTexture(n.TEXTURE0);const a=n.createTexture();n.bindTexture(n.TEXTURE_2D,a);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,a,0),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,i),n.drawBuffers([n.COLOR_ATTACHMENT0]);const l=new Uint8Array(4);return n.readPixels(o,r,1,1,n.RGBA,n.UNSIGNED_BYTE,l),n.deleteTexture(a),n.deleteFramebuffer(s),{r:l[0]/255,g:l[1]/255,b:l[2]/255,a:l[3]/255}}function Ye(i,e,t=""){i.isStyleLoaded()?i.addLayer(e,t):i.once("load",()=>{i.addLayer(e,t)})}function fe(i){const e=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"],t=Math.round((i+360)%360/22.5)%16;return e[t]}var He=`

precision highp float;
precision highp sampler2D;


// uniform float polynomialCoefDegree2;
// uniform float polynomialCoefDegree1;
// uniform float polynomialConstant;
uniform float opacity;
uniform float time;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform float tex0size;
uniform float tex1size;
uniform float tilePixelSize;
uniform bool categorySmoothTransition;
uniform bool timeInterpolation;

in vec2 tex0coord;
in vec2 tex1coord;

out vec4 fragColor;

// // The folowing code will be autogenerated
<gradient_function_definitions>


// The folowing code will be autogenerated
<getColor_code>


// Blinear interpolation
vec4 blerp(vec4 color_x0_y0, vec4 color_x0_y1, vec4 color_x1_y0, vec4 color_x1_y1, float x0, float y0, float x1, float y1, float x, float y) {
    vec4 q11 = (((x1 - x) * (y1 - y)) / ((x1 - x0) * (y1 - y0))) * color_x0_y0;
    vec4 q21 = (((x - x0) * (y1 - y)) / ((x1 - x0) * (y1 - y0))) * color_x1_y0;
    vec4 q12 = (((x1 - x) * (y - y0)) / ((x1 - x0) * (y1 - y0))) * color_x0_y1;
    vec4 q22 = (((x - x0) * (y - y0)) / ((x1 - x0) * (y1 - y0))) * color_x1_y1;
    return q11 + q21 + q12 + q22;
}


void main() {
  // we don't want to interpolate the alpha channel because it does not contain
  // transparency but a category. Going from cat 1 to 3 would otherwise create a gradient passing
  // by category 2 and we don't want that. Hence, we look for a "center pixel" value.
  vec2 centerPixelUV = vec2(
    (floor(tex0coord.x * tilePixelSize) + 0.5) / tilePixelSize,
    (floor(tex0coord.y * tilePixelSize) + 0.5) / tilePixelSize
  );

  vec2 centerPixelUV_N = vec2(
    (floor(tex0coord.x * tilePixelSize) + 0.5) / tilePixelSize,
    (floor(tex0coord.y * tilePixelSize) + 0.5 + 1.) / tilePixelSize
  );

  vec2 centerPixelUV_S = vec2(
    (floor(tex0coord.x * tilePixelSize) + 0.5) / tilePixelSize,
    (floor(tex0coord.y * tilePixelSize) + 0.5 - 1.) / tilePixelSize
  );

  vec2 centerPixelUV_E = vec2(
    (floor(tex0coord.x * tilePixelSize) + 0.5 + 1.) / tilePixelSize,
    (floor(tex0coord.y * tilePixelSize) + 0.5) / tilePixelSize
  );

  vec2 centerPixelUV_W = vec2(
    (floor(tex0coord.x * tilePixelSize) + 0.5 - 1.) / tilePixelSize,
    (floor(tex0coord.y * tilePixelSize) + 0.5) / tilePixelSize
  );


  vec4 tex0Color = texture(tex0, tex0coord);
  vec4 tex1Color = texture(tex1, tex1coord);
  vec4 inter = timeInterpolation ? mix(tex0Color, tex1Color, time) : (time < 0.5 ? tex0Color : tex1Color);

  // Because it comes from a texture, inter (above) is in the range [0.0, 1.0]f
  // and we want it back to the PNG rang [0, 255]
  vec3 inter255 = inter.rgb * 255.;

  // x is in the range of [0, 16777215]
  float x = inter255.r * 256. * 256. + inter255.g * 256. + inter255.b;

  // We apply the coeficient to get the value of the polynomial
  // y = f(x) = a*x^2 + b*x + c
  // where:
  //    a = polynomialCoefDegree2
  //    b = polynomialCoefDegree1
  //    c = polynomialConstant
  float polynomialCoefDegree2 = <polynomialCoefDegree2>;
  float polynomialCoefDegree1 = <polynomialCoefDegree1>;
  float polynomialConstant = <polynomialConstant>;

  float y = polynomialCoefDegree2 * x * x + polynomialCoefDegree1 * x + polynomialConstant;

  // The category is the type associated to the measurement, while y is its intensity.
  // This is particularly useful in the context of precipitation radar where only the intensity
  // is not enough to categorize the precipitation. In this context, the category can be used to represent
  // the precipitation type (0: no data, 1: rain, 2: snow, etc.)
  // Not all measurements require using multiple categories, in this case, the value 0 is going to be the
  // default category.
  // int category = int((time < 0.5 ? tex0Color.a : tex1Color.a) * 255.);
  int category = int((time < 0.5 ?  texture(tex0, centerPixelUV).a : texture(tex1, centerPixelUV).a) * 255.);

  vec4 color_Center = getColor(category, y);

  vec4 color = vec4(0., 0., 0., 0.);

  if (categorySmoothTransition) {
    if (tex0coord.x >= centerPixelUV.x) { // the current pixel is at the EAST of the center pixel coord
      int category_E = int((time < 0.5 ?  texture(tex0, centerPixelUV_E).a : texture(tex1, centerPixelUV_E).a) * 255.);
      vec4 color_E = getColor(category_E, y);
      
      if (tex0coord.y >= centerPixelUV.y) { // the current pixel is at the NORTH of the center pixel coord
        // the current pixel is in the NORTH EAST quadrant
        int category_N = int((time < 0.5 ?  texture(tex0, centerPixelUV_N).a : texture(tex1, centerPixelUV_N).a) * 255.);
        vec4 color_N = getColor(category_N, y);

        vec2 centerPixelUV_NE = vec2(
          (floor(tex0coord.x * tilePixelSize) + 0.5 + 1.) / tilePixelSize,
          (floor(tex0coord.y * tilePixelSize) + 0.5 + 1.) / tilePixelSize
        );

        int category_NE  = int((time < 0.5 ?  texture(tex0, centerPixelUV_NE).a : texture(tex1, centerPixelUV_NE).a) * 255.);
        vec4 color_NE = getColor(category_NE, y);

        color = blerp(color_Center, color_N, color_E, color_NE, centerPixelUV.x, centerPixelUV.y, centerPixelUV_NE.x, centerPixelUV_NE.y, tex0coord.x, tex0coord.y);

      } else { // the current pixel is at the SOUTH of the center pixel coord
        // the current pixel is in the SOUTH EAST quadrant
        int category_S = int((time < 0.5 ?  texture(tex0, centerPixelUV_S).a : texture(tex1, centerPixelUV_S).a) * 255.);
        vec4 color_S = getColor(category_S, y);

        vec2 centerPixelUV_SE = vec2(
          (floor(tex0coord.x * tilePixelSize) + 0.5 + 1.) / tilePixelSize,
          (floor(tex0coord.y * tilePixelSize) + 0.5 - 1.) / tilePixelSize
        );

        int category_SE  = int((time < 0.5 ?  texture(tex0, centerPixelUV_SE).a : texture(tex1, centerPixelUV_SE).a) * 255.);
        vec4 color_SE = getColor(category_SE, y);

        color = blerp(color_S, color_Center, color_SE, color_E, centerPixelUV_S.x, centerPixelUV_S.y, centerPixelUV_E.x, centerPixelUV_E.y, tex0coord.x, tex0coord.y);
      }

    } else { // the current pixel is at the WEST of the center pixel coord
      int category_W = int((time < 0.5 ?  texture(tex0, centerPixelUV_W).a : texture(tex1, centerPixelUV_W).a) * 255.);
      vec4 color_W = getColor(category_W, y);

      if (tex0coord.y >= centerPixelUV.y) { // the current pixel is at the NORTH of the center pixel coord
        // the current pixel is in the NORTH WEST quadrant
        int category_N = int((time < 0.5 ?  texture(tex0, centerPixelUV_N).a : texture(tex1, centerPixelUV_N).a) * 255.);
        vec4 color_N = getColor(category_N, y);

        vec2 centerPixelUV_NW = vec2(
          (floor(tex0coord.x * tilePixelSize) + 0.5 - 1.) / tilePixelSize,
          (floor(tex0coord.y * tilePixelSize) + 0.5 + 1.) / tilePixelSize
        );

        int category_NW  = int((time < 0.5 ?  texture(tex0, centerPixelUV_NW).a : texture(tex1, centerPixelUV_NW).a) * 255.);
        vec4 color_NW = getColor(category_NW, y);

        color = blerp(color_W, color_NW, color_Center, color_N, centerPixelUV_W.x, centerPixelUV_W.y, centerPixelUV_N.x, centerPixelUV_N.y, tex0coord.x, tex0coord.y);

      } else { // the current pixel is at the SOUTH of the center pixel coord
        // the current pixel is in the SOUTH WEST quadrant
        int category_S = int((time < 0.5 ?  texture(tex0, centerPixelUV_S).a : texture(tex1, centerPixelUV_S).a) * 255.);
        vec4 color_S = getColor(category_S, y);

        vec2 centerPixelUV_SW = vec2(
          (floor(tex0coord.x * tilePixelSize) + 0.5 - 1.) / tilePixelSize,
          (floor(tex0coord.y * tilePixelSize) + 0.5 - 1.) / tilePixelSize
        );

        int category_SW  = int((time < 0.5 ?  texture(tex0, centerPixelUV_SW).a : texture(tex1, centerPixelUV_SW).a) * 255.);
        vec4 color_SW = getColor(category_SW, y);

        color = blerp(color_SW, color_W, color_S, color_Center, centerPixelUV_SW.x, centerPixelUV_SW.y, centerPixelUV.x, centerPixelUV.y, tex0coord.x, tex0coord.y);
      }
    }
  } else {
    color = color_Center;
  }

  color.a *= opacity;
  fragColor = color;
}`,Ke=Object.defineProperty,qe=(i,e,t)=>e in i?Ke(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Z=(i,e,t)=>(qe(i,typeof e!="symbol"?e+"":e,t),t);const N=7;function Xe(i){return i.filter((e,t)=>t===0||t%2||t===i.length-1)}function ge(i,e=50){if(i.length<=e)return i;const t=Xe(i);return ge(t,e)}function ye(i,e,t={inputName:"v",outputName:"c"}){const o=ge(i);let r="";for(let n=0;n<o.length;n++){const a=o[n];n===0&&(r+=`vec4 ${t.outputName}=${L(a.color)};
`);const s=a.value,l=L(a.color);if(e&&n+1<o.length){const c=o[n+1].value,v=L(o[n+1].color),p=parseFloat((s-c).toFixed(N))===0?"0.":`(${t.inputName} - ${s.toFixed(N)}) / (${(c-s).toFixed(N)})`;r+=`${n>0?" else ":""} if(${t.inputName}>=${s.toFixed(N)}&&${t.inputName}<${c.toFixed(N)}) { ${t.outputName}=mix(${l},${v}, ${p} ); }
`}else r+=`if(${t.inputName}>=${s.toFixed(N)})${t.outputName}=${l};
`}return r}class ne{constructor(e,t){this.code=e,this.decode=t;var o,r;this.decode.min=(o=this.decode.min)!=null?o:0,this.decode.max=(r=this.decode.max)!=null?r:1}codeValue(e){return(e-this.decode.min)/(this.decode.max-this.decode.min)}decodeValue(e){return this.decode.min+e*(this.decode.max-this.decode.min)}decodeChannel(e){if(this.decode.channel.length>1){const t=this.decodeValue(e[this.decode.channel[0]]),o=this.decodeValue(e[this.decode.channel[1]]);return[t,o,Math.sqrt(t*t+o*o)]}return this.decodeValue(e[this.decode.channel])}getBlendCode(e){const t=this.code+"d.rgb=(d.rgb*d.a*(1.-c.a)+c.rgb*c.a)/(d.a*(1.-c.a)+c.a);d.a=d.a+c.a*(1.-d.a);";return`vec4 ${e}(vec4 d,vec4 data){${t}return d;}`}getCode(e){return`vec4 ${e}(vec4 data){${this.code}return c;}`}}function Se({channel:i="r",min:e=0,max:t=1}){let o=`${e.toFixed(N)}+data.${i}*${(t-e).toFixed(N)}`;return i.length>1&&(o=`length(${o})`),`float v=${o};`}class B extends ne{constructor(e){var t,o;const r=e.decode,n=e.stops||[{value:r.min,color:[0,0,0,0]},{value:r.max,color:[255,255,255,255]}],a=(t=e.smooth)!=null?t:!0,s=(o=e.opacity)!=null?o:1;let l=Se(r);l+=ye(n,a),l+=`c.a*=${s.toFixed(3)};`,super(l,r)}}class Je extends ne{constructor(e){var t;const o=e.decode,r=e.color||[255,255,255],n=(t=e.opacity)!=null?t:1,a=Se(o)+`vec4 c=${L(r)};c.a*=v*${n.toFixed(3)};`;super(a,o)}}class Qe{constructor(e){Z(this,"decode",{polynomialCoefDegree2:0,polynomialCoefDegree1:1,polynomialConstant:0}),Z(this,"stopsPerCategory",[{category:"all",stops:[{value:0,color:[0,0,0]},{value:255,color:[255,255,255]}]}]),Z(this,"smooth"),Z(this,"opacity"),Z(this,"code");var t,o;this.decode=e.decode,this.stopsPerCategory=e.stopsPerCategory,this.smooth=(t=e.smooth)!=null?t:!0,this.opacity=(o=e.opacity)!=null?o:1;const r=this.stopsPerCategory.filter(l=>l.category==="all");let n=this.stopsPerCategory;r.length&&(n=r);const a=n.map(l=>{let c=`vec4 _mccf_${l.category}(float v) {
`;return c+=`${ye(l.stops,this.smooth)}`,c+=`return c;}
`,c}).join(`
`);let s=`vec4 getColor(int category, float v) {
`;s+=`vec4 outputColor;
`,r.length?s+="outputColor  = _mccf_all(v);":(s+=this.stopsPerCategory.map((l,c)=>`${c===0?"":"else "}if (category == ${l.category}) outputColor  = _mccf_${l.category}(v);`).join(`
`),s+=`
 else outputColor = vec4(0., 0., 0., 0.);
`),s+=`outputColor.a *= ${this.opacity.toFixed(3)};
`,s+=`return outputColor;}
`,this.code=He.replace("<gradient_function_definitions>",a).replace("<getColor_code>",s).replace("<polynomialCoefDegree2>",this.decode.polynomialCoefDegree2.toFixed(N)).replace("<polynomialCoefDegree1>",this.decode.polynomialCoefDegree1.toFixed(N)).replace("<polynomialConstant>",this.decode.polynomialConstant.toFixed(N))}getCode(){return this.code}decodeChannel(e){const t={r:e.r*255,g:e.g*255,b:e.b*255,a:e.a*255},o=t.r*256*256+t.g*256+t.b;return[this.decode.polynomialCoefDegree2*o*o+this.decode.polynomialCoefDegree1*o+this.decode.polynomialConstant,t.a]}}var et=Object.defineProperty,tt=(i,e,t)=>e in i?et(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Te=(i,e,t)=>(tt(i,typeof e!="symbol"?e+"":e,t),t);class ot{constructor(){Te(this,"allInstances",[]),Te(this,"availableInstances",[])}add(e,t=!1){return this.allInstances.push(e),t&&this.availableInstances.push(e),e}isEmpty(){return this.availableInstances.length===0}pop(){if(this.isEmpty())throw new Error("No more instances available ini the pool.");return this.availableInstances.pop()}init(){this.availableInstances=this.allInstances.slice()}reset(){this.availableInstances=[],this.allInstances=[]}}var rt=`
precision highp float;
precision highp sampler2D;


COLORING_FRAGMENT_DEFS

out vec4 fragColor;

uniform float opacity;
uniform float zoom;
uniform float time;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform float tilePixelSize;

// texture on the neighborhood
uniform sampler2D texN0;
uniform sampler2D texN1;
uniform bool availableN;
uniform sampler2D texE0;
uniform sampler2D texE1;
uniform bool availableE;
uniform sampler2D texS0;
uniform sampler2D texS1;
uniform bool availableS;
uniform sampler2D texW0;
uniform sampler2D texW1;
uniform bool availableW;
uniform float maxSmoothingDistance;
uniform float smoothingDistanceDecayFactor;
uniform bool localSmoothing;

// The difference between the view port zoom level (eg. 5.65) and the zoom level of the tile (eg. 5)
// (always positive, could be greater than 1. if maxZoom of the TileLayer is set below 22)
uniform float zoomDelta;

in vec2 tex0coord;
in vec2 tex1coord;

float PI = 3.141592;
const int halfNbSmoothingBins = int(ceil(float(NB_SMOOTHING_BINS)) / 2.);

/*

  texturePositionIndex refers to the neighborhood (N, NE, E, SE, S, SW, W, NW) of the central (C) texture.
  The index are as follow:
  - C  : 0
  - N  : 1
  - NE : 2
  - E  : 3
  - SE : 4
  - S  : 5
  - SW : 6
  - W  : 7
  - NW : 8

  of put spatially:

    8  1  2

    7  0  3

    6  5  4


  textureTimeIndex refers to the time-wise sampling. 0 means texture before (e.g. tex0 for the central texture)
  and 1 means the texture after (e.g. tex1 for the central texture)

  Thought because of the limit of 16 texture we can send to GPU, the following are never present: 2 8 4 and 6
  and the fallback for these positions are going to be on the central (external)

*/

// A uv can have one or both component (x, and/or y) that has a value below 0.0 or greater than 1.0.
// When this happens, it means the position to lookup is actually on one of the neighbor texture.
// newUv (out) is a vec2 that is in [0., 1.] relative to the relevant neighbor
// and texturePositionIndex (out) is the index of the neighbor as described above.
void textPositionToInternalTexPosition(vec2 uv, out vec2 newUv, out int texturePositionIndex) {

  // middle column
  if (uv.x >= 0. && uv.x <= 1.) {

    // middle row (C)
    if (uv.y >= 0. && uv.y <= 1.) {
      newUv = uv;
      texturePositionIndex = 0;

    // bottom row (S)
    } else if  (uv.y < 0. && availableS) {
      newUv = vec2(uv.x, 1. + uv.y);
      texturePositionIndex = 5;

    // top row (N)
    } else if  (uv.y > 1. && availableN) {
      newUv = vec2(uv.x, 1. - uv.y);
      texturePositionIndex = 1;
    } else {
      newUv = uv;
      texturePositionIndex = 0;
    }

  // left column
  } else if  (uv.x < 0.) {

    // middle row (W)
    if (uv.y >= 0. && uv.y <= 1. && availableW) {
      newUv = vec2(1. + uv.x, uv.y);
      texturePositionIndex = 7;
    } else {
      newUv = uv;
      texturePositionIndex = 0;
    }

  // right column
  } else if  (uv.x > 1.) {

    // middle row (E)
    if (uv.y >= 0. && uv.y <= 1. && availableE) {
      newUv = vec2(uv.x -1., uv.y);
      texturePositionIndex = 3;
    } else {
      newUv = uv;
      texturePositionIndex = 0;
    }
  }
}




vec4 getTextureColorByIndex(int textureTimeIndex, int texturePositionIndex, vec2 uv) {
  
  if (textureTimeIndex == 0) {
    if (texturePositionIndex == 0) {
      return texture(tex0, uv);
    } else if (texturePositionIndex == 1) {
      return texture(texN0, uv);
    } else if (texturePositionIndex == 3) {
      return texture(texE0, uv);
    } else if (texturePositionIndex == 5) {
      return texture(texS0, uv);
    } else if (texturePositionIndex == 7) {
      return texture(texW0, uv);
    }
  } else if (textureTimeIndex == 1) {
    if (texturePositionIndex == 0) {
      return texture(tex1, uv);
    } else if (texturePositionIndex == 1) {
      return texture(texN1, uv);
    } else if (texturePositionIndex == 3) {
      return texture(texE1, uv);
    } else if (texturePositionIndex == 5) {
      return texture(texS1, uv);
    } else if (texturePositionIndex == 7) {
      return texture(texW1, uv);
    }
  } else {
    return vec4(1., 0., 0., 1.);
  }
}


vec4 getColor(int textureTimeIndex, vec2 uv) {
  int texturePositionIndex = 0;
  vec2 localUV = vec2(0., 0.);
  textPositionToInternalTexPosition(uv, localUV, texturePositionIndex);
  return getTextureColorByIndex(textureTimeIndex, texturePositionIndex, localUV);
}


vec4 circularSampleSmoothing(int textureTimeIndex, vec2 uv, float resolution, float distance, out bool isTransparant) {
    
    
    vec4 colorRGBA = getColor(textureTimeIndex, uv);
    int weightCenter = 3;
    vec4 color = colorRGBA * float(weightCenter);

    isTransparant = colorRGBA.a < 1.;

    float angularStep = 2. * PI / float(halfNbSmoothingBins);

    for (int i = 0; i < halfNbSmoothingBins; i++) {
        float angle = angularStep * float(i);
        vec2 offset = vec2(cos(angle), sin(angle)) * distance * 0.5;
        vec2 pos = uv + offset / resolution;
        vec4 c = getColor(textureTimeIndex, pos);
        color += c;
        isTransparant = isTransparant || c.a < 1.;

        angle = angularStep / 2. + angularStep * float(i);
        offset = vec2(cos(angle), sin(angle)) * distance;
        pos = uv + offset / resolution;
        c = getColor(textureTimeIndex, pos);
        color += c;
        isTransparant = isTransparant || c.a < 1.;
    }

    return color / float(2 * halfNbSmoothingBins + weightCenter);
}


void main() {
  float scaledSamplingDistance = (maxSmoothingDistance * smoothingDistanceDecayFactor / (smoothingDistanceDecayFactor + zoom)) * max(1., 2. - zoomDelta);

  bool isTransparant0 = false;
  bool isTransparant1 = false;

  vec4 tex0Color;
  vec4 tex1Color;

  if (localSmoothing && halfNbSmoothingBins != 0) {
    tex0Color = circularSampleSmoothing(0, tex0coord, tilePixelSize, scaledSamplingDistance, isTransparant0);
    tex1Color = circularSampleSmoothing(1, tex1coord, tilePixelSize, scaledSamplingDistance, isTransparant1);
  } else {
    tex0Color = texture(tex0, tex0coord);
    tex1Color = texture(tex1, tex1coord);
  }

  vec4 inter = mix(tex0Color, tex1Color, time);

  if (inter.a < 1.0 && !RENDER_TRANSPARENT) discard;

  COLORING_FRAGMENT_CALLS

  fragColor.a *= opacity;
}
`,it=`

precision highp float;
precision highp sampler2D;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

in vec3 position;
in vec2 uv;

uniform vec2 tex0xy;
uniform vec2 tex1xy;
uniform float tex0size;
uniform float tex1size;
out vec2 tex0coord;
out vec2 tex1coord;

void main()	{
  tex0coord = tex0xy + uv * tex0size;
  tex1coord = tex1xy + uv * tex1size;
  gl_Position =
    projectionMatrix *
    modelViewMatrix *
    vec4(position,1.);
}`,nt=`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D imageA;
uniform sampler2D imageB;
uniform float mixValue;

in vec2 vUv;
out vec4 fragColor;

void main() {
  fragColor = mix(texture(imageA, vUv), texture(imageB, vUv), mixValue);
}`,Pe=`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;

uniform vec2 direction;
uniform int kernelSize;
uniform sampler2D imgToBlur;

in vec2 vUv;
out vec4 fragColor;

vec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.3333333333333333) * direction;
  color += texture(image, uv) * 0.29411764705882354;
  color += texture(image, uv + (off1 / resolution)) * 0.35294117647058826;
  color += texture(image, uv - (off1 / resolution)) * 0.35294117647058826;
  return color; 
}

vec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.3846153846) * direction;
  vec2 off2 = vec2(3.2307692308) * direction;
  color += texture(image, uv) * 0.2270270270;
  color += texture(image, uv + (off1 / resolution)) * 0.3162162162;
  color += texture(image, uv - (off1 / resolution)) * 0.3162162162;
  color += texture(image, uv + (off2 / resolution)) * 0.0702702703;
  color += texture(image, uv - (off2 / resolution)) * 0.0702702703;
  return color;
}

vec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.411764705882353) * direction;
  vec2 off2 = vec2(3.2941176470588234) * direction;
  vec2 off3 = vec2(5.176470588235294) * direction;
  color += texture(image, uv) * 0.1964825501511404;
  color += texture(image, uv + (off1 / resolution)) * 0.2969069646728344;
  color += texture(image, uv - (off1 / resolution)) * 0.2969069646728344;
  color += texture(image, uv + (off2 / resolution)) * 0.09447039785044732;
  color += texture(image, uv - (off2 / resolution)) * 0.09447039785044732;
  color += texture(image, uv + (off3 / resolution)) * 0.010381362401148057;
  color += texture(image, uv - (off3 / resolution)) * 0.010381362401148057;
  return color;
}

vec4 blur19(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.434782608695652) * direction;
  vec2 off2 = vec2(3.347826086956522) * direction;
  vec2 off3 = vec2(5.260869565217392) * direction;
  vec2 off4 = vec2(7.173913043478261) * direction;


  color += texture(image, uv) * 0.16818993967466953;
  color += texture(image, uv + (off1 / resolution)) * 0.2727695816518679;
  color += texture(image, uv - (off1 / resolution)) * 0.2727695816518679;

  color += texture(image, uv + (off2 / resolution)) * 0.11690124927937194;
  color += texture(image, uv - (off2 / resolution)) * 0.11690124927937194;

  color += texture(image, uv + (off3 / resolution)) * 0.024067904263400105;
  color += texture(image, uv - (off3 / resolution)) * 0.024067904263400105;

  color += texture(image, uv + (off4 / resolution)) * 0.0021112196722280793;
  color += texture(image, uv - (off4 / resolution)) * 0.0021112196722280793;
  return color;
}


void main() {
  vec4 color = vec4(1., 0, 0, 1.);
  vec2 textureResolution = vec2(textureSize(imgToBlur, 0));

  if (kernelSize == 5) {
    color = blur5(imgToBlur, vUv, textureResolution, direction);
  } else if (kernelSize == 9) {
    color = blur9(imgToBlur, vUv, textureResolution, direction);
  } else if (kernelSize == 13) {
    color = blur13(imgToBlur, vUv, textureResolution, direction);
  } else if (kernelSize == 19) {
    color = blur19(imgToBlur, vUv, textureResolution, direction);
  }

  fragColor = color;

  // if (direction.x < 0.5) {
  //   fragColor = vec4(1., 0, 0, 1.);
  // } else {
  //   fragColor = vec4(0., 1, 0, 1.);
  // }


  // if (direction.x < 0.5) {
  //   fragColor *= 100.;
  // } 
}`,at=`#version 300 es

precision highp float;
precision highp int;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

in vec3 position;
in vec2 uv;
out vec2 vUv;


void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`,lt=`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;

in vec2 vUv;
out vec4 fragColor;

void main() {
  fragColor = vec4(1., 0., 0., 1.);
}`,st=Object.defineProperty,ct=(i,e,t)=>e in i?st(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,W=(i,e,t)=>(ct(i,typeof e!="symbol"?e+"":e,t),t);let ae=null;function ut(){return ae||(ae=new Be({alpha:!0,premultipliedAlpha:!1})),ae}class le{constructor(e,t,o=ut()){W(this,"renderer"),W(this,"camera",new ze(-1,1,1,-1,0,1)),W(this,"scene",new Fe),W(this,"renderTarget"),W(this,"material",new Oe({glslVersion:Ne,vertexShader:at,fragmentShader:lt,depthWrite:!1,transparent:!0})),W(this,"size"),this.size=new Ue(e,t),this.renderTarget=new he(e,t,{minFilter:K,magFilter:K,format:te}),this.camera.matrixAutoUpdate=!1,this.renderer=o,this.renderer.setPixelRatio(1),this.renderer.autoClear=!1;const r=new Le(new $e(2,2),this.material);this.scene.add(r)}getOutputTexture(e=!1){return e?new Ve(this.getPixelData(),this.size.x,this.size.y,te):this.renderTarget.texture}setSize(e,t){e===this.size.x&&t===this.size.y||(this.size.x=e,this.size.y=t,this.renderTarget=new he(e,t,{minFilter:K,magFilter:K,format:te}),this.renderer.setRenderTarget(this.renderTarget))}setVertexShader(e){this.material.vertexShader=e.trim(),this.material.needsUpdate=!0}setFragmentShader(e){this.material.fragmentShader=e.trim(),this.material.needsUpdate=!0}setUniform(e,t){this.material.uniforms[e]={value:t}}setDefine(e,t){this.material.fragmentShader=this.material.fragmentShader.replace(new RegExp(e,"g"),t.toString()),this.material.vertexShader=this.material.vertexShader.replace(new RegExp(e,"g"),t.toString()),this.material.needsUpdate=!0}getPixelData(){const e=this.size,t=new Uint8Array(e.x*e.y*4);return this.renderer.readRenderTargetPixels(this.renderTarget,0,0,e.x,e.y,t),t}getSize(){return this.size.clone()}process(){return this.material.needsUpdate=!0,this.renderer.setRenderTarget(this.renderTarget),this.renderer.clear(),this.renderer.render(this.scene,this.camera),this.renderTarget.texture}debugAsPNG(){const e=this.getSize(),t=this.getPixelData(),o=document.createElement("canvas");o.width=e.x,o.height=e.y;const r=o.getContext("2d");if(!r)return;const n=r.getImageData(0,0,o.width,o.height);n.data.set(t),r.putImageData(n,0,0);const a=window.open();a&&a.document.write(`<iframe src="${o.toDataURL("image/png")}" frameborder="0" style="border:0; top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen></iframe>`)}dispose(){this.renderTarget.texture.dispose(),this.renderTarget.dispose()}}var ht=Object.defineProperty,vt=(i,e,t)=>e in i?ht(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,q=(i,e,t)=>(vt(i,typeof e!="symbol"?e+"":e,t),t);class mt{constructor(e,t){this.url=e,this.onTileLoad=t,q(this,"loader",new h.TextureLoader),q(this,"lru",new We(32)),q(this,"apiKey",""),q(this,"sessionId","")}setMaptilerParams(e,t){this.apiKey=e,this.sessionId=t}urlPatternToUrl(e){const t=new URL(this.url.replace("{zxy}",e));return this.apiKey&&!t.searchParams.has("key")&&t.searchParams.append("key",this.apiKey),this.sessionId&&t.searchParams.append("mtsid",this.sessionId),t.href}getTile(e,t){if(this.lru.containsKey(e))return this.lru.get(e);if(t){const o=this.createTile(e);return this.lru.set(e,o),o}return null}createTile(e){const t=this.urlPatternToUrl(e),o={ready:!1,texture:null,zxy:e};return o.texture=this.loader.load(t,r=>{o.ready=!0,this.onTileLoad!=null&&this.onTileLoad(o,t,null)},void 0,r=>{this.onTileLoad!=null&&this.onTileLoad(o,t,r)}),o.texture.minFilter=h.LinearFilter,o.texture.needsUpdate=!0,o}disposeTile(e){e.texture&&e.texture.dispose()}expireCache(e){for(;this.lru.canExpireCache()&&!(this.lru.peekLast().zxy in e);)this.disposeTile(this.lru.pop())}dispose(){this.lru.forEach(e=>{this.disposeTile(e)}),this.lru.clear()}}var dt=Object.defineProperty,pt=(i,e,t)=>e in i?dt(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,X=(i,e,t)=>(pt(i,typeof e!="symbol"?e+"":e,t),t);class xt extends Ge{constructor(){super(),X(this,"frames",[]),X(this,"time",0),X(this,"animationSpeed",0),X(this,"lastTickTime",0)}addFrame(e,t){const o=this.findSmallerFrameIndex(e);if(o<0)this.frames.unshift({time:e,data:t});else{if(this.frames[o].time==e)throw new Error("Frame with this time already exists");this.frames.splice(o+1,0,{time:e,data:t})}this.clampAnimation()}removeFrame(e){const t=this.frames.filter(o=>o.time==e);return this.frames=this.frames.filter(o=>o.time!=e),this.clampAnimation(),t}forEachFrame(e){this.frames.forEach(t=>e(t))}getAnimationStart(){return this.frames.length?this.frames[0].time:1/0}getAnimationStartDate(){return new Date(this.getAnimationStart()*1e3)}getAnimationEnd(){return this.frames.length?this.frames[this.frames.length-1].time:-1/0}getAnimationEndDate(){return new Date(this.getAnimationEnd()*1e3)}getAnimationTime(){return this.time}getAnimationTimeDate(){return new Date(this.getAnimationTime()*1e3)}setAnimationTime(e){this.time=e,this.clampAnimation(),this.emit("animationTimeSet",{time:this.time})}clampAnimation(){this.time=Math.max(this.getAnimationStart(),Math.min(this.getAnimationEnd(),this.time))}animateByFactor(e){this.animate(e)}animate(e){e>0&&this.animationSpeed===0?this.emit("playAnimation",{time:this.time}):e===0&&this.animationSpeed>0&&this.emit("pauseAnimation",{time:this.time}),this.animationSpeed=e,this.animationSpeed!=0&&(this.lastTickTime=performance.now())}getAnimationSpeed(){return this.animationSpeed}isPlaying(){return this.animationSpeed>0}animationTick(){const e=performance.now();if(this.animationSpeed>0&&this.lastTickTime){const t=e-this.lastTickTime;this.time+=this.animationSpeed*(t/1e3);const o=this.getAnimationStart(),r=this.getAnimationEnd();this.time=o+(this.time-o)%(r-o),isNaN(this.time)&&(this.time=o),this.emit("tick",{time:this.time})}this.lastTickTime=e}findSmallerFrameIndex(e){for(let t=this.frames.length-1;t>=0;--t)if(this.frames[t].time<=e)return t;return-1}getCurrentFrames(){if(this.frames.length==0)return{frameA:null,frameB:null,mix:0};let e=this.findSmallerFrameIndex(this.time);e<0&&(e=0);const t=this.frames[e],o=this.frames[Math.min(this.frames.length-1,e+1)],r=o.time-t.time,n=r==0?0:(this.time-t.time)/r;return{frameA:t,frameB:o,mix:n}}getNextFrame(e,t){const o=this.frames.findIndex(r=>r===e);return o<0?null:t<0?o>0?this.frames[o-1]:null:o<this.frames.length-1?this.frames[o+1]:null}}var ft=Object.defineProperty,gt=(i,e,t)=>e in i?ft(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,f=(i,e,t)=>(gt(i,typeof e!="symbol"?e+"":e,t),t);class G extends xt{constructor(e,t,o=null,r=null){super(),f(this,"id"),f(this,"type","custom"),f(this,"renderingMode","3d"),f(this,"camera",new h.Camera),f(this,"scene",new h.Scene),f(this,"slippyTiles",[]),f(this,"map",null),f(this,"renderer",null),f(this,"material"),f(this,"geometry",new h.PlaneBufferGeometry(1,1)),f(this,"flusher"),f(this,"tilegrid"),f(this,"extent",null),f(this,"repaintOnPausedAnimation",!0),f(this,"materialPool",new ot),f(this,"bluringNodePasses",[]),f(this,"tileThreeContainer",new h.Object3D),f(this,"extentScale",1),f(this,"extentChangedThreshold",.75),f(this,"lastExtent",[0,0,0,0]),f(this,"lastExtentArea",0),f(this,"timeInterpolation",!0),f(this,"isReady",!1),f(this,"defaultTexture",new h.DataTexture(new Uint8Array([128,128,128,255]),1,1,h.RGBAFormat)),f(this,"onMoveEndListener"),f(this,"onResizeListener"),f(this,"onMoveListener"),f(this,"coloringFragments",null),f(this,"multiChannelColoringFragment"),f(this,"getMapOrThrow",()=>{if(this.map==null)throw new Error("Accessing map on detached layer");return this.map}),f(this,"getRendererOrThrow",()=>{if(this.renderer==null)throw new Error("Accessing renderer on detached layer");return this.renderer}),this.defaultTexture.needsUpdate=!0,this.id=e,t&&this.init(t,o,r)}init(e,t=null,o=null){var r,n,a,s,l,c,v,p,m;this.coloringFragments=t,this.multiChannelColoringFragment=o,this.repaintOnPausedAnimation=(r=e.repaintOnPausedAnimation)!=null?r:!0,this.onMoveEndListener=this.onMoveEnd.bind(this),this.onResizeListener=this.onResize.bind(this),this.onMoveListener=this.onMove.bind(this),this.tilegrid=De({minZoom:(n=e.minZoom)!=null?n:0,maxZoom:(a=e.maxZoom)!=null?a:4}),e.bounds&&(this.extent=V(e.bounds[0],e.bounds[1]).concat(V(e.bounds[2],e.bounds[3])));let d="";if(this.coloringFragments){const C=this.coloringFragments.map((x,A)=>x.getBlendCode(`_cf_${A}`));let w="fragColor";for(let x=0;x<this.coloringFragments.length;x++)w=`_cf_${x}(${w},inter)`;w=`fragColor=${w};`,d=rt.replace("COLORING_FRAGMENT_DEFS",C.join(`
`)).replace("COLORING_FRAGMENT_CALLS",w)}else o&&(d=o.getCode());const P=((s=e.nbSmoothingBins)!=null?s:16).toFixed(0);this.timeInterpolation=(l=e.timeInterpolation)!=null?l:!0,this.material=new h.RawShaderMaterial({glslVersion:h.GLSL3,uniforms:{opacity:{value:1},time:{value:0},zoom:{value:0},tex0xy:{value:[0,0]},tex1xy:{value:[0,0]},tex0size:{value:1},tex1size:{value:1},tilePixelSize:{value:1},categorySmoothTransition:{value:(c=e.categorySmoothTransition)!=null?c:!1},timeInterpolation:{value:this.timeInterpolation},tex0:{value:null},tex1:{value:null},zoomDelta:{value:0},localSmoothing:{value:(v=e.localSmoothing)!=null?v:!1},maxSmoothingDistance:{value:(p=e.maxSmoothingDistance)!=null?p:12},smoothingDistanceDecayFactor:{value:(m=e.smoothingDistanceDecayFactor)!=null?m:10},texN0:{value:this.defaultTexture},texN1:{value:this.defaultTexture},availableN:{value:!1},texE0:{value:this.defaultTexture},texE1:{value:this.defaultTexture},availableE:{value:!1},texS0:{value:this.defaultTexture},texS1:{value:this.defaultTexture},availableS:{value:!1},texW0:{value:this.defaultTexture},texW1:{value:this.defaultTexture},availableW:{value:!1}},vertexShader:it,fragmentShader:d,depthTest:!1,depthWrite:!1,transparent:!0,defines:{RENDER_TRANSPARENT:e.renderTransparentArea?"true":"false",NB_SMOOTHING_BINS:P}}),this.flusher=new h.Mesh(new h.PlaneBufferGeometry(1,1),new h.MeshBasicMaterial({colorWrite:!1,depthWrite:!1})),this.flusher.frustumCulled=!1,this.scene.add(this.flusher),this.scene.add(this.tileThreeContainer),this.updateSlippyTileGrid(8,8),this.on("playAnimation",()=>{this.forceRepaint()}),this.on("animationTimeSet",()=>{this.forceRepaint()}),this.isReady=!0}updateSlippyTileGrid(e,t){this.tileThreeContainer.clear(),this.slippyTiles.length=0;for(let o=0;o<e;o++){this.slippyTiles[o]=[];for(let r=0;r<t;r++){const n=new h.Mesh(this.geometry);n.frustumCulled=!1,this.slippyTiles[o][r]=n,this.tileThreeContainer.add(n)}}}addSource(e,t,o=null){const r=new mt(t,(n,a,s)=>{o&&o(n,a,s),this.forceRepaint()});if(this.map){const n=this.map.getSdkConfig().apiKey,a=this.map.getMaptilerSessionId();r.setMaptilerParams(n,a)}super.addFrame(e,r)}removeSource(e){super.removeFrame(e).forEach(t=>{t.data.dispose()}),this.forceRepaint()}getVisibleExtent(e){if(!this.isReady)return;const t=this.getMapOrThrow().getBounds();let o=V(t.getWest(),t.getSouth()).concat(V(t.getEast(),t.getNorth()));return this.extent&&(o=Ae(this.extent,o)),e&&Me(o,e),o}getWantedTiles(e){if(!this.isReady)return;e=Math.ceil(e);const t={},o=this.getVisibleExtent(),r=this.tilegrid.getMinZoom(),n=this.tilegrid.getMaxZoom(),a=Math.min(n,Math.max(r,e-1)),s=Math.min(n,Math.max(r,e));for(let l=a;l<=s;++l){const c=Math.pow(2,l),v=this.tilegrid.getTileRangeForExtentAndZ(o,l);for(let p=v.minX;p<=v.maxX;++p)for(let m=v.minY;m<=v.maxY;++m)m<0||m>=c||(t[`${l}/${p}/${m}`]=!0)}return t}setOpacity(e){this.isReady&&(this.material.uniforms.opacity.value=e,this.forceRepaint())}onAdd(e,t){this.map=e,this.map.on("moveend",this.onMoveEndListener),this.map.on("resize",this.onResizeListener),this.map.on("move",this.onMoveListener);const o=this.map.getSdkConfig().apiKey,r=this.map.getMaptilerSessionId();this.forEachFrame(n=>{n.data.setMaptilerParams(o,r)}),this.renderer=new h.WebGLRenderer({canvas:e.getCanvas(),context:t,depth:!1,stencil:!1,antialias:!0}),this.renderer.autoClear=!1,this.renderer.sortObjects=!1,this.renderer.debug.checkShaderErrors=!0,this.renderer.compile(this.scene,this.camera),this.onResize(),this.refresh(),this.lastExtent=this.getVisibleExtent(this.extentScale),this.lastExtentArea=ee(this.lastExtent),this.forceRepaint()}onMove(){if(!this.isReady)return;const e=this.getVisibleExtent(this.extentScale),t=ee(e),o=[Math.min(e[0],this.lastExtent[0]),Math.min(e[1],this.lastExtent[1]),Math.max(e[2],this.lastExtent[2]),Math.max(e[3],this.lastExtent[3])],r=ee(o);Ie(this.lastExtent,e)/r<=this.extentChangedThreshold&&(this.lastExtent=e,this.lastExtentArea=t,this.emit("extentChanged"))}refresh(){}onRemove(e,t){this.isReady&&(this.map!=null&&(this.map.off("moveend",this.onMoveEndListener),this.map.off("resize",this.onResizeListener),this.map.off("move",this.onMoveListener),this.map=null),this.renderer!=null&&(this.renderer.dispose(),this.renderer=null),this.forEachFrame(o=>{o.data.dispose()}),this.disposeObjects())}disposeObjects(){this.isReady&&(this.geometry.dispose(),this.material.dispose(),this.flusher.geometry.dispose(),this.flusher.material.dispose(),this.bluringNodePasses.forEach(e=>e.dispose()))}onResize(){if(!this.isReady)return;const e=this.getMapOrThrow().getCanvas(),t=e.width,o=e.height;this.getRendererOrThrow().setViewport(0,0,t,o),this.updateSlippyTileGrid(Math.ceil(t/512)+2,Math.ceil(o/512)+2)}onMoveEnd(){}getTilePlacement(e,t,o,r,n,a){if(!this.isReady)return;const s=`${o}/${r}/${n}`,l=e.getTile(s,t);if(!l||!l.ready)return o>this.tilegrid.getMinZoom()?this.getTilePlacement(e,t,o-1,Math.floor(r/2),Math.floor(n/2),a||{z:o,x:r,y:n}):null;const c={tile:l,xy:[0,0],size:1};if(a!==void 0){const v=Math.pow(2,a.z-o);c.size/=v,c.xy[0]=a.x%v/v,c.xy[1]=(Math.pow(2,a.z)-a.y-1)%v/v}return c}updateSlippyTiles(){var e;if(!this.isReady)return;const{frameA:t,frameB:o,mix:r}=this.getCurrentFrames();if(!t||!o){this.scene.visible=!1;return}this.scene.visible=!0;const n=t.data,a=o.data,s=this.getMapOrThrow().getZoom(),l=this.getWantedTiles(s),c={},v=this.tilegrid.getMinZoom(),p=this.tilegrid.getMaxZoom(),m=Math.min(p,Math.max(v,Math.floor(s))),d=Math.pow(2,m),P=1/d,C=this.getMapOrThrow().getCenter(),w=this.tilegrid.getTileCoordForCoordAndZ(V(C.lng,C.lat),m),x=s-m,A=this.slippyTiles.length;this.materialPool.init();const _=new globalThis.Map;for(let E=0;E<A;E++){const z=this.slippyTiles[0].length;for(let F=0;F<z;F++){const M=this.slippyTiles[E][F],g=w[1]+E-Math.floor(A/2),O=w[2]+F-Math.floor(z/2),Y=`${m}/${g}/${O}`;if(O<0||O>=d||!l[Y]){M.visible=!1;continue}M.visible=!0;const U=(g%d+d)%d,H=`${m}/${U}/${O}`;c[H]=!0;const Q=d-O-1;M.scale.x=P,M.scale.y=P,M.position.x=P*(g+.5),M.position.y=P*(Q+.5)-1;let b=this.getTilePlacement(n,!0,m,U,O),I=this.getTilePlacement(a,!0,m,U,O);if(b&&!I&&(I=b),!b&&I&&(b=I),!b||!I){let y=t;for(;!b&&(y=this.getNextFrame(y,-1),!!y);)b=I=this.getTilePlacement(y.data,!1,m,U,O);if(!b||!I){M.visible=!1;continue}}const R=this.materialPool.isEmpty()?this.materialPool.add(this.material.clone()):this.materialPool.pop();R.uniforms.localSmoothing.value=this.material.uniforms.localSmoothing.value,R.uniforms.maxSmoothingDistance.value=this.material.uniforms.maxSmoothingDistance.value,R.uniforms.smoothingDistanceDecayFactor.value=this.material.uniforms.smoothingDistanceDecayFactor.value,R.uniforms.timeInterpolation.value=this.material.uniforms.timeInterpolation.value,R.uniforms.categorySmoothTransition.value=this.material.uniforms.categorySmoothTransition.value,R.uniforms.opacity.value=this.material.uniforms.opacity.value,R.uniforms.tex0.value=b.tile.texture,R.uniforms.tex0xy.value=b.xy,R.uniforms.tex0size.value=b.size,R.uniforms.tex1.value=I.tile.texture,R.uniforms.tex1xy.value=I.xy,R.uniforms.tex1size.value=I.size,R.uniforms.tilePixelSize.value=(e=b.tile.texture)==null?void 0:e.image.width,R.uniforms.time.value=r,R.uniforms.zoomDelta.value=x,M.material=R,R.uniforms.zoom.value=s,_.set(`${E} ${F}`,{material:R,tileA:b,tileB:I,x:E,y:F,z:m})}}this.material.uniforms.localSmoothing.value&&_.forEach((E,z)=>{const F=E.x,M=E.y,g=E.material,O={x:F,y:M-1},Y={x:F+1,y:M},U={x:F,y:M+1},H={x:F-1,y:M},Q=`${O.x} ${O.y}`,b=`${Y.x} ${Y.y}`,I=`${U.x} ${U.y}`,R=`${H.x} ${H.y}`;let y=_.get(Q);y&&y.tileA.tile.ready&&y.tileB.tile.ready?(g.uniforms.texN0.value=y.tileA.tile.texture,g.uniforms.texN1.value=y.tileB.tile.texture,g.uniforms.availableN.value=!0):(g.uniforms.texN0.value=null,g.uniforms.texN1.value=null,g.uniforms.availableN.value=!1),y=_.get(b),y&&y.tileA.tile.ready&&y.tileB.tile.ready?(g.uniforms.texE0.value=y.tileA.tile.texture,g.uniforms.texE1.value=y.tileB.tile.texture,g.uniforms.availableE.value=!0):(g.uniforms.texE0.value=null,g.uniforms.texE1.value=null,g.uniforms.availableE.value=!1),y=_.get(I),y&&y.tileA.tile.ready&&y.tileB.tile.ready?(g.uniforms.texS0.value=y.tileA.tile.texture,g.uniforms.texS1.value=y.tileB.tile.texture,g.uniforms.availableS.value=!0):(g.uniforms.texS0.value=null,g.uniforms.texS1.value=null,g.uniforms.availableS.value=!1),y=_.get(R),y&&y.tileA.tile.ready&&y.tileB.tile.ready?(g.uniforms.texW0.value=y.tileA.tile.texture,g.uniforms.texW1.value=y.tileB.tile.texture,g.uniforms.availableW.value=!0):(g.uniforms.texW0.value=null,g.uniforms.texW1.value=null,g.uniforms.availableW.value=!1)}),setTimeout(()=>{n.expireCache(c),a.expireCache(c);const E=this.getNextFrame(o,1);E&&E.data&&Object.keys(c).forEach(z=>{E.data.getTile(z,!0)})},0)}prerender(e,t){if(!this.isReady)return;this.animationTick();const o=new h.Matrix4().fromArray(t),r=new h.Matrix4().makeTranslation(0,0,0).scale(new h.Vector3(1,-1,1));this.camera.projectionMatrix=o.multiply(r),this.updateSlippyTiles(),this.prerenderInternal()}prerenderInternal(){}render(e,t){if(!this.isReady)return;const o=this.getRendererOrThrow();o.state.reset(),this.renderInternal(),o.render(this.scene,this.camera),(this.getAnimationSpeed()>0||this.repaintOnPausedAnimation)&&this.forceRepaint()}renderInternal(){}pickFrame(e,t,o){if(!this.isReady)return null;const r=ie(e,t),n=this.tilegrid.getMaxZoom(),a=Math.pow(2,n),s=(.5+r[0])%1*a,l=(1-(r[1]+.5))*a,c=this.getTilePlacement(o,!1,n,Math.floor(s),Math.floor(l));if(c==null||c.tile.texture==null)return null;const v=xe(c.tile.texture.image,c.xy[0]+c.size*(s%1),1-c.xy[1]-c.size+c.size*(l%1));return this.coloringFragments?this.coloringFragments.map(p=>p.decodeChannel(v)).flat():this.multiChannelColoringFragment?this.multiChannelColoringFragment.decodeChannel(v):null}pick(e,t){if(!this.isReady)return;const{frameA:o,frameB:r,mix:n}=this.getCurrentFrames();if(!o||!r)return null;const a=this.pickFrame(e,t,o.data),s=this.pickFrame(e,t,r.data);return a?s?this.coloringFragments?a.map((l,c)=>{const v=s[c];return Array.isArray(l)&&Array.isArray(v)?l.map((p,m)=>{const d=v[m];return p*(1-n)+d*n}):l*(1-n)+v*n}).flat():this.multiChannelColoringFragment?this.timeInterpolation?[a[0]*(1-n)+s[0]*n,n<.5?a[1]:s[1]]:[n<.5?a[0]:s[0],n<.5?a[1]:s[1]]:null:a:s}forceRepaint(){try{this.getMapOrThrow().triggerRepaint()}catch{}}computeCurrentMixedImage({zxy:e="0/0/0",blurKernel:t=0,outputSize:o=-1,channel:r="r"}){var n,a,s,l;if(!this.isReady)return;const c=this.getCurrentFrames(),v=c.mix,p=(a=(n=c.frameA)==null?void 0:n.data.getTile(e,!1))==null?void 0:a.texture,m=(l=(s=c.frameB)==null?void 0:s.data.getTile(e,!1))==null?void 0:l.texture,d=o<0?parseInt(p?.image.width):o,P=o<0?parseInt(p?.image.height):o;this.bluringNodePasses.length||this.bluringNodePasses.push(new le(d,P),new le(d,P),new le(d,P));const C=this.bluringNodePasses[0],w=this.bluringNodePasses[1],x=this.bluringNodePasses[2];if(C.setSize(d,P),w.setSize(d,P),w.setSize(d,P),C.setFragmentShader(nt),C.setDefine("CHANNEL",r),C.setUniform("imageA",p),C.setUniform("imageB",m),C.setUniform("mixValue",v),C.process(),t===0){const _=C.getPixelData();return{data:_,channels:_.length/(d*P),width:d,height:P}}if(![5,9,13,19].includes(t))throw new Error(`The kernel bluring kernel size ${t} is not available.`);w.setUniform("direction",new h.Vector2(1,0)),w.setUniform("kernelSize",t),w.setUniform("imgToBlur",C.getOutputTexture()),w.setFragmentShader(Pe),w.process(),x.setUniform("direction",new h.Vector2(0,1)),x.setUniform("kernelSize",t),x.setUniform("imgToBlur",w.getOutputTexture()),x.setFragmentShader(Pe),x.process();const A=x.getPixelData();return{data:A,channels:A.length/(d*P),width:d,height:P}}setTimeInterpolation(e){this.isReady&&(this.material.uniforms.timeInterpolation.value=e)}setCategorySmoothTransition(e){this.isReady&&(this.material.uniforms.categorySmoothTransition.value=e,this.forceRepaint())}setLocalSmoothing(e){this.material.uniforms.localSmoothing.value=e,this.forceRepaint()}setMaxSmoothingDistance(e){this.material.uniforms.maxSmoothingDistance.value=e,this.forceRepaint()}setSmoothingDistanceDecayFactor(e){this.material.uniforms.smoothingDistanceDecayFactor.value=e,this.forceRepaint()}getRepaintOnPausedAnimation(){return this.repaintOnPausedAnimation}setRepaintOnPausedAnimation(e){this.repaintOnPausedAnimation=e,this.forceRepaint()}}var yt=`

precision highp float;
precision highp sampler2D;

uniform float opacity;
uniform sampler2D tex0;

in vec2 coord;
out vec4 fragColor;

void main() {
  vec4 c = texture(tex0, coord);

  if (c.a < 1.0 / 16.0) {
    discard;
  }

  if (opacity < 0.0001) {
    discard;
  }

  fragColor = c;
  fragColor.a *= opacity;
}
`,St=`

precision highp float;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

in vec3 position;
in vec2 uv;
out vec2 coord;

void main()	{
  coord = uv;
  gl_Position =
    projectionMatrix *
    modelViewMatrix *
    vec4(position,1.);
}`,Tt=`

precision highp float;
precision highp sampler2D;

out vec4 fragColor;

in float speed;

void main() {

  vec2 uv = vec2( gl_PointCoord.x -0.5, 1.0 - gl_PointCoord.y-0.5 );
  float dFromCenter = sqrt(uv.x*uv.x + uv.y*uv.y);

  if(dFromCenter > 0.5){
    discard;
    return;
  }

  if (speed == 0.) {
    discard;
    return;
  }

  float colorFactor = min(1.0, speed / COLOR_SPEED);

  fragColor = mix(COLOR_A, COLOR_B, colorFactor);

  float opacityFactor = smoothstep(0.05, 0.1, speed); // fade slow particles <0.1px/s change
  fragColor.a *= opacityFactor;
}`,Pt=`#version 300 es

precision highp float;



uniform sampler2D rttTexture;
uniform sampler2D rttTexturePrev;
uniform float rttSize;
uniform float screenSize;

uniform float extrapolationFactor;
uniform float renderStepSize;

out float speed;

vec4 advance(float position_) {
  if (position_ > (DENSITY / 1000.0) * screenSize * screenSize) {
    speed = 0.0;
    return vec4(0.0);
  }

  float x = fract(position_ / rttSize);
  float y = floor(position_ / rttSize) / rttSize;

  vec4 color = texture(rttTexture, vec2(x, y));
  vec2 pos = color.ba + color.rg / 255.0;

  vec4 colorPrev = texture(rttTexturePrev, vec2(x, y));
  vec2 posPrev = colorPrev.ba + colorPrev.rg / 255.0;

  vec2 diff = pos - posPrev;
  pos += diff * extrapolationFactor;

  speed =
    renderStepSize *
    step(0.0001, dot(posPrev, posPrev)) * // ignore initial zero
    length(diff * screenSize);

  return vec4(pos, diff);
}

void main() {
  float position_ = floor(position / 2.0);
  float vertex = 2.0 * fract(position / 2.0);

  vec4 posdiff = advance(position_);
  vec2 pos = posdiff.xy;
  vec2 dir = normalize(posdiff.zw);

  vec2 uv = (float(SIZE) / screenSize) * vec2(vertex, -vertex) * dir.yx;

  pos = 2.0 * (pos - uv) - 1.0;
  gl_Position = vec4(pos.x, -pos.y, 0., 1.);
}`,wt=`

precision highp float;
precision highp sampler2D;

in float position;

uniform sampler2D rttTexture;
uniform sampler2D rttTexturePrev;
uniform float rttSize;
uniform float screenSize;

uniform float extrapolationFactor;
uniform float renderStepSize;

out float speed;

float factor = 1.;

vec4 advance(float position_) {
  if (position_ > (DENSITY / 1000.0) * screenSize * screenSize) {
    speed = 0.0;
    return vec4(0.0);
  }

  float x = fract(position_ / rttSize);
  float y = floor(position_ / rttSize) / rttSize;

  vec4 color = texture(rttTexture, vec2(x, y));
  vec2 pos = color.ba + color.rg / 255.0;

  vec4 colorPrev = texture(rttTexturePrev, vec2(x, y));
  vec2 posPrev = colorPrev.ba + colorPrev.rg / 255.0;

  vec2 diff = pos - posPrev;
  pos += diff * extrapolationFactor;

  speed =
    renderStepSize *
    step(0.0001, dot(posPrev, posPrev)) * // ignore initial zero
    length(diff * screenSize);

  return vec4(pos, diff);
}

void main() {
  vec4 posdiff = advance(position);

  gl_PointSize = SIZE;
  gl_Position =
    vec4(2.0*posdiff.x-1.0,-(2.0*posdiff.y-1.0),0.,1.);
}`,Ct=`

precision highp float;
precision highp sampler2D;

#define M_PI 3.14159265358

uniform float tileScale;
uniform vec2 tilePosition;
uniform vec2 tex0xy;
uniform vec2 tex1xy;
uniform float tex0size;
uniform float tex1size;
uniform bool useAlphaAsMask;
uniform sampler2D rttTexture;
uniform vec2 rttXY;
uniform float rttScale;
uniform float time;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform float timestep;

in vec2 rttCoord;
out vec4 fragColor;


void main() {
  vec4 color = texture(rttTexture, rttCoord);

  vec2 pos = color.ba + color.rg / 255.0;

  vec2 posInTile = (rttXY + rttScale * pos) / tileScale - tilePosition;

  if (posInTile.x >= 0. && posInTile.x <= 1. &&
      posInTile.y >= 0. && posInTile.y <= 1.) {

    posInTile.y = 1.0 - posInTile.y;

    vec2 tex0coord = tex0xy + posInTile * tex0size;
    vec2 tex1coord = tex1xy + posInTile * tex1size;

    vec4 tex0Color = texture(tex0, tex0coord);
    vec4 tex1Color = texture(tex1, tex1coord);

    // We use the alpha chan to flag no-data pixels.
    // In this case, we return pos at it was received so that the speed is 0
    if (useAlphaAsMask && (tex0Color.a < 1. || tex1Color.a < 1.)) {
      fragColor = color;
      return;
    }

    vec2 uv;
    if (D_WAVES) {
      vec2 value0 = tex0Color.D_CHANNELS;
      vec2 value1 = tex1Color.D_CHANNELS;

      // https://apps.ecmwf.int/codes/grib/param-db?id=140230
      // Zero means 'coming from the north' and 90 'coming from the east'.
      float dir0 = 2.0 * M_PI * (-value0.x - 0.25);
      float dir1 = 2.0 * M_PI * (-value1.x - 0.25);

      // sqrt makes it look much nicer
      float speed = sqrt(1.0 / mix(value0.y, value1.y, time));

      uv = vec2(
        mix(cos(dir0), cos(dir1), time),
        mix(sin(dir0), sin(dir1), time)
      ) * (D_MIN + (D_MAX - D_MIN) * speed);
    } else {
      vec4 lookup = mix(tex0Color, tex1Color, time);
      vec2 value = lookup.D_CHANNELS;
      uv = D_MIN + (D_MAX - D_MIN) * value;
    }

    vec2 offset = vec2(uv.x, -uv.y) * timestep;

    pos = pos + offset;

    fragColor = vec4(
        fract(pos * 255.0),
        floor(pos * 255.0) / 255.0);
  } else {
    // retain the old color to avoid numerical issues on iOS
    fragColor = color;
  }
}`,Rt=`

precision highp float;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

in vec3 position;
in vec2 uv;

out vec2 rttCoord;

void main()	{
  rttCoord = uv;
  gl_Position = projectionMatrix * vec4(position,1.);
}`,Et=Object.defineProperty,bt=(i,e,t)=>e in i?Et(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,S=(i,e,t)=>(bt(i,typeof e!="symbol"?e+"":e,t),t);class we extends G{constructor(e,t,o,r){super(e,null,null),S(this,"rttScene",new h.Scene),S(this,"rttCamera"),S(this,"rttMaterial"),S(this,"rttMesh"),S(this,"particleTexturePrev"),S(this,"particleTexture0"),S(this,"particleTexture1"),S(this,"particleMaterial"),S(this,"particles"),S(this,"particleBackground"),S(this,"accumulator"),S(this,"accumulatorDrawMesh"),S(this,"flipFlop",!1),S(this,"numParticles"),S(this,"particleDensity"),S(this,"refreshInterval"),S(this,"fadeFactor"),S(this,"particleColor"),S(this,"particleFastColor"),S(this,"particleFastSpeed"),S(this,"particleSize"),S(this,"drawAsLines"),S(this,"particleSpeed"),S(this,"pixelRatio"),S(this,"prevRenderTime",0),S(this,"lastRenderTime",0),S(this,"forceRender",!0),S(this,"rttTimestep",200),t&&o&&this.initParticle(t,o,r)}initParticle(e,t,o){var r,n,a,s,l,c,v,p,m,d,P,C,w;if(this.init(e,o,null),this.extentScale=1.2,this.numParticles=128,t.maxAmount!=null)if(t.maxAmount>=4&&t.maxAmount&&!(t.maxAmount&t.maxAmount-1))this.numParticles=t.maxAmount;else throw new Error("The number of particles needs to be power of two and at least 4");const x=window.devicePixelRatio;this.particleDensity=(r=t.density)!=null?r:2,this.particleDensity/=x*x,this.refreshInterval=(n=t.refreshInterval)!=null?n:800,this.fadeFactor=(a=t.fadeFactor)!=null?a:.1,this.particleColor=L((s=t.color)!=null?s:[255,255,255,192]),this.particleFastColor=t.fastColor?L(t.fastColor):this.particleColor,this.particleFastSpeed=((l=t.fastSpeed)!=null?l:2)*x,this.particleSize=(c=t.size)!=null?c:1.5,this.drawAsLines=(v=t.drawAsLines)!=null?v:!1,this.particleSpeed=((p=t.speed)!=null?p:.001)/1e3,this.pixelRatio=(m=t.pixelRatio)!=null?m:x>1?1:2,this.particleTexturePrev=this.generateRandomizeParticleTexture(this.numParticles,this.numParticles),this.particleTexture0=new h.WebGLRenderTarget(this.numParticles,this.numParticles,{stencilBuffer:!1,depthBuffer:!1}),this.particleTexture0.texture=this.particleTexturePrev.clone(),this.particleTexture1=this.particleTexture0.clone(),this.rttMaterial=new h.RawShaderMaterial({glslVersion:h.GLSL3,uniforms:{rttXY:{value:[0,0]},rttScale:{value:1},rttTexture:{value:this.particleTexture0.texture},tileScale:{value:0},useAlphaAsMask:{value:(d=t.useAlphaAsMask)!=null?d:!1},tilePosition:{value:[0,0]},time:{value:0},timestep:{value:0},tex0xy:{value:[0,0]},tex1xy:{value:[0,0]},tex0size:{value:1},tex1size:{value:1},tex0:{value:null},tex1:{value:null}},vertexShader:Rt,fragmentShader:Ct,defines:{D_MIN:((P=t.decodeMin)!=null?P:0).toFixed(2),D_MAX:((C=t.decodeMax)!=null?C:1).toFixed(2),D_CHANNELS:(w=t.decodeChannels)!=null?w:"rg",D_WAVES:t.decodeAsWaves?"true":"false"},depthTest:!1,depthWrite:!1}),this.rttCamera=new h.OrthographicCamera(-this.numParticles/2,this.numParticles/2,this.numParticles/2,-this.numParticles/2,-100,100),this.rttMesh=new h.Mesh(new h.PlaneBufferGeometry(this.numParticles,this.numParticles),this.rttMaterial),this.rttScene.add(this.rttMesh),this.accumulator=new h.WebGLRenderTarget(16,16,{minFilter:h.LinearFilter,magFilter:h.LinearFilter,stencilBuffer:!1,format:h.RGBAFormat,depthBuffer:!1}),this.particleBackground=new h.Mesh(new h.PlaneBufferGeometry(2,2),new h.RawShaderMaterial({glslVersion:h.GLSL3,transparent:!0,blending:h.CustomBlending,blendEquationAlpha:h.ReverseSubtractEquation,vertexShader:"precision highp float;in vec3 position;void main(){gl_Position=vec4(position,1.);}",fragmentShader:`precision highp float;out vec4 fragColor;void main(){fragColor=vec4(.0,.0,.0,${this.fadeFactor.toFixed(2)});}`}));const A=x*this.pixelRatio*this.particleSize,_=x*this.particleSize;if(this.particleMaterial=new h.RawShaderMaterial({glslVersion:h.GLSL3,uniforms:{rttSize:{value:this.numParticles},rttTexture:{value:this.particleTexture1.texture},rttTexturePrev:{value:this.particleTexturePrev},screenSize:{value:1},extrapolationFactor:{value:0},renderStepSize:{value:0}},vertexShader:this.drawAsLines?Pt:wt,fragmentShader:Tt,defines:{COLOR_A:this.particleColor,COLOR_B:this.particleFastColor,COLOR_SPEED:this.particleFastSpeed.toFixed(2),DENSITY:this.particleDensity.toFixed(2),SIZE:(this.drawAsLines?_:A).toFixed(1)},transparent:!0,depthTest:!1,depthWrite:!1,linewidth:this.pixelRatio}),this.drawAsLines){const E=new Float32Array(Array(2*this.numParticles*this.numParticles).keys()),z=new h.BufferGeometry;z.setAttribute("position",new h.Float32BufferAttribute(E,1)),this.particles=new h.LineSegments(z,this.particleMaterial)}else{const E=new Float32Array(Array(this.numParticles*this.numParticles).keys()),z=new h.BufferGeometry;z.setAttribute("position",new h.Float32BufferAttribute(E,1)),this.particles=new h.Points(z,this.particleMaterial)}this.particles.frustumCulled=!1,this.accumulatorDrawMesh=new h.Mesh(new h.PlaneBufferGeometry(1,1),new h.RawShaderMaterial({glslVersion:h.GLSL3,premultipliedAlpha:!0,transparent:!0,depthTest:!1,depthWrite:!1,uniforms:{opacity:{value:1},tex0:{value:this.accumulator.texture}},vertexShader:St,fragmentShader:yt})),this.scene.add(this.accumulatorDrawMesh),setInterval(()=>{this.renderer&&this.randomizeParticles(!1)},this.refreshInterval),this.on("extentChanged",()=>{this.refresh()})}onAdd(e,t){super.onAdd(e,t)}generateRandomizeParticleTexture(e,t){const o=new Uint8Array(4*e*t);for(let r=0;r<o.length;r++)o[r]=Math.floor(256*Math.random());return new h.DataTexture(o,e,t)}randomizeParticles(e){if(!this.renderer)return;let t=this.numParticles,o=this.numParticles;const r=new h.Vector2(0,0);if(!e){const a=this.numParticles/4;t=a,o=a,r.x=Math.floor(Math.random()*this.numParticles/a)*a,r.y=Math.floor(Math.random()*this.numParticles/a)*a}const n=this.generateRandomizeParticleTexture(t,o);this.renderer.copyTextureToTexture(r,n,this.particleTexturePrev),this.renderer.copyTextureToTexture(r,n,this.particleTexture0.texture),this.renderer.copyTextureToTexture(r,n,this.particleTexture1.texture),n.dispose(),this.forceRender=e}getParticleUtilization(){const e=this.particleMaterial.uniforms.screenSize.value;return this.particleDensity/1e3*e*e/(this.numParticles*this.numParticles)}setOpacity(e){super.setOpacity(e),this.accumulatorDrawMesh.material.uniforms.opacity.value=e}disposeObjects(){super.disposeObjects(),this.particleTexturePrev.dispose(),this.particleTexture0.texture.dispose(),this.particleTexture0.dispose(),this.particleTexture1.texture.dispose(),this.particleTexture1.dispose(),this.accumulator.texture.dispose(),this.accumulator.dispose(),this.rttMesh.geometry.dispose(),this.rttMesh.material.dispose(),this.particleBackground.geometry.dispose(),this.particleBackground.material.dispose(),this.particles.geometry.dispose(),this.particles.material.dispose(),this.accumulatorDrawMesh.geometry.dispose(),this.accumulatorDrawMesh.material.dispose()}onResize(){super.onResize();const e=this.getMapOrThrow().getCanvas(),t=e.width,o=e.height;let r=Math.round(this.pixelRatio*this.extentScale*Math.max(t,o));r=Math.min(r,this.getRendererOrThrow().capabilities.maxTextureSize),this.accumulator.setSize(r,r),this.particleMaterial.uniforms.screenSize.value=r/this.pixelRatio,this.scene.remove(this.accumulatorDrawMesh),this.scene.add(this.accumulatorDrawMesh)}onMoveEnd(){}refresh(){const e=this.getVisibleExtent(this.extentScale),t=Math.max(e[2]-e[0],e[3]-e[1])/j,o=[.5+(e[2]+e[0])/2/j-t/2,.5-(e[3]+e[1])/2/j-t/2];this.rttMaterial.uniforms.rttScale.value=t,this.rttMaterial.uniforms.rttXY.value=o;const r=this.getRendererOrThrow();r.setRenderTarget(this.accumulator),r.setClearAlpha(0),r.clearColor(),r.setRenderTarget(null),this.randomizeParticles(!0)}prerenderInternal(){const e=performance.now(),t=e-this.lastRenderTime,o=this.forceRender||t>this.rttTimestep||!this.prevRenderTime;if(o){this.forceRender=!1,this.rttMaterial.uniforms.timestep.value=this.particleSpeed*t,this.getRendererOrThrow().setRenderTarget(this.flipFlop?this.particleTexture0:this.particleTexture1),this.getRendererOrThrow().copyFramebufferToTexture(new h.Vector2(0,0),this.particleTexturePrev),this.prevRenderTime=this.lastRenderTime,this.lastRenderTime=e;const s=this.slippyTiles.length;for(let l=0;l<s;l++){const c=this.slippyTiles[0].length;for(let v=0;v<c;v++){const p=this.slippyTiles[l][v];if(!p.visible)continue;const m=p.material.uniforms;if(!m)continue;const d=p.scale.x;this.rttMaterial.uniforms.tileScale.value=d,this.rttMaterial.uniforms.tilePosition.value=[p.position.x/d-.5,-p.position.y/d-.5],this.rttMaterial.uniforms.time.value=m.time.value,this.rttMaterial.uniforms.tex0.value=m.tex0.value,this.rttMaterial.uniforms.tex0xy.value=m.tex0xy.value,this.rttMaterial.uniforms.tex0size.value=m.tex0size.value,this.rttMaterial.uniforms.tex1.value=m.tex1.value,this.rttMaterial.uniforms.tex1xy.value=m.tex1xy.value,this.rttMaterial.uniforms.tex1size.value=m.tex1size.value,this.rttMaterial.uniforms.rttTexture.value=(this.flipFlop?this.particleTexture1:this.particleTexture0).texture;const P=this.getRendererOrThrow();P.setRenderTarget(this.flipFlop?this.particleTexture0:this.particleTexture1),P.render(this.rttScene,this.rttCamera),this.flipFlop=!this.flipFlop}}this.particleMaterial.uniforms.rttTexture.value=(this.flipFlop?this.particleTexture0:this.particleTexture1).texture}const r=this.lastRenderTime-this.prevRenderTime,n=o?0:t/r;this.particleMaterial.uniforms.extrapolationFactor.value=n,this.particleMaterial.uniforms.renderStepSize.value=r/1e3;const a=this.getRendererOrThrow();a.setRenderTarget(this.accumulator),a.render(this.particleBackground,this.camera),a.render(this.particles,this.camera),a.setRenderTarget(null)}renderInternal(){const e=this.rttMaterial.uniforms.rttScale.value;this.accumulatorDrawMesh.position.x=.5*e+this.rttMaterial.uniforms.rttXY.value[0],this.accumulatorDrawMesh.position.y=-.5*e-this.rttMaterial.uniforms.rttXY.value[1],this.accumulatorDrawMesh.scale.x=this.accumulatorDrawMesh.scale.y=e}}var _t=Object.defineProperty,At=(i,e,t)=>e in i?_t(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,se=(i,e,t)=>(At(i,typeof e!="symbol"?e+"":e,t),t);const u=class ue extends Array{constructor(e={}){super(),se(this,"min",0),se(this,"max",1),"min"in e&&(this.min=e.min),"max"in e&&(this.max=e.max),"stops"in e&&this.setStops(e.stops,{clone:!1})}static fromArrayDefinition(e){return new ue({stops:e.map(t=>({value:t[0],color:t[1]}))})}setStops(e,t={clone:!0}){const o=t.clone?this.clone():this;o.length=0;let r=1/0,n=-1/0;for(let a=0;a<e.length;a+=1)r=Math.min(r,e[a].value),n=Math.max(n,e[a].value),o.push({value:e[a].value,color:e[a].color.slice()});return o.sort((a,s)=>a.value<s.value?-1:1),this.min=r,this.max=n,o}scale(e,t,o={clone:!0}){const r=o.clone?this.clone():this,n=r[0].value,a=r.at(-1).value-n,s=t-e;for(let l=0;l<r.length;l+=1){const c=(r[l].value-n)/a*s+e;r[l].value=c}return r}clone(){return new ue({stops:this.getRawColorStops()})}getRawColorStops(){const e=[];for(let t=0;t<this.length;t+=1)e.push(this[t]);return e}reverse(e={clone:!0}){const t=e.clone?this.clone():this;for(let o=0;o<~~(t.length/2);o+=1){const r=t[o].color;t[o].color=t.at(-(o+1)).color,t.at(-(o+1)).color=r}return t}getBounds(){return{min:this.min,max:this.max}}getColor(e,t={smooth:!0}){if(e<=this[0].value)return this[0].color;if(e>=this.at(-1).value)return this.at(-1).color;for(let o=0;o<this.length-1;o+=1){if(e>this[o+1].value)continue;const r=this[o].color;if(!t.smooth)return r.slice();const n=this[o].value,a=this[o+1].value,s=this[o+1].color,l=(a-e)/(a-n);return r.map((c,v)=>Math.round(c*l+s[v]*(1-l)))}}getCanvasStrip(e={horizontal:!0,size:512,smooth:!0}){const t=document.createElement("canvas");t.width=e.horizontal?e.size:1,t.height=e.horizontal?1:e.size;const o=t.getContext("2d"),r=o.getImageData(0,0,t.width,t.height),n=r.data,a=this[0].value,s=(this.at(-1).value-a)/e.size;for(let l=0;l<e.size;l+=1){const c=this.getColor(a+l*s,{smooth:e.smooth});n[l*4]=c[0],n[l*4+1]=c[1],n[l*4+2]=c[2],n[l*4+3]=c.length>3?c[3]:255}return o.putImageData(r,0,0),t}};se(u,"builtin",{NULL:new u({stops:[{value:0,color:[0,0,0,0]},{value:1,color:[0,0,0,0]}]}),JET:new u({stops:[{value:0,color:[0,0,131]},{value:.125,color:[0,60,170]},{value:.375,color:[5,255,255]},{value:.625,color:[255,255,0]},{value:.875,color:[250,0,0]},{value:1,color:[128,0,0]}]}),HSV:new u({stops:[{value:0,color:[255,0,0]},{value:.169,color:[253,255,2]},{value:.173,color:[247,255,2]},{value:.337,color:[0,252,4]},{value:.341,color:[0,252,10]},{value:.506,color:[1,249,255]},{value:.671,color:[2,0,253]},{value:.675,color:[8,0,253]},{value:.839,color:[255,0,251]},{value:.843,color:[255,0,245]},{value:1,color:[255,0,6]}]}),HOT:new u({stops:[{value:0,color:[0,0,0]},{value:.3,color:[230,0,0]},{value:.6,color:[255,210,0]},{value:1,color:[255,255,255]}]}),SPRING:new u({stops:[{value:0,color:[255,0,255]},{value:1,color:[255,255,0]}]}),SUMMER:new u({stops:[{value:0,color:[0,128,102]},{value:1,color:[255,255,102]}]}),AUTOMN:new u({stops:[{value:0,color:[255,0,0]},{value:1,color:[255,255,0]}]}),WINTER:new u({stops:[{value:0,color:[0,0,255]},{value:1,color:[0,255,128]}]}),BONE:new u({stops:[{value:0,color:[0,0,0]},{value:.376,color:[84,84,116]},{value:.753,color:[169,200,200]},{value:1,color:[255,255,255]}]}),COPPER:new u({stops:[{value:0,color:[0,0,0]},{value:.804,color:[255,160,102]},{value:1,color:[255,199,127]}]}),GREYS:new u({stops:[{value:0,color:[0,0,0]},{value:1,color:[255,255,255]}]}),YIGNBU:new u({stops:[{value:0,color:[8,29,88]},{value:.125,color:[37,52,148]},{value:.25,color:[34,94,168]},{value:.375,color:[29,145,192]},{value:.5,color:[65,182,196]},{value:.625,color:[127,205,187]},{value:.75,color:[199,233,180]},{value:.875,color:[237,248,217]},{value:1,color:[255,255,217]}]}),GREENS:new u({stops:[{value:0,color:[0,68,27]},{value:.125,color:[0,109,44]},{value:.25,color:[35,139,69]},{value:.375,color:[65,171,93]},{value:.5,color:[116,196,118]},{value:.625,color:[161,217,155]},{value:.75,color:[199,233,192]},{value:.875,color:[229,245,224]},{value:1,color:[247,252,245]}]}),YIORRD:new u({stops:[{value:0,color:[128,0,38]},{value:.125,color:[189,0,38]},{value:.25,color:[227,26,28]},{value:.375,color:[252,78,42]},{value:.5,color:[253,141,60]},{value:.625,color:[254,178,76]},{value:.75,color:[254,217,118]},{value:.875,color:[255,237,160]},{value:1,color:[255,255,204]}]}),BLUERED:new u({stops:[{value:0,color:[0,0,255]},{value:1,color:[255,0,0]}]}),RDBU:new u({stops:[{value:0,color:[5,10,172]},{value:.35,color:[106,137,247]},{value:.5,color:[190,190,190]},{value:.6,color:[220,170,132]},{value:.7,color:[230,145,90]},{value:1,color:[178,10,28]}]}),PICNIC:new u({stops:[{value:0,color:[0,0,255]},{value:.1,color:[51,153,255]},{value:.2,color:[102,204,255]},{value:.3,color:[153,204,255]},{value:.4,color:[204,204,255]},{value:.5,color:[255,255,255]},{value:.6,color:[255,204,255]},{value:.7,color:[255,153,255]},{value:.8,color:[255,102,204]},{value:.9,color:[255,102,102]},{value:1,color:[255,0,0]}]}),RAINBOW:new u({stops:[{value:0,color:[150,0,90]},{value:.125,color:[0,0,200]},{value:.25,color:[0,25,255]},{value:.375,color:[0,152,255]},{value:.5,color:[44,255,150]},{value:.625,color:[151,255,0]},{value:.75,color:[255,234,0]},{value:.875,color:[255,111,0]},{value:1,color:[255,0,0]}]}),PORTLAND:new u({stops:[{value:0,color:[12,51,131]},{value:.25,color:[10,136,186]},{value:.5,color:[242,211,56]},{value:.75,color:[242,143,56]},{value:1,color:[217,30,30]}]}),BLACKBODY:new u({stops:[{value:0,color:[0,0,0]},{value:.2,color:[230,0,0]},{value:.4,color:[230,210,0]},{value:.7,color:[255,255,255]},{value:1,color:[160,200,255]}]}),EARTH:new u({stops:[{value:0,color:[0,0,130]},{value:.1,color:[0,180,180]},{value:.2,color:[40,210,40]},{value:.4,color:[230,230,50]},{value:.6,color:[120,70,20]},{value:1,color:[255,255,255]}]}),ELECTRIC:new u({stops:[{value:0,color:[0,0,0]},{value:.15,color:[30,0,100]},{value:.4,color:[120,0,100]},{value:.6,color:[160,90,0]},{value:.8,color:[230,200,0]},{value:1,color:[255,250,220]}]}),VIRIDIS:new u({stops:[{value:0,color:[68,1,84]},{value:.13,color:[71,44,122]},{value:.25,color:[59,81,139]},{value:.38,color:[44,113,142]},{value:.5,color:[33,144,141]},{value:.63,color:[39,173,129]},{value:.75,color:[92,200,99]},{value:.88,color:[170,220,50]},{value:1,color:[253,231,37]}]}),INFERNO:new u({stops:[{value:0,color:[0,0,4]},{value:.13,color:[31,12,72]},{value:.25,color:[85,15,109]},{value:.38,color:[136,34,106]},{value:.5,color:[186,54,85]},{value:.63,color:[227,89,51]},{value:.75,color:[249,140,10]},{value:.88,color:[249,201,50]},{value:1,color:[252,255,164]}]}),MAGMA:new u({stops:[{value:0,color:[0,0,4]},{value:.13,color:[28,16,68]},{value:.25,color:[79,18,123]},{value:.38,color:[129,37,129]},{value:.5,color:[181,54,122]},{value:.63,color:[229,80,100]},{value:.75,color:[251,135,97]},{value:.88,color:[254,194,135]},{value:1,color:[252,253,191]}]}),PLASMA:new u({stops:[{value:0,color:[13,8,135]},{value:.13,color:[75,3,161]},{value:.25,color:[125,3,168]},{value:.38,color:[168,34,150]},{value:.5,color:[203,70,121]},{value:.63,color:[229,107,93]},{value:.75,color:[248,148,65]},{value:.88,color:[253,195,40]},{value:1,color:[240,249,33]}]}),WARM:new u({stops:[{value:0,color:[125,0,179]},{value:.13,color:[172,0,187]},{value:.25,color:[219,0,170]},{value:.38,color:[255,0,130]},{value:.5,color:[255,63,74]},{value:.63,color:[255,123,0]},{value:.75,color:[234,176,0]},{value:.88,color:[190,228,0]},{value:1,color:[147,255,0]}]}),COOL:new u({stops:[{value:0,color:[125,0,179]},{value:.13,color:[116,0,218]},{value:.25,color:[98,74,237]},{value:.38,color:[68,146,231]},{value:.5,color:[0,204,197]},{value:.63,color:[0,247,146]},{value:.75,color:[0,255,88]},{value:.88,color:[40,255,8]},{value:1,color:[147,255,0]}]}),RAINBOW_SOFT:new u({stops:[{value:0,color:[125,0,179]},{value:.1,color:[199,0,180]},{value:.2,color:[255,0,121]},{value:.3,color:[255,108,0]},{value:.4,color:[222,194,0]},{value:.5,color:[150,255,0]},{value:.6,color:[0,255,55]},{value:.7,color:[0,246,150]},{value:.8,color:[50,167,222]},{value:.9,color:[103,51,235]},{value:1,color:[124,0,186]}]}),BATHYMETRY:new u({stops:[{value:0,color:[40,26,44]},{value:.13,color:[59,49,90]},{value:.25,color:[64,76,139]},{value:.38,color:[63,110,151]},{value:.5,color:[72,142,158]},{value:.63,color:[85,174,163]},{value:.75,color:[120,206,163]},{value:.88,color:[187,230,172]},{value:1,color:[253,254,204]}]}),CDOM:new u({stops:[{value:0,color:[47,15,62]},{value:.13,color:[87,23,86]},{value:.25,color:[130,28,99]},{value:.38,color:[171,41,96]},{value:.5,color:[206,67,86]},{value:.63,color:[230,106,84]},{value:.75,color:[242,149,103]},{value:.88,color:[249,193,135]},{value:1,color:[254,237,176]}]}),CHLOROPHYLL:new u({stops:[{value:0,color:[18,36,20]},{value:.13,color:[25,63,41]},{value:.25,color:[24,91,59]},{value:.38,color:[13,119,72]},{value:.5,color:[18,148,80]},{value:.63,color:[80,173,89]},{value:.75,color:[132,196,122]},{value:.88,color:[175,221,162]},{value:1,color:[215,249,208]}]}),DENSITY:new u({stops:[{value:0,color:[54,14,36]},{value:.13,color:[89,23,80]},{value:.25,color:[110,45,132]},{value:.38,color:[120,77,178]},{value:.5,color:[120,113,213]},{value:.63,color:[115,151,228]},{value:.75,color:[134,185,227]},{value:.88,color:[177,214,227]},{value:1,color:[230,241,241]}]}),FREESURFACE_BLUE:new u({stops:[{value:0,color:[30,4,110]},{value:.13,color:[47,14,176]},{value:.25,color:[41,45,236]},{value:.38,color:[25,99,212]},{value:.5,color:[68,131,200]},{value:.63,color:[114,156,197]},{value:.75,color:[157,181,203]},{value:.88,color:[200,208,216]},{value:1,color:[241,237,236]}]}),FREESURFACE_RED:new u({stops:[{value:0,color:[60,9,18]},{value:.13,color:[100,17,27]},{value:.25,color:[142,20,29]},{value:.38,color:[177,43,27]},{value:.5,color:[192,87,63]},{value:.63,color:[205,125,105]},{value:.75,color:[216,162,148]},{value:.88,color:[227,199,193]},{value:1,color:[241,237,236]}]}),OXYGEN:new u({stops:[{value:0,color:[64,5,5]},{value:.13,color:[106,6,15]},{value:.25,color:[144,26,7]},{value:.38,color:[168,64,3]},{value:.5,color:[188,100,4]},{value:.63,color:[206,136,11]},{value:.75,color:[220,174,25]},{value:.88,color:[231,215,44]},{value:1,color:[248,254,105]}]}),PAR:new u({stops:[{value:0,color:[51,20,24]},{value:.13,color:[90,32,35]},{value:.25,color:[129,44,34]},{value:.38,color:[159,68,25]},{value:.5,color:[182,99,19]},{value:.63,color:[199,134,22]},{value:.75,color:[212,171,35]},{value:.88,color:[221,210,54]},{value:1,color:[225,253,75]}]}),PHASE:new u({stops:[{value:0,color:[145,105,18]},{value:.13,color:[184,71,38]},{value:.25,color:[186,58,115]},{value:.38,color:[160,71,185]},{value:.5,color:[110,97,218]},{value:.63,color:[50,123,164]},{value:.75,color:[31,131,110]},{value:.88,color:[77,129,34]},{value:1,color:[145,105,18]}]}),SALINITY:new u({stops:[{value:0,color:[42,24,108]},{value:.13,color:[33,50,162]},{value:.25,color:[15,90,145]},{value:.38,color:[40,118,137]},{value:.5,color:[59,146,135]},{value:.63,color:[79,175,126]},{value:.75,color:[120,203,104]},{value:.88,color:[193,221,100]},{value:1,color:[253,239,154]}]}),TEMPERATURE:new u({stops:[{value:0,color:[4,35,51]},{value:.13,color:[23,51,122]},{value:.25,color:[85,59,157]},{value:.38,color:[129,79,143]},{value:.5,color:[175,95,130]},{value:.63,color:[222,112,101]},{value:.75,color:[249,146,66]},{value:.88,color:[249,196,65]},{value:1,color:[232,250,91]}]}),TURBIDITY:new u({stops:[{value:0,color:[34,31,27]},{value:.13,color:[65,50,41]},{value:.25,color:[98,69,52]},{value:.38,color:[131,89,57]},{value:.5,color:[161,112,59]},{value:.63,color:[185,140,66]},{value:.75,color:[202,174,88]},{value:.88,color:[216,209,126]},{value:1,color:[233,246,171]}]}),VELOCITY_BLUE:new u({stops:[{value:0,color:[17,32,64]},{value:.13,color:[35,52,116]},{value:.25,color:[29,81,156]},{value:.38,color:[31,113,162]},{value:.5,color:[50,144,169]},{value:.63,color:[87,173,176]},{value:.75,color:[149,196,189]},{value:.88,color:[203,221,211]},{value:1,color:[254,251,230]}]}),VELOCITY_GREEN:new u({stops:[{value:0,color:[23,35,19]},{value:.13,color:[24,64,38]},{value:.25,color:[11,95,45]},{value:.38,color:[39,123,35]},{value:.5,color:[95,146,12]},{value:.63,color:[152,165,18]},{value:.75,color:[201,186,69]},{value:.88,color:[233,216,137]},{value:1,color:[255,253,205]}]}),CUBEHELIX:new u({stops:[{value:0,color:[0,0,0]},{value:.07,color:[22,5,59]},{value:.13,color:[60,4,105]},{value:.2,color:[109,1,135]},{value:.27,color:[161,0,147]},{value:.33,color:[210,2,142]},{value:.4,color:[251,11,123]},{value:.47,color:[255,29,97]},{value:.53,color:[255,54,69]},{value:.6,color:[255,85,46]},{value:.67,color:[255,120,34]},{value:.73,color:[255,157,37]},{value:.8,color:[241,191,57]},{value:.87,color:[224,220,93]},{value:.93,color:[218,241,142]},{value:1,color:[227,253,198]}]}),CIVIDIS:new u({stops:[{value:0,color:[0,32,77,255]},{value:.125,color:[5,54,110,255]},{value:.25,color:[65,77,108,255]},{value:.375,color:[97,100,111,255]},{value:.5,color:[125,124,121,255]},{value:.625,color:[156,149,120,255]},{value:.75,color:[190,175,111,255]},{value:.875,color:[225,204,94,255]},{value:1,color:[255,235,70,255]}]}),TURBO:new u({stops:[{value:0,color:[48,18,59,255]},{value:.125,color:[70,107,227,255]},{value:.25,color:[40,187,236,255]},{value:.375,color:[49,242,153,255]},{value:.5,color:[162,252,60,255]},{value:.625,color:[237,208,58,255]},{value:.75,color:[251,128,34,255]},{value:.875,color:[210,49,5,255]},{value:1,color:[122,4,3,255]}]}),ROCKET:new u({stops:[{value:0,color:[250,235,221,0]},{value:.133,color:[250,235,221,255]},{value:.266,color:[246,170,130,255]},{value:.4,color:[240,96,67,255]},{value:.533,color:[203,27,79,255]},{value:.666,color:[132,30,90,255]},{value:.8,color:[63,27,68,255]},{value:1,color:[3,5,26,255]}]}),MAKO:new u({stops:[{value:0,color:[11,4,5,255]},{value:.125,color:[43,28,53,255]},{value:.25,color:[62,53,107,255]},{value:.375,color:[59,86,152,255]},{value:.5,color:[53,123,162,255]},{value:.625,color:[53,158,170,255]},{value:.75,color:[73,193,173,255]},{value:.875,color:[150,221,181,255]},{value:1,color:[222,245,229,255]}]}),TERRAIN:new u({stops:[{value:-10001,color:[0,20,60]},{value:-5e3,color:[0,10,30]},{value:-1e3,color:[0,30,80]},{value:-100,color:[0,38,115]},{value:0,color:[122,200,255]},{value:10,color:[51,102,0]},{value:500,color:[129,195,31]},{value:800,color:[255,255,204]},{value:1200,color:[244,189,69]},{value:2e3,color:[132,75,0]},{value:3e3,color:[102,51,12]},{value:8e3,color:[255,255,255]}]}),PRESSURE:new u({stops:[{value:900,color:[0,0,100,250]},{value:950,color:[0,0,255,250]},{value:980,color:[0,0,255,120]},{value:1e3,color:[255,255,255,0]},{value:1020,color:[255,0,0,120]},{value:1080,color:[255,0,0,250]}]}),PRESSURE_2:new u({stops:[{value:900,color:[8,16,48,255]},{value:950,color:[0,32,96,255]},{value:976,color:[0,52,146,255]},{value:986,color:[0,90,148,255]},{value:995,color:[0,117,146,255]},{value:1002,color:[26,140,147,255]},{value:1007,color:[103,162,155,255]},{value:1011,color:[155,183,172,255]},{value:1013,color:[182,182,182,255]},{value:1015,color:[176,174,152,255]},{value:1019,color:[167,147,107,255]},{value:1024,color:[163,116,67,255]},{value:1030,color:[159,81,44,255]},{value:1038,color:[142,47,57,255]},{value:1046,color:[111,24,64,255]},{value:1080,color:[48,8,24,255]}]}),PRESSURE_3:new u({stops:[{value:900,color:[40,46,117,255]},{value:950,color:[40,51,121,255]},{value:976,color:[42,63,125,255]},{value:986,color:[55,97,141,255]},{value:995,color:[69,115,150,255]},{value:1002,color:[87,144,168,255]},{value:1007,color:[125,184,194,255]},{value:1011,color:[195,226,226,255]},{value:1013,color:[245,220,196,255]},{value:1015,color:[232,191,160,255]},{value:1019,color:[219,154,125,255]},{value:1024,color:[210,115,98,255]},{value:1030,color:[194,72,67,255]},{value:1038,color:[199,61,60,255]},{value:1046,color:[177,50,54,255]},{value:1080,color:[159,42,48,255]}]}),TEMPERATURE_2:new u({stops:[{value:-70.15,color:[115,70,105,255]},{value:-55.15,color:[202,172,195,255]},{value:-40.15,color:[162,70,145,255]},{value:-25.15,color:[143,89,169,255]},{value:-15.15,color:[157,219,217,255]},{value:-8.15,color:[106,191,181,255]},{value:-4.15,color:[100,166,189,255]},{value:0,color:[93,133,198,255]},{value:.85,color:[68,125,99,255]},{value:9.85,color:[128,147,24,255]},{value:20.85,color:[243,183,4,255]},{value:29.85,color:[232,83,25,255]},{value:46.85,color:[71,14,0,255]}]}),TEMPERATURE_3:new u({stops:[{value:-65,color:[3,78,77,255]},{value:-55,color:[4,98,96,255]},{value:-40,color:[5,122,120,255]},{value:-30,color:[6,152,149,255]},{value:-20,color:[8,201,198,255]},{value:-15,color:[20,245,241,255]},{value:-10,color:[108,237,249,255]},{value:-5,color:[133,205,250,255]},{value:0,color:[186,227,252,255]},{value:5,color:[238,221,145,255]},{value:10,color:[232,183,105,255]},{value:15,color:[232,137,69,255]},{value:20,color:[231,107,24,255]},{value:25,color:[236,84,19,255]},{value:30,color:[236,44,19,255]},{value:40,color:[123,23,10,255]},{value:55,color:[91,11,0,255]}]}),PRECIPITATION:new u({stops:[{value:0,color:[111,111,111,0]},{value:.6,color:[60,116,160,180]},{value:6,color:[59,161,161,255]},{value:8,color:[59,161,61,255]},{value:10,color:[130,161,59,255]},{value:15,color:[161,161,59,255]},{value:20,color:[161,59,59,255]},{value:31,color:[161,59,161,255]},{value:50,color:[168,168,168,255]}]}),PRECIPITATION_2:new u({stops:[{value:0,color:[255,255,255,0]},{value:.1,color:[171,218,252,255]},{value:1,color:[98,186,249,255]},{value:2,color:[87,160,240,255]},{value:4,color:[112,128,250,255]},{value:6,color:[128,102,245,255]},{value:8,color:[152,102,245,255]},{value:10,color:[154,87,172,255]},{value:15,color:[228,88,126,255]},{value:20,color:[247,135,95,255]},{value:30,color:[249,206,64,255]},{value:50,color:[250,248,168,52]}]}),RADAR:new u({stops:[{value:0,color:[7,235,236,0]},{value:4,color:[7,235,236,80]},{value:5,color:[7,235,236,255]},{value:10,color:[0,159,246,255]},{value:15,color:[0,0,247,255]},{value:20,color:[3,255,0,255]},{value:25,color:[0,200,2,255]},{value:30,color:[1,144,0,255]},{value:35,color:[255,255,0,255]},{value:40,color:[231,192,0,255]},{value:45,color:[255,145,3,255]},{value:50,color:[255,0,0,255]},{value:55,color:[215,0,0,255]},{value:60,color:[192,0,0,255]},{value:65,color:[255,0,255,255]},{value:70,color:[155,85,200,255]},{value:75,color:[235,235,235,255]}]}),RADAR_CLOUD:new u({stops:[{value:4,color:[134,134,176,0]},{value:7,color:[134,134,176,30]},{value:10,color:[134,134,176,60]},{value:20,color:[110,110,145,80]},{value:35,color:[77,77,105,140]},{value:45,color:[58,58,87,180]},{value:60,color:[26,26,51,220]}]}),PRESSURE_CIVIDIS:new u({stops:[{value:900,color:[0,32,77,255]},{value:950,color:[0,37,82,255]},{value:976,color:[15,56,110,255]},{value:986,color:[49,68,107,255]},{value:995,color:[70,80,107,255]},{value:1002,color:[87,92,109,255]},{value:1007,color:[102,105,112,255]},{value:1011,color:[117,117,117,255]},{value:1013,color:[132,130,121,255]},{value:1015,color:[149,143,120,255]},{value:1019,color:[166,157,117,255]},{value:1024,color:[184,171,112,255]},{value:1030,color:[203,186,105,255]},{value:1038,color:[221,201,95,255]},{value:1046,color:[250,229,65,255]},{value:1080,color:[255,234,70,255]}]}),RADAR_ROCKET:new u({stops:[{value:0,color:[250,235,221,0]},{value:.1,color:[250,235,221,255]},{value:10,color:[246,180,142,255]},{value:20,color:[243,118,81,255]},{value:30,color:[225,51,66,255]},{value:40,color:[174,23,89,255]},{value:50,color:[112,31,87,255]},{value:60,color:[54,25,62,255]},{value:75,color:[3,5,26,255]}]}),WIND_ROCKET:new u({stops:[{value:0,color:[250,235,221,255]},{value:1,color:[246,187,151,255]},{value:3,color:[244,135,94,255]},{value:5,color:[236,75,62,255]},{value:10,color:[203,27,79,255]},{value:15,color:[150,28,91,255]},{value:20,color:[97,31,83,255]},{value:25,color:[48,23,58,255]},{value:30,color:[3,5,26,255]}]}),MAKO_PRECIPITATION:new u({stops:[{value:0,color:[255,255,255,0]},{value:.1,color:[222,245,229,255]},{value:1,color:[168,225,188,255]},{value:2,color:[96,206,172,255]},{value:4,color:[61,180,173,255]},{value:6,color:[52,151,169,255]},{value:8,color:[53,123,162,255]},{value:10,color:[57,93,156,255]},{value:15,color:[65,64,129,255]},{value:20,color:[56,42,84,255]},{value:30,color:[38,23,42,255]},{value:50,color:[11,4,5,255]}]}),TEMPERATURE_TURBO:new u({stops:[{value:-65,color:[48,18,59,255]},{value:-55,color:[64,64,162,255]},{value:-40,color:[70,107,227,255]},{value:-30,color:[66,147,255,255]},{value:-20,color:[40,187,236,255]},{value:-15,color:[24,220,195,255]},{value:-10,color:[49,242,153,255]},{value:-5,color:[107,254,100,255]},{value:0,color:[162,252,60,255]},{value:5,color:[204,237,52,255]},{value:10,color:[237,208,58,255]},{value:15,color:[253,173,53,255]},{value:20,color:[231,107,24,255]},{value:25,color:[236,82,15,255]},{value:30,color:[210,49,5,255]},{value:40,color:[172,23,1,255]},{value:55,color:[122,4,3,255]}]})});let k=u;const ce={endpoint:"https://api.maptiler.com/weather/latest.json",tileSourceUrlSchema:"https://api.maptiler.com/tiles/{tileset_id}/{zxy}.{format}"};Object.freeze(ce);const $={GFS_TEMPERATURE_2M:"temperature-2m:gfs",GFS_PRESSURE_MSL:"pressure-msl:gfs",GFS_PRECIPITATION_1H:"precipitation-1h:gfs",GFS_FROZEN_PRECIPITATION_PERCENT:"frozen_precipitation-1h:gfs",GFS_WIND_10M:"wind-10m:gfs",GFS_RADAR_COMPOSITE:"radar-composite:gfs",GFS_CLOUD_COVER_TOTAL:"cloud_cover-total:gfs"},J={latest:null};class T{static async fetchLatest(e,t){const o=`${ce.endpoint}?key=${e}&mtsid=${t}`,r=await fetch(o,{cache:"no-store"});J.latest=await r.json()}static getDataForWeatherVariableID(e){if(!J.latest)return null;const t=J.latest.variables.filter(o=>o.metadata.weather_variable.variable_id===e);return t.length?t[0]:null}static hasData(){return!!J.latest}static getTemperatureData(){return T.getDataForWeatherVariableID($.GFS_TEMPERATURE_2M)}static getPressureData(){return T.getDataForWeatherVariableID($.GFS_PRESSURE_MSL)}static getPrecipitationData(){return T.getDataForWeatherVariableID($.GFS_PRECIPITATION_1H)}static getCloudCoverData(){return T.getDataForWeatherVariableID($.GFS_CLOUD_COVER_TOTAL)}static getFrozenPrecipitationData(){return T.getDataForWeatherVariableID($.GFS_FROZEN_PRECIPITATION_PERCENT)}static getRadarData(){return T.getDataForWeatherVariableID($.GFS_RADAR_COMPOSITE)}static getWindData(){return T.getDataForWeatherVariableID($.GFS_WIND_10M)}static getSourcesAndTimestamps(e,t,o){return e.keyframes.map(r=>({source:`${ce.tileSourceUrlSchema.replace("{tileset_id}",r.id).replace("{format}",e.tile_format)}?key=${t}&mtsid=${o}`,timestamp:+new Date(r.timestamp)/1e3}))}}var Mt=Object.defineProperty,It=(i,e,t)=>e in i?Mt(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ce=(i,e,t)=>(It(i,typeof e!="symbol"?e+"":e,t),t);const D={maxAmount:128,color:[255,255,255,0],density:200,size:1,speed:.002,refreshInterval:200,fadeFactor:.04,opacity:1,colorramp:k.builtin.VIRIDIS,smooth:!0,fastColor:[255,255,255,255],fastSpeed:3};class Dt extends we{constructor(e={}){super(e.id||"MapTiler Wind",null,null,null),Ce(this,"constructorOptions"),Ce(this,"isSourceReady",!1),this.constructorOptions=e}async onAdd(e,t){var o,r,n,a,s,l,c,v,p,m,d,P;const C=e.getSdkConfig().apiKey,w=e.getMaptilerSessionId();T.hasData()||await T.fetchLatest(C,w);const x=T.getWindData();this.initParticle({minZoom:x.metadata.minzoom,maxZoom:x.metadata.maxzoom},{decodeChannels:x.metadata.weather_variable.decoding.channels.toLowerCase(),decodeMin:x.metadata.weather_variable.decoding.min,decodeMax:x.metadata.weather_variable.decoding.max,decodeAsWaves:!1,maxAmount:(o=this.constructorOptions.maxAmount)!=null?o:D.maxAmount,color:(r=this.constructorOptions.color)!=null?r:D.color,fastColor:(n=this.constructorOptions.fastColor)!=null?n:D.fastColor,fastSpeed:(a=this.constructorOptions.fastSpeed)!=null?a:D.fastSpeed,density:(s=this.constructorOptions.density)!=null?s:D.density,size:(l=this.constructorOptions.size)!=null?l:D.size,speed:(c=this.constructorOptions.speed)!=null?c:D.speed,refreshInterval:(v=this.constructorOptions.refreshInterval)!=null?v:D.refreshInterval,fadeFactor:(p=this.constructorOptions.fadeFactor)!=null?p:D.fadeFactor},[new B({decode:{channel:x.metadata.weather_variable.decoding.channels.toLowerCase(),min:x.metadata.weather_variable.decoding.min,max:x.metadata.weather_variable.decoding.max},stops:(m=this.constructorOptions.colorramp)!=null?m:D.colorramp.scale(0,40),smooth:(d=this.constructorOptions.smooth)!=null?d:D.smooth,opacity:(P=this.constructorOptions.opacity)!=null?P:D.opacity})]),super.onAdd(e,t),T.getSourcesAndTimestamps(x,C,w).forEach(_=>{this.addSource(_.timestamp,_.source)});const A=+new Date/1e3;A>=this.getAnimationStart()&&A<=this.getAnimationEnd()&&this.setAnimationTime(A),this.isSourceReady=!0,this.emit("sourceReady",{map:e,layer:this})}getIsSourceReady(){return this.isSourceReady}pickAt(e,t){const o=super.pick(e,t);if(!o)return null;const r=o[0],n=o[1],a=Math.sqrt(r**2+n**2),s=Math.atan2(r,n)*180/Math.PI;return{speedMetersPerSecond:a,speedKilometersPerHour:a*3.6,speedMilesPerHour:a*2.23694,speedFeetPerSecond:a*3.28084,speedKnots:a*1.94384,directionAngle:s,compassDirection:fe(s+180)}}}var zt=Object.defineProperty,Ft=(i,e,t)=>e in i?zt(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Re=(i,e,t)=>(Ft(i,typeof e!="symbol"?e+"":e,t),t);class Ot extends G{constructor(e={}){super(e.id||"MapTiler Pressure",null,null,null),Re(this,"constructorOptions"),Re(this,"isSourceReady",!1),this.constructorOptions=e}async onAdd(e,t){var o,r,n;const a=e.getSdkConfig().apiKey,s=e.getMaptilerSessionId();T.hasData()||await T.fetchLatest(a,s);const l=T.getPressureData();this.init({minZoom:l.metadata.minzoom,maxZoom:l.metadata.maxzoom,repaintOnPausedAnimation:!1},[new B({decode:{channel:l.metadata.weather_variable.decoding.channels.toLowerCase(),min:l.metadata.weather_variable.decoding.min,max:l.metadata.weather_variable.decoding.max},stops:(o=this.constructorOptions.colorramp)!=null?o:k.builtin.PRESSURE_2,smooth:(r=this.constructorOptions.smooth)!=null?r:!0,opacity:(n=this.constructorOptions.opacity)!=null?n:1})]),super.onAdd(e,t),T.getSourcesAndTimestamps(l,a,s).forEach(v=>{this.addSource(v.timestamp,v.source)});const c=+new Date/1e3;c>=this.getAnimationStart()&&c<=this.getAnimationEnd()&&this.setAnimationTime(c),this.isSourceReady=!0,this.emit("sourceReady",{map:e,layer:this})}getIsSourceReady(){return this.isSourceReady}pickAt(e,t){const o=super.pick(e,t);return o?{value:o[0]}:null}}var Nt=Object.defineProperty,Ut=(i,e,t)=>e in i?Nt(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ee=(i,e,t)=>(Ut(i,typeof e!="symbol"?e+"":e,t),t);class Lt extends G{constructor(e={}){super(e.id||"MapTiler Temperature",null,null,null),Ee(this,"constructorOptions"),Ee(this,"isSourceReady",!1),this.constructorOptions=e}async onAdd(e,t){var o,r,n;const a=e.getSdkConfig().apiKey,s=e.getMaptilerSessionId();T.hasData()||await T.fetchLatest(a,s);const l=T.getTemperatureData();this.init({minZoom:l.metadata.minzoom,maxZoom:l.metadata.maxzoom,repaintOnPausedAnimation:!1},[new B({decode:{channel:l.metadata.weather_variable.decoding.channels.toLowerCase(),min:l.metadata.weather_variable.decoding.min,max:l.metadata.weather_variable.decoding.max},stops:(o=this.constructorOptions.colorramp)!=null?o:k.builtin.TEMPERATURE_2,smooth:(r=this.constructorOptions.smooth)!=null?r:!0,opacity:(n=this.constructorOptions.opacity)!=null?n:1})]),super.onAdd(e,t),T.getSourcesAndTimestamps(l,a,s).forEach(v=>{this.addSource(v.timestamp,v.source)});const c=+new Date/1e3;c>=this.getAnimationStart()&&c<=this.getAnimationEnd()&&this.setAnimationTime(c),this.isSourceReady=!0,this.emit("sourceReady",{map:e,layer:this})}getIsSourceReady(){return this.isSourceReady}pickAt(e,t){const o=super.pick(e,t);if(!o)return null;const r=o[0];return{value:r,valueImperial:32+r*9/5}}}var $t=Object.defineProperty,Vt=(i,e,t)=>e in i?$t(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,be=(i,e,t)=>(Vt(i,typeof e!="symbol"?e+"":e,t),t);class Bt extends G{constructor(e={}){super(e.id||"MapTiler Precipitation",null,null,null),be(this,"constructorOptions"),be(this,"isSourceReady",!1),this.constructorOptions=e}async onAdd(e,t){var o,r,n;const a=e.getSdkConfig().apiKey,s=e.getMaptilerSessionId();T.hasData()||await T.fetchLatest(a,s);const l=T.getPrecipitationData();this.init({minZoom:l.metadata.minzoom,maxZoom:l.metadata.maxzoom,repaintOnPausedAnimation:!1},[new B({decode:{channel:l.metadata.weather_variable.decoding.channels.toLowerCase(),min:l.metadata.weather_variable.decoding.min,max:l.metadata.weather_variable.decoding.max},stops:(o=this.constructorOptions.colorramp)!=null?o:k.builtin.PRECIPITATION,smooth:(r=this.constructorOptions.smooth)!=null?r:!0,opacity:(n=this.constructorOptions.opacity)!=null?n:1})]),super.onAdd(e,t),T.getSourcesAndTimestamps(l,a,s).forEach(v=>{this.addSource(v.timestamp,v.source)});const c=+new Date/1e3;c>=this.getAnimationStart()&&c<=this.getAnimationEnd()&&this.setAnimationTime(c),this.isSourceReady=!0,this.emit("sourceReady",{map:e,layer:this})}getIsSourceReady(){return this.isSourceReady}pickAt(e,t){const o=super.pick(e,t);return o?{value:o[0],valueImperial:o[0]/2.54}:null}}var Wt=Object.defineProperty,Gt=(i,e,t)=>e in i?Wt(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,_e=(i,e,t)=>(Gt(i,typeof e!="symbol"?e+"":e,t),t);class kt extends G{constructor(e={}){super(e.id||"MapTiler Radar",null,null,null),_e(this,"constructorOptions"),_e(this,"isSourceReady",!1),this.constructorOptions=e}async onAdd(e,t){var o,r,n;const a=e.getSdkConfig().apiKey,s=e.getMaptilerSessionId();T.hasData()||await T.fetchLatest(a,s);const l=T.getRadarData();this.init({minZoom:l.metadata.minzoom,maxZoom:l.metadata.maxzoom,repaintOnPausedAnimation:!1},[new B({decode:{channel:l.metadata.weather_variable.decoding.channels.toLowerCase(),min:l.metadata.weather_variable.decoding.min,max:l.metadata.weather_variable.decoding.max},stops:(o=this.constructorOptions.colorramp)!=null?o:k.builtin.RADAR,smooth:(r=this.constructorOptions.smooth)!=null?r:!0,opacity:(n=this.constructorOptions.opacity)!=null?n:1})]),super.onAdd(e,t),T.getSourcesAndTimestamps(l,a,s).forEach(v=>{this.addSource(v.timestamp,v.source)});const c=+new Date/1e3;c>=this.getAnimationStart()&&c<=this.getAnimationEnd()&&this.setAnimationTime(c),this.isSourceReady=!0,this.emit("sourceReady",{map:e,layer:this})}getIsSourceReady(){return this.isSourceReady}pickAt(e,t){const o=super.pick(e,t);return o?{value:o[0]}:null}}export{ve as ChannelIndices,k as ColorRamp,ne as ColoringFragmentBase,j as EARTH_PERIMETER_M,pe as EARTH_RADIUS_M,B as GradientColoringFragment,Qe as MultiChannelGradientColoringFragment,Je as OpacityColoringFragment,we as ParticleLayer,Bt as PrecipitationLayer,Ot as PressureLayer,kt as RadarLayer,Lt as TemperatureLayer,G as TileLayer,Dt as WindLayer,Ye as addLayerWhenReady,L as floatifyColor,fe as getCardinalDirection,me as latToUnit,je as makeUnitColor,Ze as pixelToLat,xe as sampleImage,de as unitToLat,V as wgs84ToMerc,ie as wgs84ToUnit};
