var Ve = Object.defineProperty;
var Be = (s, i, e) => i in s ? Ve(s, i, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[i] = e;
var n = (s, i, e) => (Be(s, typeof i != "symbol" ? i + "" : i, e), e), xe = (s, i, e) => {
  if (!i.has(s))
    throw TypeError("Cannot " + e);
};
var d = (s, i, e) => (xe(s, i, "read from private field"), e ? e.call(s) : i.get(s)), I = (s, i, e) => {
  if (i.has(s))
    throw TypeError("Cannot add the same private member more than once");
  i instanceof WeakSet ? i.add(s) : i.set(s, e);
}, E = (s, i, e, t) => (xe(s, i, "write to private field"), t ? t.call(s, e) : i.set(s, e), e);
var pe = (s, i, e, t) => ({
  set _(o) {
    E(s, i, o, e);
  },
  get _() {
    return d(s, i, t);
  }
}), P = (s, i, e) => (xe(s, i, "access private method"), e);
import { getIntersection as We, scaleFromCenter as Ge, getArea as $e, getIntersectionArea as ke } from "ol/extent.js";
import { createXYZ as Ze } from "ol/tilegrid.js";
import * as v from "three";
import { OrthographicCamera as Ye, Scene as He, RawShaderMaterial as Ke, GLSL3 as Xe, Vector2 as je, WebGLRenderTarget as De, LinearFilter as ce, RGBAFormat as ge, Mesh as qe, PlaneGeometry as Je, DataTexture as Qe, WebGLRenderer as et } from "three";
import tt from "ol/structs/LRUCache.js";
import { EventEmitter as ot } from "events";
var b, w, R, W, J, G, Q, Ee, _, F, ve, be, ee, Ce, te, Ie, oe, Me, me, ze, re, Ae;
class rt extends Map {
  constructor(e = {}) {
    super();
    I(this, Q);
    I(this, _);
    I(this, ve);
    I(this, ee);
    I(this, te);
    I(this, oe);
    I(this, me);
    I(this, re);
    I(this, b, 0);
    I(this, w, /* @__PURE__ */ new Map());
    I(this, R, /* @__PURE__ */ new Map());
    I(this, W, void 0);
    I(this, J, void 0);
    I(this, G, void 0);
    if (!(e.maxSize && e.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof e.maxAge == "number" && e.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    E(this, W, e.maxSize), E(this, J, e.maxAge || Number.POSITIVE_INFINITY), E(this, G, e.onEviction);
  }
  // For tests.
  get __oldCache() {
    return d(this, R);
  }
  get(e) {
    if (d(this, w).has(e)) {
      const t = d(this, w).get(e);
      return P(this, ee, Ce).call(this, e, t);
    }
    if (d(this, R).has(e)) {
      const t = d(this, R).get(e);
      if (P(this, _, F).call(this, e, t) === !1)
        return P(this, me, ze).call(this, e, t), t.value;
    }
  }
  set(e, t, { maxAge: o = d(this, J) } = {}) {
    const r = typeof o == "number" && o !== Number.POSITIVE_INFINITY ? Date.now() + o : void 0;
    return d(this, w).has(e) ? d(this, w).set(e, {
      value: t,
      expiry: r
    }) : P(this, oe, Me).call(this, e, { value: t, expiry: r }), this;
  }
  has(e) {
    return d(this, w).has(e) ? !P(this, _, F).call(this, e, d(this, w).get(e)) : d(this, R).has(e) ? !P(this, _, F).call(this, e, d(this, R).get(e)) : !1;
  }
  peek(e) {
    if (d(this, w).has(e))
      return P(this, te, Ie).call(this, e, d(this, w));
    if (d(this, R).has(e))
      return P(this, te, Ie).call(this, e, d(this, R));
  }
  delete(e) {
    const t = d(this, w).delete(e);
    return t && pe(this, b)._--, d(this, R).delete(e) || t;
  }
  clear() {
    d(this, w).clear(), d(this, R).clear(), E(this, b, 0);
  }
  resize(e) {
    if (!(e && e > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    const t = [...P(this, re, Ae).call(this)], o = t.length - e;
    o < 0 ? (E(this, w, new Map(t)), E(this, R, /* @__PURE__ */ new Map()), E(this, b, t.length)) : (o > 0 && P(this, Q, Ee).call(this, t.slice(0, o)), E(this, R, new Map(t.slice(o))), E(this, w, /* @__PURE__ */ new Map()), E(this, b, 0)), E(this, W, e);
  }
  *keys() {
    for (const [e] of this)
      yield e;
  }
  *values() {
    for (const [, e] of this)
      yield e;
  }
  *[Symbol.iterator]() {
    for (const e of d(this, w)) {
      const [t, o] = e;
      P(this, _, F).call(this, t, o) === !1 && (yield [t, o.value]);
    }
    for (const e of d(this, R)) {
      const [t, o] = e;
      d(this, w).has(t) || P(this, _, F).call(this, t, o) === !1 && (yield [t, o.value]);
    }
  }
  *entriesDescending() {
    let e = [...d(this, w)];
    for (let t = e.length - 1; t >= 0; --t) {
      const o = e[t], [r, a] = o;
      P(this, _, F).call(this, r, a) === !1 && (yield [r, a.value]);
    }
    e = [...d(this, R)];
    for (let t = e.length - 1; t >= 0; --t) {
      const o = e[t], [r, a] = o;
      d(this, w).has(r) || P(this, _, F).call(this, r, a) === !1 && (yield [r, a.value]);
    }
  }
  *entriesAscending() {
    for (const [e, t] of P(this, re, Ae).call(this))
      yield [e, t.value];
  }
  get size() {
    if (!d(this, b))
      return d(this, R).size;
    let e = 0;
    for (const t of d(this, R).keys())
      d(this, w).has(t) || e++;
    return Math.min(d(this, b) + e, d(this, W));
  }
  get maxSize() {
    return d(this, W);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(e, t = this) {
    for (const [o, r] of this.entriesAscending())
      e.call(t, r, o, this);
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
}
b = new WeakMap(), w = new WeakMap(), R = new WeakMap(), W = new WeakMap(), J = new WeakMap(), G = new WeakMap(), Q = new WeakSet(), Ee = function(e) {
  if (typeof d(this, G) == "function")
    for (const [t, o] of e)
      d(this, G).call(this, t, o.value);
}, _ = new WeakSet(), F = function(e, t) {
  return typeof t.expiry == "number" && t.expiry <= Date.now() ? (typeof d(this, G) == "function" && d(this, G).call(this, e, t.value), this.delete(e)) : !1;
}, ve = new WeakSet(), be = function(e, t) {
  if (P(this, _, F).call(this, e, t) === !1)
    return t.value;
}, ee = new WeakSet(), Ce = function(e, t) {
  return t.expiry ? P(this, ve, be).call(this, e, t) : t.value;
}, te = new WeakSet(), Ie = function(e, t) {
  const o = t.get(e);
  return P(this, ee, Ce).call(this, e, o);
}, oe = new WeakSet(), Me = function(e, t) {
  d(this, w).set(e, t), pe(this, b)._++, d(this, b) >= d(this, W) && (E(this, b, 0), P(this, Q, Ee).call(this, d(this, R)), E(this, R, d(this, w)), E(this, w, /* @__PURE__ */ new Map()));
}, me = new WeakSet(), ze = function(e, t) {
  d(this, R).delete(e), P(this, oe, Me).call(this, e, t);
}, re = new WeakSet(), Ae = function* () {
  for (const e of d(this, R)) {
    const [t, o] = e;
    d(this, w).has(t) || P(this, _, F).call(this, t, o) === !1 && (yield e);
  }
  for (const e of d(this, w)) {
    const [t, o] = e;
    P(this, _, F).call(this, t, o) === !1 && (yield e);
  }
};
var it = /* @__PURE__ */ ((s) => (s[s.r = 0] = "r", s[s.g = 1] = "g", s[s.b = 2] = "b", s[s.a = 3] = "a", s))(it || {});
let Se = null, ye = null;
function at() {
  return (!Se || !ye) && (Se = document.createElement("canvas"), ye = Se.getContext("webgl2")), ye;
}
function K(s) {
  return `vec4(${(s[0] / 255).toFixed(3)},${(s[1] / 255).toFixed(3)},${(s[2] / 255).toFixed(3)},${((s[3] ?? 255) / 255).toFixed(3)})`;
}
function Lt(s) {
  return [
    s[0] / 255,
    s[1] / 255,
    s[2] / 255,
    (s[3] ?? 255) / 255
  ];
}
function lt(s) {
  return 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + s * Math.PI / 360)) / 360;
}
function Ne(s, i) {
  return [s / 360, lt(i)];
}
function st(s) {
  const i = Math.PI, e = Math.atan, t = Math.exp, o = t(s * 2 * i);
  return (e(o) - i / 4) * 360 / i;
}
function Ot(s, i) {
  const e = -0.5 * (s / i * 2 - 1);
  return st(e);
}
const nt = 6378137, he = 2 * Math.PI * nt;
function j(s, i) {
  return Ne(s, i).map((e) => e * he);
}
const Te = new rt({
  maxSize: 200
});
function ct(s, i, e) {
  const t = Math.floor(i * s.width), o = Math.floor(e * s.height), r = at();
  if (r == null)
    throw new Error("Failed to obtain WebGL2 context");
  r.activeTexture(r.TEXTURE0);
  const a = r.createTexture();
  r.bindTexture(r.TEXTURE_2D, a);
  const l = r.createFramebuffer();
  r.bindFramebuffer(r.FRAMEBUFFER, l), r.framebufferTexture2D(
    r.FRAMEBUFFER,
    r.COLOR_ATTACHMENT0,
    r.TEXTURE_2D,
    a,
    0
  ), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, s), r.drawBuffers([r.COLOR_ATTACHMENT0]);
  const c = new Uint8Array(4);
  return r.readPixels(t, o, 1, 1, r.RGBA, r.UNSIGNED_BYTE, c), r.deleteTexture(a), r.deleteFramebuffer(l), {
    r: c[0] / 255,
    g: c[1] / 255,
    b: c[2] / 255,
    a: c[3] / 255
  };
}
function ut(s, i, e) {
  let t;
  if (Te.has(s))
    t = Te.get(s);
  else {
    const l = document.createElement("canvas");
    if (t = l.getContext("2d", { willReadFrequently: !0 }), !t)
      throw new Error("Unable to get canvas context");
    Te.set(s, t), l.width = s.width, l.height = s.height, t.drawImage(s, 0, 0, s.width, s.height);
  }
  if (!t)
    throw new Error("Unable to get canvas context");
  const o = Math.floor(i * s.width), r = Math.floor(e * s.height), a = t.getImageData(o, r, 1, 1).data;
  return {
    r: a[0] / 255,
    g: a[1] / 255,
    b: a[2] / 255,
    a: a[3] / 255
  };
}
function Vt(s, i, e = "") {
  s.isStyleLoaded() ? s.addLayer(i, e) : s.once("load", () => {
    s.addLayer(i, e);
  });
}
function ht(s) {
  const i = [
    "N",
    "NNE",
    "NE",
    "ENE",
    "E",
    "ESE",
    "SE",
    "SSE",
    "S",
    "SSW",
    "SW",
    "WSW",
    "W",
    "WNW",
    "NW",
    "NNW"
  ], e = Math.round((s + 360) % 360 / 22.5) % 16;
  return i[e];
}
var vt = "precision highp float;precision highp sampler2D;uniform float opacity;uniform float time;uniform sampler2D tex0;uniform sampler2D tex1;uniform float tex0size;uniform float tex1size;uniform float tilePixelSize;uniform bool categorySmoothTransition;uniform bool timeInterpolation;in vec2 tex0coord;in vec2 tex1coord;out vec4 fragColor;<gradient_function_definitions><getColor_code>vec4 blerp(vec4 color_x0_y0,vec4 color_x0_y1,vec4 color_x1_y0,vec4 color_x1_y1,float x0,float y0,float x1,float y1,float x,float y){vec4 q11=(((x1-x)*(y1-y))/((x1-x0)*(y1-y0)))*color_x0_y0;vec4 q21=(((x-x0)*(y1-y))/((x1-x0)*(y1-y0)))*color_x1_y0;vec4 q12=(((x1-x)*(y-y0))/((x1-x0)*(y1-y0)))*color_x0_y1;vec4 q22=(((x-x0)*(y-y0))/((x1-x0)*(y1-y0)))*color_x1_y1;return q11+q21+q12+q22;}void main(){vec2 centerPixelUV=vec2((floor(tex0coord.x*tilePixelSize)+0.5)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5)/tilePixelSize);vec2 centerPixelUV_N=vec2((floor(tex0coord.x*tilePixelSize)+0.5)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5+1.)/tilePixelSize);vec2 centerPixelUV_S=vec2((floor(tex0coord.x*tilePixelSize)+0.5)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5-1.)/tilePixelSize);vec2 centerPixelUV_E=vec2((floor(tex0coord.x*tilePixelSize)+0.5+1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5)/tilePixelSize);vec2 centerPixelUV_W=vec2((floor(tex0coord.x*tilePixelSize)+0.5-1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5)/tilePixelSize);vec4 tex0Color=texture(tex0,tex0coord);vec4 tex1Color=texture(tex1,tex1coord);vec4 inter=timeInterpolation ? mix(tex0Color,tex1Color,time):(time<0.5 ? tex0Color : tex1Color);vec3 inter255=inter.rgb*255.;float x=inter255.r*256.*256.+inter255.g*256.+inter255.b;float polynomialCoefDegree2=<polynomialCoefDegree2>;float polynomialCoefDegree1=<polynomialCoefDegree1>;float polynomialConstant=<polynomialConstant>;float y=polynomialCoefDegree2*x*x+polynomialCoefDegree1*x+polynomialConstant;int category=int((time<0.5 ? texture(tex0,centerPixelUV).a : texture(tex1,centerPixelUV).a)*255.);vec4 color_Center=getColor(category,y);vec4 color=vec4(0.,0.,0.,0.);if(categorySmoothTransition){if(tex0coord.x>=centerPixelUV.x){int category_E=int((time<0.5 ? texture(tex0,centerPixelUV_E).a : texture(tex1,centerPixelUV_E).a)*255.);vec4 color_E=getColor(category_E,y);if(tex0coord.y>=centerPixelUV.y){int category_N=int((time<0.5 ? texture(tex0,centerPixelUV_N).a : texture(tex1,centerPixelUV_N).a)*255.);vec4 color_N=getColor(category_N,y);vec2 centerPixelUV_NE=vec2((floor(tex0coord.x*tilePixelSize)+0.5+1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5+1.)/tilePixelSize);int category_NE=int((time<0.5 ?  texture(tex0,centerPixelUV_NE).a : texture(tex1,centerPixelUV_NE).a)*255.);vec4 color_NE=getColor(category_NE,y);color=blerp(color_Center,color_N,color_E,color_NE,centerPixelUV.x,centerPixelUV.y,centerPixelUV_NE.x,centerPixelUV_NE.y,tex0coord.x,tex0coord.y);}else{int category_S=int((time<0.5 ? texture(tex0,centerPixelUV_S).a : texture(tex1,centerPixelUV_S).a)*255.);vec4 color_S=getColor(category_S,y);vec2 centerPixelUV_SE=vec2((floor(tex0coord.x*tilePixelSize)+0.5+1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5-1.)/tilePixelSize);int category_SE=int((time<0.5 ?  texture(tex0,centerPixelUV_SE).a : texture(tex1,centerPixelUV_SE).a)*255.);vec4 color_SE=getColor(category_SE,y);color=blerp(color_S,color_Center,color_SE,color_E,centerPixelUV_S.x,centerPixelUV_S.y,centerPixelUV_E.x,centerPixelUV_E.y,tex0coord.x,tex0coord.y);}}else{int category_W=int((time<0.5 ? texture(tex0,centerPixelUV_W).a : texture(tex1,centerPixelUV_W).a)*255.);vec4 color_W=getColor(category_W,y);if(tex0coord.y>=centerPixelUV.y){int category_N=int((time<0.5 ? texture(tex0,centerPixelUV_N).a : texture(tex1,centerPixelUV_N).a)*255.);vec4 color_N=getColor(category_N,y);vec2 centerPixelUV_NW=vec2((floor(tex0coord.x*tilePixelSize)+0.5-1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5+1.)/tilePixelSize);int category_NW=int((time<0.5 ?  texture(tex0,centerPixelUV_NW).a : texture(tex1,centerPixelUV_NW).a)*255.);vec4 color_NW=getColor(category_NW,y);color=blerp(color_W,color_NW,color_Center,color_N,centerPixelUV_W.x,centerPixelUV_W.y,centerPixelUV_N.x,centerPixelUV_N.y,tex0coord.x,tex0coord.y);}else{int category_S=int((time<0.5 ? texture(tex0,centerPixelUV_S).a : texture(tex1,centerPixelUV_S).a)*255.);vec4 color_S=getColor(category_S,y);vec2 centerPixelUV_SW=vec2((floor(tex0coord.x*tilePixelSize)+0.5-1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5-1.)/tilePixelSize);int category_SW=int((time<0.5 ?  texture(tex0,centerPixelUV_SW).a : texture(tex1,centerPixelUV_SW).a)*255.);vec4 color_SW=getColor(category_SW,y);color=blerp(color_SW,color_W,color_S,color_Center,centerPixelUV_SW.x,centerPixelUV_SW.y,centerPixelUV.x,centerPixelUV.y,tex0coord.x,tex0coord.y);}}}else{color=color_Center;}color.a*=opacity;fragColor=color;}";
const U = 7;
function mt(s) {
  return s.filter(
    (i, e) => e === 0 || e % 2 || e === s.length - 1
  );
}
function Fe(s, i = 50) {
  if (s.length <= i)
    return s;
  const e = mt(s);
  return Fe(e, i);
}
function Ue(s, i, e = {
  inputName: "v",
  outputName: "c"
}) {
  const t = Fe(s);
  let o = "";
  for (let r = 0; r < t.length; r++) {
    const a = t[r];
    r === 0 && (o += `vec4 ${e.outputName}=${K(a.color)};
`);
    const l = a.value, c = K(a.color);
    if (i && r + 1 < t.length) {
      const h = t[r + 1].value, m = K(t[r + 1].color), f = parseFloat((l - h).toFixed(U)) === 0 ? "0." : `(${e.inputName} - ${l.toFixed(U)}) / (${(h - l).toFixed(U)})`;
      o += `${r > 0 ? " else " : ""} if(${e.inputName}>=${l.toFixed(
        U
      )}&&${e.inputName}<${h.toFixed(U)}) { ${e.outputName}=mix(${c},${m}, ${f} ); }
`;
    } else
      o += `if(${e.inputName}>=${l.toFixed(U)})${e.outputName}=${c};
`;
  }
  return o;
}
class Le {
  /**
   * @param code Inputs: `vec4 dst`, `vec4 data`. Outputs into `dst`.
   */
  constructor(i, e) {
    this.code = i, this.decode = e, this.decode.min = this.decode.min ?? 0, this.decode.max = this.decode.max ?? 1;
  }
  /**
   * Get the value in the unit interval [0, 1] computed with `.decode.min` and `.decode.max`
   * @param value
   * @returns
   */
  codeValue(i) {
    return (i - this.decode.min) / (this.decode.max - this.decode.min);
  }
  /**
   * Given a value in the unit interval [0, 1] get the real world value bounded by `.decode.min` and `.decode.max`
   * @param value
   * @returns
   */
  decodeValue(i) {
    return this.decode.min + i * (this.decode.max - this.decode.min);
  }
  /**
   * Get real world values of the given pixel (with rgb or rgba in [0, 1]) for the channel(s)
   * specified in `.decode.channel`
   * @param pixel
   * @returns
   */
  decodeChannel(i) {
    if (this.decode.channel.length > 1) {
      const e = this.decodeValue(i[this.decode.channel[0]]), t = this.decodeValue(i[this.decode.channel[1]]);
      return [e, t, Math.sqrt(e * e + t * t)];
    }
    return this.decodeValue(i[this.decode.channel]);
  }
  /**
   * Generate shader/GLSL code for blending
   * @param name
   * @returns
   */
  getBlendCode(i) {
    const e = this.code + "d.rgb=(d.rgb*d.a*(1.-c.a)+c.rgb*c.a)/(d.a*(1.-c.a)+c.a);d.a=d.a+c.a*(1.-d.a);";
    return `vec4 ${i}(vec4 d,vec4 data){${e}return d;}`;
  }
  /**
   * Generate shader/GLSL code
   * @param name
   * @returns
   */
  getCode(i) {
    return `vec4 ${i}(vec4 data){${this.code}return c;}`;
  }
}
function Oe({
  channel: s = "r",
  min: i = 0,
  max: e = 1
}) {
  let t = `${i.toFixed(U)}+data.${s}*${(e - i).toFixed(U)}`;
  return s.length > 1 && (t = `length(${t})`), `float v=${t};`;
}
class ie extends Le {
  /**
   */
  constructor(i) {
    const e = i.decode, t = i.stops || [
      { value: e.min, color: [0, 0, 0, 0] },
      { value: e.max, color: [255, 255, 255, 255] }
    ], o = i.smooth ?? !0, r = i.opacity ?? 1;
    let a = Oe(e);
    a += Ue(t, o), a += `c.a*=${r.toFixed(3)};`, super(a, e);
  }
}
class Bt extends Le {
  /**
   * .
   */
  constructor(i) {
    const e = i.decode, t = i.color || [255, 255, 255], o = i.opacity ?? 1, r = Oe(e) + `vec4 c=${K(t)};c.a*=v*${o.toFixed(3)};`;
    super(r, e);
  }
}
class Wt {
  constructor(i) {
    // The default polynomial is f(x) = 0x^2 + 1x + 0, or put simply: f(x) = x ,
    // so no transformation is applied to the data.
    n(this, "decode", {
      polynomialCoefDegree2: 0,
      polynomialCoefDegree1: 1,
      polynomialConstant: 0
    });
    // The default arrays of multiple colorstops contains a gradient definition for only one category,
    // groing from black to white on the data range [0, 255]
    n(this, "stopsPerCategory", [
      {
        category: "all",
        stops: [
          { value: 0, color: [0, 0, 0] },
          { value: 255, color: [255, 255, 255] }
        ]
      }
    ]);
    n(this, "smooth");
    n(this, "opacity");
    n(this, "code");
    this.decode = i.decode, this.stopsPerCategory = i.stopsPerCategory, this.smooth = i.smooth ?? !0, this.opacity = i.opacity ?? 1;
    const e = this.stopsPerCategory.filter(
      (a) => a.category === "all"
    );
    let t = this.stopsPerCategory;
    e.length && (t = e);
    const o = t.map((a) => {
      let l = `vec4 _mccf_${a.category}(float v) {
`;
      return l += `${Ue(
        a.stops,
        this.smooth
      )}`, l += `return c;}
`, l;
    }).join(`
`);
    let r = `vec4 getColor(int category, float v) {
`;
    r += `vec4 outputColor;
`, e.length ? r += "outputColor  = _mccf_all(v);" : (r += this.stopsPerCategory.map(
      (a, l) => `${l === 0 ? "" : "else "}if (category == ${a.category}) outputColor  = _mccf_${a.category}(v);`
    ).join(`
`), r += `
 else outputColor = vec4(0., 0., 0., 0.);
`), r += `outputColor.a *= ${this.opacity.toFixed(3)};
`, r += `return outputColor;}
`, this.code = vt.replace("<gradient_function_definitions>", o).replace("<getColor_code>", r).replace(
      "<polynomialCoefDegree2>",
      this.decode.polynomialCoefDegree2.toFixed(U)
    ).replace(
      "<polynomialCoefDegree1>",
      this.decode.polynomialCoefDegree1.toFixed(U)
    ).replace(
      "<polynomialConstant>",
      this.decode.polynomialConstant.toFixed(U)
    );
  }
  getCode() {
    return this.code;
  }
  decodeChannel(i) {
    const e = {
      r: i.r * 255,
      g: i.g * 255,
      b: i.b * 255,
      a: i.a * 255
    }, t = e.r * 256 * 256 + e.g * 256 + e.b;
    return [this.decode.polynomialCoefDegree2 * t * t + this.decode.polynomialCoefDegree1 * t + this.decode.polynomialConstant, e.a];
  }
}
class dt {
  constructor() {
    n(this, "allInstances", []);
    n(this, "availableInstances", []);
  }
  /**
   * Add an instance to the pool
   * @param obj
   * @param isAvailable make it available when true (default: false)
   * @returns
   */
  add(i, e = !1) {
    return this.allInstances.push(i), e && this.availableInstances.push(i), i;
  }
  /**
   * Check if there are still available instances in the pool.
   * @returns
   */
  isEmpty() {
    return this.availableInstances.length === 0;
  }
  /**
   * Pops one instance from the pool.
   * @throw when the pool of available instances is empty. Use `.isEmpty()` to test.
   * @returns
   *
   */
  pop() {
    if (this.isEmpty())
      throw new Error("No more instances available ini the pool.");
    return this.availableInstances.pop();
  }
  /**
   * Make all the instances available again
   */
  init() {
    this.availableInstances = this.allInstances.slice();
  }
  /**
   * Remove all elements
   */
  reset() {
    this.availableInstances = [], this.allInstances = [];
  }
}
var ft = "precision highp float;precision highp sampler2D;COLORING_FRAGMENT_DEFSout vec4 fragColor;uniform float opacity;uniform float zoom;uniform float time;uniform sampler2D tex0;uniform sampler2D tex1;uniform float tilePixelSize;uniform sampler2D texN0;uniform sampler2D texN1;uniform bool availableN;uniform sampler2D texE0;uniform sampler2D texE1;uniform bool availableE;uniform sampler2D texS0;uniform sampler2D texS1;uniform bool availableS;uniform sampler2D texW0;uniform sampler2D texW1;uniform bool availableW;uniform float maxSmoothingDistance;uniform float smoothingDistanceDecayFactor;uniform bool localSmoothing;uniform float zoomDelta;in vec2 tex0coord;in vec2 tex1coord;float PI=3.141592;const int halfNbSmoothingBins=int(ceil(float(NB_SMOOTHING_BINS))/2.);void textPositionToInternalTexPosition(vec2 uv,out vec2 newUv,out int texturePositionIndex){if(uv.x>=0.&&uv.x<=1.){if(uv.y>=0.&&uv.y<=1.){newUv=uv;texturePositionIndex=0;}else if(uv.y<0.&&availableS){newUv=vec2(uv.x,1.+uv.y);texturePositionIndex=5;}else if(uv.y>1.&&availableN){newUv=vec2(uv.x,1.-uv.y);texturePositionIndex=1;}else{newUv=uv;texturePositionIndex=0;}}else if(uv.x<0.){if(uv.y>=0.&&uv.y<=1.&&availableW){newUv=vec2(1.+uv.x,uv.y);texturePositionIndex=7;}else{newUv=uv;texturePositionIndex=0;}}else if(uv.x>1.){if(uv.y>=0.&&uv.y<=1.&&availableE){newUv=vec2(uv.x-1.,uv.y);texturePositionIndex=3;}else{newUv=uv;texturePositionIndex=0;}}}vec4 getTextureColorByIndex(int textureTimeIndex,int texturePositionIndex,vec2 uv){if(textureTimeIndex==0){if(texturePositionIndex==0){return texture(tex0,uv);}else if(texturePositionIndex==1){return texture(texN0,uv);}else if(texturePositionIndex==3){return texture(texE0,uv);}else if(texturePositionIndex==5){return texture(texS0,uv);}else if(texturePositionIndex==7){return texture(texW0,uv);}}else if(textureTimeIndex==1){if(texturePositionIndex==0){return texture(tex1,uv);}else if(texturePositionIndex==1){return texture(texN1,uv);}else if(texturePositionIndex==3){return texture(texE1,uv);}else if(texturePositionIndex==5){return texture(texS1,uv);}else if(texturePositionIndex==7){return texture(texW1,uv);}}else{return vec4(1.,0.,0.,1.);}}vec4 getColor(int textureTimeIndex,vec2 uv){int texturePositionIndex=0;vec2 localUV=vec2(0.,0.);textPositionToInternalTexPosition(uv,localUV,texturePositionIndex);return getTextureColorByIndex(textureTimeIndex,texturePositionIndex,localUV);}vec4 circularSampleSmoothing(int textureTimeIndex,vec2 uv,float resolution,float distance,out bool isTransparant){vec4 colorRGBA=getColor(textureTimeIndex,uv);int weightCenter=3;vec4 color=colorRGBA*float(weightCenter);isTransparant=colorRGBA.a<1.;float angularStep=2.*PI/float(halfNbSmoothingBins);for(int i=0;i<halfNbSmoothingBins;i++){float angle=angularStep*float(i);vec2 offset=vec2(cos(angle),sin(angle))*distance*0.5;vec2 pos=uv+offset/resolution;vec4 c=getColor(textureTimeIndex,pos);color+=c;isTransparant=isTransparant||c.a<1.;angle=angularStep/2.+angularStep*float(i);offset=vec2(cos(angle),sin(angle))*distance;pos=uv+offset/resolution;c=getColor(textureTimeIndex,pos);color+=c;isTransparant=isTransparant||c.a<1.;}return color/float(2*halfNbSmoothingBins+weightCenter);}void main(){float scaledSamplingDistance=(maxSmoothingDistance*smoothingDistanceDecayFactor/(smoothingDistanceDecayFactor+zoom))*max(1.,2.-zoomDelta);bool isTransparant0=false;bool isTransparant1=false;vec4 tex0Color;vec4 tex1Color;if(localSmoothing&&halfNbSmoothingBins!=0){tex0Color=circularSampleSmoothing(0,tex0coord,tilePixelSize,scaledSamplingDistance,isTransparant0);tex1Color=circularSampleSmoothing(1,tex1coord,tilePixelSize,scaledSamplingDistance,isTransparant1);}else{tex0Color=texture(tex0,tex0coord);tex1Color=texture(tex1,tex1coord);}vec4 inter=mix(tex0Color,tex1Color,time);if(inter.a<1.0&&!RENDER_TRANSPARENT)discard;COLORING_FRAGMENT_CALLSfragColor.a*=opacity;}", xt = "precision highp float;precision highp sampler2D;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;in vec3 position;in vec2 uv;uniform vec2 tex0xy;uniform vec2 tex1xy;uniform float tex0size;uniform float tex1size;out vec2 tex0coord;out vec2 tex1coord;void main(){tex0coord=tex0xy+uv*tex0size;tex1coord=tex1xy+uv*tex1size;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}", pt = "precision highp float;precision highp int;precision highp sampler2D;uniform sampler2D imageA;uniform sampler2D imageB;uniform float mixValue;in vec2 vUv;out vec4 fragColor;void main(){fragColor=mix(texture(imageA,vUv),texture(imageB,vUv),mixValue);}", _e = "precision highp float;precision highp int;precision highp sampler2D;uniform vec2 direction;uniform int kernelSize;uniform sampler2D imgToBlur;in vec2 vUv;out vec4 fragColor;vec4 blur5(sampler2D image,vec2 uv,vec2 resolution,vec2 direction){vec4 color=vec4(0.0);vec2 off1=vec2(1.3333333333333333)*direction;color+=texture(image,uv)*0.29411764705882354;color+=texture(image,uv+(off1/resolution))*0.35294117647058826;color+=texture(image,uv-(off1/resolution))*0.35294117647058826;return color;}vec4 blur9(sampler2D image,vec2 uv,vec2 resolution,vec2 direction){vec4 color=vec4(0.0);vec2 off1=vec2(1.3846153846)*direction;vec2 off2=vec2(3.2307692308)*direction;color+=texture(image,uv)*0.2270270270;color+=texture(image,uv+(off1/resolution))*0.3162162162;color+=texture(image,uv-(off1/resolution))*0.3162162162;color+=texture(image,uv+(off2/resolution))*0.0702702703;color+=texture(image,uv-(off2/resolution))*0.0702702703;return color;}vec4 blur13(sampler2D image,vec2 uv,vec2 resolution,vec2 direction){vec4 color=vec4(0.0);vec2 off1=vec2(1.411764705882353)*direction;vec2 off2=vec2(3.2941176470588234)*direction;vec2 off3=vec2(5.176470588235294)*direction;color+=texture(image,uv)*0.1964825501511404;color+=texture(image,uv+(off1/resolution))*0.2969069646728344;color+=texture(image,uv-(off1/resolution))*0.2969069646728344;color+=texture(image,uv+(off2/resolution))*0.09447039785044732;color+=texture(image,uv-(off2/resolution))*0.09447039785044732;color+=texture(image,uv+(off3/resolution))*0.010381362401148057;color+=texture(image,uv-(off3/resolution))*0.010381362401148057;return color;}vec4 blur19(sampler2D image,vec2 uv,vec2 resolution,vec2 direction){vec4 color=vec4(0.0);vec2 off1=vec2(1.434782608695652)*direction;vec2 off2=vec2(3.347826086956522)*direction;vec2 off3=vec2(5.260869565217392)*direction;vec2 off4=vec2(7.173913043478261)*direction;color+=texture(image,uv)*0.16818993967466953;color+=texture(image,uv+(off1/resolution))*0.2727695816518679;color+=texture(image,uv-(off1/resolution))*0.2727695816518679;color+=texture(image,uv+(off2/resolution))*0.11690124927937194;color+=texture(image,uv-(off2/resolution))*0.11690124927937194;color+=texture(image,uv+(off3/resolution))*0.024067904263400105;color+=texture(image,uv-(off3/resolution))*0.024067904263400105;color+=texture(image,uv+(off4/resolution))*0.0021112196722280793;color+=texture(image,uv-(off4/resolution))*0.0021112196722280793;return color;}void main(){vec4 color=vec4(1.,0,0,1.);vec2 textureResolution=vec2(textureSize(imgToBlur,0));if(kernelSize==5){color=blur5(imgToBlur,vUv,textureResolution,direction);}else if(kernelSize==9){color=blur9(imgToBlur,vUv,textureResolution,direction);}else if(kernelSize==13){color=blur13(imgToBlur,vUv,textureResolution,direction);}else if(kernelSize==19){color=blur19(imgToBlur,vUv,textureResolution,direction);}fragColor=color;}", gt = "precision highp float;precision highp int;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;in vec3 position;in vec2 uv;out vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}", St = "precision highp float;precision highp int;precision highp sampler2D;in vec2 vUv;out vec4 fragColor;void main(){fragColor=vec4(1.,0.,0.,1.);}";
let we = null;
function yt() {
  return we || (we = new et({
    alpha: !0,
    premultipliedAlpha: !1
  })), we;
}
class Pe {
  /**
   *
   * @param width width of the output
   * @param height height of the output
   * @param renderer optional existing renderer to use
   */
  constructor(i, e, t = yt()) {
    n(this, "renderer");
    //= new WebGLRenderer();
    n(this, "camera", new Ye(
      -1,
      1,
      1,
      -1,
      0,
      1
    ));
    n(this, "scene", new He());
    n(this, "renderTarget");
    n(this, "material", new Ke({
      glslVersion: Xe,
      vertexShader: gt,
      fragmentShader: St,
      depthWrite: !1,
      transparent: !0
    }));
    n(this, "size");
    this.size = new je(i, e), this.renderTarget = new De(i, e, {
      minFilter: ce,
      magFilter: ce,
      format: ge
    }), this.camera.matrixAutoUpdate = !1, this.renderer = t, this.renderer.setPixelRatio(1), this.renderer.autoClear = !1;
    const o = new qe(new Je(2, 2), this.material);
    this.scene.add(o);
  }
  /**
   * Get the output texture
   * @param forceDataTexture Makes a deep copy of the texture data to return a `THREE.DataTexture`. This is much slower
   * but allows this instance to be disposed while keeping a copy of the texture.
   * @returns
   */
  getOutputTexture(i = !1) {
    return i ? new Qe(
      this.getPixelData(),
      this.size.x,
      this.size.y,
      ge
    ) : this.renderTarget.texture;
  }
  /**
   * Set the size of the output
   * @param width
   * @param height
   * @returns
   */
  setSize(i, e) {
    i === this.size.x && e === this.size.y || (this.size.x = i, this.size.y = e, this.renderTarget = new De(i, e, {
      minFilter: ce,
      magFilter: ce,
      format: ge
    }), this.renderer.setRenderTarget(this.renderTarget));
  }
  /**
   * Set the vertex shader for this pass
   * @param shader
   */
  setVertexShader(i) {
    this.material.vertexShader = i.trim(), this.material.needsUpdate = !0;
  }
  /**
   * Set the fragment shader for this pass
   * @param shader
   */
  setFragmentShader(i) {
    this.material.fragmentShader = i.trim(), this.material.needsUpdate = !0;
  }
  /**
   * Add a uniform
   * @param name
   * @param value
   */
  setUniform(i, e) {
    this.material.uniforms[i] = { value: e };
  }
  /**
   * Dynamically replace some string in a shader (`name`) by others (`value`)
   * @param name
   * @param value
   */
  setDefine(i, e) {
    this.material.fragmentShader = this.material.fragmentShader.replace(
      new RegExp(i, "g"),
      e.toString()
    ), this.material.vertexShader = this.material.vertexShader.replace(
      new RegExp(i, "g"),
      e.toString()
    ), this.material.needsUpdate = !0;
  }
  /**
   * Retrieve the pixel data as a single dimension array of RGBA.
   * This can be slow because of memory transfer from GPU to CPU
   */
  getPixelData() {
    const i = this.size, e = new Uint8Array(i.x * i.y * 4);
    return this.renderer.readRenderTargetPixels(
      this.renderTarget,
      0,
      0,
      i.x,
      i.y,
      e
    ), e;
  }
  /**
   * Get the defined size of the output
   * @returns
   */
  getSize() {
    return this.size.clone();
  }
  /**
   * Run the shader code. The result is then stored internaly in a `THREE.RenderTarget`
   * @returns
   */
  process() {
    return this.material.needsUpdate = !0, this.renderer.setRenderTarget(this.renderTarget), this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.renderTarget.texture;
  }
  /**
   * Opens the output image in a separate window for debugging purposes.
   */
  debugAsPNG() {
    const i = this.getSize(), e = this.getPixelData(), t = document.createElement("canvas");
    t.width = i.x, t.height = i.y;
    const o = t.getContext("2d");
    if (!o)
      return;
    const r = o.getImageData(0, 0, t.width, t.height);
    r.data.set(e), o.putImageData(r, 0, 0);
    const a = window.open();
    a && a.document.write(
      `<iframe src="${t.toDataURL(
        "image/png"
      )}" frameborder="0" style="border:0; top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen></iframe>`
    );
  }
  /**
   * Free the render target memory
   */
  dispose() {
    this.renderTarget.texture.dispose(), this.renderTarget.dispose();
  }
}
const Re = "api.maptiler.com", q = {
  maptilerApiHost: Re,
  // we use a mockup:
  endpoint: `https://${Re}/weather/latest.json`,
  tileSourceUrlSchema: `https://${Re}/tiles/{tileset_id}/{zxy}.{format}`
};
Object.freeze(q);
class Tt {
  /**
   *
   * @param url The URL must have a pattern such as `https://api.maptiler.com/tiles/something/{zxy}.png`
   * @param onTileLoad
   */
  constructor(i, e) {
    n(this, "loader", new v.TextureLoader());
    n(this, "lru", new tt(32));
    n(this, "apiKey", "");
    n(this, "sessionId", "");
    this.url = i, this.onTileLoad = e;
  }
  setMaptilerParams(i, e) {
    this.apiKey = i, this.sessionId = e;
  }
  urlPatternToUrl(i) {
    let e;
    try {
      e = new URL(this.url.replace("{zxy}", i));
    } catch {
      e = new URL(this.url.replace("{zxy}", i), document.baseURI);
    }
    return e.host === q.maptilerApiHost && (this.apiKey && !e.searchParams.has("key") && e.searchParams.append("key", this.apiKey), this.sessionId && !e.searchParams.has("mtsid") && e.searchParams.append("mtsid", this.sessionId)), e.href;
  }
  /**
   * Get a tile from its ID.
   * Retrieves the tile from cache if present, otherwise loads it and adds it to cache
   * @param zxy of shape `"z/x/y"`, for example `"0/0/0"`
   * @param load
   * @returns
   */
  getTile(i, e) {
    if (i.split("/").map((o) => parseInt(o)).some((o) => o < 0))
      return null;
    if (this.lru.containsKey(i))
      return this.lru.get(i);
    if (e) {
      const o = this.createTile(i);
      return this.lru.set(i, o), o;
    }
    return null;
  }
  /**
   * Loads a tile and adds it to cache. When created `.ready` is `false` but when the loading callback
   * is successful, it is turned to `true`. Due to this asynchronous behaviour, the `Tile`returned by
   * this function will always have its `.ready`attribute to false.
   *
   * @param zxy of shape `"z/x/y"`, for example `"0/0/0"`
   * @returns
   */
  createTile(i) {
    const e = this.urlPatternToUrl(i), t = {
      ready: !1,
      texture: null,
      zxy: i
    };
    return t.texture = this.loader.load(
      e,
      () => {
        t.ready = !0, this.onTileLoad != null && this.onTileLoad(t, e, null);
      },
      // on progress callback (deprecated)
      void 0,
      // On load fail callback
      (o) => {
        this.onTileLoad != null && this.onTileLoad(t, e, o);
      }
    ), t.texture.minFilter = v.LinearFilter, t.texture.needsUpdate = !0, t;
  }
  /**
   * Frees the GPU related resources allocated by a texture. See [Texture.dispose() on ThreeJS](https://threejs.org/docs/?q=texture#api/en/textures/Texture.dispose).
   * @param tile
   */
  disposeTile(i) {
    i.texture && i.texture.dispose();
  }
  /**
   * Dispose all the Tiles that are overflowing the size of the cache, except the ones provided in argument.
   * @param usedTiles
   */
  expireCache(i) {
    for (; this.lru.canExpireCache() && !(this.lru.peekLast().zxy in i); )
      this.disposeTile(this.lru.pop());
  }
  /**
   * Dispose all the tiles from the cache (clearing the cache)
   */
  dispose() {
    this.lru.forEach((i) => {
      this.disposeTile(i);
    }), this.lru.clear();
  }
}
class wt extends ot {
  constructor() {
    super();
    n(this, "frames", []);
    n(this, "time", 0);
    n(this, "animationSpeed", 0);
    n(this, "lastTickTime", 0);
  }
  /**
   * Add a new TimeFrame information to the animation. If the frame container is not empty,
   * then the provided TimeFrame data will be added at the corresct position based on its time.
   * @param time
   * @param data
   */
  addFrame(e, t) {
    const o = this.findSmallerFrameIndex(e);
    if (o < 0)
      this.frames.unshift({
        time: e,
        data: t
      });
    else {
      if (this.frames[o].time == e)
        throw new Error("Frame with this time already exists");
      this.frames.splice(o + 1, 0, {
        time: e,
        data: t
      });
    }
    this.clampAnimation();
  }
  /**
   * Remove a frame using its time as an ID
   * @param time
   * @returns
   */
  removeFrame(e) {
    const t = this.frames.filter((o) => o.time == e);
    return this.frames = this.frames.filter((o) => o.time != e), this.clampAnimation(), t;
  }
  /**
   * Call a function for each TimeFrame of the amimation
   * @param action
   */
  forEachFrame(e) {
    this.frames.forEach((t) => e(t));
  }
  /**
   * Get the time of the first TimeFrame (always the begining of the animation).
   * If the frame container is empty, returns Infinity
   */
  getAnimationStart() {
    return this.frames.length ? this.frames[0].time : 1 / 0;
  }
  /**
   * Get the animation start as a Date object
   * @returns
   */
  getAnimationStartDate() {
    return new Date(this.getAnimationStart() * 1e3);
  }
  /**
   * Get the end time of the animation or -Infinity if empty.
   */
  getAnimationEnd() {
    return this.frames.length ? this.frames[this.frames.length - 1].time : -1 / 0;
  }
  /**
   * Get the animation end as a date object
   * @returns
   */
  getAnimationEndDate() {
    return new Date(this.getAnimationEnd() * 1e3);
  }
  /**
   * Get the current time of the animation
   */
  getAnimationTime() {
    return this.time;
  }
  /**
   * Get the current time of the animation as a Date object
   * @returns
   */
  getAnimationTimeDate() {
    return new Date(this.getAnimationTime() * 1e3);
  }
  /**
   * Change the visualization to a specific time. Does not stop animation.
   */
  setAnimationTime(e) {
    this.time = e, this.clampAnimation(), this.emit("animationTimeSet", {
      time: this.time
    });
  }
  clampAnimation() {
    this.time = Math.max(
      this.getAnimationStart(),
      Math.min(this.getAnimationEnd(), this.time)
    );
  }
  /**
   * Animate by a factor of real life speed.
   * Exampe, if `factor` is `10`, then the animation will play at 10 times the real life speed.
   * @param factor
   */
  animateByFactor(e) {
    this.animate(e);
  }
  /**
   * Changes the speed of the animation. `0` to stop.
   * The speed is in number of real world milliseconds per animation second.
   * Example: if timePerSecond is set to 10*1000, then the animation will run
   * 10x of real world speed.
   */
  animate(e) {
    e > 0 && this.animationSpeed === 0 ? this.emit("playAnimation", {
      time: this.time
    }) : e === 0 && this.animationSpeed > 0 && this.emit("pauseAnimation", {
      time: this.time
    }), this.animationSpeed = e, this.animationSpeed != 0 && (this.lastTickTime = performance.now());
  }
  /**
   * Get the speed of the animation.
   * The speed is in number of real world seconds per animation second.
   */
  getAnimationSpeed() {
    return this.animationSpeed;
  }
  /**
   * Tells whether the animation is currently playing
   * @returns
   */
  isPlaying() {
    return this.animationSpeed > 0;
  }
  /**
   * Make the animation time progress based on the current timestamps.
   */
  animationTick() {
    const e = performance.now();
    if (this.animationSpeed > 0 && this.lastTickTime) {
      const t = e - this.lastTickTime;
      this.time += this.animationSpeed * (t / 1e3);
      const o = this.getAnimationStart(), r = this.getAnimationEnd();
      this.time = o + (this.time - o) % (r - o), isNaN(this.time) && (this.time = o), this.emit("tick", {
        time: this.time
      });
    }
    this.lastTickTime = e;
  }
  /**
   * Find the index of TimeFrame whose time is just immediately below targetTime
   * @param targetTime
   * @returns
   */
  findSmallerFrameIndex(e) {
    for (let t = this.frames.length - 1; t >= 0; --t)
      if (this.frames[t].time <= e)
        return t;
    return -1;
  }
  /**
   * Based on the current animation time, retrieve the frame immediately before (frameA),
   * the frame immediately after (frameB) and the mix.
   * The mixe value is in the interval [0, 1], where close to `0` means the current time
   * is close to frameA and close to `1` means the current time is close to frameB. The mix
   * value is provided so that linear interpolation of data can be performed.
   * @returns
   */
  getCurrentFrames() {
    if (this.frames.length == 0)
      return {
        frameA: null,
        frameB: null,
        mix: 0
      };
    let e = this.findSmallerFrameIndex(this.time);
    e < 0 && (e = 0);
    const t = this.frames[e], o = this.frames[Math.min(this.frames.length - 1, e + 1)], r = o.time - t.time, a = r == 0 ? 0 : (this.time - t.time) / r;
    return {
      frameA: t,
      frameB: o,
      mix: a
    };
  }
  /**
   * Providing a TimeFrame (time + data), get the TimeFrame from the annimation that is
   * directly after (when `direction` is positive) or immediately before (when `direction` is negative)
   * @param frame
   * @param direction
   * @returns
   */
  getNextFrame(e, t) {
    const o = this.frames.findIndex((r) => r === e);
    return o < 0 ? null : t < 0 ? o > 0 ? this.frames[o - 1] : null : o < this.frames.length - 1 ? this.frames[o + 1] : null;
  }
}
const Z = {
  GFS_TEMPERATURE_2M: "temperature-2m:gfs",
  GFS_PRESSURE_MSL: "pressure-msl:gfs",
  GFS_PRECIPITATION_1H: "precipitation-1h:gfs",
  GFS_FROZEN_PRECIPITATION_PERCENT: "frozen_precipitation-1h:gfs",
  GFS_WIND_10M: "wind-10m:gfs",
  GFS_RADAR_COMPOSITE: "radar-composite:gfs",
  GFS_CLOUD_COVER_TOTAL: "cloud_cover-total:gfs"
}, ue = {
  latest: null
};
class y {
  static async fetchLatest(i, e) {
    const t = `${q.endpoint}?key=${i}&mtsid=${e}`, o = await fetch(t, { cache: "no-store" });
    ue.latest = await o.json();
  }
  static getDataForWeatherVariableID(i) {
    if (!ue.latest)
      return null;
    const e = ue.latest.variables.filter(
      (t) => t.metadata.weather_variable.variable_id === i
    );
    return e.length ? e[0] : null;
  }
  static hasData() {
    return !!ue.latest;
  }
  static getTemperatureData() {
    return y.getDataForWeatherVariableID(
      Z.GFS_TEMPERATURE_2M
    );
  }
  static getPressureData() {
    return y.getDataForWeatherVariableID(
      Z.GFS_PRESSURE_MSL
    );
  }
  static getPrecipitationData() {
    return y.getDataForWeatherVariableID(
      Z.GFS_PRECIPITATION_1H
    );
  }
  static getCloudCoverData() {
    return y.getDataForWeatherVariableID(
      Z.GFS_CLOUD_COVER_TOTAL
    );
  }
  static getFrozenPrecipitationData() {
    return y.getDataForWeatherVariableID(
      Z.GFS_FROZEN_PRECIPITATION_PERCENT
    );
  }
  static getRadarData() {
    return y.getDataForWeatherVariableID(
      Z.GFS_RADAR_COMPOSITE
    );
  }
  static getWindData() {
    return y.getDataForWeatherVariableID(
      Z.GFS_WIND_10M
    );
  }
  static getSourcesAndTimestamps(i, e, t) {
    return i.keyframes.map((o) => ({
      source: `${q.tileSourceUrlSchema.replace("{tileset_id}", o.id).replace(
        "{format}",
        i.tile_format
      )}?key=${e}&mtsid=${t}`,
      timestamp: +new Date(o.timestamp) / 1e3
      // timestamp is given in seconds
    }));
  }
}
class ae extends wt {
  /**
   *
   * @param id Unique identifier of the layer in the map.
   * @param options
   * @param coloringFragments
   */
  constructor(e, t, o = null, r = null) {
    super();
    n(this, "id");
    n(this, "type", "custom");
    n(this, "renderingMode", "3d");
    // In 2d mode certain layer types can't be interlaced
    /**
     * Camera used to render the tiles
     */
    n(this, "camera", new v.Camera());
    /**
     * Scene to add the tiles to
     */
    n(this, "scene", new v.Scene());
    /**
     * Array of array of Tiles (plane geometry meshes)
     */
    n(this, "slippyTiles", []);
    /**
     * Instance of MapTiler SDK map
     */
    n(this, "map", null);
    /**
     * Renderer to render the tiles
     */
    n(this, "renderer", null);
    /**
     * The shader material of the tiles (with uniforms such as textures, time, etc.)
     */
    n(this, "material");
    /**
     * The plane geometry used for all the tiles
     */
    n(this, "geometry", new v.PlaneGeometry(1, 1));
    /**
     * TODO
     */
    n(this, "flusher");
    /**
     * A TileGrid (from OL) that contains some tile logic such as mercator to index, etc.
     */
    n(this, "tilegrid");
    /**
     * Extent as in OL
     */
    n(this, "extent", null);
    /**
     * Indicated whether the the function `map.triggerRepaint()` should be called
     * when the animation is paused.
     */
    n(this, "repaintOnPausedAnimation", !0);
    /**
     * Manages a pool of rawshadermaterial to reuse, rather cloning endlessly
     */
    n(this, "materialPool", new dt());
    n(this, "bluringNodePasses", []);
    // will be instanciated when we know the tile size
    n(this, "tileThreeContainer", new v.Object3D());
    /**
     * ratio to wich the extent is enlarged when using the method `.getVisibleExtent()`
     */
    n(this, "extentScale", 1);
    /**
     * The event `"extentChanged"` is emitted when the intersection-over-union ration from the former extent to the new
     * is below this.extentChangedThreshold
     */
    n(this, "extentChangedThreshold", 0.75);
    n(this, "lastExtent", [0, 0, 0, 0]);
    n(this, "timeInterpolation", !0);
    n(this, "isReady", !1);
    n(this, "defaultTexture", new v.DataTexture(
      new Uint8Array([128, 128, 128, 255]),
      1,
      1,
      v.RGBAFormat
    ));
    n(this, "onMoveEndListener");
    n(this, "onResizeListener");
    n(this, "onMoveListener");
    n(this, "coloringFragments", null);
    n(this, "multiChannelColoringFragment");
    n(this, "loadLowerZoomLevels");
    n(this, "getMapOrThrow", () => {
      if (this.map == null)
        throw new Error("Accessing map on detached layer");
      return this.map;
    });
    n(this, "getRendererOrThrow", () => {
      if (this.renderer == null)
        throw new Error("Accessing renderer on detached layer");
      return this.renderer;
    });
    this.defaultTexture.needsUpdate = !0, this.id = e, t && this.init(t, o, r);
  }
  init(e, t = null, o = null) {
    this.loadLowerZoomLevels = e.loadLowerZoomLevels ?? !0, this.coloringFragments = t, this.multiChannelColoringFragment = o, this.repaintOnPausedAnimation = e.repaintOnPausedAnimation ?? !0, this.onMoveEndListener = this.onMoveEnd.bind(this), this.onResizeListener = this.onResize.bind(this), this.onMoveListener = this.onMove.bind(this), this.tilegrid = Ze({
      minZoom: e.minZoom ?? 0,
      maxZoom: e.maxZoom ?? 4
    }), e.bounds && (this.extent = j(e.bounds[0], e.bounds[1]).concat(
      j(e.bounds[2], e.bounds[3])
    ));
    let r = "";
    if (this.coloringFragments) {
      const l = this.coloringFragments.map(
        (h, m) => h.getBlendCode(`_cf_${m}`)
      );
      let c = "fragColor";
      for (let h = 0; h < this.coloringFragments.length; h++)
        c = `_cf_${h}(${c},inter)`;
      c = `fragColor=${c};`, r = ft.replace(
        "COLORING_FRAGMENT_DEFS",
        l.join(`
`)
      ).replace("COLORING_FRAGMENT_CALLS", c);
    } else
      o && (r = o.getCode());
    const a = (e.nbSmoothingBins ?? 16).toFixed(0);
    this.timeInterpolation = e.timeInterpolation ?? !0, this.material = new v.RawShaderMaterial({
      glslVersion: v.GLSL3,
      uniforms: {
        opacity: { value: 1 },
        time: { value: 0 },
        zoom: { value: 0 },
        tex0xy: { value: [0, 0] },
        tex1xy: { value: [0, 0] },
        tex0size: { value: 1 },
        tex1size: { value: 1 },
        tilePixelSize: { value: 1 },
        categorySmoothTransition: {
          value: e.categorySmoothTransition ?? !1
        },
        timeInterpolation: { value: this.timeInterpolation },
        tex0: {
          value: null
        },
        tex1: {
          value: null
        },
        zoomDelta: { value: 0 },
        localSmoothing: { value: e.localSmoothing ?? !1 },
        maxSmoothingDistance: { value: e.maxSmoothingDistance ?? 12 },
        smoothingDistanceDecayFactor: {
          value: e.smoothingDistanceDecayFactor ?? 10
        },
        // Tile texture around the current one.
        // Used when smoothing is enabled
        texN0: { value: this.defaultTexture },
        texN1: { value: this.defaultTexture },
        availableN: { value: !1 },
        texE0: { value: this.defaultTexture },
        texE1: { value: this.defaultTexture },
        availableE: { value: !1 },
        texS0: { value: this.defaultTexture },
        texS1: { value: this.defaultTexture },
        availableS: { value: !1 },
        texW0: { value: this.defaultTexture },
        texW1: { value: this.defaultTexture },
        availableW: { value: !1 }
      },
      vertexShader: xt,
      fragmentShader: r,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      defines: {
        RENDER_TRANSPARENT: e.renderTransparentArea ? "true" : "false",
        NB_SMOOTHING_BINS: a
      }
    }), this.flusher = new v.Mesh(
      new v.PlaneGeometry(1, 1),
      new v.MeshBasicMaterial({
        colorWrite: !1,
        depthWrite: !1
      })
    ), this.flusher.frustumCulled = !1, this.scene.add(this.flusher), this.scene.add(this.tileThreeContainer), this.updateSlippyTileGrid(8, 8), this.on("playAnimation", () => {
      this.forceRepaint();
    }), this.on("animationTimeSet", () => {
      this.forceRepaint();
    }), this.isReady = !0;
  }
  /**
   * Remove the current tiles of the tile grid from the scene and reinstanciate them all
   * (three.Mesh) based onthe arguments, then add them to the scene again.
   * Note: The tils positions are not updated yet, this is performed by `.updateSlippyTile()`
   * @param width
   * @param height
   */
  updateSlippyTileGrid(e, t) {
    this.tileThreeContainer.clear(), this.slippyTiles.length = 0;
    for (let o = 0; o < e; o++) {
      this.slippyTiles[o] = [];
      for (let r = 0; r < t; r++) {
        const a = new v.Mesh(this.geometry);
        a.frustumCulled = !1, this.slippyTiles[o][r] = a, this.tileThreeContainer.add(a);
      }
    }
  }
  validateSource(e) {
    let t;
    try {
      t = new URL(e);
    } catch {
      t = new URL(e, document.baseURI);
    }
    if (t.host !== q.maptilerApiHost)
      throw new Error(
        `

MapTiler Weather library can only source data from MapTiler Cloud.
Please use our MapTiler Plus library for self hosting: https://www.maptiler.com/weather/
or host your data with our generous free plan at MapTiler Cloud: https://cloud.maptiler.com
`
      );
  }
  /**
   * Adds another frame to the animation.
   * @param time Time of the data in this frame. Should be unique.
   * @param url URL to the tiles. Expected to have `{zxy}` placeholder to be dynamically replaced with `z/x/y` coordinates.
   */
  addSource(e, t, o = null) {
    this.validateSource(t);
    const r = new Tt(
      t,
      (a, l, c) => {
        o && o(a, l, c), this.forceRepaint();
      }
    );
    if (this.map) {
      const a = this.map.getSdkConfig().apiKey, l = this.map.getMaptilerSessionId();
      r.setMaptilerParams(a, l);
    }
    super.addFrame(e, r);
  }
  /**
   * Removes frame
   */
  removeSource(e) {
    super.removeFrame(e).forEach((o) => {
      o.data.dispose();
    }), this.forceRepaint();
  }
  /**
   * Ge the Extent as defined in OL
   * @param scale
   * @returns
   */
  getVisibleExtent(e) {
    if (!this.isReady)
      return null;
    const t = this.getMapOrThrow().getBounds();
    let o = j(t.getWest(), t.getSouth()).concat(
      j(t.getEast(), t.getNorth())
    );
    return this.extent && (o = We(this.extent, o)), e && Ge(o, e), o;
  }
  /**
   * Get the list of all the tiles wanted for this extent and from the min zoom to the max zoom.
   * This is used to prevent updating tiles that are not in this list in `.updateSlippyTile()`
   * @param currentZ
   * @returns
   */
  getWantedTiles(e) {
    if (!this.isReady)
      return {};
    e = Math.ceil(e);
    const t = {}, o = this.getVisibleExtent();
    if (!o)
      throw new Error("The extent is null");
    const r = this.tilegrid.getMinZoom(), a = this.tilegrid.getMaxZoom(), l = Math.min(a, Math.max(r, e - 1)), c = Math.min(a, Math.max(r, e));
    for (let h = l; h <= c; ++h) {
      const m = Math.pow(2, h), f = this.tilegrid.getTileRangeForExtentAndZ(o, h);
      for (let x = f.minX; x <= f.maxX; ++x)
        for (let g = f.minY; g <= f.maxY; ++g)
          g < 0 || g >= m || (t[`${h}/${x}/${g}`] = !0);
    }
    return t;
  }
  /**
   * Changes the global opacity of the layer.
   * Default is `1`
   *
   * @param opacity Opacity 0-1.
   */
  setOpacity(e) {
    this.isReady && (this.material.uniforms.opacity.value = e, this.forceRepaint());
  }
  /**
   * Method from CustomLayerInterface, called when the layer is added to the map
   * @param map
   * @param gl
   */
  onAdd(e, t) {
    this.map = e, this.map.on("moveend", this.onMoveEndListener), this.map.on("resize", this.onResizeListener), this.map.on("move", this.onMoveListener);
    const o = this.map.getSdkConfig().apiKey, r = this.map.getMaptilerSessionId();
    this.forEachFrame((l) => {
      l.data.setMaptilerParams(o, r);
    }), y.hasData() || y.fetchLatest(o, r), this.renderer = new v.WebGLRenderer({
      canvas: e.getCanvas(),
      context: t,
      depth: !1,
      stencil: !1,
      //alpha: true,
      antialias: !0
    }), this.renderer.autoClear = !1, this.renderer.sortObjects = !1, this.renderer.debug.checkShaderErrors = !0, this.renderer.compile(this.scene, this.camera), this.onResize(), this.refresh();
    const a = this.getVisibleExtent(this.extentScale);
    if (!a)
      throw new Error("The last extent is null");
    this.lastExtent = a, this.forceRepaint();
  }
  onMove() {
    if (!this.isReady)
      return;
    const e = this.getVisibleExtent(this.extentScale);
    if (!e)
      throw new Error("New extent is null");
    const t = [
      Math.min(e[0], this.lastExtent[0]),
      Math.min(e[1], this.lastExtent[1]),
      Math.max(e[2], this.lastExtent[2]),
      Math.max(e[3], this.lastExtent[3])
    ], o = $e(t);
    ke(this.lastExtent, e) / o <= this.extentChangedThreshold && (this.lastExtent = e, this.emit("extentChanged"));
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  refresh() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onRemove(e, t) {
    this.isReady && (this.map != null && (this.map.off("moveend", this.onMoveEndListener), this.map.off("resize", this.onResizeListener), this.map.off("move", this.onMoveListener), this.map = null), this.renderer != null && (this.renderer.dispose(), this.renderer = null), this.forEachFrame((o) => {
      o.data.dispose();
    }), this.disposeObjects());
  }
  /**
   * Remove some data allocated (not of the tiles)
   */
  disposeObjects() {
    this.isReady && (this.geometry.dispose(), this.material.dispose(), this.flusher.geometry.dispose(), this.flusher.material.dispose(), this.bluringNodePasses.forEach((e) => e.dispose()));
  }
  /**
   * Callback when the window is resized.
   */
  onResize() {
    if (!this.isReady)
      return;
    const e = this.getMapOrThrow().getCanvas(), t = e.width, o = e.height;
    this.getRendererOrThrow().setViewport(0, 0, t, o), this.updateSlippyTileGrid(
      Math.ceil(t / 512) + 2,
      Math.ceil(o / 512) + 2
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onMoveEnd() {
  }
  /**
   * Get the TilePlacement from a zxy
   * @param source
   * @param load
   * @param z
   * @param x
   * @param y
   * @param originalTileCoordinates
   * @returns
   */
  getTilePlacement(e, t, o, r, a, l) {
    if (!this.isReady)
      return null;
    const c = `${o}/${r}/${a}`, h = e.getTile(c, t);
    if (!h || !h.ready)
      return this.loadLowerZoomLevels && o > this.tilegrid.getMinZoom() ? this.getTilePlacement(
        e,
        t,
        o - 1,
        Math.floor(r / 2),
        Math.floor(a / 2),
        l || { z: o, x: r, y: a }
      ) : null;
    const m = {
      tile: h,
      xy: [0, 0],
      size: 1
    };
    if (l !== void 0) {
      const f = Math.pow(2, l.z - o);
      m.size /= f, m.xy[0] = l.x % f / f, m.xy[1] = (Math.pow(2, l.z) - l.y - 1) % f / f;
    }
    return m;
  }
  /**
   * Update the tile's mesh position and size, as well each tile material uniforms
   * (time, texture, etc.)
   * @returns
   */
  updateSlippyTiles() {
    var $;
    if (!this.isReady)
      return;
    const { frameA: e, frameB: t, mix: o } = this.getCurrentFrames();
    if (!e || !t) {
      this.scene.visible = !1;
      return;
    }
    this.scene.visible = !0;
    const r = e.data, a = t.data, l = this.getMapOrThrow().getZoom(), c = this.getWantedTiles(l), h = {}, m = this.tilegrid.getMinZoom(), f = this.tilegrid.getMaxZoom(), x = Math.min(f, Math.max(m, Math.floor(l))), g = Math.pow(2, x), T = 1 / g, L = this.getMapOrThrow().getCenter(), B = this.tilegrid.getTileCoordForCoordAndZ(
      j(L.lng, L.lat),
      x
    ), le = l - x, X = this.slippyTiles.length;
    this.materialPool.init();
    const O = new globalThis.Map();
    for (let M = 0; M < X; M++) {
      const V = this.slippyTiles[0].length;
      for (let z = 0; z < V; z++) {
        const S = this.slippyTiles[M][z], H = B[1] + M - Math.floor(X / 2), N = B[2] + z - Math.floor(V / 2), se = `${x}/${H}/${N}`;
        if (N < 0 || N >= g || !c[se]) {
          S.visible = !1;
          continue;
        }
        S.visible = !0;
        const k = (H % g + g) % g, de = `${x}/${k}/${N}`;
        h[de] = !0;
        const fe = g - N - 1;
        S.scale.x = T, S.scale.y = T, S.position.x = T * (H + 0.5), S.position.y = T * (fe + 0.5) - 1;
        let C = this.getTilePlacement(r, !0, x, k, N), A = this.getTilePlacement(a, !0, x, k, N);
        if (C && !A && (A = C), !C && A && (C = A), !C || !A) {
          let ne = e;
          for (; !C && (ne = this.getNextFrame(ne, -1), !!ne); )
            C = A = this.getTilePlacement(
              ne.data,
              !1,
              x,
              k,
              N
            );
          if (!C || !A) {
            S.visible = !1;
            continue;
          }
        }
        const p = this.materialPool.isEmpty() ? this.materialPool.add(this.material.clone()) : this.materialPool.pop();
        p.uniforms.localSmoothing.value = this.material.uniforms.localSmoothing.value, p.uniforms.maxSmoothingDistance.value = this.material.uniforms.maxSmoothingDistance.value, p.uniforms.smoothingDistanceDecayFactor.value = this.material.uniforms.smoothingDistanceDecayFactor.value, p.uniforms.timeInterpolation.value = this.material.uniforms.timeInterpolation.value, p.uniforms.categorySmoothTransition.value = this.material.uniforms.categorySmoothTransition.value, p.uniforms.opacity.value = this.material.uniforms.opacity.value, p.uniforms.tex0.value = C.tile.texture, p.uniforms.tex0xy.value = C.xy, p.uniforms.tex0size.value = C.size, p.uniforms.tex1.value = A.tile.texture, p.uniforms.tex1xy.value = A.xy, p.uniforms.tex1size.value = A.size, p.uniforms.tilePixelSize.value = ($ = C.tile.texture) == null ? void 0 : $.image.width, p.uniforms.time.value = o, p.uniforms.zoomDelta.value = le, S.material = p, p.uniforms.zoom.value = l, O.set(`${M} ${z}`, {
          material: p,
          tileA: C,
          tileB: A,
          x: M,
          y: z,
          z: x
        });
      }
    }
    this.material.uniforms.localSmoothing.value && O.forEach((M) => {
      const V = M.x, z = M.y, S = M.material, H = { x: V, y: z - 1 }, N = { x: V + 1, y: z }, se = { x: V, y: z + 1 }, k = { x: V - 1, y: z }, de = `${H.x} ${H.y}`, fe = `${N.x} ${N.y}`, C = `${se.x} ${se.y}`, A = `${k.x} ${k.y}`;
      let p = O.get(de);
      p && p.tileA.tile.ready && p.tileB.tile.ready ? (S.uniforms.texN0.value = p.tileA.tile.texture, S.uniforms.texN1.value = p.tileB.tile.texture, S.uniforms.availableN.value = !0) : (S.uniforms.texN0.value = null, S.uniforms.texN1.value = null, S.uniforms.availableN.value = !1), p = O.get(fe), p && p.tileA.tile.ready && p.tileB.tile.ready ? (S.uniforms.texE0.value = p.tileA.tile.texture, S.uniforms.texE1.value = p.tileB.tile.texture, S.uniforms.availableE.value = !0) : (S.uniforms.texE0.value = null, S.uniforms.texE1.value = null, S.uniforms.availableE.value = !1), p = O.get(C), p && p.tileA.tile.ready && p.tileB.tile.ready ? (S.uniforms.texS0.value = p.tileA.tile.texture, S.uniforms.texS1.value = p.tileB.tile.texture, S.uniforms.availableS.value = !0) : (S.uniforms.texS0.value = null, S.uniforms.texS1.value = null, S.uniforms.availableS.value = !1), p = O.get(A), p && p.tileA.tile.ready && p.tileB.tile.ready ? (S.uniforms.texW0.value = p.tileA.tile.texture, S.uniforms.texW1.value = p.tileB.tile.texture, S.uniforms.availableW.value = !0) : (S.uniforms.texW0.value = null, S.uniforms.texW1.value = null, S.uniforms.availableW.value = !1);
    }), setTimeout(() => {
      r.expireCache(h), a.expireCache(h);
      const M = this.getNextFrame(t, 1);
      M && M.data && Object.keys(h).forEach((V) => {
        M.data.getTile(V, !0);
      });
    }, 0);
  }
  /**
   * This method is called from CustomLayerInterface before rendering.
   * This is used to apply the map matrix to the local camera
   * to te
   * @param _gl
   * @param matrix
   */
  prerender(e, t) {
    if (!this.isReady)
      return;
    this.animationTick();
    const o = new v.Matrix4().fromArray(t), r = new v.Matrix4().makeTranslation(0, 0, 0).scale(new v.Vector3(1, -1, 1));
    this.camera.projectionMatrix = o.multiply(r), this.updateSlippyTiles(), this.prerenderInternal();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  prerenderInternal() {
  }
  /**
   * This method is called from CustomLayerInterface and is used to render the local tiles
   * into the MapTiler SDK context
   * @param _gl
   * @param _matrix
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e, t) {
    if (!this.isReady)
      return;
    const o = this.getRendererOrThrow();
    o.state.reset(), this.renderInternal(), o.render(this.scene, this.camera), (this.getAnimationSpeed() > 0 || this.repaintOnPausedAnimation) && this.forceRepaint();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  renderInternal() {
  }
  /**
   * Get layer image decoded value (decoded means on the real world interval such as provided [decode.min, decode.max])
   * @param lng
   * @param lat
   * @param source
   * @returns
   */
  pickFrame(e, t, o) {
    var f;
    if (!this.isReady)
      return null;
    const r = Ne(e, t);
    if (!this.map)
      return null;
    const a = Math.min(~~((f = this.map) == null ? void 0 : f.getZoom()), this.tilegrid.getMaxZoom()), l = Math.pow(2, a), c = (0.5 + r[0]) % 1 * l, h = (1 - (r[1] + 0.5)) * l, m = this.getTilePlacement(
      o,
      !0,
      a,
      Math.floor(c),
      Math.floor(h)
    );
    if (m == null || m.tile.texture == null)
      return null;
    if (this.coloringFragments) {
      const x = ut(
        m.tile.texture.image,
        m.xy[0] + m.size * (c % 1),
        1 - m.xy[1] - m.size + m.size * (h % 1)
      );
      return this.coloringFragments.map((g) => g.decodeChannel(x)).flat();
    } else if (this.multiChannelColoringFragment) {
      const x = ct(
        m.tile.texture.image,
        m.xy[0] + m.size * (c % 1),
        1 - m.xy[1] - m.size + m.size * (h % 1)
      );
      return this.multiChannelColoringFragment.decodeChannel(x);
    }
    return null;
  }
  /**
   * Picks the best currently available values at the position.
   *
   * The values are read from the already loaded tiles at the current time.
   *
   * Return the interpolated array of decoded values
   * of the same length as the number of specified coloring fragments.
   *
   * If the coloring fragments uses more channels (e.g. "rg"),
   * the corresponding value is an array of `[r value, g value, sqrt(r^2 + g^2)]`.
   *
   * @param lng
   * @param lat
   * @returns Array of decoded interpolated values.
   */
  pick(e, t) {
    if (!this.isReady)
      return null;
    const { frameA: o, frameB: r, mix: a } = this.getCurrentFrames();
    if (!o || !r)
      return null;
    const l = this.pickFrame(e, t, o.data), c = this.pickFrame(e, t, r.data);
    return l ? c ? this.coloringFragments ? l.map((h, m) => {
      const f = c[m];
      return Array.isArray(h) && Array.isArray(f) ? h.map((x, g) => {
        const T = f[g];
        return x * (1 - a) + T * a;
      }) : h * (1 - a) + f * a;
    }).flat() : this.multiChannelColoringFragment ? this.timeInterpolation ? [
      l[0] * (1 - a) + c[0] * a,
      // value
      a < 0.5 ? l[1] : c[1]
      // category
    ] : [
      a < 0.5 ? l[0] : c[0],
      // value
      a < 0.5 ? l[1] : c[1]
      // category
    ] : null : l : c;
  }
  forceRepaint() {
    try {
      this.getMapOrThrow().triggerRepaint();
    } catch {
    }
  }
  /**
   * Get the current mixed image as a ImageData, meaning with pixel data, width, height and number of channels
   * @param options.zxy The tile ID
   * @param options.blurKernel Size of the bluring kernel
   * @param options.outputSize Size of the outpout image (-1 means same as input). Note that the bluring is applied on an image of this size.
   * @returns
   */
  computeCurrentMixedImage({
    zxy: e = "0/0/0",
    blurKernel: t = 0,
    outputSize: o = -1,
    channel: r = "r"
  }) {
    var B, le, X, O;
    if (!this.isReady)
      return null;
    const a = this.getCurrentFrames(), l = a.mix, c = (le = (B = a.frameA) == null ? void 0 : B.data.getTile(e, !1)) == null ? void 0 : le.texture, h = (O = (X = a.frameB) == null ? void 0 : X.data.getTile(e, !1)) == null ? void 0 : O.texture, m = o < 0 ? parseInt(c == null ? void 0 : c.image.width) : o, f = o < 0 ? parseInt(c == null ? void 0 : c.image.height) : o;
    this.bluringNodePasses.length || this.bluringNodePasses.push(
      new Pe(m, f),
      new Pe(m, f),
      new Pe(m, f)
    );
    const x = this.bluringNodePasses[0], g = this.bluringNodePasses[1], T = this.bluringNodePasses[2];
    if (x.setSize(m, f), g.setSize(m, f), g.setSize(m, f), x.setFragmentShader(pt), x.setDefine("CHANNEL", r), x.setUniform("imageA", c), x.setUniform("imageB", h), x.setUniform("mixValue", l), x.process(), t === 0) {
      const $ = x.getPixelData();
      return {
        data: $,
        channels: $.length / (m * f),
        width: m,
        height: f
      };
    }
    if (![5, 9, 13, 19].includes(t))
      throw new Error(
        `The kernel bluring kernel size ${t} is not available.`
      );
    g.setUniform("direction", new v.Vector2(1, 0)), g.setUniform("kernelSize", t), g.setUniform(
      "imgToBlur",
      x.getOutputTexture()
    ), g.setFragmentShader(_e), g.process(), T.setUniform("direction", new v.Vector2(0, 1)), T.setUniform("kernelSize", t), T.setUniform(
      "imgToBlur",
      g.getOutputTexture()
    ), T.setFragmentShader(_e), T.process();
    const L = T.getPixelData();
    return this.bluringNodePasses.forEach(($) => {
      $.dispose();
    }), {
      data: L,
      channels: L.length / (m * f),
      width: m,
      height: f
    };
  }
  /**
   * Enables data interpolation between keyframes when true. Only shows keyframe data when false.
   * @param ti
   */
  setTimeInterpolation(e) {
    this.isReady && (this.material.uniforms.timeInterpolation.value = e);
  }
  /**
   * Enable smoothing category color when true. Hard edge between categories when false.
   * This seeting applies only to TileLayers using MultiChannelGradientColoringFragment
   * as the other types of oloring fragment do not use categories.
   * @param cst
   */
  setCategorySmoothTransition(e) {
    this.isReady && (this.material.uniforms.categorySmoothTransition.value = e, this.forceRepaint());
  }
  /**
   * If `true`, enables the local smoothing
   * @param s
   */
  setLocalSmoothing(e) {
    this.material.uniforms.localSmoothing.value = e, this.forceRepaint();
  }
  /**
   * Defines the size of the smoothing kernel
   * @param d
   */
  setMaxSmoothingDistance(e) {
    this.material.uniforms.maxSmoothingDistance.value = e, this.forceRepaint();
  }
  /**
   * Defines by what factor the smoothing kernel size is reduced with increasing zoom level
   * @param f
   */
  setSmoothingDistanceDecayFactor(e) {
    this.material.uniforms.smoothingDistanceDecayFactor.value = e, this.forceRepaint();
  }
  /**
   * Get whether or not the frames continues to rendered on a paused animation
   * @returns
   */
  getRepaintOnPausedAnimation() {
    return this.repaintOnPausedAnimation;
  }
  /**
   * If `true`, even the paused animation is rendered up to 60 times
   * per seconds. If `false`, the rendering is paused when the animation is paused.
   * Pausing the animation has side effects:
   * - it lowers energy consumtion
   * - it prevents overheating
   * - it pauses time-independant annimation (arrows, particles)
   * @param r
   */
  setRepaintOnPausedAnimation(e) {
    this.repaintOnPausedAnimation = e, this.forceRepaint();
  }
}
var Pt = "precision highp float;precision highp sampler2D;uniform float opacity;uniform sampler2D tex0;in vec2 coord;out vec4 fragColor;void main(){vec4 c=texture(tex0,coord);if(c.a<1.0/16.0){discard;}if(opacity<0.0001){discard;}fragColor=c;fragColor.a*=opacity;}", Rt = "precision highp float;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;in vec3 position;in vec2 uv;out vec2 coord;void main(){coord=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}", Et = "precision highp float;precision highp sampler2D;out vec4 fragColor;in float speed;void main(){vec2 uv=vec2(gl_PointCoord.x-0.5,1.0-gl_PointCoord.y-0.5);float dFromCenter=sqrt(uv.x*uv.x+uv.y*uv.y);if(dFromCenter>0.5){discard;return;}if(speed==0.){discard;return;}float colorFactor=min(1.0,speed/COLOR_SPEED);fragColor=mix(COLOR_A,COLOR_B,colorFactor);float opacityFactor=smoothstep(0.05,0.1,speed);fragColor.a*=opacityFactor;}", Ct = `#version 300 es
precision highp float;uniform sampler2D rttTexture;uniform sampler2D rttTexturePrev;uniform float rttSize;uniform float screenSize;uniform float extrapolationFactor;uniform float renderStepSize;out float speed;vec4 advance(float position_){if(position_>(DENSITY/1000.0)*screenSize*screenSize){speed=0.0;return vec4(0.0);}float x=fract(position_/rttSize);float y=floor(position_/rttSize)/rttSize;vec4 color=texture(rttTexture,vec2(x,y));vec2 pos=color.ba+color.rg/255.0;vec4 colorPrev=texture(rttTexturePrev,vec2(x,y));vec2 posPrev=colorPrev.ba+colorPrev.rg/255.0;vec2 diff=pos-posPrev;pos+=diff*extrapolationFactor;speed=renderStepSize*step(0.0001,dot(posPrev,posPrev))*length(diff*screenSize);return vec4(pos,diff);}void main(){float position_=floor(position/2.0);float vertex=2.0*fract(position/2.0);vec4 posdiff=advance(position_);vec2 pos=posdiff.xy;vec2 dir=normalize(posdiff.zw);vec2 uv=(float(SIZE)/screenSize)*vec2(vertex,-vertex)*dir.yx;pos=2.0*(pos-uv)-1.0;gl_Position=vec4(pos.x,-pos.y,0.,1.);}`, It = "precision highp float;precision highp sampler2D;in float position;uniform sampler2D rttTexture;uniform sampler2D rttTexturePrev;uniform float rttSize;uniform float screenSize;uniform float extrapolationFactor;uniform float renderStepSize;uniform bool fastIsLarger;out float speed;float factor=1.;vec4 advance(float position_){if(position_>(DENSITY/1000.0)*screenSize*screenSize){speed=0.0;return vec4(0.0);}float x=fract(position_/rttSize);float y=floor(position_/rttSize)/rttSize;vec4 color=texture(rttTexture,vec2(x,y));vec2 pos=color.ba+color.rg/255.0;vec4 colorPrev=texture(rttTexturePrev,vec2(x,y));vec2 posPrev=colorPrev.ba+colorPrev.rg/255.0;vec2 diff=pos-posPrev;pos+=diff*extrapolationFactor;speed=renderStepSize*step(0.0001,dot(posPrev,posPrev))*length(diff*screenSize);return vec4(pos,diff);}void main(){vec4 posdiff=advance(position);gl_PointSize=fastIsLarger ?(SIZE+SIZE*log(speed+1.))/2. : SIZE;gl_Position=vec4(2.0*posdiff.x-1.0,-(2.0*posdiff.y-1.0),0.,1.);}", Mt = `precision highp float;precision highp sampler2D;
#define M_PI 3.14159265358
uniform float tileScale;uniform vec2 tilePosition;uniform vec2 tex0xy;uniform vec2 tex1xy;uniform float tex0size;uniform float tex1size;uniform bool useAlphaAsMask;uniform sampler2D rttTexture;uniform vec2 rttXY;uniform float rttScale;uniform float time;uniform sampler2D tex0;uniform sampler2D tex1;uniform float timestep;uniform float canvasDiagonal;uniform float angleDirectionShiftSkip;uniform bool uniformSpeed;uniform float tileGridPass;in vec2 rttCoord;out vec4 fragColor;float modI(float a,float b){float m=a-floor((a+0.5)/b)*b;return floor(m+0.5);}void main(){vec4 color=texture(rttTexture,rttCoord);if(tileGridPass==0.&&modI(floor(color.r*255.),2.)==0.){fragColor=color;return;}if(tileGridPass==1.&&modI(floor(color.r*255.),2.)!=0.){fragColor=color;return;}vec2 pos=color.ba+color.rg/255.0;vec2 posInTile=(rttXY+rttScale*pos)/tileScale-tilePosition;float uniformSpeedFactor=uniformSpeed ?(4000./canvasDiagonal): 1.;if(posInTile.x>=0.&&posInTile.x<=1.&&posInTile.y>=0.&&posInTile.y<=1.){posInTile.y=1.0-posInTile.y;vec2 tex0coord=tex0xy+posInTile*tex0size;vec2 tex1coord=tex1xy+posInTile*tex1size;vec4 tex0Color=texture(tex0,tex0coord);vec4 tex1Color=texture(tex1,tex1coord);if(useAlphaAsMask&&(tex0Color.a<1.||tex1Color.a<1.)){fragColor=color;return;}vec2 uv;bool skipRendering=false;if(D_WAVES){vec2 value0=tex0Color.D_CHANNELS;vec2 value1=tex1Color.D_CHANNELS;float dir0=2.0*M_PI*(-value0.x-0.25);float dir1=2.0*M_PI*(-value1.x-0.25);float speed=sqrt(1.0/mix(value0.y,value1.y,time));uv=vec2(mix(cos(dir0),cos(dir1),time),mix(sin(dir0),sin(dir1),time))*(D_MIN+(D_MAX-D_MIN)*speed);}else{vec4 lookup=mix(tex0Color,tex1Color,time);vec2 value=lookup.D_CHANNELS;uv=D_MIN+(D_MAX-D_MIN)*value;if(angleDirectionShiftSkip<89.999){vec2 offset=vec2(uv.x,-uv.y)*timestep*uniformSpeedFactor;vec2 nextPos=pos+offset;vec2 posNextInTile=(rttXY+rttScale*nextPos)/tileScale-tilePosition;posNextInTile.y=1.0-posNextInTile.y;vec2 tex0coordNext=tex0xy+posNextInTile*tex0size;vec2 tex1coordNext=tex1xy+posNextInTile*tex1size;vec4 tex0ColorNext=texture(tex0,tex0coordNext);vec4 tex1ColorNext=texture(tex1,tex1coordNext);vec4 lookupNext=mix(tex0ColorNext,tex1ColorNext,time);vec2 valueNext=lookupNext.D_CHANNELS;vec2 uvNext=D_MIN+(D_MAX-D_MIN)*valueNext;skipRendering=dot(normalize(uv),normalize(uvNext))<cos(angleDirectionShiftSkip*M_PI/180.);}}vec2 offset=vec2(uv.x,-uv.y)*timestep*uniformSpeedFactor;if(skipRendering){offset=vec2(0.,0.);}vec2 newPos=pos+offset;fragColor=vec4(fract(newPos*255.0),floor(newPos*255.0)/255.0);float red255=floor(fragColor.r*255.);if(tileGridPass==0.){if(modI(red255,2.)!=0.){red255-=1.;}}else{if(modI(red255,2.)==0.){red255+=1.;}}fragColor.r=red255/255.;}else{fragColor=color;}}`, At = "precision highp float;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;in vec3 position;in vec2 uv;out vec2 rttCoord;void main(){rttCoord=uv;gl_Position=projectionMatrix*vec4(position,1.);}";
class Dt extends ae {
  /**
   * @param id Unique identifier of the layer in the map.
   * @param options
   * @param particleOptions
   * @param coloringFragments If not null, the same data will also be displayed as raster.
   */
  constructor(e, t, o, r) {
    super(e, null, null);
    n(this, "rttScene", new v.Scene());
    n(this, "rttCamera");
    n(this, "rttMaterial");
    n(this, "rttMesh");
    n(this, "particleTexturePrev");
    n(this, "particleTexture0");
    n(this, "particleTexture1");
    n(this, "particleMaterial");
    n(this, "particles");
    n(this, "particleBackground");
    n(this, "accumulator");
    n(this, "accumulatorDrawMesh");
    n(this, "flipFlop", !1);
    n(this, "numParticles");
    n(this, "particleDensity");
    n(this, "refreshInterval");
    n(this, "fadeFactor");
    n(this, "particleColor");
    n(this, "particleFastColor");
    n(this, "particleFastSpeed");
    n(this, "particleSize");
    n(this, "drawAsLines");
    n(this, "particleSpeed");
    n(this, "pixelRatio");
    n(this, "prevRenderTime", 0);
    n(this, "lastRenderTime", 0);
    n(this, "forceRender", !0);
    n(this, "rttTimestep", 200);
    n(this, "tileGridPass", 0);
    t && o && this.initParticle(t, o, r);
  }
  initParticle(e, t, o) {
    if (this.init(e, o, null), this.extentScale = 1.2, this.numParticles = 128, t.maxAmount != null)
      if (t.maxAmount >= 4 && t.maxAmount && !(t.maxAmount & t.maxAmount - 1))
        this.numParticles = t.maxAmount;
      else
        throw new Error(
          "The number of particles needs to be power of two and at least 4"
        );
    const r = window.devicePixelRatio;
    this.particleDensity = t.density ?? 2, this.particleDensity /= r * r, this.refreshInterval = t.refreshInterval ?? 800, this.fadeFactor = t.fadeFactor ?? 0.1, this.particleColor = K(
      t.color ?? [255, 255, 255, 192]
    ), this.particleFastColor = t.fastColor ? K(t.fastColor) : this.particleColor, this.particleFastSpeed = (t.fastSpeed ?? 2) * r, this.particleSize = t.size ?? 1.5, this.drawAsLines = t.drawAsLines ?? !1, this.particleSpeed = (t.speed ?? 1e-3) / 1e3, this.pixelRatio = t.pixelRatio ?? (r > 1 ? 1 : 2), this.particleTexturePrev = this.generateRandomizeParticleTexture(
      this.numParticles,
      this.numParticles
    ), this.particleTexture0 = new v.WebGLRenderTarget(
      this.numParticles,
      this.numParticles,
      {
        stencilBuffer: !1,
        depthBuffer: !1
      }
    ), this.particleTexture0.texture = this.particleTexturePrev.clone(), this.particleTexture1 = this.particleTexture0.clone(), this.rttMaterial = new v.RawShaderMaterial({
      glslVersion: v.GLSL3,
      uniforms: {
        tileGridPass: { value: this.tileGridPass },
        uniformSpeed: { value: t.uniformSpeed ?? !1 },
        canvasDiagonal: { value: 0 },
        angleDirectionShiftSkip: {
          value: t.angleDirectionShiftSkip ?? 90
        },
        rttXY: { value: [0, 0] },
        rttScale: { value: 1 },
        rttTexture: {
          value: this.particleTexture0.texture
        },
        tileScale: { value: 0 },
        useAlphaAsMask: { value: t.useAlphaAsMask ?? !1 },
        tilePosition: { value: [0, 0] },
        time: { value: 0 },
        timestep: { value: 0 },
        tex0xy: { value: [0, 0] },
        tex1xy: { value: [0, 0] },
        tex0size: { value: 1 },
        tex1size: { value: 1 },
        tex0: {
          value: null
        },
        tex1: {
          value: null
        }
      },
      vertexShader: At,
      fragmentShader: Mt,
      defines: {
        D_MIN: (t.decodeMin ?? 0).toFixed(2),
        D_MAX: (t.decodeMax ?? 1).toFixed(2),
        D_CHANNELS: t.decodeChannels ?? "rg",
        D_WAVES: t.decodeAsWaves ? "true" : "false"
      },
      depthTest: !1,
      depthWrite: !1
    }), this.rttCamera = new v.OrthographicCamera(
      -this.numParticles / 2,
      this.numParticles / 2,
      this.numParticles / 2,
      -this.numParticles / 2,
      -100,
      100
    ), this.rttMesh = new v.Mesh(
      new v.PlaneGeometry(this.numParticles, this.numParticles),
      this.rttMaterial
    ), this.rttScene.add(this.rttMesh), this.accumulator = new v.WebGLRenderTarget(16, 16, {
      minFilter: v.LinearFilter,
      magFilter: v.LinearFilter,
      stencilBuffer: !1,
      format: v.RGBAFormat,
      depthBuffer: !1
    }), this.particleBackground = new v.Mesh(
      new v.PlaneGeometry(2, 2),
      new v.RawShaderMaterial({
        glslVersion: v.GLSL3,
        transparent: !0,
        blending: v.CustomBlending,
        blendEquationAlpha: v.ReverseSubtractEquation,
        vertexShader: "precision highp float;in vec3 position;void main(){gl_Position=vec4(position,1.);}",
        fragmentShader: `precision highp float;out vec4 fragColor;void main(){fragColor=vec4(.0,.0,.0,${this.fadeFactor.toFixed(
          2
        )});}`
      })
    );
    const a = r * this.pixelRatio * this.particleSize, l = r * this.particleSize;
    if (this.particleMaterial = new v.RawShaderMaterial({
      glslVersion: v.GLSL3,
      uniforms: {
        fastIsLarger: { value: t.fastIsLarger ?? !1 },
        rttSize: { value: this.numParticles },
        rttTexture: {
          value: this.particleTexture1.texture
        },
        rttTexturePrev: {
          value: this.particleTexturePrev
        },
        screenSize: { value: 1 },
        extrapolationFactor: { value: 0 },
        renderStepSize: { value: 0 }
      },
      vertexShader: this.drawAsLines ? Ct : It,
      fragmentShader: Et,
      defines: {
        COLOR_A: this.particleColor,
        COLOR_B: this.particleFastColor,
        COLOR_SPEED: this.particleFastSpeed.toFixed(2),
        DENSITY: this.particleDensity.toFixed(2),
        SIZE: (this.drawAsLines ? l : a).toFixed(1)
      },
      transparent: !0,
      depthTest: !1,
      depthWrite: !1,
      linewidth: this.pixelRatio
      // not guaranteed to work, but try anyway
    }), this.drawAsLines) {
      const c = new Float32Array(
        Array(2 * this.numParticles * this.numParticles).keys()
      ), h = new v.BufferGeometry();
      h.setAttribute(
        "position",
        new v.Float32BufferAttribute(c, 1)
      ), this.particles = new v.LineSegments(
        h,
        this.particleMaterial
      );
    } else {
      const c = new Float32Array(
        Array(this.numParticles * this.numParticles).keys()
      ), h = new v.BufferGeometry();
      h.setAttribute(
        "position",
        new v.Float32BufferAttribute(c, 1)
      ), this.particles = new v.Points(h, this.particleMaterial);
    }
    this.particles.frustumCulled = !1, this.accumulatorDrawMesh = new v.Mesh(
      new v.PlaneGeometry(1, 1),
      new v.RawShaderMaterial({
        glslVersion: v.GLSL3,
        premultipliedAlpha: !0,
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
        uniforms: {
          opacity: { value: 1 },
          tex0: {
            value: this.accumulator.texture
          }
        },
        vertexShader: Rt,
        fragmentShader: Pt
      })
    ), this.scene.add(this.accumulatorDrawMesh), setInterval(() => {
      this.renderer && this.randomizeParticles(!1);
    }, this.refreshInterval), this.on("extentChanged", () => {
      this.refresh();
    });
  }
  onAdd(e, t) {
    super.onAdd(e, t);
  }
  generateRandomizeParticleTexture(e, t) {
    const o = new Uint8Array(4 * e * t);
    for (let r = 0; r < o.length; r++)
      o[r] = Math.floor(256 * Math.random());
    return new v.DataTexture(o, e, t);
  }
  randomizeParticles(e) {
    if (!this.renderer)
      return;
    let t = this.numParticles, o = this.numParticles;
    const r = new v.Vector2(0, 0);
    if (!e) {
      const l = this.numParticles / 4;
      t = l, o = l, r.x = Math.floor(Math.random() * this.numParticles / l) * l, r.y = Math.floor(Math.random() * this.numParticles / l) * l;
    }
    const a = this.generateRandomizeParticleTexture(t, o);
    this.renderer.copyTextureToTexture(r, a, this.particleTexturePrev), this.renderer.copyTextureToTexture(
      r,
      a,
      this.particleTexture0.texture
    ), this.renderer.copyTextureToTexture(
      r,
      a,
      this.particleTexture1.texture
    ), a.dispose(), this.forceRender = e;
  }
  /**
   * Returns the ratio between the number of actually visible particle
   * (to statisfy the specified density) and the maximum amount (maxAmount).
   *
   * Value >1 mean that more particles would be utilized if availabe.
   *
   * Useful for debugging and fine-tuning client application.
   */
  getParticleUtilization() {
    const e = this.particleMaterial.uniforms.screenSize.value;
    return this.particleDensity / 1e3 * e * e / (this.numParticles * this.numParticles);
  }
  setOpacity(e) {
    super.setOpacity(e), this.accumulatorDrawMesh.material.uniforms.opacity.value = e;
  }
  disposeObjects() {
    super.disposeObjects(), this.particleTexturePrev.dispose(), this.particleTexture0.texture.dispose(), this.particleTexture0.dispose(), this.particleTexture1.texture.dispose(), this.particleTexture1.dispose(), this.accumulator.texture.dispose(), this.accumulator.dispose(), this.rttMesh.geometry.dispose(), this.rttMesh.material.dispose(), this.particleBackground.geometry.dispose(), this.particleBackground.material.dispose(), this.particles.geometry.dispose(), this.particles.material.dispose(), this.accumulatorDrawMesh.geometry.dispose(), this.accumulatorDrawMesh.material.dispose();
  }
  onResize() {
    super.onResize();
    const e = this.getMapOrThrow().getCanvas(), t = e.width, o = e.height;
    let r = Math.round(
      this.pixelRatio * this.extentScale * Math.max(t, o)
    );
    const a = Math.sqrt(t * t + o * o) * (devicePixelRatio === 1 ? 2 : 1);
    this.rttMaterial.uniforms.canvasDiagonal.value = a, r = Math.min(
      r,
      this.getRendererOrThrow().capabilities.maxTextureSize
    ), this.accumulator.setSize(r, r), this.particleMaterial.uniforms.screenSize.value = r / this.pixelRatio, this.scene.remove(this.accumulatorDrawMesh), this.scene.add(this.accumulatorDrawMesh);
  }
  onMoveEnd() {
  }
  refresh() {
    const e = this.getVisibleExtent(this.extentScale);
    if (!e)
      throw new Error("The extent is null");
    const t = Math.max(e[2] - e[0], e[3] - e[1]) / he, o = [
      0.5 + (e[2] + e[0]) / 2 / he - t / 2,
      0.5 - (e[3] + e[1]) / 2 / he - t / 2
    ];
    this.rttMaterial.uniforms.rttScale.value = t, this.rttMaterial.uniforms.rttXY.value = o;
    const r = this.getRendererOrThrow();
    r.setRenderTarget(this.accumulator), r.setClearAlpha(0), r.clearColor(), r.setRenderTarget(null), this.randomizeParticles(!0);
  }
  prerenderInternal() {
    const e = performance.now(), t = e - this.lastRenderTime, o = this.forceRender || t > this.rttTimestep || !this.prevRenderTime;
    if (o) {
      this.forceRender = !1, this.rttMaterial.uniforms.timestep.value = this.particleSpeed * t, this.getRendererOrThrow().setRenderTarget(
        this.flipFlop ? this.particleTexture1 : this.particleTexture0
      ), this.getRendererOrThrow().copyFramebufferToTexture(
        new v.Vector2(0, 0),
        this.particleTexturePrev
      ), this.prevRenderTime = this.lastRenderTime, this.lastRenderTime = e;
      const c = this.slippyTiles.length;
      for (let h = 0; h < c; h++) {
        const m = this.slippyTiles[0].length;
        for (let f = 0; f < m; f++) {
          const x = this.slippyTiles[h][f];
          if (!x.visible)
            continue;
          const T = x.material.uniforms;
          if (!T)
            continue;
          const L = x.scale.x;
          this.rttMaterial.uniforms.tileScale.value = L, this.rttMaterial.uniforms.tilePosition.value = [
            x.position.x / L - 0.5,
            -x.position.y / L - 0.5
          ], this.rttMaterial.uniforms.tileGridPass.value = this.tileGridPass, this.rttMaterial.uniforms.time.value = T.time.value, this.rttMaterial.uniforms.tex0.value = T.tex0.value, this.rttMaterial.uniforms.tex0xy.value = T.tex0xy.value, this.rttMaterial.uniforms.tex0size.value = T.tex0size.value, this.rttMaterial.uniforms.tex1.value = T.tex1.value, this.rttMaterial.uniforms.tex1xy.value = T.tex1xy.value, this.rttMaterial.uniforms.tex1size.value = T.tex1size.value, this.rttMaterial.uniforms.rttTexture.value = (this.flipFlop ? this.particleTexture1 : this.particleTexture0).texture;
          const B = this.getRendererOrThrow();
          B.setRenderTarget(
            this.flipFlop ? this.particleTexture0 : this.particleTexture1
          ), B.render(this.rttScene, this.rttCamera), this.flipFlop = !this.flipFlop;
        }
      }
      this.particleMaterial.uniforms.rttTexture.value = (this.flipFlop ? this.particleTexture1 : this.particleTexture0).texture, this.tileGridPass = +!this.tileGridPass;
    }
    const r = this.lastRenderTime - this.prevRenderTime, a = o ? 0 : t / r;
    this.particleMaterial.uniforms.extrapolationFactor.value = a, this.particleMaterial.uniforms.renderStepSize.value = r / 1e3;
    const l = this.getRendererOrThrow();
    l.setRenderTarget(this.accumulator), l.render(this.particleBackground, this.camera), l.render(this.particles, this.camera), l.setRenderTarget(null);
  }
  renderInternal() {
    const e = this.rttMaterial.uniforms.rttScale.value;
    this.accumulatorDrawMesh.position.x = 0.5 * e + this.rttMaterial.uniforms.rttXY.value[0], this.accumulatorDrawMesh.position.y = -0.5 * e - this.rttMaterial.uniforms.rttXY.value[1], this.accumulatorDrawMesh.scale.x = this.accumulatorDrawMesh.scale.y = e;
  }
}
const u = class u extends Array {
  constructor(e = {}) {
    super();
    n(this, "min", 0);
    n(this, "max", 1);
    "min" in e && (this.min = e.min), "max" in e && (this.max = e.max), "stops" in e && this.setStops(e.stops, { clone: !1 });
  }
  /**
   * Converts a array-definition color ramp definition into a usable ColorRamp instance.
   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
   * @param cr
   * @returns
   */
  static fromArrayDefinition(e) {
    return new u({
      stops: e.map((t) => ({
        value: t[0],
        color: t[1]
      }))
    });
  }
  setStops(e, t = { clone: !0 }) {
    const o = t.clone ? this.clone() : this;
    o.length = 0;
    let r = 1 / 0, a = -1 / 0;
    for (let l = 0; l < e.length; l += 1)
      r = Math.min(r, e[l].value), a = Math.max(a, e[l].value), o.push({
        value: e[l].value,
        color: e[l].color.slice()
        // we want to make sure we do a deep copy and not a reference
      });
    return o.sort(
      (l, c) => l.value < c.value ? -1 : 1
    ), this.min = r, this.max = a, o;
  }
  scale(e, t, o = { clone: !0 }) {
    const r = o.clone, a = this[0].value, c = this.at(-1).value - a, h = t - e, m = [];
    for (let f = 0; f < this.length; f += 1) {
      const T = (this[f].value - a) / c * h + e;
      r ? m.push({
        value: T,
        color: this[f].color.slice()
      }) : this[f].value = T;
    }
    return r ? new u({ stops: m }) : this;
  }
  // for some reason, I had to reimplement this
  at(e) {
    return e < 0 ? this[this.length + e] : this[e];
  }
  clone() {
    return new u({ stops: this.getRawColorStops() });
  }
  getRawColorStops() {
    const e = [];
    for (let t = 0; t < this.length; t += 1)
      e.push(this[t]);
    return e;
  }
  reverse(e = { clone: !0 }) {
    const t = e.clone ? this.clone() : this;
    for (let o = 0; o < ~~(t.length / 2); o += 1) {
      const r = t[o].color;
      t[o].color = t.at(-(o + 1)).color, t.at(-(o + 1)).color = r;
    }
    return t;
  }
  getBounds() {
    return { min: this.min, max: this.max };
  }
  getColor(e, t = { smooth: !0 }) {
    if (e <= this[0].value)
      return this[0].color;
    if (e >= this.at(-1).value)
      return this.at(-1).color;
    for (let o = 0; o < this.length - 1; o += 1) {
      if (e > this[o + 1].value)
        continue;
      const r = this[o].color;
      if (!t.smooth)
        return r.slice();
      const a = this[o].value, l = this[o + 1].value, c = this[o + 1].color, h = (l - e) / (l - a);
      return r.map(
        (m, f) => Math.round(m * h + c[f] * (1 - h))
      );
    }
    return [0, 0, 0];
  }
  getCanvasStrip(e = {
    horizontal: !0,
    size: 512,
    smooth: !0
  }) {
    const t = document.createElement("canvas");
    t.width = e.horizontal ? e.size : 1, t.height = e.horizontal ? 1 : e.size;
    const o = t.getContext("2d");
    if (!o)
      throw new Error("Canvs context is missing");
    const r = o.getImageData(0, 0, t.width, t.height), a = r.data, l = e.size, c = this[0].value, f = (this.at(-1).value - c) / l;
    for (let x = 0; x < l; x += 1) {
      const g = this.getColor(c + x * f, {
        smooth: e.smooth
      });
      a[x * 4] = g[0], a[x * 4 + 1] = g[1], a[x * 4 + 2] = g[2], a[x * 4 + 3] = g.length > 3 ? g[3] : 255;
    }
    return o.putImageData(r, 0, 0), t;
  }
};
n(u, "builtin", {
  /**
   * A fully transparent [0, 0, 0, 0] colorramp to hide data.
   * Defined in interval [0, 1], without unit.
   */
  NULL: new u({
    stops: [
      { value: 0, color: [0, 0, 0, 0] },
      { value: 1, color: [0, 0, 0, 0] }
    ]
  }),
  /**
   * Classic jet color ramp.
   * Defined in interval [0, 1], without unit.
   */
  JET: new u({
    stops: [
      { value: 0, color: [0, 0, 131] },
      { value: 0.125, color: [0, 60, 170] },
      { value: 0.375, color: [5, 255, 255] },
      { value: 0.625, color: [255, 255, 0] },
      { value: 0.875, color: [250, 0, 0] },
      { value: 1, color: [128, 0, 0] }
    ]
  }),
  /**
   * Classic HSV color ramp (hue, saturation, value).
   * Defined in interval [0, 1], without unit.
   */
  HSV: new u({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 0.169, color: [253, 255, 2] },
      { value: 0.173, color: [247, 255, 2] },
      { value: 0.337, color: [0, 252, 4] },
      { value: 0.341, color: [0, 252, 10] },
      { value: 0.506, color: [1, 249, 255] },
      { value: 0.671, color: [2, 0, 253] },
      { value: 0.675, color: [8, 0, 253] },
      { value: 0.839, color: [255, 0, 251] },
      { value: 0.843, color: [255, 0, 245] },
      { value: 1, color: [255, 0, 6] }
    ]
  }),
  /**
   * Classic hot color ramp.
   * Defined in interval [0, 1], without unit.
   */
  HOT: new u({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.3, color: [230, 0, 0] },
      { value: 0.6, color: [255, 210, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic spring color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SPRING: new u({
    stops: [
      { value: 0, color: [255, 0, 255] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic summer color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SUMMER: new u({
    stops: [
      { value: 0, color: [0, 128, 102] },
      { value: 1, color: [255, 255, 102] }
    ]
  }),
  /**
   * Classic autommn color ramp.
   * Defined in interval [0, 1], without unit.
   */
  AUTOMN: new u({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic winter color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WINTER: new u({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [0, 255, 128] }
    ]
  }),
  /**
   * Classic bone color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BONE: new u({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.376, color: [84, 84, 116] },
      { value: 0.753, color: [169, 200, 200] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic copper color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COPPER: new u({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.804, color: [255, 160, 102] },
      { value: 1, color: [255, 199, 127] }
    ]
  }),
  /**
   * Classic greys color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREYS: new u({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic yignbu color ramp (blue to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIGNBU: new u({
    stops: [
      { value: 0, color: [8, 29, 88] },
      { value: 0.125, color: [37, 52, 148] },
      { value: 0.25, color: [34, 94, 168] },
      { value: 0.375, color: [29, 145, 192] },
      { value: 0.5, color: [65, 182, 196] },
      { value: 0.625, color: [127, 205, 187] },
      { value: 0.75, color: [199, 233, 180] },
      { value: 0.875, color: [237, 248, 217] },
      { value: 1, color: [255, 255, 217] }
    ]
  }),
  /**
   * Classic greens color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREENS: new u({
    stops: [
      { value: 0, color: [0, 68, 27] },
      { value: 0.125, color: [0, 109, 44] },
      { value: 0.25, color: [35, 139, 69] },
      { value: 0.375, color: [65, 171, 93] },
      { value: 0.5, color: [116, 196, 118] },
      { value: 0.625, color: [161, 217, 155] },
      { value: 0.75, color: [199, 233, 192] },
      { value: 0.875, color: [229, 245, 224] },
      { value: 1, color: [247, 252, 245] }
    ]
  }),
  /**
   * Classic yiorrd color ramp (red to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIORRD: new u({
    stops: [
      { value: 0, color: [128, 0, 38] },
      { value: 0.125, color: [189, 0, 38] },
      { value: 0.25, color: [227, 26, 28] },
      { value: 0.375, color: [252, 78, 42] },
      { value: 0.5, color: [253, 141, 60] },
      { value: 0.625, color: [254, 178, 76] },
      { value: 0.75, color: [254, 217, 118] },
      { value: 0.875, color: [255, 237, 160] },
      { value: 1, color: [255, 255, 204] }
    ]
  }),
  /**
   * Classic blue-red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLUERED: new u({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rdbu color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RDBU: new u({
    stops: [
      { value: 0, color: [5, 10, 172] },
      { value: 0.35, color: [106, 137, 247] },
      { value: 0.5, color: [190, 190, 190] },
      { value: 0.6, color: [220, 170, 132] },
      { value: 0.7, color: [230, 145, 90] },
      { value: 1, color: [178, 10, 28] }
    ]
  }),
  /**
   * Classic picnic color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PICNIC: new u({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 0.1, color: [51, 153, 255] },
      { value: 0.2, color: [102, 204, 255] },
      { value: 0.3, color: [153, 204, 255] },
      { value: 0.4, color: [204, 204, 255] },
      { value: 0.5, color: [255, 255, 255] },
      { value: 0.6, color: [255, 204, 255] },
      { value: 0.7, color: [255, 153, 255] },
      { value: 0.8, color: [255, 102, 204] },
      { value: 0.9, color: [255, 102, 102] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rainbow color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW: new u({
    stops: [
      { value: 0, color: [150, 0, 90] },
      { value: 0.125, color: [0, 0, 200] },
      { value: 0.25, color: [0, 25, 255] },
      { value: 0.375, color: [0, 152, 255] },
      { value: 0.5, color: [44, 255, 150] },
      { value: 0.625, color: [151, 255, 0] },
      { value: 0.75, color: [255, 234, 0] },
      { value: 0.875, color: [255, 111, 0] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic Portland color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PORTLAND: new u({
    stops: [
      { value: 0, color: [12, 51, 131] },
      { value: 0.25, color: [10, 136, 186] },
      { value: 0.5, color: [242, 211, 56] },
      { value: 0.75, color: [242, 143, 56] },
      { value: 1, color: [217, 30, 30] }
    ]
  }),
  /**
   * Classic blackbody color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLACKBODY: new u({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.2, color: [230, 0, 0] },
      { value: 0.4, color: [230, 210, 0] },
      { value: 0.7, color: [255, 255, 255] },
      { value: 1, color: [160, 200, 255] }
    ]
  }),
  /**
   * Classic earth color ramp.
   * Defined in interval [0, 1], without unit.
   */
  EARTH: new u({
    stops: [
      { value: 0, color: [0, 0, 130] },
      { value: 0.1, color: [0, 180, 180] },
      { value: 0.2, color: [40, 210, 40] },
      { value: 0.4, color: [230, 230, 50] },
      { value: 0.6, color: [120, 70, 20] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic electric color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ELECTRIC: new u({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.15, color: [30, 0, 100] },
      { value: 0.4, color: [120, 0, 100] },
      { value: 0.6, color: [160, 90, 0] },
      { value: 0.8, color: [230, 200, 0] },
      { value: 1, color: [255, 250, 220] }
    ]
  }),
  /**
   * Classic viridis color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VIRIDIS: new u({
    stops: [
      { value: 0, color: [68, 1, 84] },
      { value: 0.13, color: [71, 44, 122] },
      { value: 0.25, color: [59, 81, 139] },
      { value: 0.38, color: [44, 113, 142] },
      { value: 0.5, color: [33, 144, 141] },
      { value: 0.63, color: [39, 173, 129] },
      { value: 0.75, color: [92, 200, 99] },
      { value: 0.88, color: [170, 220, 50] },
      { value: 1, color: [253, 231, 37] }
    ]
  }),
  /**
   * Classic inferno color ramp.
   * Defined in interval [0, 1], without unit.
   */
  INFERNO: new u({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [31, 12, 72] },
      { value: 0.25, color: [85, 15, 109] },
      { value: 0.38, color: [136, 34, 106] },
      { value: 0.5, color: [186, 54, 85] },
      { value: 0.63, color: [227, 89, 51] },
      { value: 0.75, color: [249, 140, 10] },
      { value: 0.88, color: [249, 201, 50] },
      { value: 1, color: [252, 255, 164] }
    ]
  }),
  /**
   * Classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  MAGMA: new u({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [28, 16, 68] },
      { value: 0.25, color: [79, 18, 123] },
      { value: 0.38, color: [129, 37, 129] },
      { value: 0.5, color: [181, 54, 122] },
      { value: 0.63, color: [229, 80, 100] },
      { value: 0.75, color: [251, 135, 97] },
      { value: 0.88, color: [254, 194, 135] },
      { value: 1, color: [252, 253, 191] }
    ]
  }),
  /**
   * Classic plasma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PLASMA: new u({
    stops: [
      { value: 0, color: [13, 8, 135] },
      { value: 0.13, color: [75, 3, 161] },
      { value: 0.25, color: [125, 3, 168] },
      { value: 0.38, color: [168, 34, 150] },
      { value: 0.5, color: [203, 70, 121] },
      { value: 0.63, color: [229, 107, 93] },
      { value: 0.75, color: [248, 148, 65] },
      { value: 0.88, color: [253, 195, 40] },
      { value: 1, color: [240, 249, 33] }
    ]
  }),
  /**
   * Classic warm color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WARM: new u({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [172, 0, 187] },
      { value: 0.25, color: [219, 0, 170] },
      { value: 0.38, color: [255, 0, 130] },
      { value: 0.5, color: [255, 63, 74] },
      { value: 0.63, color: [255, 123, 0] },
      { value: 0.75, color: [234, 176, 0] },
      { value: 0.88, color: [190, 228, 0] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic cool color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COOL: new u({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [116, 0, 218] },
      { value: 0.25, color: [98, 74, 237] },
      { value: 0.38, color: [68, 146, 231] },
      { value: 0.5, color: [0, 204, 197] },
      { value: 0.63, color: [0, 247, 146] },
      { value: 0.75, color: [0, 255, 88] },
      { value: 0.88, color: [40, 255, 8] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic rainboz soft color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW_SOFT: new u({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.1, color: [199, 0, 180] },
      { value: 0.2, color: [255, 0, 121] },
      { value: 0.3, color: [255, 108, 0] },
      { value: 0.4, color: [222, 194, 0] },
      { value: 0.5, color: [150, 255, 0] },
      { value: 0.6, color: [0, 255, 55] },
      { value: 0.7, color: [0, 246, 150] },
      { value: 0.8, color: [50, 167, 222] },
      { value: 0.9, color: [103, 51, 235] },
      { value: 1, color: [124, 0, 186] }
    ]
  }),
  /**
   * Classic bathymetry color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BATHYMETRY: new u({
    stops: [
      { value: 0, color: [40, 26, 44] },
      { value: 0.13, color: [59, 49, 90] },
      { value: 0.25, color: [64, 76, 139] },
      { value: 0.38, color: [63, 110, 151] },
      { value: 0.5, color: [72, 142, 158] },
      { value: 0.63, color: [85, 174, 163] },
      { value: 0.75, color: [120, 206, 163] },
      { value: 0.88, color: [187, 230, 172] },
      { value: 1, color: [253, 254, 204] }
    ]
  }),
  /**
   * Classic cdom color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CDOM: new u({
    stops: [
      { value: 0, color: [47, 15, 62] },
      { value: 0.13, color: [87, 23, 86] },
      { value: 0.25, color: [130, 28, 99] },
      { value: 0.38, color: [171, 41, 96] },
      { value: 0.5, color: [206, 67, 86] },
      { value: 0.63, color: [230, 106, 84] },
      { value: 0.75, color: [242, 149, 103] },
      { value: 0.88, color: [249, 193, 135] },
      { value: 1, color: [254, 237, 176] }
    ]
  }),
  /**
   * Classic chlorophyll color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CHLOROPHYLL: new u({
    stops: [
      { value: 0, color: [18, 36, 20] },
      { value: 0.13, color: [25, 63, 41] },
      { value: 0.25, color: [24, 91, 59] },
      { value: 0.38, color: [13, 119, 72] },
      { value: 0.5, color: [18, 148, 80] },
      { value: 0.63, color: [80, 173, 89] },
      { value: 0.75, color: [132, 196, 122] },
      { value: 0.88, color: [175, 221, 162] },
      { value: 1, color: [215, 249, 208] }
    ]
  }),
  /**
   * Classic density color ramp.
   * Defined in interval [0, 1], without unit.
   */
  DENSITY: new u({
    stops: [
      { value: 0, color: [54, 14, 36] },
      { value: 0.13, color: [89, 23, 80] },
      { value: 0.25, color: [110, 45, 132] },
      { value: 0.38, color: [120, 77, 178] },
      { value: 0.5, color: [120, 113, 213] },
      { value: 0.63, color: [115, 151, 228] },
      { value: 0.75, color: [134, 185, 227] },
      { value: 0.88, color: [177, 214, 227] },
      { value: 1, color: [230, 241, 241] }
    ]
  }),
  /**
   * Classic freesurface blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_BLUE: new u({
    stops: [
      { value: 0, color: [30, 4, 110] },
      { value: 0.13, color: [47, 14, 176] },
      { value: 0.25, color: [41, 45, 236] },
      { value: 0.38, color: [25, 99, 212] },
      { value: 0.5, color: [68, 131, 200] },
      { value: 0.63, color: [114, 156, 197] },
      { value: 0.75, color: [157, 181, 203] },
      { value: 0.88, color: [200, 208, 216] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic freesurface red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_RED: new u({
    stops: [
      { value: 0, color: [60, 9, 18] },
      { value: 0.13, color: [100, 17, 27] },
      { value: 0.25, color: [142, 20, 29] },
      { value: 0.38, color: [177, 43, 27] },
      { value: 0.5, color: [192, 87, 63] },
      { value: 0.63, color: [205, 125, 105] },
      { value: 0.75, color: [216, 162, 148] },
      { value: 0.88, color: [227, 199, 193] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic oxygen color ramp.
   * Defined in interval [0, 1], without unit.
   */
  OXYGEN: new u({
    stops: [
      { value: 0, color: [64, 5, 5] },
      { value: 0.13, color: [106, 6, 15] },
      { value: 0.25, color: [144, 26, 7] },
      { value: 0.38, color: [168, 64, 3] },
      { value: 0.5, color: [188, 100, 4] },
      { value: 0.63, color: [206, 136, 11] },
      { value: 0.75, color: [220, 174, 25] },
      { value: 0.88, color: [231, 215, 44] },
      { value: 1, color: [248, 254, 105] }
    ]
  }),
  /**
   * Classic par color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PAR: new u({
    stops: [
      { value: 0, color: [51, 20, 24] },
      { value: 0.13, color: [90, 32, 35] },
      { value: 0.25, color: [129, 44, 34] },
      { value: 0.38, color: [159, 68, 25] },
      { value: 0.5, color: [182, 99, 19] },
      { value: 0.63, color: [199, 134, 22] },
      { value: 0.75, color: [212, 171, 35] },
      { value: 0.88, color: [221, 210, 54] },
      { value: 1, color: [225, 253, 75] }
    ]
  }),
  /**
   * Classic phase color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PHASE: new u({
    stops: [
      { value: 0, color: [145, 105, 18] },
      { value: 0.13, color: [184, 71, 38] },
      { value: 0.25, color: [186, 58, 115] },
      { value: 0.38, color: [160, 71, 185] },
      { value: 0.5, color: [110, 97, 218] },
      { value: 0.63, color: [50, 123, 164] },
      { value: 0.75, color: [31, 131, 110] },
      { value: 0.88, color: [77, 129, 34] },
      { value: 1, color: [145, 105, 18] }
    ]
  }),
  /**
   * Classic salinity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SALINITY: new u({
    stops: [
      { value: 0, color: [42, 24, 108] },
      { value: 0.13, color: [33, 50, 162] },
      { value: 0.25, color: [15, 90, 145] },
      { value: 0.38, color: [40, 118, 137] },
      { value: 0.5, color: [59, 146, 135] },
      { value: 0.63, color: [79, 175, 126] },
      { value: 0.75, color: [120, 203, 104] },
      { value: 0.88, color: [193, 221, 100] },
      { value: 1, color: [253, 239, 154] }
    ]
  }),
  /**
   * Classic temperature color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TEMPERATURE: new u({
    stops: [
      { value: 0, color: [4, 35, 51] },
      { value: 0.13, color: [23, 51, 122] },
      { value: 0.25, color: [85, 59, 157] },
      { value: 0.38, color: [129, 79, 143] },
      { value: 0.5, color: [175, 95, 130] },
      { value: 0.63, color: [222, 112, 101] },
      { value: 0.75, color: [249, 146, 66] },
      { value: 0.88, color: [249, 196, 65] },
      { value: 1, color: [232, 250, 91] }
    ]
  }),
  /**
   * Classic turbidity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TURBIDITY: new u({
    stops: [
      { value: 0, color: [34, 31, 27] },
      { value: 0.13, color: [65, 50, 41] },
      { value: 0.25, color: [98, 69, 52] },
      { value: 0.38, color: [131, 89, 57] },
      { value: 0.5, color: [161, 112, 59] },
      { value: 0.63, color: [185, 140, 66] },
      { value: 0.75, color: [202, 174, 88] },
      { value: 0.88, color: [216, 209, 126] },
      { value: 1, color: [233, 246, 171] }
    ]
  }),
  /**
   * Classic velocity blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_BLUE: new u({
    stops: [
      { value: 0, color: [17, 32, 64] },
      { value: 0.13, color: [35, 52, 116] },
      { value: 0.25, color: [29, 81, 156] },
      { value: 0.38, color: [31, 113, 162] },
      { value: 0.5, color: [50, 144, 169] },
      { value: 0.63, color: [87, 173, 176] },
      { value: 0.75, color: [149, 196, 189] },
      { value: 0.88, color: [203, 221, 211] },
      { value: 1, color: [254, 251, 230] }
    ]
  }),
  /**
   * Classic velocity green color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_GREEN: new u({
    stops: [
      { value: 0, color: [23, 35, 19] },
      { value: 0.13, color: [24, 64, 38] },
      { value: 0.25, color: [11, 95, 45] },
      { value: 0.38, color: [39, 123, 35] },
      { value: 0.5, color: [95, 146, 12] },
      { value: 0.63, color: [152, 165, 18] },
      { value: 0.75, color: [201, 186, 69] },
      { value: 0.88, color: [233, 216, 137] },
      { value: 1, color: [255, 253, 205] }
    ]
  }),
  /**
   * Classic cube helix color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CUBEHELIX: new u({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.07, color: [22, 5, 59] },
      { value: 0.13, color: [60, 4, 105] },
      { value: 0.2, color: [109, 1, 135] },
      { value: 0.27, color: [161, 0, 147] },
      { value: 0.33, color: [210, 2, 142] },
      { value: 0.4, color: [251, 11, 123] },
      { value: 0.47, color: [255, 29, 97] },
      { value: 0.53, color: [255, 54, 69] },
      { value: 0.6, color: [255, 85, 46] },
      { value: 0.67, color: [255, 120, 34] },
      { value: 0.73, color: [255, 157, 37] },
      { value: 0.8, color: [241, 191, 57] },
      { value: 0.87, color: [224, 220, 93] },
      { value: 0.93, color: [218, 241, 142] },
      { value: 1, color: [227, 253, 198] }
    ]
  }),
  /**
   * The cividis color ramp is color blind friendly.
   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239
   * Defined in interval [0, 1], without unit.
   */
  CIVIDIS: new u({
    stops: [
      { value: 0, color: [0, 32, 77, 255] },
      { value: 0.125, color: [5, 54, 110, 255] },
      { value: 0.25, color: [65, 77, 108, 255] },
      { value: 0.375, color: [97, 100, 111, 255] },
      { value: 0.5, color: [125, 124, 121, 255] },
      { value: 0.625, color: [156, 149, 120, 255] },
      { value: 0.75, color: [190, 175, 111, 255] },
      { value: 0.875, color: [225, 204, 94, 255] },
      { value: 1, color: [255, 235, 70, 255] }
    ]
  }),
  /**
   * Classic turbo color ramp.
   * This is a luminance-constant alternative to the jet, making it more
   * clor-blind friendly.
   * Defined in interval [0, 1], without unit.
   */
  TURBO: new u({
    stops: [
      { value: 0, color: [48, 18, 59, 255] },
      { value: 0.125, color: [70, 107, 227, 255] },
      { value: 0.25, color: [40, 187, 236, 255] },
      { value: 0.375, color: [49, 242, 153, 255] },
      { value: 0.5, color: [162, 252, 60, 255] },
      { value: 0.625, color: [237, 208, 58, 255] },
      { value: 0.75, color: [251, 128, 34, 255] },
      { value: 0.875, color: [210, 49, 5, 255] },
      { value: 1, color: [122, 4, 3, 255] }
    ]
  }),
  /**
   * The rocket color ramp is perceptually uniform, which makes it more
   * color bliend friendly than the classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ROCKET: new u({
    stops: [
      { value: 0, color: [250, 235, 221, 0] },
      { value: 0.133, color: [250, 235, 221, 255] },
      { value: 0.266, color: [246, 170, 130, 255] },
      { value: 0.4, color: [240, 96, 67, 255] },
      { value: 0.533, color: [203, 27, 79, 255] },
      { value: 0.666, color: [132, 30, 90, 255] },
      { value: 0.8, color: [63, 27, 68, 255] },
      { value: 1, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * The mako color ramp is perceptually uniform and can be seen as
   * a color blind friendly alternative to bathymetry or yignbu.
   * Defined in interval [0, 1], without unit.
   */
  MAKO: new u({
    stops: [
      { value: 0, color: [11, 4, 5, 255] },
      { value: 0.125, color: [43, 28, 53, 255] },
      { value: 0.25, color: [62, 53, 107, 255] },
      { value: 0.375, color: [59, 86, 152, 255] },
      { value: 0.5, color: [53, 123, 162, 255] },
      { value: 0.625, color: [53, 158, 170, 255] },
      { value: 0.75, color: [73, 193, 173, 255] },
      { value: 0.875, color: [150, 221, 181, 255] },
      { value: 1, color: [222, 245, 229, 255] }
    ]
  }),
  // --------- specialized --------------
  /**
   * Elevation terrain, values are in meter.
   * Defined in interval [-10001, 8000].
   */
  TERRAIN: new u({
    stops: [
      { value: -10001, color: [0, 20, 60] },
      { value: -5e3, color: [0, 10, 30] },
      { value: -1e3, color: [0, 30, 80] },
      { value: -100, color: [0, 38, 115] },
      { value: 0, color: [122, 200, 255] },
      { value: 10, color: [51, 102, 0] },
      { value: 500, color: [129, 195, 31] },
      { value: 800, color: [255, 255, 204] },
      { value: 1200, color: [244, 189, 69] },
      { value: 2e3, color: [132, 75, 0] },
      { value: 3e3, color: [102, 51, 12] },
      { value: 8e3, color: [255, 255, 255] }
    ]
  }),
  /**
   * Atmospheric pressure, values in hPa (or millibar)
   * Defined in interval [900, 1080].
   */
  PRESSURE: new u({
    stops: [
      { value: 900, color: [0, 0, 100, 250] },
      { value: 950, color: [0, 0, 255, 250] },
      { value: 980, color: [0, 0, 255, 120] },
      { value: 1e3, color: [255, 255, 255, 0] },
      { value: 1020, color: [255, 0, 0, 120] },
      { value: 1080, color: [255, 0, 0, 250] }
    ]
  }),
  /**
   * Atmospheric pressure, values in hPa (or millibar).
   * Defined in interval [900, 1080].
   */
  PRESSURE_2: new u({
    stops: [
      { value: 900, color: [8, 16, 48, 255] },
      { value: 950, color: [0, 32, 96, 255] },
      { value: 976, color: [0, 52, 146, 255] },
      { value: 986, color: [0, 90, 148, 255] },
      { value: 995, color: [0, 117, 146, 255] },
      { value: 1002, color: [26, 140, 147, 255] },
      { value: 1007, color: [103, 162, 155, 255] },
      { value: 1011, color: [155, 183, 172, 255] },
      { value: 1013, color: [182, 182, 182, 255] },
      { value: 1015, color: [176, 174, 152, 255] },
      { value: 1019, color: [167, 147, 107, 255] },
      { value: 1024, color: [163, 116, 67, 255] },
      { value: 1030, color: [159, 81, 44, 255] },
      { value: 1038, color: [142, 47, 57, 255] },
      { value: 1046, color: [111, 24, 64, 255] },
      { value: 1080, color: [48, 8, 24, 255] }
    ]
  }),
  /**
   * Atmospheric pressure, values in hPa (or millibar).
   * Defined in interval [900, 1080].
   */
  PRESSURE_3: new u({
    stops: [
      { value: 900, color: [40, 46, 117, 255] },
      { value: 950, color: [40, 51, 121, 255] },
      { value: 976, color: [42, 63, 125, 255] },
      { value: 986, color: [55, 97, 141, 255] },
      { value: 995, color: [69, 115, 150, 255] },
      { value: 1002, color: [87, 144, 168, 255] },
      { value: 1007, color: [125, 184, 194, 255] },
      { value: 1011, color: [195, 226, 226, 255] },
      { value: 1013, color: [245, 220, 196, 255] },
      { value: 1015, color: [232, 191, 160, 255] },
      { value: 1019, color: [219, 154, 125, 255] },
      { value: 1024, color: [210, 115, 98, 255] },
      { value: 1030, color: [194, 72, 67, 255] },
      { value: 1038, color: [199, 61, 60, 255] },
      { value: 1046, color: [177, 50, 54, 255] },
      { value: 1080, color: [159, 42, 48, 255] }
    ]
  }),
  /**
   * Atmospheric pressure, values in hPa (or millibar).
   * Defined in interval [900, 1080]. The main difference
   * with PRESSURE_3 is the true neutral zone (pale gray)
   * from 1012.5 to 1013.5hPa
   */
  PRESSURE_4: new u({
    stops: [
      { value: 900, color: [40, 46, 117, 255] },
      { value: 950, color: [40, 51, 121, 255] },
      { value: 976, color: [42, 63, 125, 255] },
      { value: 986, color: [55, 97, 141, 255] },
      { value: 995, color: [69, 115, 150, 255] },
      { value: 1002, color: [87, 144, 168, 255] },
      { value: 1007, color: [125, 184, 194, 255] },
      { value: 1012.5, color: [226, 226, 226, 255] },
      { value: 1013.5, color: [226, 226, 226, 255] },
      { value: 1015, color: [232, 191, 160, 255] },
      { value: 1019, color: [219, 154, 125, 255] },
      { value: 1024, color: [210, 115, 98, 255] },
      { value: 1030, color: [194, 72, 67, 255] },
      { value: 1038, color: [199, 61, 60, 255] },
      { value: 1046, color: [177, 50, 54, 255] },
      { value: 1080, color: [159, 42, 48, 255] }
    ]
  }),
  /**
   * Temperatures in degree Celsius.
   * Defined in interval [-70.15, 46.85].
   */
  TEMPERATURE_2: new u({
    stops: [
      { value: -70.15, color: [115, 70, 105, 255] },
      { value: -55.15, color: [202, 172, 195, 255] },
      { value: -40.15, color: [162, 70, 145, 255] },
      { value: -25.15, color: [143, 89, 169, 255] },
      { value: -15.15, color: [157, 219, 217, 255] },
      { value: -8.15, color: [106, 191, 181, 255] },
      { value: -4.15, color: [100, 166, 189, 255] },
      { value: 0, color: [93, 133, 198, 255] },
      { value: 0.85, color: [68, 125, 99, 255] },
      { value: 9.85, color: [128, 147, 24, 255] },
      { value: 20.85, color: [243, 183, 4, 255] },
      { value: 29.85, color: [232, 83, 25, 255] },
      { value: 46.85, color: [71, 14, 0, 255] }
    ]
  }),
  /**
   * Temperatures in degrees Celsius.
   * Defined in interval [-65, 55].
   */
  TEMPERATURE_3: new u({
    stops: [
      { value: -65, color: [3, 78, 77, 255] },
      { value: -55, color: [4, 98, 96, 255] },
      { value: -40, color: [5, 122, 120, 255] },
      { value: -30, color: [6, 152, 149, 255] },
      { value: -20, color: [8, 201, 198, 255] },
      { value: -15, color: [20, 245, 241, 255] },
      { value: -10, color: [108, 237, 249, 255] },
      { value: -5, color: [133, 205, 250, 255] },
      { value: 0, color: [186, 227, 252, 255] },
      { value: 5, color: [238, 221, 145, 255] },
      { value: 10, color: [232, 183, 105, 255] },
      { value: 15, color: [232, 137, 69, 255] },
      { value: 20, color: [231, 107, 24, 255] },
      { value: 25, color: [236, 84, 19, 255] },
      { value: 30, color: [236, 44, 19, 255] },
      { value: 40, color: [123, 23, 10, 255] },
      { value: 55, color: [91, 11, 0, 255] }
    ]
  }),
  /**
   * Precipitation in mm per hour.
   *  Defined in interval [0, 50].
   */
  PRECIPITATION: new u({
    stops: [
      { value: 0, color: [111, 111, 111, 0] },
      { value: 0.6, color: [60, 116, 160, 180] },
      { value: 6, color: [59, 161, 161, 255] },
      { value: 8, color: [59, 161, 61, 255] },
      { value: 10, color: [130, 161, 59, 255] },
      { value: 15, color: [161, 161, 59, 255] },
      { value: 20, color: [161, 59, 59, 255] },
      { value: 31, color: [161, 59, 161, 255] },
      { value: 50, color: [168, 168, 168, 255] }
    ]
  }),
  /**
   * precipitation in mm per hour.
   *  Defined in interval [0, 50].
   */
  PRECIPITATION_2: new u({
    stops: [
      { value: 0, color: [255, 255, 255, 0] },
      { value: 0.1, color: [171, 218, 252, 255] },
      { value: 1, color: [98, 186, 249, 255] },
      { value: 2, color: [87, 160, 240, 255] },
      { value: 4, color: [112, 128, 250, 255] },
      { value: 6, color: [128, 102, 245, 255] },
      { value: 8, color: [152, 102, 245, 255] },
      { value: 10, color: [154, 87, 172, 255] },
      { value: 15, color: [228, 88, 126, 255] },
      { value: 20, color: [247, 135, 95, 255] },
      { value: 30, color: [249, 206, 64, 255] },
      { value: 50, color: [250, 248, 168, 52] }
    ]
  }),
  /**
   * Radar color ramp from NOAA in dBZ.
   *  Defined in interval [0, 75].
   */
  RADAR: new u({
    stops: [
      { value: 0, color: [7, 235, 236, 0] },
      { value: 4, color: [7, 235, 236, 80] },
      { value: 5, color: [7, 235, 236, 255] },
      { value: 10, color: [0, 159, 246, 255] },
      { value: 15, color: [0, 0, 247, 255] },
      { value: 20, color: [3, 255, 0, 255] },
      { value: 25, color: [0, 200, 2, 255] },
      { value: 30, color: [1, 144, 0, 255] },
      { value: 35, color: [255, 255, 0, 255] },
      { value: 40, color: [231, 192, 0, 255] },
      { value: 45, color: [255, 145, 3, 255] },
      { value: 50, color: [255, 0, 0, 255] },
      { value: 55, color: [215, 0, 0, 255] },
      { value: 60, color: [192, 0, 0, 255] },
      { value: 65, color: [255, 0, 255, 255] },
      { value: 70, color: [155, 85, 200, 255] },
      { value: 75, color: [235, 235, 235, 255] }
    ]
  }),
  /**
   * Intended to be used with Radar data to create a slighly blue-tinted greyscale
   * to represent cloud coverage. Values are in dBZ.
   * Defined in interval [4, 60].
   */
  RADAR_CLOUD: new u({
    stops: [
      { value: 4, color: [134, 134, 176, 0] },
      { value: 7, color: [134, 134, 176, 30] },
      { value: 10, color: [134, 134, 176, 60] },
      { value: 20, color: [110, 110, 145, 80] },
      { value: 35, color: [77, 77, 105, 140] },
      { value: 45, color: [58, 58, 87, 180] },
      { value: 60, color: [26, 26, 51, 220] }
    ]
  }),
  /**
   * This atmospheric pressure color ramp is based on cividis,
   * hence it is more clor bliend friendly. Values are in hPa (or millibar).
   * Defined in interval [900, 1080].
   */
  PRESSURE_CIVIDIS: new u({
    stops: [
      { value: 900, color: [0, 32, 77, 255] },
      { value: 950, color: [0, 37, 82, 255] },
      { value: 976, color: [15, 56, 110, 255] },
      { value: 986, color: [49, 68, 107, 255] },
      { value: 995, color: [70, 80, 107, 255] },
      { value: 1002, color: [87, 92, 109, 255] },
      { value: 1007, color: [102, 105, 112, 255] },
      { value: 1011, color: [117, 117, 117, 255] },
      { value: 1013, color: [132, 130, 121, 255] },
      { value: 1015, color: [149, 143, 120, 255] },
      { value: 1019, color: [166, 157, 117, 255] },
      { value: 1024, color: [184, 171, 112, 255] },
      { value: 1030, color: [203, 186, 105, 255] },
      { value: 1038, color: [221, 201, 95, 255] },
      { value: 1046, color: [250, 229, 65, 255] },
      { value: 1080, color: [255, 234, 70, 255] }
    ]
  }),
  /**
   * This rocket color ramp scaled for radar data is a color blind
   * friendly alternative. Values are in dBZ.
   * Defined in interval [0, 75]
   */
  RADAR_ROCKET: new u({
    stops: [
      { value: 0, color: [250, 235, 221, 0] },
      { value: 0.1, color: [250, 235, 221, 255] },
      { value: 10, color: [246, 180, 142, 255] },
      { value: 20, color: [243, 118, 81, 255] },
      { value: 30, color: [225, 51, 66, 255] },
      { value: 40, color: [174, 23, 89, 255] },
      { value: 50, color: [112, 31, 87, 255] },
      { value: 60, color: [54, 25, 62, 255] },
      { value: 75, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * This rocket color ramp scaled for wind speed is a color blind
   * friendly alternative. Values are in m/sec.
   * Defined in interval [0, 30]
   */
  WIND_ROCKET: new u({
    stops: [
      { value: 0, color: [250, 235, 221, 255] },
      { value: 1, color: [246, 187, 151, 255] },
      { value: 3, color: [244, 135, 94, 255] },
      { value: 5, color: [236, 75, 62, 255] },
      { value: 10, color: [203, 27, 79, 255] },
      { value: 15, color: [150, 28, 91, 255] },
      { value: 20, color: [97, 31, 83, 255] },
      { value: 25, color: [48, 23, 58, 255] },
      { value: 30, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * This mako color ramps is scale for precipitation is a color blind
   * friendly alternative. Values are in mm/hour
   * Defined in interval [0, 50].
   */
  MAKO_PRECIPITATION: new u({
    stops: [
      { value: 0, color: [255, 255, 255, 0] },
      { value: 0.1, color: [222, 245, 229, 255] },
      { value: 1, color: [168, 225, 188, 255] },
      { value: 2, color: [96, 206, 172, 255] },
      { value: 4, color: [61, 180, 173, 255] },
      { value: 6, color: [52, 151, 169, 255] },
      { value: 8, color: [53, 123, 162, 255] },
      { value: 10, color: [57, 93, 156, 255] },
      { value: 15, color: [65, 64, 129, 255] },
      { value: 20, color: [56, 42, 84, 255] },
      { value: 30, color: [38, 23, 42, 255] },
      { value: 50, color: [11, 4, 5, 255] }
    ]
  }),
  /**
   * Based on the turbo color ramp, this one is scaled
   * to render temperatures in degree Celcius.
   * This is a perceptually uniform alternative to jet, making it more color bliend friendly.
   * Defined in interval [-65, 55].
   */
  TEMPERATURE_TURBO: new u({
    stops: [
      { value: -65, color: [48, 18, 59, 255] },
      { value: -55, color: [64, 64, 162, 255] },
      { value: -40, color: [70, 107, 227, 255] },
      { value: -30, color: [66, 147, 255, 255] },
      { value: -20, color: [40, 187, 236, 255] },
      { value: -15, color: [24, 220, 195, 255] },
      { value: -10, color: [49, 242, 153, 255] },
      { value: -5, color: [107, 254, 100, 255] },
      { value: 0, color: [162, 252, 60, 255] },
      { value: 5, color: [204, 237, 52, 255] },
      { value: 10, color: [237, 208, 58, 255] },
      { value: 15, color: [253, 173, 53, 255] },
      { value: 20, color: [231, 107, 24, 255] },
      { value: 25, color: [236, 82, 15, 255] },
      { value: 30, color: [210, 49, 5, 255] },
      { value: 40, color: [172, 23, 1, 255] },
      { value: 55, color: [122, 4, 3, 255] }
    ]
  })
});
let Y = u;
const D = {
  maxAmount: 128,
  color: [255, 255, 255, 0],
  density: 200,
  size: 1,
  speed: 15e-4,
  refreshInterval: 200,
  fadeFactor: 0.04,
  opacity: 1,
  colorramp: Y.builtin.VIRIDIS,
  smooth: !0,
  fastColor: [255, 255, 255, 255],
  fastSpeed: 3,
  fastIsLarger: !0
};
class Gt extends Dt {
  constructor(e = {}) {
    super(e.id || "MapTiler Wind", null, null, null);
    n(this, "constructorOptions");
    n(this, "isSourceReady", !1);
    n(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, t) {
    const o = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    y.hasData() || await y.fetchLatest(o, r);
    const a = y.getWindData();
    if (!a)
      throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? D.colorramp.scale(0, 40), this.initParticle(
      {
        minZoom: a.metadata.minzoom,
        maxZoom: a.metadata.maxzoom
      },
      {
        decodeChannels: a.metadata.weather_variable.decoding.channels.toLowerCase(),
        decodeMin: a.metadata.weather_variable.decoding.min,
        decodeMax: a.metadata.weather_variable.decoding.max,
        decodeAsWaves: !1,
        maxAmount: this.constructorOptions.maxAmount ?? D.maxAmount,
        color: this.constructorOptions.color ?? D.color,
        fastColor: this.constructorOptions.fastColor ?? D.fastColor,
        fastSpeed: this.constructorOptions.fastSpeed ?? D.fastSpeed,
        density: this.constructorOptions.density ?? D.density,
        size: this.constructorOptions.size ?? D.size,
        speed: this.constructorOptions.speed ?? D.speed,
        refreshInterval: this.constructorOptions.refreshInterval ?? D.refreshInterval,
        fadeFactor: this.constructorOptions.fadeFactor ?? D.fadeFactor,
        angleDirectionShiftSkip: 30,
        uniformSpeed: !0,
        fastIsLarger: this.constructorOptions.fastIsLarger ?? D.fastIsLarger
      },
      [
        new ie({
          decode: {
            channel: a.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: a.metadata.weather_variable.decoding.min,
            max: a.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? D.smooth,
          opacity: this.constructorOptions.opacity ?? D.opacity
        })
      ]
    ), super.onAdd(e, t), y.getSourcesAndTimestamps(
      a,
      o,
      r
    ).forEach((c) => {
      this.addSource(c.timestamp, c.source);
    });
    const l = +/* @__PURE__ */ new Date() / 1e3;
    l >= this.getAnimationStart() && l <= this.getAnimationEnd() && this.setAnimationTime(l), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the wind speed and direction in multiple measurement units at a given location
   * @param lng
   * @param lat
   * @returns
   */
  pickAt(e, t) {
    const o = super.pick(e, t);
    if (!o)
      return null;
    const r = o[0], a = o[1], l = Math.sqrt(r ** 2 + a ** 2), h = Math.atan2(r, a) * 180 / Math.PI;
    return {
      speedMetersPerSecond: l,
      speedKilometersPerHour: l * 3.6,
      speedMilesPerHour: l * 2.23694,
      speedFeetPerSecond: l * 3.28084,
      speedKnots: l * 1.94384,
      directionAngle: h,
      compassDirection: ht(h + 180)
    };
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
class $t extends ae {
  constructor(e = {}) {
    super(e.id || "MapTiler Pressure", null, null, null);
    n(this, "constructorOptions");
    n(this, "isSourceReady", !1);
    n(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, t) {
    const o = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    y.hasData() || await y.fetchLatest(o, r);
    const a = y.getPressureData();
    if (!a)
      throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? Y.builtin.PRESSURE_2, this.init(
      {
        minZoom: a.metadata.minzoom,
        maxZoom: a.metadata.maxzoom,
        repaintOnPausedAnimation: !1
      },
      [
        new ie({
          decode: {
            channel: a.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: a.metadata.weather_variable.decoding.min,
            max: a.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? !0,
          opacity: this.constructorOptions.opacity ?? 1
        })
      ]
    ), super.onAdd(e, t), y.getSourcesAndTimestamps(
      a,
      o,
      r
    ).forEach((c) => {
      this.addSource(c.timestamp, c.source);
    });
    const l = +/* @__PURE__ */ new Date() / 1e3;
    l >= this.getAnimationStart() && l <= this.getAnimationEnd() && this.setAnimationTime(l), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the air pressure in hPa at a given location
   * @param lng
   * @param lat
   * @returns
   */
  pickAt(e, t) {
    const o = super.pick(e, t);
    return o ? {
      value: o[0]
    } : null;
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
class kt extends ae {
  constructor(e = {}) {
    super(e.id || "MapTiler Temperature", null, null, null);
    n(this, "constructorOptions");
    n(this, "isSourceReady", !1);
    n(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, t) {
    const o = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    y.hasData() || await y.fetchLatest(o, r);
    const a = y.getTemperatureData();
    if (!a)
      throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? Y.builtin.TEMPERATURE_2, this.init(
      {
        minZoom: a.metadata.minzoom,
        maxZoom: a.metadata.maxzoom,
        repaintOnPausedAnimation: !1
      },
      [
        new ie({
          decode: {
            channel: a.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: a.metadata.weather_variable.decoding.min,
            max: a.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? !0,
          opacity: this.constructorOptions.opacity ?? 1
        })
      ]
    ), super.onAdd(e, t), y.getSourcesAndTimestamps(
      a,
      o,
      r
    ).forEach((c) => {
      this.addSource(c.timestamp, c.source);
    });
    const l = +/* @__PURE__ */ new Date() / 1e3;
    l >= this.getAnimationStart() && l <= this.getAnimationEnd() && this.setAnimationTime(l), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the temperature in multiple measurement units at a given location
   * @param lng
   * @param lat
   * @returns
   */
  pickAt(e, t) {
    const o = super.pick(e, t);
    if (!o)
      return null;
    const r = o[0];
    return {
      value: r,
      valueImperial: 32 + r * 9 / 5
    };
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
class Zt extends ae {
  constructor(e = {}) {
    super(e.id || "MapTiler Precipitation", null, null, null);
    n(this, "constructorOptions");
    n(this, "isSourceReady", !1);
    n(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, t) {
    const o = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    y.hasData() || await y.fetchLatest(o, r);
    const a = y.getPrecipitationData();
    if (!a)
      throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? Y.builtin.PRECIPITATION, this.init(
      {
        minZoom: a.metadata.minzoom,
        maxZoom: a.metadata.maxzoom,
        repaintOnPausedAnimation: !1
      },
      [
        new ie({
          decode: {
            channel: a.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: a.metadata.weather_variable.decoding.min,
            max: a.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? !0,
          opacity: this.constructorOptions.opacity ?? 1
        })
      ]
    ), super.onAdd(e, t), y.getSourcesAndTimestamps(
      a,
      o,
      r
    ).forEach((c) => {
      this.addSource(c.timestamp, c.source);
    });
    const l = +/* @__PURE__ */ new Date() / 1e3;
    l >= this.getAnimationStart() && l <= this.getAnimationEnd() && this.setAnimationTime(l), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the amount of precipitation in mm/h
   * @param lng
   * @param lat
   * @returns
   */
  pickAt(e, t) {
    const o = super.pick(e, t);
    return o ? {
      value: o[0],
      valueImperial: o[0] / 2.54
    } : null;
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
class Yt extends ae {
  constructor(e = {}) {
    super(e.id || "MapTiler Radar", null, null, null);
    n(this, "constructorOptions");
    n(this, "isSourceReady", !1);
    n(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, t) {
    const o = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    y.hasData() || await y.fetchLatest(o, r);
    const a = y.getRadarData();
    if (!a)
      throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? Y.builtin.RADAR, this.init(
      {
        minZoom: a.metadata.minzoom,
        maxZoom: a.metadata.maxzoom,
        repaintOnPausedAnimation: !1
      },
      [
        new ie({
          decode: {
            channel: a.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: a.metadata.weather_variable.decoding.min,
            max: a.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? !0,
          opacity: this.constructorOptions.opacity ?? 1
        })
      ]
    ), super.onAdd(e, t), y.getSourcesAndTimestamps(
      a,
      o,
      r
    ).forEach((c) => {
      this.addSource(c.timestamp, c.source);
    });
    const l = +/* @__PURE__ */ new Date() / 1e3;
    l >= this.getAnimationStart() && l <= this.getAnimationEnd() && this.setAnimationTime(l), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the radar reflectivity in dBZ at a given location
   * @param lng
   * @param lat
   * @returns
   */
  pickAt(e, t) {
    const o = super.pick(e, t);
    return o ? {
      value: o[0]
    } : null;
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
export {
  it as ChannelIndices,
  Y as ColorRamp,
  Le as ColoringFragmentBase,
  he as EARTH_PERIMETER_M,
  nt as EARTH_RADIUS_M,
  ie as GradientColoringFragment,
  dt as InstancePool,
  Wt as MultiChannelGradientColoringFragment,
  Bt as OpacityColoringFragment,
  Dt as ParticleLayer,
  Zt as PrecipitationLayer,
  $t as PressureLayer,
  Yt as RadarLayer,
  kt as TemperatureLayer,
  ae as TileLayer,
  y as WeatherDataHandler,
  Z as WeatherVariableID,
  Gt as WindLayer,
  Vt as addLayerWhenReady,
  K as floatifyColor,
  ht as getCardinalDirection,
  lt as latToUnit,
  Lt as makeUnitColor,
  Ot as pixelToLat,
  ct as sampleImage,
  ut as sampleImageCanvas,
  st as unitToLat,
  j as wgs84ToMerc,
  Ne as wgs84ToUnit
};
