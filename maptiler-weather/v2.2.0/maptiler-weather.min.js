var Eo = Object.defineProperty;
var Bt = (n) => {
  throw TypeError(n);
};
var Co = (n, t, e) => t in n ? Eo(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var u = (n, t, e) => Co(n, typeof t != "symbol" ? t + "" : t, e), At = (n, t, e) => t.has(n) || Bt("Cannot " + e);
var a = (n, t, e) => (At(n, t, "read from private field"), e ? e.call(n) : t.get(n)), b = (n, t, e) => t.has(n) ? Bt("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), _ = (n, t, e, o) => (At(n, t, "write to private field"), o ? o.call(n, e) : t.set(n, e), e), p = (n, t, e) => (At(n, t, "access private method"), e);
var ht = (n, t, e, o) => ({
  set _(i) {
    _(n, t, i, e);
  },
  get _() {
    return a(n, t, o);
  }
});
import * as T from "three";
import { OrthographicCamera as Ro, Scene as Po, RawShaderMaterial as Ao, GLSL3 as bo, Vector2 as Io, WebGLRenderTarget as kt, LinearFilter as ft, RGBAFormat as bt, Mesh as Mo, PlaneGeometry as Fo, DataTexture as No, WebGLRenderer as zo } from "three";
import { EventEmitter as Do } from "events";
const Ve = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, oo = /* @__PURE__ */ new Set(), Dt = typeof process == "object" && process ? process : {}, io = (n, t, e, o) => {
  typeof Dt.emitWarning == "function" ? Dt.emitWarning(n, t, e, o) : console.error(`[${e}] ${t}: ${n}`);
};
let wt = globalThis.AbortController, Yt = globalThis.AbortSignal;
var Qt;
if (typeof wt > "u") {
  Yt = class {
    constructor() {
      u(this, "onabort");
      u(this, "_onabort", []);
      u(this, "reason");
      u(this, "aborted", !1);
    }
    addEventListener(o, i) {
      this._onabort.push(i);
    }
  }, wt = class {
    constructor() {
      u(this, "signal", new Yt());
      t();
    }
    abort(o) {
      var i, r;
      if (!this.signal.aborted) {
        this.signal.reason = o, this.signal.aborted = !0;
        for (const l of this.signal._onabort)
          l(o);
        (r = (i = this.signal).onabort) == null || r.call(i, o);
      }
    }
  };
  let n = ((Qt = Dt.env) == null ? void 0 : Qt.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const t = () => {
    n && (n = !1, io("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t));
  };
}
const Oo = (n) => !oo.has(n), Re = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), ro = (n) => Re(n) ? n <= Math.pow(2, 8) ? Uint8Array : n <= Math.pow(2, 16) ? Uint16Array : n <= Math.pow(2, 32) ? Uint32Array : n <= Number.MAX_SAFE_INTEGER ? pt : null : null;
class pt extends Array {
  constructor(t) {
    super(t), this.fill(0);
  }
}
var Ze;
const Ue = class Ue {
  constructor(t, e) {
    u(this, "heap");
    u(this, "length");
    if (!a(Ue, Ze))
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new e(t), this.length = 0;
  }
  static create(t) {
    const e = ro(t);
    if (!e)
      return [];
    _(Ue, Ze, !0);
    const o = new Ue(t, e);
    return _(Ue, Ze, !1), o;
  }
  push(t) {
    this.heap[this.length++] = t;
  }
  pop() {
    return this.heap[--this.length];
  }
};
Ze = new WeakMap(), // private constructor
b(Ue, Ze, !1);
let Ot = Ue;
var eo, to, ce, oe, ue, he, He, je, G, fe, W, z, C, K, ie, $, V, de, B, me, ve, re, xe, Me, q, m, Ut, Le, _e, rt, ne, no, We, Ke, nt, Pe, Ae, Lt, St, yt, N, Wt, et, be, Gt, qe;
let Uo = (qe = class {
  constructor(t) {
    b(this, m);
    // options that cannot be changed without disaster
    b(this, ce);
    b(this, oe);
    b(this, ue);
    b(this, he);
    b(this, He);
    b(this, je);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    u(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    u(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    u(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    u(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    u(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    u(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    u(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    u(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    u(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    u(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    u(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    u(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    u(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    u(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    u(this, "ignoreFetchAbort");
    // computed properties
    b(this, G);
    b(this, fe);
    b(this, W);
    b(this, z);
    b(this, C);
    b(this, K);
    b(this, ie);
    b(this, $);
    b(this, V);
    b(this, de);
    b(this, B);
    b(this, me);
    b(this, ve);
    b(this, re);
    b(this, xe);
    b(this, Me);
    b(this, q);
    // conditionally set private methods related to TTL
    b(this, Le, () => {
    });
    b(this, _e, () => {
    });
    b(this, rt, () => {
    });
    /* c8 ignore stop */
    b(this, ne, () => !1);
    b(this, We, (t) => {
    });
    b(this, Ke, (t, e, o) => {
    });
    b(this, nt, (t, e, o, i) => {
      if (o || i)
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    });
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    u(this, eo, "LRUCache");
    const { max: e = 0, ttl: o, ttlResolution: i = 1, ttlAutopurge: r, updateAgeOnGet: l, updateAgeOnHas: s, allowStale: c, dispose: h, disposeAfter: d, noDisposeOnSet: f, noUpdateTTL: v, maxSize: x = 0, maxEntrySize: E = 0, sizeCalculation: y, fetchMethod: w, memoMethod: S, noDeleteOnFetchRejection: P, noDeleteOnStaleGet: I, allowStaleOnFetchRejection: A, allowStaleOnFetchAbort: D, ignoreFetchAbort: k } = t;
    if (e !== 0 && !Re(e))
      throw new TypeError("max option must be a nonnegative integer");
    const O = e ? ro(e) : Array;
    if (!O)
      throw new Error("invalid max value: " + e);
    if (_(this, ce, e), _(this, oe, x), this.maxEntrySize = E || a(this, oe), this.sizeCalculation = y, this.sizeCalculation) {
      if (!a(this, oe) && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (S !== void 0 && typeof S != "function")
      throw new TypeError("memoMethod must be a function if defined");
    if (_(this, je, S), w !== void 0 && typeof w != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (_(this, He, w), _(this, Me, !!w), _(this, W, /* @__PURE__ */ new Map()), _(this, z, new Array(e).fill(void 0)), _(this, C, new Array(e).fill(void 0)), _(this, K, new O(e)), _(this, ie, new O(e)), _(this, $, 0), _(this, V, 0), _(this, de, Ot.create(e)), _(this, G, 0), _(this, fe, 0), typeof h == "function" && _(this, ue, h), typeof d == "function" ? (_(this, he, d), _(this, B, [])) : (_(this, he, void 0), _(this, B, void 0)), _(this, xe, !!a(this, ue)), _(this, q, !!a(this, he)), this.noDisposeOnSet = !!f, this.noUpdateTTL = !!v, this.noDeleteOnFetchRejection = !!P, this.allowStaleOnFetchRejection = !!A, this.allowStaleOnFetchAbort = !!D, this.ignoreFetchAbort = !!k, this.maxEntrySize !== 0) {
      if (a(this, oe) !== 0 && !Re(a(this, oe)))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!Re(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      p(this, m, no).call(this);
    }
    if (this.allowStale = !!c, this.noDeleteOnStaleGet = !!I, this.updateAgeOnGet = !!l, this.updateAgeOnHas = !!s, this.ttlResolution = Re(i) || i === 0 ? i : 1, this.ttlAutopurge = !!r, this.ttl = o || 0, this.ttl) {
      if (!Re(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      p(this, m, Ut).call(this);
    }
    if (a(this, ce) === 0 && this.ttl === 0 && a(this, oe) === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !a(this, ce) && !a(this, oe)) {
      const Se = "LRU_CACHE_UNBOUNDED";
      Oo(Se) && (oo.add(Se), io("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", Se, qe));
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(t) {
    return {
      // properties
      starts: a(t, ve),
      ttls: a(t, re),
      sizes: a(t, me),
      keyMap: a(t, W),
      keyList: a(t, z),
      valList: a(t, C),
      next: a(t, K),
      prev: a(t, ie),
      get head() {
        return a(t, $);
      },
      get tail() {
        return a(t, V);
      },
      free: a(t, de),
      // methods
      isBackgroundFetch: (e) => {
        var o;
        return p(o = t, m, N).call(o, e);
      },
      backgroundFetch: (e, o, i, r) => {
        var l;
        return p(l = t, m, yt).call(l, e, o, i, r);
      },
      moveToTail: (e) => {
        var o;
        return p(o = t, m, et).call(o, e);
      },
      indexes: (e) => {
        var o;
        return p(o = t, m, Pe).call(o, e);
      },
      rindexes: (e) => {
        var o;
        return p(o = t, m, Ae).call(o, e);
      },
      isStale: (e) => {
        var o;
        return a(o = t, ne).call(o, e);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return a(this, ce);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return a(this, oe);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return a(this, fe);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return a(this, G);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return a(this, He);
  }
  get memoMethod() {
    return a(this, je);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return a(this, ue);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return a(this, he);
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(t) {
    return a(this, W).has(t) ? 1 / 0 : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const t of p(this, m, Pe).call(this))
      a(this, C)[t] !== void 0 && a(this, z)[t] !== void 0 && !p(this, m, N).call(this, a(this, C)[t]) && (yield [a(this, z)[t], a(this, C)[t]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const t of p(this, m, Ae).call(this))
      a(this, C)[t] !== void 0 && a(this, z)[t] !== void 0 && !p(this, m, N).call(this, a(this, C)[t]) && (yield [a(this, z)[t], a(this, C)[t]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const t of p(this, m, Pe).call(this)) {
      const e = a(this, z)[t];
      e !== void 0 && !p(this, m, N).call(this, a(this, C)[t]) && (yield e);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const t of p(this, m, Ae).call(this)) {
      const e = a(this, z)[t];
      e !== void 0 && !p(this, m, N).call(this, a(this, C)[t]) && (yield e);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const t of p(this, m, Pe).call(this))
      a(this, C)[t] !== void 0 && !p(this, m, N).call(this, a(this, C)[t]) && (yield a(this, C)[t]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const t of p(this, m, Ae).call(this))
      a(this, C)[t] !== void 0 && !p(this, m, N).call(this, a(this, C)[t]) && (yield a(this, C)[t]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [(to = Symbol.iterator, eo = Symbol.toStringTag, to)]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(t, e = {}) {
    for (const o of p(this, m, Pe).call(this)) {
      const i = a(this, C)[o], r = p(this, m, N).call(this, i) ? i.__staleWhileFetching : i;
      if (r !== void 0 && t(r, a(this, z)[o], this))
        return this.get(a(this, z)[o], e);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(t, e = this) {
    for (const o of p(this, m, Pe).call(this)) {
      const i = a(this, C)[o], r = p(this, m, N).call(this, i) ? i.__staleWhileFetching : i;
      r !== void 0 && t.call(e, r, a(this, z)[o], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(t, e = this) {
    for (const o of p(this, m, Ae).call(this)) {
      const i = a(this, C)[o], r = p(this, m, N).call(this, i) ? i.__staleWhileFetching : i;
      r !== void 0 && t.call(e, r, a(this, z)[o], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let t = !1;
    for (const e of p(this, m, Ae).call(this, { allowStale: !0 }))
      a(this, ne).call(this, e) && (p(this, m, be).call(this, a(this, z)[e], "expire"), t = !0);
    return t;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(t) {
    const e = a(this, W).get(t);
    if (e === void 0)
      return;
    const o = a(this, C)[e], i = p(this, m, N).call(this, o) ? o.__staleWhileFetching : o;
    if (i === void 0)
      return;
    const r = { value: i };
    if (a(this, re) && a(this, ve)) {
      const l = a(this, re)[e], s = a(this, ve)[e];
      if (l && s) {
        const c = l - (Ve.now() - s);
        r.ttl = c, r.start = Date.now();
      }
    }
    return a(this, me) && (r.size = a(this, me)[e]), r;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const t = [];
    for (const e of p(this, m, Pe).call(this, { allowStale: !0 })) {
      const o = a(this, z)[e], i = a(this, C)[e], r = p(this, m, N).call(this, i) ? i.__staleWhileFetching : i;
      if (r === void 0 || o === void 0)
        continue;
      const l = { value: r };
      if (a(this, re) && a(this, ve)) {
        l.ttl = a(this, re)[e];
        const s = Ve.now() - a(this, ve)[e];
        l.start = Math.floor(Date.now() - s);
      }
      a(this, me) && (l.size = a(this, me)[e]), t.unshift([o, l]);
    }
    return t;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(t) {
    this.clear();
    for (const [e, o] of t) {
      if (o.start) {
        const i = Date.now() - o.start;
        o.start = Ve.now() - i;
      }
      this.set(e, o.value, o);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(t, e, o = {}) {
    var v, x, E, y, w;
    if (e === void 0)
      return this.delete(t), this;
    const { ttl: i = this.ttl, start: r, noDisposeOnSet: l = this.noDisposeOnSet, sizeCalculation: s = this.sizeCalculation, status: c } = o;
    let { noUpdateTTL: h = this.noUpdateTTL } = o;
    const d = a(this, nt).call(this, t, e, o.size || 0, s);
    if (this.maxEntrySize && d > this.maxEntrySize)
      return c && (c.set = "miss", c.maxEntrySizeExceeded = !0), p(this, m, be).call(this, t, "set"), this;
    let f = a(this, G) === 0 ? void 0 : a(this, W).get(t);
    if (f === void 0)
      f = a(this, G) === 0 ? a(this, V) : a(this, de).length !== 0 ? a(this, de).pop() : a(this, G) === a(this, ce) ? p(this, m, St).call(this, !1) : a(this, G), a(this, z)[f] = t, a(this, C)[f] = e, a(this, W).set(t, f), a(this, K)[a(this, V)] = f, a(this, ie)[f] = a(this, V), _(this, V, f), ht(this, G)._++, a(this, Ke).call(this, f, d, c), c && (c.set = "add"), h = !1;
    else {
      p(this, m, et).call(this, f);
      const S = a(this, C)[f];
      if (e !== S) {
        if (a(this, Me) && p(this, m, N).call(this, S)) {
          S.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: P } = S;
          P !== void 0 && !l && (a(this, xe) && ((v = a(this, ue)) == null || v.call(this, P, t, "set")), a(this, q) && ((x = a(this, B)) == null || x.push([P, t, "set"])));
        } else l || (a(this, xe) && ((E = a(this, ue)) == null || E.call(this, S, t, "set")), a(this, q) && ((y = a(this, B)) == null || y.push([S, t, "set"])));
        if (a(this, We).call(this, f), a(this, Ke).call(this, f, d, c), a(this, C)[f] = e, c) {
          c.set = "replace";
          const P = S && p(this, m, N).call(this, S) ? S.__staleWhileFetching : S;
          P !== void 0 && (c.oldValue = P);
        }
      } else c && (c.set = "update");
    }
    if (i !== 0 && !a(this, re) && p(this, m, Ut).call(this), a(this, re) && (h || a(this, rt).call(this, f, i, r), c && a(this, _e).call(this, c, f)), !l && a(this, q) && a(this, B)) {
      const S = a(this, B);
      let P;
      for (; P = S == null ? void 0 : S.shift(); )
        (w = a(this, he)) == null || w.call(this, ...P);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var t;
    try {
      for (; a(this, G); ) {
        const e = a(this, C)[a(this, $)];
        if (p(this, m, St).call(this, !0), p(this, m, N).call(this, e)) {
          if (e.__staleWhileFetching)
            return e.__staleWhileFetching;
        } else if (e !== void 0)
          return e;
      }
    } finally {
      if (a(this, q) && a(this, B)) {
        const e = a(this, B);
        let o;
        for (; o = e == null ? void 0 : e.shift(); )
          (t = a(this, he)) == null || t.call(this, ...o);
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(t, e = {}) {
    const { updateAgeOnHas: o = this.updateAgeOnHas, status: i } = e, r = a(this, W).get(t);
    if (r !== void 0) {
      const l = a(this, C)[r];
      if (p(this, m, N).call(this, l) && l.__staleWhileFetching === void 0)
        return !1;
      if (a(this, ne).call(this, r))
        i && (i.has = "stale", a(this, _e).call(this, i, r));
      else return o && a(this, Le).call(this, r), i && (i.has = "hit", a(this, _e).call(this, i, r)), !0;
    } else i && (i.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(t, e = {}) {
    const { allowStale: o = this.allowStale } = e, i = a(this, W).get(t);
    if (i === void 0 || !o && a(this, ne).call(this, i))
      return;
    const r = a(this, C)[i];
    return p(this, m, N).call(this, r) ? r.__staleWhileFetching : r;
  }
  async fetch(t, e = {}) {
    const {
      // get options
      allowStale: o = this.allowStale,
      updateAgeOnGet: i = this.updateAgeOnGet,
      noDeleteOnStaleGet: r = this.noDeleteOnStaleGet,
      // set options
      ttl: l = this.ttl,
      noDisposeOnSet: s = this.noDisposeOnSet,
      size: c = 0,
      sizeCalculation: h = this.sizeCalculation,
      noUpdateTTL: d = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection: f = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection: v = this.allowStaleOnFetchRejection,
      ignoreFetchAbort: x = this.ignoreFetchAbort,
      allowStaleOnFetchAbort: E = this.allowStaleOnFetchAbort,
      context: y,
      forceRefresh: w = !1,
      status: S,
      signal: P
    } = e;
    if (!a(this, Me))
      return S && (S.fetch = "get"), this.get(t, {
        allowStale: o,
        updateAgeOnGet: i,
        noDeleteOnStaleGet: r,
        status: S
      });
    const I = {
      allowStale: o,
      updateAgeOnGet: i,
      noDeleteOnStaleGet: r,
      ttl: l,
      noDisposeOnSet: s,
      size: c,
      sizeCalculation: h,
      noUpdateTTL: d,
      noDeleteOnFetchRejection: f,
      allowStaleOnFetchRejection: v,
      allowStaleOnFetchAbort: E,
      ignoreFetchAbort: x,
      status: S,
      signal: P
    };
    let A = a(this, W).get(t);
    if (A === void 0) {
      S && (S.fetch = "miss");
      const D = p(this, m, yt).call(this, t, A, I, y);
      return D.__returned = D;
    } else {
      const D = a(this, C)[A];
      if (p(this, m, N).call(this, D)) {
        const le = o && D.__staleWhileFetching !== void 0;
        return S && (S.fetch = "inflight", le && (S.returnedStale = !0)), le ? D.__staleWhileFetching : D.__returned = D;
      }
      const k = a(this, ne).call(this, A);
      if (!w && !k)
        return S && (S.fetch = "hit"), p(this, m, et).call(this, A), i && a(this, Le).call(this, A), S && a(this, _e).call(this, S, A), D;
      const O = p(this, m, yt).call(this, t, A, I, y), Z = O.__staleWhileFetching !== void 0 && o;
      return S && (S.fetch = k ? "stale" : "refresh", Z && k && (S.returnedStale = !0)), Z ? O.__staleWhileFetching : O.__returned = O;
    }
  }
  async forceFetch(t, e = {}) {
    const o = await this.fetch(t, e);
    if (o === void 0)
      throw new Error("fetch() returned undefined");
    return o;
  }
  memo(t, e = {}) {
    const o = a(this, je);
    if (!o)
      throw new Error("no memoMethod provided to constructor");
    const { context: i, forceRefresh: r, ...l } = e, s = this.get(t, l);
    if (!r && s !== void 0)
      return s;
    const c = o(t, s, {
      options: l,
      context: i
    });
    return this.set(t, c, l), c;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(t, e = {}) {
    const { allowStale: o = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: r = this.noDeleteOnStaleGet, status: l } = e, s = a(this, W).get(t);
    if (s !== void 0) {
      const c = a(this, C)[s], h = p(this, m, N).call(this, c);
      return l && a(this, _e).call(this, l, s), a(this, ne).call(this, s) ? (l && (l.get = "stale"), h ? (l && o && c.__staleWhileFetching !== void 0 && (l.returnedStale = !0), o ? c.__staleWhileFetching : void 0) : (r || p(this, m, be).call(this, t, "expire"), l && o && (l.returnedStale = !0), o ? c : void 0)) : (l && (l.get = "hit"), h ? c.__staleWhileFetching : (p(this, m, et).call(this, s), i && a(this, Le).call(this, s), c));
    } else l && (l.get = "miss");
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(t) {
    return p(this, m, be).call(this, t, "delete");
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return p(this, m, Gt).call(this, "delete");
  }
}, ce = new WeakMap(), oe = new WeakMap(), ue = new WeakMap(), he = new WeakMap(), He = new WeakMap(), je = new WeakMap(), G = new WeakMap(), fe = new WeakMap(), W = new WeakMap(), z = new WeakMap(), C = new WeakMap(), K = new WeakMap(), ie = new WeakMap(), $ = new WeakMap(), V = new WeakMap(), de = new WeakMap(), B = new WeakMap(), me = new WeakMap(), ve = new WeakMap(), re = new WeakMap(), xe = new WeakMap(), Me = new WeakMap(), q = new WeakMap(), m = new WeakSet(), Ut = function() {
  const t = new pt(a(this, ce)), e = new pt(a(this, ce));
  _(this, re, t), _(this, ve, e), _(this, rt, (r, l, s = Ve.now()) => {
    if (e[r] = l !== 0 ? s : 0, t[r] = l, l !== 0 && this.ttlAutopurge) {
      const c = setTimeout(() => {
        a(this, ne).call(this, r) && p(this, m, be).call(this, a(this, z)[r], "expire");
      }, l + 1);
      c.unref && c.unref();
    }
  }), _(this, Le, (r) => {
    e[r] = t[r] !== 0 ? Ve.now() : 0;
  }), _(this, _e, (r, l) => {
    if (t[l]) {
      const s = t[l], c = e[l];
      if (!s || !c)
        return;
      r.ttl = s, r.start = c, r.now = o || i();
      const h = r.now - c;
      r.remainingTTL = s - h;
    }
  });
  let o = 0;
  const i = () => {
    const r = Ve.now();
    if (this.ttlResolution > 0) {
      o = r;
      const l = setTimeout(() => o = 0, this.ttlResolution);
      l.unref && l.unref();
    }
    return r;
  };
  this.getRemainingTTL = (r) => {
    const l = a(this, W).get(r);
    if (l === void 0)
      return 0;
    const s = t[l], c = e[l];
    if (!s || !c)
      return 1 / 0;
    const h = (o || i()) - c;
    return s - h;
  }, _(this, ne, (r) => {
    const l = e[r], s = t[r];
    return !!s && !!l && (o || i()) - l > s;
  });
}, Le = new WeakMap(), _e = new WeakMap(), rt = new WeakMap(), ne = new WeakMap(), no = function() {
  const t = new pt(a(this, ce));
  _(this, fe, 0), _(this, me, t), _(this, We, (e) => {
    _(this, fe, a(this, fe) - t[e]), t[e] = 0;
  }), _(this, nt, (e, o, i, r) => {
    if (p(this, m, N).call(this, o))
      return 0;
    if (!Re(i))
      if (r) {
        if (typeof r != "function")
          throw new TypeError("sizeCalculation must be a function");
        if (i = r(o, e), !Re(i))
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
    return i;
  }), _(this, Ke, (e, o, i) => {
    if (t[e] = o, a(this, oe)) {
      const r = a(this, oe) - t[e];
      for (; a(this, fe) > r; )
        p(this, m, St).call(this, !0);
    }
    _(this, fe, a(this, fe) + t[e]), i && (i.entrySize = o, i.totalCalculatedSize = a(this, fe));
  });
}, We = new WeakMap(), Ke = new WeakMap(), nt = new WeakMap(), Pe = function* ({ allowStale: t = this.allowStale } = {}) {
  if (a(this, G))
    for (let e = a(this, V); !(!p(this, m, Lt).call(this, e) || ((t || !a(this, ne).call(this, e)) && (yield e), e === a(this, $))); )
      e = a(this, ie)[e];
}, Ae = function* ({ allowStale: t = this.allowStale } = {}) {
  if (a(this, G))
    for (let e = a(this, $); !(!p(this, m, Lt).call(this, e) || ((t || !a(this, ne).call(this, e)) && (yield e), e === a(this, V))); )
      e = a(this, K)[e];
}, Lt = function(t) {
  return t !== void 0 && a(this, W).get(a(this, z)[t]) === t;
}, St = function(t) {
  var r, l;
  const e = a(this, $), o = a(this, z)[e], i = a(this, C)[e];
  return a(this, Me) && p(this, m, N).call(this, i) ? i.__abortController.abort(new Error("evicted")) : (a(this, xe) || a(this, q)) && (a(this, xe) && ((r = a(this, ue)) == null || r.call(this, i, o, "evict")), a(this, q) && ((l = a(this, B)) == null || l.push([i, o, "evict"]))), a(this, We).call(this, e), t && (a(this, z)[e] = void 0, a(this, C)[e] = void 0, a(this, de).push(e)), a(this, G) === 1 ? (_(this, $, _(this, V, 0)), a(this, de).length = 0) : _(this, $, a(this, K)[e]), a(this, W).delete(o), ht(this, G)._--, e;
}, yt = function(t, e, o, i) {
  const r = e === void 0 ? void 0 : a(this, C)[e];
  if (p(this, m, N).call(this, r))
    return r;
  const l = new wt(), { signal: s } = o;
  s == null || s.addEventListener("abort", () => l.abort(s.reason), {
    signal: l.signal
  });
  const c = {
    signal: l.signal,
    options: o,
    context: i
  }, h = (y, w = !1) => {
    const { aborted: S } = l.signal, P = o.ignoreFetchAbort && y !== void 0;
    if (o.status && (S && !w ? (o.status.fetchAborted = !0, o.status.fetchError = l.signal.reason, P && (o.status.fetchAbortIgnored = !0)) : o.status.fetchResolved = !0), S && !P && !w)
      return f(l.signal.reason);
    const I = x;
    return a(this, C)[e] === x && (y === void 0 ? I.__staleWhileFetching ? a(this, C)[e] = I.__staleWhileFetching : p(this, m, be).call(this, t, "fetch") : (o.status && (o.status.fetchUpdated = !0), this.set(t, y, c.options))), y;
  }, d = (y) => (o.status && (o.status.fetchRejected = !0, o.status.fetchError = y), f(y)), f = (y) => {
    const { aborted: w } = l.signal, S = w && o.allowStaleOnFetchAbort, P = S || o.allowStaleOnFetchRejection, I = P || o.noDeleteOnFetchRejection, A = x;
    if (a(this, C)[e] === x && (!I || A.__staleWhileFetching === void 0 ? p(this, m, be).call(this, t, "fetch") : S || (a(this, C)[e] = A.__staleWhileFetching)), P)
      return o.status && A.__staleWhileFetching !== void 0 && (o.status.returnedStale = !0), A.__staleWhileFetching;
    if (A.__returned === A)
      throw y;
  }, v = (y, w) => {
    var P;
    const S = (P = a(this, He)) == null ? void 0 : P.call(this, t, r, c);
    S && S instanceof Promise && S.then((I) => y(I === void 0 ? void 0 : I), w), l.signal.addEventListener("abort", () => {
      (!o.ignoreFetchAbort || o.allowStaleOnFetchAbort) && (y(void 0), o.allowStaleOnFetchAbort && (y = (I) => h(I, !0)));
    });
  };
  o.status && (o.status.fetchDispatched = !0);
  const x = new Promise(v).then(h, d), E = Object.assign(x, {
    __abortController: l,
    __staleWhileFetching: r,
    __returned: void 0
  });
  return e === void 0 ? (this.set(t, E, { ...c.options, status: void 0 }), e = a(this, W).get(t)) : a(this, C)[e] = E, E;
}, N = function(t) {
  if (!a(this, Me))
    return !1;
  const e = t;
  return !!e && e instanceof Promise && e.hasOwnProperty("__staleWhileFetching") && e.__abortController instanceof wt;
}, Wt = function(t, e) {
  a(this, ie)[e] = t, a(this, K)[t] = e;
}, et = function(t) {
  t !== a(this, V) && (t === a(this, $) ? _(this, $, a(this, K)[t]) : p(this, m, Wt).call(this, a(this, ie)[t], a(this, K)[t]), p(this, m, Wt).call(this, a(this, V), t), _(this, V, t));
}, be = function(t, e) {
  var i, r, l, s;
  let o = !1;
  if (a(this, G) !== 0) {
    const c = a(this, W).get(t);
    if (c !== void 0)
      if (o = !0, a(this, G) === 1)
        p(this, m, Gt).call(this, e);
      else {
        a(this, We).call(this, c);
        const h = a(this, C)[c];
        if (p(this, m, N).call(this, h) ? h.__abortController.abort(new Error("deleted")) : (a(this, xe) || a(this, q)) && (a(this, xe) && ((i = a(this, ue)) == null || i.call(this, h, t, e)), a(this, q) && ((r = a(this, B)) == null || r.push([h, t, e]))), a(this, W).delete(t), a(this, z)[c] = void 0, a(this, C)[c] = void 0, c === a(this, V))
          _(this, V, a(this, ie)[c]);
        else if (c === a(this, $))
          _(this, $, a(this, K)[c]);
        else {
          const d = a(this, ie)[c];
          a(this, K)[d] = a(this, K)[c];
          const f = a(this, K)[c];
          a(this, ie)[f] = a(this, ie)[c];
        }
        ht(this, G)._--, a(this, de).push(c);
      }
  }
  if (a(this, q) && ((l = a(this, B)) != null && l.length)) {
    const c = a(this, B);
    let h;
    for (; h = c == null ? void 0 : c.shift(); )
      (s = a(this, he)) == null || s.call(this, ...h);
  }
  return o;
}, Gt = function(t) {
  var e, o, i;
  for (const r of p(this, m, Ae).call(this, { allowStale: !0 })) {
    const l = a(this, C)[r];
    if (p(this, m, N).call(this, l))
      l.__abortController.abort(new Error("deleted"));
    else {
      const s = a(this, z)[r];
      a(this, xe) && ((e = a(this, ue)) == null || e.call(this, l, s, t)), a(this, q) && ((o = a(this, B)) == null || o.push([l, s, t]));
    }
  }
  if (a(this, W).clear(), a(this, C).fill(void 0), a(this, z).fill(void 0), a(this, re) && a(this, ve) && (a(this, re).fill(0), a(this, ve).fill(0)), a(this, me) && a(this, me).fill(0), _(this, $, 0), _(this, V, 0), a(this, de).length = 0, _(this, fe, 0), _(this, G, 0), a(this, q) && a(this, B)) {
    const r = a(this, B);
    let l;
    for (; l = r == null ? void 0 : r.shift(); )
      (i = a(this, he)) == null || i.call(this, ...l);
  }
}, qe);
var Lo = /* @__PURE__ */ ((n) => (n[n.r = 0] = "r", n[n.g = 1] = "g", n[n.b = 2] = "b", n[n.a = 3] = "a", n))(Lo || {});
let tt = null, It = null, Ne = null;
function lo() {
  if (!It || !Ne) {
    It = document.createElement("canvas"), Ne = It.getContext("webgl2");
    const n = Ne == null ? void 0 : Ne.getParameter(Ne.MAX_TEXTURE_IMAGE_UNITS);
    tt = new Uo({
      max: n,
      // When a new texture added while the cache is full, we clear the least recently used texture from GPU memory
      dispose: (t, e) => {
        lo().deleteTexture(t);
      }
    });
  }
  return Ne;
}
function $e(n) {
  return `vec4(${(n[0] / 255).toFixed(3)},${(n[1] / 255).toFixed(3)},${(n[2] / 255).toFixed(3)},${((n[3] ?? 255) / 255).toFixed(3)})`;
}
function Ji(n) {
  return [n[0] / 255, n[1] / 255, n[2] / 255, (n[3] ?? 255) / 255];
}
function Wo(n) {
  return 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360)) / 360;
}
function _t(n, t) {
  return [n / 360, Wo(t)];
}
function Go(n) {
  const t = Math.PI, e = Math.atan, o = Math.exp, i = o(n * 2 * t);
  return (e(i) - t / 4) * 360 / t;
}
function Qi(n, t) {
  const e = -0.5 * (n / t * 2 - 1);
  return Go(e);
}
const Vo = 6378137, Tt = 2 * Math.PI * Vo;
function Qe(n, t) {
  return _t(n, t).map((e) => e * Tt);
}
function ze(n, t, e) {
  const o = Math.floor(t * n.width), i = Math.floor(e * n.height), r = lo();
  if (r == null)
    throw new Error("Failed to obtain WebGL2 context");
  if (!tt)
    throw new Error("Could not initialize texture cache");
  r.activeTexture(r.TEXTURE0);
  let l;
  tt.has(n) ? l = tt.get(n) : (l = r.createTexture(), r.bindTexture(r.TEXTURE_2D, l), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, n), tt.set(n, l));
  const s = r.createFramebuffer();
  r.bindFramebuffer(r.FRAMEBUFFER, s), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, l, 0), r.drawBuffers([r.COLOR_ATTACHMENT0]);
  const c = new Uint8Array(4);
  return r.readPixels(o, i, 1, 1, r.RGBA, r.UNSIGNED_BYTE, c), r.deleteFramebuffer(s), {
    r: c[0] / 255,
    g: c[1] / 255,
    b: c[2] / 255,
    a: c[3] / 255
  };
}
function er(n, t, e = "") {
  n.isStyleLoaded() ? n.addLayer(t, e) : n.once("load", () => {
    n.addLayer(t, e);
  });
}
function Bo(n) {
  const t = [
    "N",
    "NNE",
    "NE",
    "ENE",
    "E",
    "ESE",
    "SE",
    "SSE",
    "S",
    "SSW",
    "SW",
    "WSW",
    "W",
    "WNW",
    "NW",
    "NNW"
  ], e = Math.round((n + 360) % 360 / 22.5) % 16;
  return t[e];
}
function ko(n, t) {
  const e = _t(n, t);
  return [e[0] + 0.5, e[1] * -1 + 0.5];
}
function Xt(n, t) {
  const e = ko(n.lng, n.lat), o = 2 ** t;
  return {
    z: t,
    x: e[0] * o,
    y: e[1] * o
  };
}
function Yo(n, t) {
  const e = ~~t, o = Xt(n.getNorthWest(), e), i = Xt(n.getSouthEast(), e), r = [];
  for (let l = Math.floor(o.x); l <= i.x; l += 1)
    for (let s = Math.floor(o.y); s <= Math.floor(i.y); s += 1)
      r.push(`${t}/${l}/${s}`);
  return r;
}
var Xo = `precision highp float;precision highp sampler2D;
#define USES_CATEGORIES <uses_categories>
#define VALUE_NUMBER_CHANNELS <value_number_channels>
uniform float opacity;uniform float time;uniform sampler2D tex0;uniform sampler2D tex1;uniform float tex0size;uniform float tex1size;uniform float tilePixelSize;uniform bool categorySmoothTransition;uniform bool timeInterpolation;uniform bool interpolateTileEdge;uniform sampler2D texN0;uniform sampler2D texN1;uniform bool availableN;uniform sampler2D texE0;uniform sampler2D texE1;uniform bool availableE;uniform sampler2D texS0;uniform sampler2D texS1;uniform bool availableS;uniform sampler2D texW0;uniform sampler2D texW1;uniform bool availableW;in vec2 tex0coord;in vec2 tex1coord;out vec4 fragColor;<gradient_function_definitions><getColor_code>float xNoTileEdgeInterpolation(sampler2D tex,vec2 texCoord){vec4 texColorFull=texture(tex,texCoord);vec3 texColorFull255=texColorFull.rgb*255.;
#if (VALUE_NUMBER_CHANNELS == 3)
vec3 texColor=texColorFull255.<value_channels>;return texColor.r*256.*256.+texColor.g*256.+texColor.b;
#endif
#if (VALUE_NUMBER_CHANNELS == 2)
vec2 texColor=texColorFull255.<value_channels>;return texColor.r*256.+texColor.g;
#endif
#if (VALUE_NUMBER_CHANNELS == 1)
return texColorFull255.<value_channels>;
#endif
}vec4 blerp(vec4 color_x0_y0,vec4 color_x0_y1,vec4 color_x1_y0,vec4 color_x1_y1,float x0,float y0,float x1,float y1,float x,float y){vec4 q11=(((x1-x)*(y1-y))/((x1-x0)*(y1-y0)))*color_x0_y0;vec4 q21=(((x-x0)*(y1-y))/((x1-x0)*(y1-y0)))*color_x1_y0;vec4 q12=(((x1-x)*(y-y0))/((x1-x0)*(y1-y0)))*color_x0_y1;vec4 q22=(((x-x0)*(y-y0))/((x1-x0)*(y1-y0)))*color_x1_y1;return q11+q21+q12+q22;}void main(){vec2 tileImageCoord=tex0coord*tilePixelSize;vec2 centerPixelUV=(floor(tileImageCoord)+0.5)/tilePixelSize;float xTex0=xNoTileEdgeInterpolation(tex0,tex0coord);float xTex1=xNoTileEdgeInterpolation(tex1,tex1coord);if(interpolateTileEdge){if(tileImageCoord.x<0.5&&availableW){float xTexW0=xNoTileEdgeInterpolation(texW0,vec2(1.,tex0coord.y));float xTexW1=xNoTileEdgeInterpolation(texW1,vec2(1.,tex0coord.y));float ratioCurrentTile=tileImageCoord.x+0.5;xTex0=ratioCurrentTile*xTex0+(1.-ratioCurrentTile)*xTexW0;xTex1=ratioCurrentTile*xTex1+(1.-ratioCurrentTile)*xTexW1;}else if(tileImageCoord.x>(tilePixelSize-0.5)&&availableE){float xTexE0=xNoTileEdgeInterpolation(texE0,vec2(0.,tex0coord.y));float xTexE1=xNoTileEdgeInterpolation(texE1,vec2(0.,tex0coord.y));float ratioCurrentTile=1.+((tilePixelSize-0.5)-tileImageCoord.x);xTex0=ratioCurrentTile*xTex0+(1.-ratioCurrentTile)*xTexE0;xTex1=ratioCurrentTile*xTex1+(1.-ratioCurrentTile)*xTexE1;}if(tileImageCoord.y<0.5&&availableS){float xTexS0=xNoTileEdgeInterpolation(texS0,vec2(tex0coord.x,1.));float xTexS1=xNoTileEdgeInterpolation(texS1,vec2(tex0coord.x,1.));float ratioCurrentTile=tileImageCoord.y+0.5;xTex0=ratioCurrentTile*xTex0+(1.-ratioCurrentTile)*xTexS0;xTex1=ratioCurrentTile*xTex1+(1.-ratioCurrentTile)*xTexS1;}else if(tileImageCoord.y>(tilePixelSize-0.5)&&availableN){float xTexN0=xNoTileEdgeInterpolation(texN0,vec2(tex0coord.x,0.));float xTexN1=xNoTileEdgeInterpolation(texN1,vec2(tex0coord.x,0.));float ratioCurrentTile=1.+((tilePixelSize-0.5)-tileImageCoord.y);xTex0=ratioCurrentTile*xTex0+(1.-ratioCurrentTile)*xTexN0;xTex1=ratioCurrentTile*xTex1+(1.-ratioCurrentTile)*xTexN1;}}float x=timeInterpolation ? mix(xTex0,xTex1,time):(time<0.5 ? xTex0 : xTex1);float polynomialCoefDegree2=<polynomialCoefDegree2>;float polynomialCoefDegree1=<polynomialCoefDegree1>;float polynomialConstant=<polynomialConstant>;float y=polynomialCoefDegree2*x*x+polynomialCoefDegree1*x+polynomialConstant;int category=0;
#if (USES_CATEGORIES == 1)
category=int((time<0.5 ? texture(tex0,centerPixelUV).a : texture(tex1,centerPixelUV).a)*255.);
#endif
vec4 color_Center=getColor(category,y);vec4 color=vec4(0.,0.,0.,0.);if(categorySmoothTransition){vec2 centerPixelUV_N=vec2((floor(tex0coord.x*tilePixelSize)+0.5)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5+1.)/tilePixelSize);vec2 centerPixelUV_S=vec2((floor(tex0coord.x*tilePixelSize)+0.5)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5-1.)/tilePixelSize);vec2 centerPixelUV_E=vec2((floor(tex0coord.x*tilePixelSize)+0.5+1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5)/tilePixelSize);vec2 centerPixelUV_W=vec2((floor(tex0coord.x*tilePixelSize)+0.5-1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5)/tilePixelSize);if(tex0coord.x>=centerPixelUV.x){int category_E=0;
#if (USES_CATEGORIES == 1)
category_E=int((time<0.5 ? texture(tex0,centerPixelUV_E).<category_channel>: texture(tex1,centerPixelUV_E).<category_channel>)*255.);
#endif
vec4 color_E=getColor(category_E,y);if(tex0coord.y>=centerPixelUV.y){int category_N=0;
#if (USES_CATEGORIES == 1)
category_N=int((time<0.5 ? texture(tex0,centerPixelUV_N).<category_channel>: texture(tex1,centerPixelUV_N).<category_channel>)*255.);
#endif
vec4 color_N=getColor(category_N,y);vec2 centerPixelUV_NE=vec2((floor(tex0coord.x*tilePixelSize)+0.5+1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5+1.)/tilePixelSize);int category_NE=0;
#if (USES_CATEGORIES == 1)
category_NE=int((time<0.5 ? texture(tex0,centerPixelUV_NE).<category_channel>: texture(tex1,centerPixelUV_NE).<category_channel>)*255.);
#endif
vec4 color_NE=getColor(category_NE,y);color=blerp(color_Center,color_N,color_E,color_NE,centerPixelUV.x,centerPixelUV.y,centerPixelUV_NE.x,centerPixelUV_NE.y,tex0coord.x,tex0coord.y);}else{int category_S=0;
#if (USES_CATEGORIES == 1)
category_S=int((time<0.5 ? texture(tex0,centerPixelUV_S).<category_channel>: texture(tex1,centerPixelUV_S).<category_channel>)*255.);
#endif
vec4 color_S=getColor(category_S,y);vec2 centerPixelUV_SE=vec2((floor(tex0coord.x*tilePixelSize)+0.5+1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5-1.)/tilePixelSize);int category_SE=0;
#if (USES_CATEGORIES == 1)
category_SE=int((time<0.5 ? texture(tex0,centerPixelUV_SE).<category_channel>: texture(tex1,centerPixelUV_SE).<category_channel>)*255.);
#endif
vec4 color_SE=getColor(category_SE,y);color=blerp(color_S,color_Center,color_SE,color_E,centerPixelUV_S.x,centerPixelUV_S.y,centerPixelUV_E.x,centerPixelUV_E.y,tex0coord.x,tex0coord.y);}}else{int category_W=0;
#if (USES_CATEGORIES == 1)
category_W=int((time<0.5 ? texture(tex0,centerPixelUV_W).<category_channel>: texture(tex1,centerPixelUV_W).<category_channel>)*255.);
#endif
vec4 color_W=getColor(category_W,y);if(tex0coord.y>=centerPixelUV.y){int category_N=0;
#if (USES_CATEGORIES == 1)
category_N=int((time<0.5 ? texture(tex0,centerPixelUV_N).<category_channel>: texture(tex1,centerPixelUV_N).<category_channel>)*255.);
#endif
vec4 color_N=getColor(category_N,y);vec2 centerPixelUV_NW=vec2((floor(tex0coord.x*tilePixelSize)+0.5-1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5+1.)/tilePixelSize);int category_NW=0;
#if (USES_CATEGORIES == 1)
category_NW=int((time<0.5 ? texture(tex0,centerPixelUV_NW).<category_channel>: texture(tex1,centerPixelUV_NW).<category_channel>)*255.);
#endif
vec4 color_NW=getColor(category_NW,y);color=blerp(color_W,color_NW,color_Center,color_N,centerPixelUV_W.x,centerPixelUV_W.y,centerPixelUV_N.x,centerPixelUV_N.y,tex0coord.x,tex0coord.y);}else{int category_S=0;
#if (USES_CATEGORIES == 1)
category_S=int((time<0.5 ? texture(tex0,centerPixelUV_S).<category_channel>: texture(tex1,centerPixelUV_S).<category_channel>)*255.);
#endif
vec4 color_S=getColor(category_S,y);vec2 centerPixelUV_SW=vec2((floor(tex0coord.x*tilePixelSize)+0.5-1.)/tilePixelSize,(floor(tex0coord.y*tilePixelSize)+0.5-1.)/tilePixelSize);int category_SW=0;
#if (USES_CATEGORIES == 1)
category_SW=int((time<0.5 ? texture(tex0,centerPixelUV_SW).<category_channel>: texture(tex1,centerPixelUV_SW).<category_channel>)*255.);
#endif
vec4 color_SW=getColor(category_SW,y);color=blerp(color_SW,color_W,color_S,color_Center,centerPixelUV_SW.x,centerPixelUV_SW.y,centerPixelUV.x,centerPixelUV.y,tex0coord.x,tex0coord.y);}}}else{color=color_Center;}color.a*=opacity;fragColor=color;}`;
const ge = 7;
function $o(n) {
  return n.filter((t, e) => e === 0 || e % 2 || e === n.length - 1);
}
function ao(n, t = 50) {
  if (n.length <= t)
    return n;
  const e = $o(n);
  return ao(e, t);
}
function so(n, t, e = {
  inputName: "v",
  outputName: "c"
}) {
  const o = ao(n);
  let i = "";
  for (let r = 0; r < o.length; r++) {
    const l = o[r];
    r === 0 && (i += `vec4 ${e.outputName}=${$e(l.color)};
`);
    const s = l.value, c = $e(l.color);
    if (t && r + 1 < o.length) {
      const h = o[r + 1].value, d = $e(o[r + 1].color), f = Number.parseFloat((s - h).toFixed(ge)) === 0 ? "0." : `(${e.inputName} - ${s.toFixed(ge)}) / (${(h - s).toFixed(ge)})`;
      i += `${r > 0 ? " else " : ""} if(${e.inputName}>=${s.toFixed(
        ge
      )}&&${e.inputName}<${h.toFixed(ge)}) { ${e.outputName}=mix(${c},${d}, ${f} ); }
`;
    } else
      i += `if(${e.inputName}>=${s.toFixed(ge)})${e.outputName}=${c};
`;
  }
  return i;
}
class co {
  /**
   * @param code Inputs: `vec4 dst`, `vec4 data`. Outputs into `dst`.
   */
  constructor(t, e) {
    this.code = t, this.decode = e, this.decode.min = this.decode.min ?? 0, this.decode.max = this.decode.max ?? 1;
  }
  /**
   * Get the value in the unit interval [0, 1] computed with `.decode.min` and `.decode.max`
   * @param value
   * @returns
   */
  codeValue(t) {
    return (t - this.decode.min) / (this.decode.max - this.decode.min);
  }
  /**
   * Given a value in the unit interval [0, 1] get the real world value bounded by `.decode.min` and `.decode.max`
   * @param value
   * @returns
   */
  decodeValue(t) {
    return this.decode.min + t * (this.decode.max - this.decode.min);
  }
  /**
   * Get real world values of the given pixel (with rgb or rgba in [0, 1]) for the channel(s)
   * specified in `.decode.channel`
   * @param pixel
   * @returns
   */
  decodeChannel(t) {
    if (this.decode.channel.length > 1) {
      const e = this.decodeValue(t[this.decode.channel[0]]), o = this.decodeValue(t[this.decode.channel[1]]);
      return [e, o, Math.sqrt(e * e + o * o)];
    }
    return this.decodeValue(t[this.decode.channel]);
  }
  /**
   * Generate shader/GLSL code for blending
   * @param name
   * @returns
   */
  getBlendCode(t) {
    const e = `${this.code} d.rgb=(d.rgb*d.a*(1.-c.a)+c.rgb*c.a)/(d.a*(1.-c.a)+c.a); d.a=d.a+c.a*(1.-d.a);`;
    return `vec4 ${t}(vec4 d,vec4 data){${e}return d;}`;
  }
  /**
   * Generate shader/GLSL code
   * @param name
   * @returns
   */
  getCode(t) {
    return `vec4 ${t}(vec4 data){${this.code}return c;}`;
  }
}
function uo({ channel: n = "r", min: t = 0, max: e = 1 }) {
  let o = `${t.toFixed(ge)}+data.${n}*${(e - t).toFixed(ge)}`;
  return n.length > 1 && (o = `length(${o})`), `float v=${o};`;
}
class lt extends co {
  /**
   */
  constructor(t) {
    const e = t.decode, o = t.stops || [
      { value: e.min, color: [0, 0, 0, 0] },
      { value: e.max, color: [255, 255, 255, 255] }
    ], i = t.smooth ?? !0, r = t.opacity ?? 1;
    let l = uo(e);
    l += so(o, i), l += `c.a*=${r.toFixed(3)};`, super(l, e);
  }
}
class tr extends co {
  /**
   * .
   */
  constructor(t) {
    const e = t.decode, o = t.color || [255, 255, 255], i = t.opacity ?? 1, r = `${uo(e)} vec4 c=${$e(o)}; c.a*=v*${i.toFixed(3)};`;
    super(r, e);
  }
}
class or {
  constructor(t) {
    // The default polynomial is f(x) = 0x^2 + 1x + 0, or put simply: f(x) = x ,
    // so no transformation is applied to the data.
    u(this, "decode", {
      polynomialCoefDegree2: 0,
      polynomialCoefDegree1: 1,
      polynomialConstant: 0
    });
    // The default arrays of multiple colorstops contains a gradient definition for only one category,
    // groing from black to white on the data range [0, 255]
    u(this, "stopsPerCategory", [
      {
        category: "all",
        stops: [
          { value: 0, color: [0, 0, 0] },
          { value: 255, color: [255, 255, 255] }
        ]
      }
    ]);
    u(this, "smooth");
    u(this, "opacity");
    u(this, "code");
    u(this, "categoryChannel");
    u(this, "valueChannels");
    u(this, "valueNumberOfChannels");
    this.decode = t.decode, this.stopsPerCategory = t.stopsPerCategory, this.smooth = t.smooth ?? !0, this.opacity = t.opacity ?? 1, this.categoryChannel = t.categoryChannel ?? "a", this.valueChannels = t.valueChannels ?? "rgb", this.valueNumberOfChannels = this.valueChannels.length;
    const e = this.stopsPerCategory.filter((l) => {
      if (l.category !== "all" && typeof l.category != "number")
        throw new Error("The category can only be a number or the string 'all'.");
      return l.category === "all";
    });
    let o = this.stopsPerCategory;
    e.length && (o = e);
    const i = o.map((l) => {
      let s = `vec4 _mccf_${l.category}(float v) {
`;
      return s += `${so(l.stops, this.smooth)}`, s += `return c;}
`, s;
    }).join(`
`);
    let r = `vec4 getColor(int category, float v) {
`;
    r += `vec4 outputColor;
`, e.length ? r += `outputColor  = _mccf_all(v);
` : (r += this.stopsPerCategory.map(
      (l, s) => `${s === 0 ? "" : "else "}if (category == ${l.category}) outputColor  = _mccf_${l.category}(v);`
    ).join(`
`), r += `
 else outputColor = vec4(0., 0., 0., 0.);
`), r += `outputColor.a *= ${this.opacity.toFixed(3)};
`, r += `return outputColor;}
`, this.code = Xo.replace("<gradient_function_definitions>", i).replace("<getColor_code>", r).replace("<polynomialCoefDegree2>", this.decode.polynomialCoefDegree2.toFixed(ge)).replace("<polynomialCoefDegree1>", this.decode.polynomialCoefDegree1.toFixed(ge)).replace("<polynomialConstant>", this.decode.polynomialConstant.toFixed(ge)).replace("<uses_categories>", e.length ? "0" : "1").replace("<value_number_channels>", this.valueNumberOfChannels.toFixed()).replaceAll("<category_channel>", this.categoryChannel).replaceAll("<value_channels>", this.valueChannels);
  }
  getCode() {
    return this.code;
  }
  decodeChannel_ORIG(t) {
    const e = {
      r: t.r * 255,
      g: t.g * 255,
      b: t.b * 255,
      a: t.a * 255
    }, o = e.r * 256 * 256 + e.g * 256 + e.b;
    return [this.decode.polynomialCoefDegree2 * o * o + this.decode.polynomialCoefDegree1 * o + this.decode.polynomialConstant, e.a];
  }
  decodeChannel(t) {
    const e = {
      r: t.r * 255,
      g: t.g * 255,
      b: t.b * 255,
      a: t.a * 255
    }, o = this.valueChannels.split("");
    let i = 0;
    return this.valueNumberOfChannels === 1 ? i = e[o[0]] : this.valueNumberOfChannels === 2 ? i = e[o[0]] * 256 + e[o[1]] : this.valueNumberOfChannels === 3 && (i = e[o[0]] * 256 * 256 + e[o[1]] * 256 + e[o[2]]), [this.decode.polynomialCoefDegree2 * i * i + this.decode.polynomialCoefDegree1 * i + this.decode.polynomialConstant, e[this.categoryChannel]];
  }
}
const X = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
}, Zo = {
  1: "The view center is not defined",
  2: "The view resolution is not defined",
  3: "The view rotation is not defined",
  4: "`image` and `src` cannot be provided at the same time",
  5: "`imgSize` must be set when `image` is provided",
  7: "`format` must be set when `url` is set",
  8: "Unknown `serverType` configured",
  9: "`url` must be configured or set using `#setUrl()`",
  10: "The default `geometryFunction` can only handle `Point` geometries",
  11: "`options.featureTypes` must be an Array",
  12: "`options.geometryName` must also be provided when `options.bbox` is set",
  13: "Invalid corner",
  14: "Invalid color",
  15: "Tried to get a value for a key that does not exist in the cache",
  16: "Tried to set a value for a key that is used already",
  17: "`resolutions` must be sorted in descending order",
  18: "Either `origin` or `origins` must be configured, never both",
  19: "Number of `tileSizes` and `resolutions` must be equal",
  20: "Number of `origins` and `resolutions` must be equal",
  22: "Either `tileSize` or `tileSizes` must be configured, never both",
  24: "Invalid extent or geometry provided as `geometry`",
  25: "Cannot fit empty extent provided as `geometry`",
  26: "Features must have an id set",
  27: "Features must have an id set",
  28: '`renderMode` must be `"hybrid"` or `"vector"`',
  30: "The passed `feature` was already added to the source",
  31: "Tried to enqueue an `element` that was already added to the queue",
  32: "Transformation matrix cannot be inverted",
  33: "Invalid units",
  34: "Invalid geometry layout",
  36: "Unknown SRS type",
  37: "Unknown geometry type found",
  38: "`styleMapValue` has an unknown type",
  39: "Unknown geometry type",
  40: "Expected `feature` to have a geometry",
  41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
  42: "Question unknown, the answer is 42",
  43: "Expected `layers` to be an array or a `Collection`",
  47: "Expected `controls` to be an array or an `ol/Collection`",
  48: "Expected `interactions` to be an array or an `ol/Collection`",
  49: "Expected `overlays` to be an array or an `ol/Collection`",
  50: "`options.featureTypes` should be an Array",
  51: "Either `url` or `tileJSON` options must be provided",
  52: "Unknown `serverType` configured",
  53: "Unknown `tierSizeCalculation` configured",
  55: "The {-y} placeholder requires a tile grid with extent",
  56: "mapBrowserEvent must originate from a pointer event",
  57: "At least 2 conditions are required",
  59: "Invalid command found in the PBF",
  60: "Missing or invalid `size`",
  61: "Cannot determine IIIF Image API version from provided image information JSON",
  62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
  64: "Layer opacity must be a number",
  66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
  67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
  68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection",
  69: "`width` or `height` cannot be provided together with `scale`"
};
class Ho extends Error {
  /**
   * @param {number} code Error code.
   */
  constructor(t) {
    const e = Zo[t];
    super(e), this.code = t, this.name = "AssertionError", this.message = e;
  }
}
function Ie(n, t) {
  if (!n)
    throw new Ho(t);
}
function jo(n, t) {
  return n[0] <= t[0] && t[2] <= n[2] && n[1] <= t[1] && t[3] <= n[3];
}
function $t(n, t) {
  const e = n[0], o = n[1], i = n[2], r = n[3], l = t[0], s = t[1];
  let c = X.UNKNOWN;
  return l < e ? c = c | X.LEFT : l > i && (c = c | X.RIGHT), s < o ? c = c | X.BELOW : s > r && (c = c | X.ABOVE), c === X.UNKNOWN && (c = X.INTERSECTING), c;
}
function ho() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function fo(n, t, e, o, i) {
  return i ? (i[0] = n, i[1] = t, i[2] = e, i[3] = o, i) : [n, t, e, o];
}
function Ko(n) {
  return fo(1 / 0, 1 / 0, -1 / 0, -1 / 0, n);
}
function qo(n, t, e, o, i) {
  for (; e < o; e += i)
    Jo(n, t[e], t[e + 1]);
  return n;
}
function Jo(n, t, e) {
  n[0] = Math.min(n[0], t), n[1] = Math.min(n[1], e), n[2] = Math.max(n[2], t), n[3] = Math.max(n[3], e);
}
function mo(n) {
  let t = 0;
  return ti(n) || (t = go(n) * vo(n)), t;
}
function vo(n) {
  return n[3] - n[1];
}
function Qo(n, t) {
  const e = xo(n, t);
  return mo(e);
}
function xo(n, t, e) {
  const o = e || ho();
  return po(n, t) ? (n[0] > t[0] ? o[0] = n[0] : o[0] = t[0], n[1] > t[1] ? o[1] = n[1] : o[1] = t[1], n[2] < t[2] ? o[2] = n[2] : o[2] = t[2], n[3] < t[3] ? o[3] = n[3] : o[3] = t[3]) : Ko(o), o;
}
function ei(n) {
  return [n[0], n[3]];
}
function go(n) {
  return n[2] - n[0];
}
function po(n, t) {
  return n[0] <= t[2] && n[2] >= t[0] && n[1] <= t[3] && n[3] >= t[1];
}
function ti(n) {
  return n[2] < n[0] || n[3] < n[1];
}
function oi(n, t) {
  const e = (n[2] - n[0]) / 2 * (t - 1), o = (n[3] - n[1]) / 2 * (t - 1);
  n[0] -= e, n[2] += e, n[1] -= o, n[3] += o;
}
function ii(n, t, e) {
  let o = !1;
  const i = $t(n, t), r = $t(n, e);
  if (i === X.INTERSECTING || r === X.INTERSECTING)
    o = !0;
  else {
    const l = n[0], s = n[1], c = n[2], h = n[3], d = t[0], f = t[1], v = e[0], x = e[1], E = (x - f) / (v - d);
    let y, w;
    r & X.ABOVE && !(i & X.ABOVE) && (y = v - (x - h) / E, o = y >= l && y <= c), !o && r & X.RIGHT && !(i & X.RIGHT) && (w = x - (v - c) * E, o = w >= s && w <= h), !o && r & X.BELOW && !(i & X.BELOW) && (y = v - (x - s) / E, o = y >= l && y <= c), !o && r & X.LEFT && !(i & X.LEFT) && (w = x - (v - l) * E, o = w >= s && w <= h);
  }
  return o;
}
class So {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(t, e, o, i) {
    this.minX = t, this.maxX = e, this.minY = o, this.maxY = i;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(t) {
    return this.containsXY(t[1], t[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(t) {
    return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(t, e) {
    return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(t) {
    return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(t) {
    t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(t) {
    return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
  }
}
function Be(n, t, e, o, i) {
  return i !== void 0 ? (i.minX = n, i.maxX = t, i.minY = e, i.maxY = o, i) : new So(n, t, e, o);
}
const ri = 42, yo = 256;
function ni(n, t, e) {
  return Math.min(Math.max(n, t), e);
}
function To(n, t) {
  const e = Math.pow(10, t);
  return Math.round(n * e) / e;
}
function dt(n, t) {
  return Math.floor(To(n, t));
}
function mt(n, t) {
  return Math.ceil(To(n, t));
}
function Zt(n, t, e, o) {
  return o !== void 0 ? (o[0] = n, o[1] = t, o[2] = e, o) : [n, t, e];
}
function li(n, t, e, o, i) {
  let r;
  for (t += o; t < e; t += o)
    if (r = i(
      n.slice(t - o, t),
      n.slice(t, t + o)
    ), r)
      return r;
  return !1;
}
function vt(n, t, e, o, i, r) {
  let l = 0, s = n[e - o], c = n[e - o + 1];
  for (; t < e; t += o) {
    const h = n[t], d = n[t + 1];
    c <= r ? d > r && (h - s) * (r - c) - (i - s) * (d - c) > 0 && l++ : d <= r && (h - s) * (r - c) - (i - s) * (d - c) < 0 && l--, s = h, c = d;
  }
  return l !== 0;
}
function ai(n, t, e, o, i) {
  const r = qo(
    ho(),
    n,
    t,
    e,
    o
  );
  return po(i, r) ? jo(i, r) || r[0] >= i[0] && r[2] <= i[2] || r[1] >= i[1] && r[3] <= i[3] ? !0 : li(
    n,
    t,
    e,
    o,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(l, s) {
      return ii(i, l, s);
    }
  ) : !1;
}
function si(n, t, e, o, i) {
  return !!(ai(n, t, e, o, i) || vt(
    n,
    t,
    e,
    o,
    i[0],
    i[1]
  ) || vt(
    n,
    t,
    e,
    o,
    i[0],
    i[3]
  ) || vt(
    n,
    t,
    e,
    o,
    i[2],
    i[1]
  ) || vt(
    n,
    t,
    e,
    o,
    i[2],
    i[3]
  ));
}
function ci(n, t) {
  return n > t ? 1 : n < t ? -1 : 0;
}
function ui(n, t, e) {
  if (n[0] <= t)
    return 0;
  const o = n.length;
  if (t <= n[o - 1])
    return o - 1;
  if (typeof e == "function") {
    for (let i = 1; i < o; ++i) {
      const r = n[i];
      if (r === t)
        return i;
      if (r < t)
        return e(t, n[i - 1], r) > 0 ? i - 1 : i;
    }
    return o - 1;
  }
  if (e > 0) {
    for (let i = 1; i < o; ++i)
      if (n[i] < t)
        return i - 1;
    return o - 1;
  }
  if (e < 0) {
    for (let i = 1; i < o; ++i)
      if (n[i] <= t)
        return i;
    return o - 1;
  }
  for (let i = 1; i < o; ++i) {
    if (n[i] == t)
      return i;
    if (n[i] < t)
      return n[i - 1] - t < t - n[i] ? i - 1 : i;
  }
  return o - 1;
}
function hi(n, t, e) {
  const o = t || ci;
  return n.every(function(i, r) {
    if (r === 0)
      return !0;
    const l = o(n[r - 1], i);
    return !(l > 0 || l === 0);
  });
}
function ot(n, t) {
  return Array.isArray(n) ? n : (t === void 0 ? t = [n, n] : (t[0] = n, t[1] = n), t);
}
const ke = [0, 0, 0], Ce = 5;
class fi {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(t) {
    this.minZoom = t.minZoom !== void 0 ? t.minZoom : 0, this.resolutions_ = t.resolutions, Ie(
      hi(
        this.resolutions_,
        function(i, r) {
          return r - i;
        }
      ),
      17
    );
    let e;
    if (!t.origins) {
      for (let i = 0, r = this.resolutions_.length - 1; i < r; ++i)
        if (!e)
          e = this.resolutions_[i] / this.resolutions_[i + 1];
        else if (this.resolutions_[i] / this.resolutions_[i + 1] !== e) {
          e = void 0;
          break;
        }
    }
    this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = t.origin !== void 0 ? t.origin : null, this.origins_ = null, t.origins !== void 0 && (this.origins_ = t.origins, Ie(this.origins_.length == this.resolutions_.length, 20));
    const o = t.extent;
    o !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = ei(o)), Ie(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      18
    ), this.tileSizes_ = null, t.tileSizes !== void 0 && (this.tileSizes_ = t.tileSizes, Ie(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = t.tileSize !== void 0 ? t.tileSize : this.tileSizes_ ? null : yo, Ie(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      22
    ), this.extent_ = o !== void 0 ? o : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], t.sizes !== void 0 ? this.fullTileRanges_ = t.sizes.map(function(i, r) {
      const l = new So(
        Math.min(0, i[0]),
        Math.max(i[0] - 1, -1),
        Math.min(0, i[1]),
        Math.max(i[1] - 1, -1)
      );
      if (o) {
        const s = this.getTileRangeForExtentAndZ(o, r);
        l.minX = Math.max(s.minX, l.minX), l.maxX = Math.min(s.maxX, l.maxX), l.minY = Math.max(s.minY, l.minY), l.maxY = Math.min(s.maxY, l.maxY);
      }
      return l;
    }, this) : o && this.calculateTileRanges_(o);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(t, e, o) {
    const i = this.getTileRangeForExtentAndZ(t, e);
    for (let r = i.minX, l = i.maxX; r <= l; ++r)
      for (let s = i.minY, c = i.maxY; s <= c; ++s)
        o([e, r, s]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(t, e, o, i) {
    let r, l, s, c = null, h = t[0] - 1;
    for (this.zoomFactor_ === 2 ? (l = t[1], s = t[2]) : c = this.getTileCoordExtent(t, i); h >= this.minZoom; ) {
      if (this.zoomFactor_ === 2 ? (l = Math.floor(l / 2), s = Math.floor(s / 2), r = Be(l, l, s, s, o)) : r = this.getTileRangeForExtentAndZ(
        c,
        h,
        o
      ), e(h, r))
        return !0;
      --h;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(t) {
    return this.origin_ ? this.origin_ : this.origins_[t];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(t) {
    return this.resolutions_[t];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(t, e, o) {
    if (t[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const r = t[1] * 2, l = t[2] * 2;
        return Be(
          r,
          r + 1,
          l,
          l + 1,
          e
        );
      }
      const i = this.getTileCoordExtent(
        t,
        o || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        i,
        t[0] + 1,
        e
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(t, e, o) {
    if (e > this.maxZoom || e < this.minZoom)
      return null;
    const i = t[0], r = t[1], l = t[2];
    if (e === i)
      return Be(
        r,
        l,
        r,
        l,
        o
      );
    if (this.zoomFactor_) {
      const c = Math.pow(this.zoomFactor_, e - i), h = Math.floor(r * c), d = Math.floor(l * c);
      if (e < i)
        return Be(h, h, d, d, o);
      const f = Math.floor(c * (r + 1)) - 1, v = Math.floor(c * (l + 1)) - 1;
      return Be(h, f, d, v, o);
    }
    const s = this.getTileCoordExtent(t, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(s, e, o);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(t, e, o) {
    this.getTileCoordForXYAndZ_(t[0], t[3], e, !1, ke);
    const i = ke[1], r = ke[2];
    this.getTileCoordForXYAndZ_(t[2], t[1], e, !0, ke);
    const l = ke[1], s = ke[2];
    return Be(i, l, r, s, o);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(t) {
    const e = this.getOrigin(t[0]), o = this.getResolution(t[0]), i = ot(this.getTileSize(t[0]), this.tmpSize_);
    return [
      e[0] + (t[1] + 0.5) * i[0] * o,
      e[1] - (t[2] + 0.5) * i[1] * o
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(t, e) {
    const o = this.getOrigin(t[0]), i = this.getResolution(t[0]), r = ot(this.getTileSize(t[0]), this.tmpSize_), l = o[0] + t[1] * r[0] * i, s = o[1] - (t[2] + 1) * r[1] * i, c = l + r[0] * i, h = s + r[1] * i;
    return fo(l, s, c, h, e);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(t, e, o) {
    return this.getTileCoordForXYAndResolution_(
      t[0],
      t[1],
      e,
      !1,
      o
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(t, e, o, i, r) {
    const l = this.getZForResolution(o), s = o / this.getResolution(l), c = this.getOrigin(l), h = ot(this.getTileSize(l), this.tmpSize_);
    let d = s * (t - c[0]) / o / h[0], f = s * (c[1] - e) / o / h[1];
    return i ? (d = mt(d, Ce) - 1, f = mt(f, Ce) - 1) : (d = dt(d, Ce), f = dt(f, Ce)), Zt(l, d, f, r);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(t, e, o, i, r) {
    const l = this.getOrigin(o), s = this.getResolution(o), c = ot(this.getTileSize(o), this.tmpSize_);
    let h = (t - l[0]) / s / c[0], d = (l[1] - e) / s / c[1];
    return i ? (h = mt(h, Ce) - 1, d = mt(d, Ce) - 1) : (h = dt(h, Ce), d = dt(d, Ce)), Zt(o, h, d, r);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(t, e, o) {
    return this.getTileCoordForXYAndZ_(
      t[0],
      t[1],
      e,
      !1,
      o
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(t) {
    return this.resolutions_[t[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(t) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */
  getFullTileRange(t) {
    return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(t, e) {
    const o = ui(
      this.resolutions_,
      t,
      e || 0
    );
    return ni(o, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(t, e) {
    return si(
      e,
      0,
      e.length,
      2,
      this.getTileCoordExtent(t)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(t) {
    const e = this.resolutions_.length, o = new Array(e);
    for (let i = this.minZoom; i < e; ++i)
      o[i] = this.getTileRangeForExtentAndZ(t, i);
    this.fullTileRanges_ = o;
  }
}
const di = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class wo {
  /**
   * @param {Options} options Projection options.
   */
  constructor(t) {
    this.code_ = t.code, this.units_ = /** @type {import("./Units.js").Units} */
    t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || di[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(t) {
    this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(t) {
    this.defaultTileGrid_ = t;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(t) {
    this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(t) {
    this.worldExtent_ = t;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(t) {
    this.getPointResolutionFunc_ = t;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const at = 6378137, Xe = Math.PI * at, mi = [-Xe, -Xe, Xe, Xe], vi = [-180, -85, 180, 85], xt = at * Math.log(Math.tan(Math.PI / 2));
class Ye extends wo {
  /**
   * @param {string} code Code.
   */
  constructor(t) {
    super({
      code: t,
      units: "m",
      extent: mi,
      global: !0,
      worldExtent: vi,
      getPointResolution: function(e, o) {
        return e / Math.cosh(o[1] / at);
      }
    });
  }
}
const Ht = [
  new Ye("EPSG:3857"),
  new Ye("EPSG:102100"),
  new Ye("EPSG:102113"),
  new Ye("EPSG:900913"),
  new Ye("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new Ye("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function xi(n, t, e) {
  const o = n.length;
  e = e > 1 ? e : 2, t === void 0 && (e > 2 ? t = n.slice() : t = new Array(o));
  for (let i = 0; i < o; i += e) {
    t[i] = Xe * n[i] / 180;
    let r = at * Math.log(Math.tan(Math.PI * (+n[i + 1] + 90) / 360));
    r > xt ? r = xt : r < -xt && (r = -xt), t[i + 1] = r;
  }
  return t;
}
function gi(n, t, e) {
  const o = n.length;
  e = e > 1 ? e : 2, t === void 0 && (e > 2 ? t = n.slice() : t = new Array(o));
  for (let i = 0; i < o; i += e)
    t[i] = 180 * n[i] / Xe, t[i + 1] = 360 * Math.atan(Math.exp(n[i + 1] / at)) / Math.PI - 90;
  return t;
}
const pi = 6378137, jt = [-180, -90, 180, 90], Si = Math.PI * pi / 180;
class De extends wo {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(t, e) {
    super({
      code: t,
      units: "degrees",
      extent: jt,
      axisOrientation: e,
      global: !0,
      metersPerUnit: Si,
      worldExtent: jt
    });
  }
}
const Kt = [
  new De("CRS:84"),
  new De("EPSG:4326", "neu"),
  new De("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new De("urn:ogc:def:crs:OGC:2:84"),
  new De("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new De("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new De("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let Vt = {};
function yi(n) {
  return Vt[n] || Vt[n.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function Ti(n, t) {
  Vt[n] = t;
}
let Mt = {};
function Et(n, t, e) {
  const o = n.getCode(), i = t.getCode();
  o in Mt || (Mt[o] = {}), Mt[o][i] = e;
}
function _o(n, t) {
  if (t !== void 0) {
    for (let e = 0, o = n.length; e < o; ++e)
      t[e] = n[e];
    t = t;
  } else
    t = n.slice();
  return t;
}
function wi(n) {
  Ti(n.getCode(), n), Et(n, n, _o);
}
function _i(n) {
  n.forEach(wi);
}
function Ei(n) {
  return yi(
    /** @type {string} */
    n
  );
}
function qt(n) {
  _i(n), n.forEach(function(t) {
    n.forEach(function(e) {
      t !== e && Et(t, e, _o);
    });
  });
}
function Ci(n, t, e, o) {
  n.forEach(function(i) {
    t.forEach(function(r) {
      Et(i, r, e), Et(r, i, o);
    });
  });
}
function Ri() {
  qt(Ht), qt(Kt), Ci(
    Kt,
    Ht,
    xi,
    gi
  );
}
Ri();
function Pi(n) {
  const t = n || {}, e = t.extent || Ei("EPSG:3857").getExtent(), o = {
    extent: e,
    minZoom: t.minZoom,
    tileSize: t.tileSize,
    resolutions: Ai(
      e,
      t.maxZoom,
      t.tileSize,
      t.maxResolution
    )
  };
  return new fi(o);
}
function Ai(n, t, e, o) {
  t = t !== void 0 ? t : ri, e = ot(e !== void 0 ? e : yo);
  const i = vo(n), r = go(n);
  o = o > 0 ? o : Math.max(r / e[0], i / e[1]);
  const l = t + 1, s = new Array(l);
  for (let c = 0; c < l; ++c)
    s[c] = o / Math.pow(2, c);
  return s;
}
class bi {
  constructor() {
    u(this, "allInstances", []);
    u(this, "availableInstances", []);
  }
  /**
   * Add an instance to the pool
   * @param obj
   * @param isAvailable make it available when true (default: false)
   * @returns
   */
  add(t, e = !1) {
    return this.allInstances.push(t), e && this.availableInstances.push(t), t;
  }
  /**
   * Check if there are still available instances in the pool.
   * @returns
   */
  isEmpty() {
    return this.availableInstances.length === 0;
  }
  /**
   * Pops one instance from the pool.
   * @throw when the pool of available instances is empty. Use `.isEmpty()` to test.
   * @returns
   *
   */
  pop() {
    if (this.isEmpty())
      throw new Error("No more instances available ini the pool.");
    return this.availableInstances.pop();
  }
  /**
   * Make all the instances available again
   */
  init() {
    this.availableInstances = this.allInstances.slice();
  }
  /**
   * Remove all elements
   */
  reset() {
    this.availableInstances = [], this.allInstances = [];
  }
}
var Ii = "precision highp float;precision highp sampler2D;COLORING_FRAGMENT_DEFSout vec4 fragColor;uniform float opacity;uniform float zoom;uniform float time;uniform sampler2D tex0;uniform sampler2D tex1;uniform float tilePixelSize;uniform sampler2D texN0;uniform sampler2D texN1;uniform bool availableN;uniform sampler2D texE0;uniform sampler2D texE1;uniform bool availableE;uniform sampler2D texS0;uniform sampler2D texS1;uniform bool availableS;uniform sampler2D texW0;uniform sampler2D texW1;uniform bool availableW;uniform float maxSmoothingDistance;uniform float smoothingDistanceDecayFactor;uniform bool localSmoothing;uniform float zoomDelta;in vec2 tex0coord;in vec2 tex1coord;in vec2 mercCoord;float PI=3.141592;const int halfNbSmoothingBins=int(ceil(float(NB_SMOOTHING_BINS))/2.);void textPositionToInternalTexPosition(vec2 uv,out vec2 newUv,out int texturePositionIndex){if(uv.x>=0.&&uv.x<=1.){if(uv.y>=0.&&uv.y<=1.){newUv=uv;texturePositionIndex=0;}else if(uv.y<0.&&availableS){newUv=vec2(uv.x,1.+uv.y);texturePositionIndex=5;}else if(uv.y>1.&&availableN){newUv=vec2(uv.x,1.-uv.y);texturePositionIndex=1;}else{newUv=uv;texturePositionIndex=0;}}else if(uv.x<0.){if(uv.y>=0.&&uv.y<=1.&&availableW){newUv=vec2(1.+uv.x,uv.y);texturePositionIndex=7;}else{newUv=uv;texturePositionIndex=0;}}else if(uv.x>1.){if(uv.y>=0.&&uv.y<=1.&&availableE){newUv=vec2(uv.x-1.,uv.y);texturePositionIndex=3;}else{newUv=uv;texturePositionIndex=0;}}}vec4 getTextureColorByIndex(int textureTimeIndex,int texturePositionIndex,vec2 uv){if(textureTimeIndex==0){if(texturePositionIndex==0){return texture(tex0,uv);}else if(texturePositionIndex==1){return texture(texN0,uv);}else if(texturePositionIndex==3){return texture(texE0,uv);}else if(texturePositionIndex==5){return texture(texS0,uv);}else if(texturePositionIndex==7){return texture(texW0,uv);}}else if(textureTimeIndex==1){if(texturePositionIndex==0){return texture(tex1,uv);}else if(texturePositionIndex==1){return texture(texN1,uv);}else if(texturePositionIndex==3){return texture(texE1,uv);}else if(texturePositionIndex==5){return texture(texS1,uv);}else if(texturePositionIndex==7){return texture(texW1,uv);}}else{return vec4(1.,0.,0.,1.);}}vec4 getColor(int textureTimeIndex,vec2 uv){int texturePositionIndex=0;vec2 localUV=vec2(0.,0.);textPositionToInternalTexPosition(uv,localUV,texturePositionIndex);return getTextureColorByIndex(textureTimeIndex,texturePositionIndex,localUV);}vec4 circularSampleSmoothing(int textureTimeIndex,vec2 uv,float resolution,float distance,out bool isTransparant){vec4 colorRGBA=getColor(textureTimeIndex,uv);int weightCenter=3;vec4 color=colorRGBA*float(weightCenter);isTransparant=colorRGBA.a<1.;float angularStep=2.*PI/float(halfNbSmoothingBins);for(int i=0;i<halfNbSmoothingBins;i++){float angle=angularStep*float(i);vec2 offset=vec2(cos(angle),sin(angle))*distance*0.5;vec2 pos=uv+offset/resolution;vec4 c=getColor(textureTimeIndex,pos);color+=c;isTransparant=isTransparant||c.a<1.;angle=angularStep/2.+angularStep*float(i);offset=vec2(cos(angle),sin(angle))*distance;pos=uv+offset/resolution;c=getColor(textureTimeIndex,pos);color+=c;isTransparant=isTransparant||c.a<1.;}return color/float(2*halfNbSmoothingBins+weightCenter);}void main(){float scaledSamplingDistance=(maxSmoothingDistance*smoothingDistanceDecayFactor/(smoothingDistanceDecayFactor+zoom))*max(1.,2.-zoomDelta);bool isTransparant0=false;bool isTransparant1=false;vec4 tex0Color;vec4 tex1Color;if(localSmoothing&&halfNbSmoothingBins!=0){tex0Color=circularSampleSmoothing(0,tex0coord,tilePixelSize,scaledSamplingDistance,isTransparant0);tex1Color=circularSampleSmoothing(1,tex1coord,tilePixelSize,scaledSamplingDistance,isTransparant1);}else{tex0Color=texture(tex0,tex0coord);tex1Color=texture(tex1,tex1coord);}vec4 inter=mix(tex0Color,tex1Color,time);if(inter.a<1.0&&!RENDER_TRANSPARENT)discard;COLORING_FRAGMENT_CALLSfragColor.a*=opacity;}", Mi = "precision highp float;precision highp sampler2D;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;in vec3 position;in vec2 uv;uniform vec2 tex0xy;uniform vec2 tex1xy;uniform float tex0size;uniform float tex1size;out vec2 tex0coord;out vec2 tex1coord;out vec2 mercCoord;void main(){tex0coord=tex0xy+uv*tex0size;tex1coord=tex1xy+uv*tex1size;mercCoord=(modelViewMatrix*vec4(position,1.0)).xy*vec2(1.0,-1.0);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}", Fi = "precision highp float;precision highp int;precision highp sampler2D;uniform sampler2D imageA;uniform sampler2D imageB;uniform float mixValue;in vec2 vUv;out vec4 fragColor;void main(){fragColor=mix(texture(imageA,vUv),texture(imageB,vUv),mixValue);}", Jt = "precision highp float;precision highp int;precision highp sampler2D;uniform vec2 direction;uniform int kernelSize;uniform sampler2D imgToBlur;in vec2 vUv;out vec4 fragColor;vec4 blur5(sampler2D image,vec2 uv,vec2 resolution,vec2 direction){vec4 color=vec4(0.0);vec2 off1=vec2(1.3333333333333333)*direction;color+=texture(image,uv)*0.29411764705882354;color+=texture(image,uv+(off1/resolution))*0.35294117647058826;color+=texture(image,uv-(off1/resolution))*0.35294117647058826;return color;}vec4 blur9(sampler2D image,vec2 uv,vec2 resolution,vec2 direction){vec4 color=vec4(0.0);vec2 off1=vec2(1.3846153846)*direction;vec2 off2=vec2(3.2307692308)*direction;color+=texture(image,uv)*0.2270270270;color+=texture(image,uv+(off1/resolution))*0.3162162162;color+=texture(image,uv-(off1/resolution))*0.3162162162;color+=texture(image,uv+(off2/resolution))*0.0702702703;color+=texture(image,uv-(off2/resolution))*0.0702702703;return color;}vec4 blur13(sampler2D image,vec2 uv,vec2 resolution,vec2 direction){vec4 color=vec4(0.0);vec2 off1=vec2(1.411764705882353)*direction;vec2 off2=vec2(3.2941176470588234)*direction;vec2 off3=vec2(5.176470588235294)*direction;color+=texture(image,uv)*0.1964825501511404;color+=texture(image,uv+(off1/resolution))*0.2969069646728344;color+=texture(image,uv-(off1/resolution))*0.2969069646728344;color+=texture(image,uv+(off2/resolution))*0.09447039785044732;color+=texture(image,uv-(off2/resolution))*0.09447039785044732;color+=texture(image,uv+(off3/resolution))*0.010381362401148057;color+=texture(image,uv-(off3/resolution))*0.010381362401148057;return color;}vec4 blur19(sampler2D image,vec2 uv,vec2 resolution,vec2 direction){vec4 color=vec4(0.0);vec2 off1=vec2(1.434782608695652)*direction;vec2 off2=vec2(3.347826086956522)*direction;vec2 off3=vec2(5.260869565217392)*direction;vec2 off4=vec2(7.173913043478261)*direction;color+=texture(image,uv)*0.16818993967466953;color+=texture(image,uv+(off1/resolution))*0.2727695816518679;color+=texture(image,uv-(off1/resolution))*0.2727695816518679;color+=texture(image,uv+(off2/resolution))*0.11690124927937194;color+=texture(image,uv-(off2/resolution))*0.11690124927937194;color+=texture(image,uv+(off3/resolution))*0.024067904263400105;color+=texture(image,uv-(off3/resolution))*0.024067904263400105;color+=texture(image,uv+(off4/resolution))*0.0021112196722280793;color+=texture(image,uv-(off4/resolution))*0.0021112196722280793;return color;}void main(){vec4 color=vec4(1.,0,0,1.);vec2 textureResolution=vec2(textureSize(imgToBlur,0));if(kernelSize==5){color=blur5(imgToBlur,vUv,textureResolution,direction);}else if(kernelSize==9){color=blur9(imgToBlur,vUv,textureResolution,direction);}else if(kernelSize==13){color=blur13(imgToBlur,vUv,textureResolution,direction);}else if(kernelSize==19){color=blur19(imgToBlur,vUv,textureResolution,direction);}fragColor=color;}", Ni = "precision highp float;precision highp int;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;in vec3 position;in vec2 uv;out vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}", zi = "precision highp float;precision highp int;precision highp sampler2D;in vec2 vUv;out vec4 fragColor;void main(){fragColor=vec4(1.,0.,0.,1.);}";
let Ft = null;
function Di() {
  return Ft || (Ft = new zo({
    alpha: !0,
    premultipliedAlpha: !1
  })), Ft;
}
class Nt {
  /**
   *
   * @param width width of the output
   * @param height height of the output
   * @param renderer optional existing renderer to use
   */
  constructor(t, e, o = Di()) {
    u(this, "renderer");
    //= new WebGLRenderer();
    u(this, "camera", new Ro(-1, 1, 1, -1, 0, 1));
    u(this, "scene", new Po());
    u(this, "renderTarget");
    u(this, "material", new Ao({
      glslVersion: bo,
      vertexShader: Ni,
      fragmentShader: zi,
      depthWrite: !1,
      transparent: !0
    }));
    u(this, "size");
    this.size = new Io(t, e), this.renderTarget = new kt(t, e, {
      minFilter: ft,
      magFilter: ft,
      format: bt
    }), this.camera.matrixAutoUpdate = !1, this.renderer = o, this.renderer.setPixelRatio(1), this.renderer.autoClear = !1;
    const i = new Mo(new Fo(2, 2), this.material);
    this.scene.add(i);
  }
  /**
   * Get the output texture
   * @param forceDataTexture Makes a deep copy of the texture data to return a `THREE.DataTexture`. This is much slower
   * but allows this instance to be disposed while keeping a copy of the texture.
   * @returns
   */
  getOutputTexture(t = !1) {
    return t ? new No(this.getPixelData(), this.size.x, this.size.y, bt) : this.renderTarget.texture;
  }
  /**
   * Set the size of the output
   * @param width
   * @param height
   * @returns
   */
  setSize(t, e) {
    t === this.size.x && e === this.size.y || (this.size.x = t, this.size.y = e, this.renderTarget = new kt(t, e, {
      minFilter: ft,
      magFilter: ft,
      format: bt
    }), this.renderer.setRenderTarget(this.renderTarget));
  }
  /**
   * Set the vertex shader for this pass
   * @param shader
   */
  setVertexShader(t) {
    this.material.vertexShader = t.trim(), this.material.needsUpdate = !0;
  }
  /**
   * Set the fragment shader for this pass
   * @param shader
   */
  setFragmentShader(t) {
    this.material.fragmentShader = t.trim(), this.material.needsUpdate = !0;
  }
  /**
   * Add a uniform
   * @param name
   * @param value
   */
  setUniform(t, e) {
    this.material.uniforms[t] = { value: e };
  }
  /**
   * Dynamically replace some string in a shader (`name`) by others (`value`)
   * @param name
   * @param value
   */
  setDefine(t, e) {
    this.material.fragmentShader = this.material.fragmentShader.replace(new RegExp(t, "g"), e.toString()), this.material.vertexShader = this.material.vertexShader.replace(new RegExp(t, "g"), e.toString()), this.material.needsUpdate = !0;
  }
  /**
   * Retrieve the pixel data as a single dimension array of RGBA.
   * This can be slow because of memory transfer from GPU to CPU
   */
  getPixelData() {
    const t = this.size, e = new Uint8Array(t.x * t.y * 4);
    return this.renderer.readRenderTargetPixels(this.renderTarget, 0, 0, t.x, t.y, e), e;
  }
  /**
   * Get the defined size of the output
   * @returns
   */
  getSize() {
    return this.size.clone();
  }
  /**
   * Run the shader code. The result is then stored internaly in a `THREE.RenderTarget`
   * @returns
   */
  process() {
    return this.material.needsUpdate = !0, this.renderer.setRenderTarget(this.renderTarget), this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.renderTarget.texture;
  }
  /**
   * Opens the output image in a separate window for debugging purposes.
   */
  debugAsPNG() {
    const t = this.getSize(), e = this.getPixelData(), o = document.createElement("canvas");
    o.width = t.x, o.height = t.y;
    const i = o.getContext("2d");
    if (!i)
      return;
    const r = i.getImageData(0, 0, o.width, o.height);
    r.data.set(e), i.putImageData(r, 0, 0);
    const l = window.open();
    l && l.document.write(
      `<iframe src="${o.toDataURL(
        "image/png"
      )}" frameborder="0" style="border:0; top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen></iframe>`
    );
  }
  /**
   * Free the render target memory
   */
  dispose() {
    this.renderTarget.texture.dispose(), this.renderTarget.dispose();
  }
}
class Oi {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(t) {
    this.highWaterMark = t !== void 0 ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(t) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(t) {
    return this.entries_.hasOwnProperty(t);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(t) {
    let e = this.oldest_;
    for (; e; )
      t(e.value_, e.key_, this), e = e.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(t, e) {
    const o = this.entries_[t];
    return Ie(o !== void 0, 15), o === this.newest_ || (o === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (o.newer.older = o.older, o.older.newer = o.newer), o.newer = null, o.older = this.newest_, this.newest_.newer = o, this.newest_ = o), o.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(t) {
    const e = this.entries_[t];
    return Ie(e !== void 0, 15), e === this.newest_ ? (this.newest_ = /** @type {Entry} */
    e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const t = new Array(this.count_);
    let e = 0, o;
    for (o = this.newest_; o; o = o.older)
      t[e++] = o.key_;
    return t;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const t = new Array(this.count_);
    let e = 0, o;
    for (o = this.newest_; o; o = o.older)
      t[e++] = o.value_;
    return t;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T} Value.
   */
  peek(t) {
    if (this.containsKey(t))
      return this.entries_[t].value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const t = this.oldest_;
    return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(t, e) {
    this.get(t), this.entries_[t].value_ = e;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(t, e) {
    Ie(!(t in this.entries_), 16);
    const o = {
      key_: t,
      newer: null,
      older: this.newest_,
      value_: e
    };
    this.newest_ ? this.newest_.newer = o : this.oldest_ = o, this.newest_ = o, this.entries_[t] = o, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(t) {
    this.highWaterMark = t;
  }
}
const zt = "api.maptiler.com", it = {
  maptilerApiHost: zt,
  // we use a mockup:
  endpoint: `https://${zt}/weather/latest.json`,
  tileSourceUrlSchema: `https://${zt}/tiles/{tileset_id}/{zxy}.{format}`
};
Object.freeze(it);
class Ui {
  /**
   *
   * @param url The URL must have a pattern such as `https://api.maptiler.com/tiles/something/{zxy}.png`
   * @param onTileLoad
   */
  constructor(t, e) {
    u(this, "loader", new T.TextureLoader());
    u(this, "lru", new Oi(32));
    u(this, "apiKey", "");
    u(this, "sessionId", "");
    this.url = t, this.onTileLoad = e;
  }
  setMaptilerParams(t, e) {
    this.apiKey = t, this.sessionId = e;
  }
  urlPatternToUrl(t) {
    let e;
    try {
      e = new URL(this.url.replace("{zxy}", t));
    } catch {
      e = new URL(this.url.replace("{zxy}", t), document.baseURI);
    }
    return e.host === it.maptilerApiHost && (this.apiKey && !e.searchParams.has("key") && e.searchParams.append("key", this.apiKey), this.sessionId && !e.searchParams.has("mtsid") && e.searchParams.append("mtsid", this.sessionId)), e.href;
  }
  /**
   * Get a tile from its ID.
   * Retrieves the tile from cache if present, otherwise loads it and adds it to cache
   * @param zxy of shape `"z/x/y"`, for example `"0/0/0"`
   * @param load
   * @returns
   */
  getTile(t, e) {
    if (t.split("/").map((i) => Number.parseInt(i)).some((i) => i < 0)) return null;
    if (this.lru.containsKey(t))
      return this.lru.get(t);
    if (e) {
      const i = this.createTile(t);
      return this.lru.set(t, i), i;
    }
    return null;
  }
  /**
   * Loads a tile and adds it to cache. When created `.ready` is `false` but when the loading callback
   * is successful, it is turned to `true`. Due to this asynchronous behaviour, the `Tile`returned by
   * this function will always have its `.ready`attribute to false.
   *
   * @param zxy of shape `"z/x/y"`, for example `"0/0/0"`
   * @returns
   */
  createTile(t) {
    const e = this.urlPatternToUrl(t), o = {
      ready: !1,
      texture: null,
      zxy: t
    };
    return o.texture = this.loader.load(
      e,
      () => {
        o.ready = !0, this.onTileLoad != null && this.onTileLoad(o, e, null);
      },
      // on progress callback (deprecated)
      void 0,
      // On load fail callback
      (i) => {
        this.onTileLoad != null && this.onTileLoad(o, e, i);
      }
    ), o.texture.minFilter = T.LinearFilter, o.texture.needsUpdate = !0, o;
  }
  /**
   * Frees the GPU related resources allocated by a texture. See [Texture.dispose() on ThreeJS](https://threejs.org/docs/?q=texture#api/en/textures/Texture.dispose).
   * @param tile
   */
  disposeTile(t) {
    t.texture && t.texture.dispose();
  }
  /**
   * Dispose all the Tiles that are overflowing the size of the cache, except the ones provided in argument.
   * @param usedTiles
   */
  expireCache(t) {
    for (; this.lru.canExpireCache() && !(this.lru.peekLast().zxy in t); )
      this.disposeTile(this.lru.pop());
  }
  /**
   * Dispose all the tiles from the cache (clearing the cache)
   */
  dispose() {
    for (const t of this.lru.getValues())
      this.disposeTile(t);
    this.lru.clear();
  }
}
class Li extends Do {
  constructor() {
    super(...arguments);
    u(this, "frames", []);
    u(this, "time", 0);
    u(this, "animationSpeed", 0);
    u(this, "lastTickTime", 0);
  }
  /**
   * Add a new TimeFrame information to the animation. If the frame container is not empty,
   * then the provided TimeFrame data will be added at the corresct position based on its time.
   * @param time
   * @param data
   */
  addFrame(e, o) {
    const i = this.findSmallerFrameIndex(e);
    if (i < 0)
      this.frames.unshift({
        time: e,
        data: o
      });
    else {
      if (this.frames[i].time === e)
        throw new Error("Frame with this time already exists");
      this.frames.splice(i + 1, 0, {
        time: e,
        data: o
      });
    }
    this.clampAnimation();
  }
  /**
   * Remove a frame using its time as an ID
   * @param time
   * @returns
   */
  removeFrame(e) {
    const o = this.frames.filter((i) => i.time === e);
    return this.frames = this.frames.filter((i) => i.time !== e), this.clampAnimation(), o;
  }
  /**
   * Call a function for each TimeFrame of the animation
   * @param action
   */
  forEachFrame(e) {
    for (const o of this.frames)
      e(o);
  }
  /**
   * Get the time of the first TimeFrame (always the begining of the animation).
   * If the frame container is empty, returns Infinity
   */
  getAnimationStart() {
    return this.frames.length ? this.frames[0].time : Number.POSITIVE_INFINITY;
  }
  /**
   * Get the animation start as a Date object
   * @returns
   */
  getAnimationStartDate() {
    return new Date(this.getAnimationStart() * 1e3);
  }
  /**
   * Get the end time of the animation or -Infinity if empty.
   */
  getAnimationEnd() {
    return this.frames.length ? this.frames[this.frames.length - 1].time : Number.NEGATIVE_INFINITY;
  }
  /**
   * Get the animation end as a date object
   * @returns
   */
  getAnimationEndDate() {
    return new Date(this.getAnimationEnd() * 1e3);
  }
  /**
   * Get the current time of the animation
   */
  getAnimationTime() {
    return this.time;
  }
  /**
   * Get the current time of the animation as a Date object
   * @returns
   */
  getAnimationTimeDate() {
    return new Date(this.getAnimationTime() * 1e3);
  }
  /**
   * Change the visualization to a specific time. Does not stop animation.
   */
  setAnimationTime(e) {
    this.time = e, this.clampAnimation(), this.emit("animationTimeSet", {
      time: this.time
    });
  }
  clampAnimation() {
    this.time = Math.max(this.getAnimationStart(), Math.min(this.getAnimationEnd(), this.time));
  }
  /**
   * Animate by a factor of real life speed.
   * Exampe, if `factor` is `10`, then the animation will play at 10 times the real life speed.
   * @param factor
   */
  animateByFactor(e) {
    this.animate(e);
  }
  /**
   * Changes the speed of the animation. `0` to stop.
   * The speed is in number of real world milliseconds per animation second.
   * Example: if timePerSecond is set to 10*1000, then the animation will run
   * 10x of real world speed.
   */
  animate(e) {
    e > 0 && this.animationSpeed === 0 ? this.emit("playAnimation", {
      time: this.time
    }) : e === 0 && this.animationSpeed > 0 && this.emit("pauseAnimation", {
      time: this.time
    }), this.animationSpeed = e, this.animationSpeed !== 0 && (this.lastTickTime = performance.now());
  }
  /**
   * Get the speed of the animation.
   * The speed is in number of real world seconds per animation second.
   */
  getAnimationSpeed() {
    return this.animationSpeed;
  }
  /**
   * Tells whether the animation is currently playing
   * @returns
   */
  isPlaying() {
    return this.animationSpeed > 0;
  }
  /**
   * Make the animation time progress based on the current timestamps.
   */
  animationTick() {
    const e = performance.now();
    if (this.animationSpeed > 0 && this.lastTickTime) {
      const o = e - this.lastTickTime;
      this.time += this.animationSpeed * (o / 1e3);
      const i = this.getAnimationStart(), r = this.getAnimationEnd();
      this.time = i + (this.time - i) % (r - i), Number.isNaN(this.time) && (this.time = i), this.emit("tick", {
        time: this.time
      });
    }
    this.lastTickTime = e;
  }
  /**
   * Find the index of TimeFrame whose time is just immediately below targetTime
   * @param targetTime
   * @returns
   */
  findSmallerFrameIndex(e) {
    for (let o = this.frames.length - 1; o >= 0; --o)
      if (this.frames[o].time <= e)
        return o;
    return -1;
  }
  /**
   * Based on the current animation time, retrieve the frame immediately before (frameA),
   * the frame immediately after (frameB) and the mix.
   * The mixe value is in the interval [0, 1], where close to `0` means the current time
   * is close to frameA and close to `1` means the current time is close to frameB. The mix
   * value is provided so that linear interpolation of data can be performed.
   * @returns
   */
  getCurrentFrames() {
    if (this.frames.length === 0)
      return {
        frameA: null,
        frameB: null,
        mix: 0
      };
    let e = this.findSmallerFrameIndex(this.time);
    e < 0 && (e = 0);
    const o = this.frames[e], i = this.frames[Math.min(this.frames.length - 1, e + 1)], r = i.time - o.time, l = r === 0 ? 0 : (this.time - o.time) / r;
    return {
      frameA: o,
      frameB: i,
      mix: l
    };
  }
  /**
   * Providing a TimeFrame (time + data), get the TimeFrame from the annimation that is
   * directly after (when `direction` is positive) or immediately before (when `direction` is negative)
   * @param frame
   * @param direction
   * @returns
   */
  getNextFrame(e, o) {
    const i = this.frames.findIndex((r) => r === e);
    return i < 0 ? null : o < 0 ? i > 0 ? this.frames[i - 1] : null : i < this.frames.length - 1 ? this.frames[i + 1] : null;
  }
}
const Oe = {
  GFS_TEMPERATURE_2M: "temperature-2m:gfs",
  GFS_PRESSURE_MSL: "pressure-msl:gfs",
  GFS_PRECIPITATION_1H: "precipitation-1h:gfs",
  GFS_FROZEN_PRECIPITATION_PERCENT: "frozen_precipitation-1h:gfs",
  GFS_WIND_10M: "wind-10m:gfs",
  GFS_RADAR_COMPOSITE: "radar-composite:gfs",
  GFS_CLOUD_COVER_TOTAL: "cloud_cover-total:gfs"
}, gt = {
  latest: null
};
class F {
  static async fetchLatest(t, e) {
    const o = `${it.endpoint}?key=${t}&mtsid=${e}`, i = await fetch(o, { cache: "no-store" });
    gt.latest = await i.json();
  }
  static getDataForWeatherVariableID(t) {
    if (!gt.latest)
      return null;
    const e = gt.latest.variables.filter(
      (o) => o.metadata.weather_variable.variable_id === t
    );
    return e.length ? e[0] : null;
  }
  static hasData() {
    return !!gt.latest;
  }
  static getTemperatureData() {
    return F.getDataForWeatherVariableID(Oe.GFS_TEMPERATURE_2M);
  }
  static getPressureData() {
    return F.getDataForWeatherVariableID(Oe.GFS_PRESSURE_MSL);
  }
  static getPrecipitationData() {
    return F.getDataForWeatherVariableID(Oe.GFS_PRECIPITATION_1H);
  }
  static getCloudCoverData() {
    return F.getDataForWeatherVariableID(Oe.GFS_CLOUD_COVER_TOTAL);
  }
  static getFrozenPrecipitationData() {
    return F.getDataForWeatherVariableID(Oe.GFS_FROZEN_PRECIPITATION_PERCENT);
  }
  static getRadarData() {
    return F.getDataForWeatherVariableID(Oe.GFS_RADAR_COMPOSITE);
  }
  static getWindData() {
    return F.getDataForWeatherVariableID(Oe.GFS_WIND_10M);
  }
  static getSourcesAndTimestamps(t, e, o) {
    return t.keyframes.map((i) => ({
      source: `${it.tileSourceUrlSchema.replace("{tileset_id}", i.id).replace("{format}", t.tile_format)}?key=${e}&mtsid=${o}`,
      timestamp: +new Date(i.timestamp) / 1e3
      // timestamp is given in seconds
    }));
  }
}
class st extends Li {
  /**
   *
   * @param id Unique identifier of the layer in the map.
   * @param options
   * @param coloringFragments
   */
  constructor(e, o, i = null, r = null) {
    super();
    u(this, "id");
    u(this, "type", "custom");
    u(this, "renderingMode", "3d");
    // In 2d mode certain layer types can't be interlaced
    /**
     * Camera used to render the tiles
     */
    u(this, "camera", new T.Camera());
    /**
     * Scene to add the tiles to
     */
    u(this, "scene", new T.Scene());
    /**
     * Array of array of Tiles (plane geometry meshes)
     */
    u(this, "slippyTiles", []);
    /**
     * Instance of MapTiler SDK map
     */
    u(this, "map", null);
    /**
     * Renderer to render the tiles
     */
    u(this, "renderer", null);
    /**
     * The shader material of the tiles (with uniforms such as textures, time, etc.)
     */
    u(this, "material");
    /**
     * The plane geometry used for all the tiles
     */
    u(this, "geometry", new T.PlaneGeometry(1, 1));
    /**
     * TODO
     */
    u(this, "flusher");
    /**
     * A TileGrid (from OL) that contains some tile logic such as mercator to index, etc.
     */
    u(this, "tilegrid");
    /**
     * Extent as in OL
     */
    u(this, "extent", null);
    /**
     * Indicated whether the the function `map.triggerRepaint()` should be called
     * when the animation is paused.
     */
    u(this, "repaintOnPausedAnimation", !0);
    /**
     * Manages a pool of rawshadermaterial to reuse, rather cloning endlessly
     */
    u(this, "materialPool", new bi());
    u(this, "bluringNodePasses", []);
    // will be instanciated when we know the tile size
    u(this, "tileThreeContainer", new T.Object3D());
    /**
     * ratio to wich the extent is enlarged when using the method `.getVisibleExtent()`
     */
    u(this, "extentScale", 1);
    /**
     * The event `"extentChanged"` is emitted when the intersection-over-union ration from the former extent to the new
     * is below this.extentChangedThreshold
     */
    u(this, "extentChangedThreshold", 0.75);
    u(this, "lastExtent", [0, 0, 0, 0]);
    u(this, "timeInterpolation", !0);
    u(this, "isReady", !1);
    u(this, "defaultTexture", new T.DataTexture(
      new Uint8Array([128, 128, 128, 255]),
      1,
      1,
      T.RGBAFormat
    ));
    u(this, "onMoveEndListener");
    u(this, "onResizeListener");
    u(this, "onMoveListener");
    u(this, "coloringFragments", null);
    u(this, "multiChannelColoringFragment");
    u(this, "loadLowerZoomLevels");
    u(this, "interpolateTileEdge", !1);
    u(this, "getMapOrThrow", () => {
      if (this.map == null)
        throw new Error("Accessing map on detached layer");
      return this.map;
    });
    u(this, "getRendererOrThrow", () => {
      if (this.renderer == null)
        throw new Error("Accessing renderer on detached layer");
      return this.renderer;
    });
    this.defaultTexture.needsUpdate = !0, this.id = e, o && this.init(o, i, r);
  }
  init(e, o = null, i = null) {
    this.interpolateTileEdge = e.interpolateTileEdge ?? !1, this.loadLowerZoomLevels = e.loadLowerZoomLevels ?? !0, this.coloringFragments = o, this.multiChannelColoringFragment = i, this.repaintOnPausedAnimation = e.repaintOnPausedAnimation ?? !0, this.onMoveEndListener = this.onMoveEnd.bind(this), this.onResizeListener = this.onResize.bind(this), this.onMoveListener = this.onMove.bind(this), this.tilegrid = Pi({
      minZoom: e.minZoom ?? 0,
      maxZoom: e.maxZoom ?? 4
    }), e.bounds && (this.extent = Qe(e.bounds[0], e.bounds[1]).concat(Qe(e.bounds[2], e.bounds[3])));
    let r = "";
    if (this.coloringFragments) {
      const s = this.coloringFragments.map((h, d) => h.getBlendCode(`_cf_${d}`));
      let c = "fragColor";
      for (let h = 0; h < this.coloringFragments.length; h++)
        c = `_cf_${h}(${c},inter)`;
      c = `fragColor=${c};`, r = Ii.replace("COLORING_FRAGMENT_DEFS", s.join(`
`)).replace(
        "COLORING_FRAGMENT_CALLS",
        c
      );
    } else i && (r = i.getCode());
    const l = (e.nbSmoothingBins ?? 16).toFixed(0);
    this.timeInterpolation = e.timeInterpolation ?? !0, this.material = new T.RawShaderMaterial({
      glslVersion: T.GLSL3,
      uniforms: {
        opacity: { value: 1 },
        time: { value: 0 },
        zoom: { value: 0 },
        tex0xy: { value: [0, 0] },
        tex1xy: { value: [0, 0] },
        tex0size: { value: 1 },
        tex1size: { value: 1 },
        tilePixelSize: { value: 1 },
        categorySmoothTransition: {
          value: e.categorySmoothTransition ?? !1
        },
        timeInterpolation: { value: this.timeInterpolation },
        tex0: {
          value: null
        },
        tex1: {
          value: null
        },
        zoomDelta: { value: 0 },
        localSmoothing: { value: e.localSmoothing ?? !1 },
        maxSmoothingDistance: { value: e.maxSmoothingDistance ?? 12 },
        smoothingDistanceDecayFactor: {
          value: e.smoothingDistanceDecayFactor ?? 10
        },
        // Tile texture around the current one.
        // Used when smoothing is enabled
        texN0: { value: this.defaultTexture },
        texN1: { value: this.defaultTexture },
        availableN: { value: !1 },
        texE0: { value: this.defaultTexture },
        texE1: { value: this.defaultTexture },
        availableE: { value: !1 },
        texS0: { value: this.defaultTexture },
        texS1: { value: this.defaultTexture },
        availableS: { value: !1 },
        texW0: { value: this.defaultTexture },
        texW1: { value: this.defaultTexture },
        availableW: { value: !1 },
        interpolateTileEdge: { value: this.interpolateTileEdge }
      },
      vertexShader: Mi,
      fragmentShader: r,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      defines: {
        RENDER_TRANSPARENT: e.renderTransparentArea ? "true" : "false",
        NB_SMOOTHING_BINS: l
      }
    }), this.flusher = new T.Mesh(
      new T.PlaneGeometry(1, 1),
      new T.MeshBasicMaterial({
        colorWrite: !1,
        depthWrite: !1
      })
    ), this.flusher.frustumCulled = !1, this.scene.add(this.flusher), this.scene.add(this.tileThreeContainer), this.updateSlippyTileGrid(8, 8), this.on("playAnimation", () => {
      this.forceRepaint();
    }), this.on("animationTimeSet", () => {
      this.forceRepaint();
    }), this.isReady = !0;
  }
  /**
   * Remove the current tiles of the tile grid from the scene and reinstanciate them all
   * (three.Mesh) based onthe arguments, then add them to the scene again.
   * Note: The tils positions are not updated yet, this is performed by `.updateSlippyTile()`
   * @param width
   * @param height
   */
  updateSlippyTileGrid(e, o) {
    this.tileThreeContainer.clear(), this.slippyTiles.length = 0;
    for (let i = 0; i < e; i++) {
      this.slippyTiles[i] = [];
      for (let r = 0; r < o; r++) {
        const l = new T.Mesh(this.geometry);
        l.frustumCulled = !1, this.slippyTiles[i][r] = l, this.tileThreeContainer.add(l);
      }
    }
  }
  validateSource(e) {
    let o;
    try {
      o = new URL(e);
    } catch {
      o = new URL(e, document.baseURI);
    }
    if (o.host !== it.maptilerApiHost)
      throw new Error(
        `

MapTiler Weather library can only source data from MapTiler Cloud.
Please use our MapTiler Plus library for self hosting: https://www.maptiler.com/weather/
or host your data with our generous free plan at MapTiler Cloud: https://cloud.maptiler.com
`
      );
  }
  /**
   * Adds another frame to the animation.
   * @param time Time of the data in this frame. Should be unique.
   * @param url URL to the tiles. Expected to have `{zxy}` placeholder to be dynamically replaced with `z/x/y` coordinates.
   */
  addSource(e, o, i = null) {
    this.validateSource(o);
    const r = new Ui(o, (l, s, c) => {
      i && i(l, s, c), this.forceRepaint();
    });
    if (this.map) {
      const l = this.map.getSdkConfig().apiKey, s = this.map.getMaptilerSessionId();
      r.setMaptilerParams(l, s);
    }
    super.addFrame(e, r);
  }
  /**
   * Removes frame
   */
  removeSource(e) {
    const o = super.removeFrame(e);
    for (const i of o)
      i.data.dispose();
    this.forceRepaint();
  }
  /**
   * Ge the Extent as defined in OL
   * @param scale
   * @returns
   */
  getVisibleExtent(e) {
    if (!this.isReady)
      return null;
    const o = this.getMapOrThrow().getBounds();
    let i = Qe(o.getWest(), o.getSouth()).concat(Qe(o.getEast(), o.getNorth()));
    return this.extent && (i = xo(this.extent, i)), e && oi(i, e), i;
  }
  /**
   * Get the list of all the tiles wanted for this extent and from the min zoom to the max zoom.
   * This is used to prevent updating tiles that are not in this list in `.updateSlippyTile()`
   * @param currentZ
   * @returns
   */
  getWantedTiles(e) {
    const o = Math.ceil(e), i = {}, r = this.getMapOrThrow().getBounds(), l = this.tilegrid.getMinZoom(), s = this.tilegrid.getMaxZoom(), c = Math.min(s, Math.max(l, o - 1)), h = Math.min(s, Math.max(l, o));
    for (let d = c; d <= h; ++d) {
      const f = Yo(r, d);
      for (const v of f)
        i[v] = !0;
    }
    return i;
  }
  /**
   * Changes the global opacity of the layer.
   * Default is `1`
   *
   * @param opacity Opacity 0-1.
   */
  setOpacity(e) {
    this.isReady && (this.material.uniforms.opacity.value = e, this.forceRepaint());
  }
  /**
   * Method from CustomLayerInterface, called when the layer is added to the map
   * @param map
   * @param gl
   */
  onAdd(e, o) {
    this.map = e, this.map.on("moveend", this.onMoveEndListener), this.map.on("resize", this.onResizeListener), this.map.on("move", this.onMoveListener);
    const i = this.map.getSdkConfig().apiKey, r = this.map.getMaptilerSessionId();
    this.forEachFrame((s) => {
      s.data.setMaptilerParams(i, r);
    }), F.hasData() || F.fetchLatest(i, r), this.renderer = new T.WebGLRenderer({
      canvas: e.getCanvas(),
      context: o,
      depth: !1,
      stencil: !1,
      //alpha: true,
      antialias: !0
    }), this.renderer.autoClear = !1, this.renderer.sortObjects = !1, this.renderer.debug.checkShaderErrors = !0, this.renderer.compile(this.scene, this.camera), this.onResize(), this.refresh();
    const l = this.getVisibleExtent(this.extentScale);
    if (!l) throw new Error("The last extent is null");
    this.lastExtent = l, this.forceRepaint();
  }
  onMove() {
    if (!this.isReady)
      return;
    const e = this.getVisibleExtent(this.extentScale);
    if (!e) throw new Error("New extent is null");
    const o = [
      Math.min(e[0], this.lastExtent[0]),
      Math.min(e[1], this.lastExtent[1]),
      Math.max(e[2], this.lastExtent[2]),
      Math.max(e[3], this.lastExtent[3])
    ], i = mo(o);
    Qo(this.lastExtent, e) / i <= this.extentChangedThreshold && (this.lastExtent = e, this.emit("extentChanged"));
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  refresh() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onRemove(e, o) {
    this.isReady && (this.map != null && (this.map.off("moveend", this.onMoveEndListener), this.map.off("resize", this.onResizeListener), this.map.off("move", this.onMoveListener), this.map = null), this.renderer != null && (this.renderer.dispose(), this.renderer = null), this.forEachFrame((i) => {
      i.data.dispose();
    }), this.disposeObjects());
  }
  /**
   * Remove some data allocated (not of the tiles)
   */
  disposeObjects() {
    if (this.isReady) {
      this.geometry.dispose(), this.material.dispose(), this.flusher.geometry.dispose(), this.flusher.material.dispose();
      for (const e of this.bluringNodePasses)
        e.dispose();
    }
  }
  /**
   * Callback when the window is resized.
   */
  onResize() {
    if (!this.isReady)
      return;
    const e = this.getMapOrThrow().getCanvas(), o = e.width, i = e.height;
    this.getRendererOrThrow().setViewport(0, 0, o, i), this.updateSlippyTileGrid(Math.ceil(o / 512) + 2, Math.ceil(i / 512) + 2);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onMoveEnd() {
  }
  /**
   * Get the TilePlacement from a zxy
   * @param source
   * @param load
   * @param z
   * @param x
   * @param y
   * @param originalTileCoordinates
   * @returns
   */
  getTilePlacement(e, o, i, r, l, s) {
    if (!this.isReady)
      return null;
    const c = `${i}/${r}/${l}`, h = e.getTile(c, o);
    if (!h || !h.ready)
      return this.loadLowerZoomLevels && i > this.tilegrid.getMinZoom() ? this.getTilePlacement(
        e,
        o,
        i - 1,
        Math.floor(r / 2),
        Math.floor(l / 2),
        s || { z: i, x: r, y: l }
      ) : null;
    const d = {
      tile: h,
      xy: [0, 0],
      size: 1
    };
    if (s !== void 0) {
      const f = 2 ** (s.z - i);
      d.size /= f, d.xy[0] = s.x % f / f, d.xy[1] = (2 ** s.z - s.y - 1) % f / f;
    }
    return d;
  }
  /**
   * Update the tile's mesh position and size, as well each tile material uniforms
   * (time, texture, etc.)
   * @returns
   */
  updateSlippyTiles() {
    var A, D, k, O, Se, Z, le, ye, Te, Ct, J, Q, Rt, we, Ee, Je, pe;
    if (!this.isReady)
      return;
    const { frameA: e, frameB: o, mix: i } = this.getCurrentFrames();
    if (!e || !o) {
      this.scene.visible = !1;
      return;
    }
    this.scene.visible = !0;
    const r = e.data, l = o.data, s = this.getMapOrThrow().getZoom(), c = this.getWantedTiles(s), h = {}, d = this.tilegrid.getMinZoom(), f = this.tilegrid.getMaxZoom(), v = Math.min(f, Math.max(d, Math.floor(s))), x = 2 ** v, E = 1 / x, y = this.getMapOrThrow().getCenter(), w = this.tilegrid.getTileCoordForCoordAndZ(Qe(y.lng, y.lat), v), S = s - v, P = this.slippyTiles.length;
    this.materialPool.init();
    const I = new globalThis.Map();
    for (let U = 0; U < P; U++) {
      const ae = this.slippyTiles[0].length;
      for (let Y = 0; Y < ae; Y++) {
        const H = this.slippyTiles[U][Y], M = w[1] + U - Math.floor(P / 2), se = w[2] + Y - Math.floor(ae / 2), ct = `${v}/${M}/${se}`;
        if (se < 0 || se >= x || !c[ct]) {
          H.visible = !1;
          continue;
        }
        H.visible = !0;
        const Fe = (M % x + x) % x, ut = `${v}/${Fe}/${se}`;
        h[ut] = !0;
        const Pt = x - se - 1;
        H.scale.x = E, H.scale.y = E, H.position.x = E * (M + 0.5), H.position.y = E * (Pt + 0.5) - 1;
        let j = this.getTilePlacement(r, !0, v, Fe, se), ee = this.getTilePlacement(l, !0, v, Fe, se);
        if (j && !ee && (ee = j), !j && ee && (j = ee), !j || !ee) {
          let R = e;
          for (; !j && (R = this.getNextFrame(R, -1), !!R); )
            j = ee = this.getTilePlacement(R.data, !1, v, Fe, se);
          if (!j || !ee) {
            H.visible = !1;
            continue;
          }
        }
        const L = this.materialPool.isEmpty() ? this.materialPool.add(this.material.clone()) : this.materialPool.pop();
        L.uniforms.localSmoothing.value = this.material.uniforms.localSmoothing.value, L.uniforms.maxSmoothingDistance.value = this.material.uniforms.maxSmoothingDistance.value, L.uniforms.smoothingDistanceDecayFactor.value = this.material.uniforms.smoothingDistanceDecayFactor.value, L.uniforms.timeInterpolation.value = this.material.uniforms.timeInterpolation.value, L.uniforms.categorySmoothTransition.value = this.material.uniforms.categorySmoothTransition.value, L.uniforms.opacity.value = this.material.uniforms.opacity.value, L.uniforms.tex0.value = j.tile.texture, L.uniforms.tex0xy.value = j.xy, L.uniforms.tex0size.value = j.size, L.uniforms.tex1.value = ee.tile.texture, L.uniforms.tex1xy.value = ee.xy, L.uniforms.tex1size.value = ee.size, L.uniforms.tilePixelSize.value = (A = j.tile.texture) == null ? void 0 : A.image.width, L.uniforms.time.value = i, L.uniforms.zoomDelta.value = S, H.material = L, L.uniforms.zoom.value = s, I.set(`${U} ${Y}`, {
          material: L,
          tileA: j,
          tileB: ee,
          x: U,
          y: Y,
          z: v
        });
      }
    }
    if (this.material.uniforms.localSmoothing.value || this.interpolateTileEdge)
      for (const U of I) {
        const ae = U[1], Y = ae.x, H = ae.y, M = ae.material, se = { x: Y, y: H - 1 }, ct = { x: Y + 1, y: H }, Fe = { x: Y, y: H + 1 }, ut = { x: Y - 1, y: H }, Pt = `${se.x} ${se.y}`, j = `${ct.x} ${ct.y}`, ee = `${Fe.x} ${Fe.y}`, L = `${ut.x} ${ut.y}`;
        let R = I.get(Pt);
        (k = (D = R == null ? void 0 : R.tileA) == null ? void 0 : D.tile) != null && k.ready && ((Se = (O = R == null ? void 0 : R.tileB) == null ? void 0 : O.tile) != null && Se.ready) ? (M.uniforms.texN0.value = R.tileA.tile.texture, M.uniforms.texN1.value = R.tileB.tile.texture, M.uniforms.availableN.value = !0) : (M.uniforms.texN0.value = null, M.uniforms.texN1.value = null, M.uniforms.availableN.value = !1), R = I.get(j), (le = (Z = R == null ? void 0 : R.tileA) == null ? void 0 : Z.tile) != null && le.ready && ((Te = (ye = R == null ? void 0 : R.tileB) == null ? void 0 : ye.tile) != null && Te.ready) ? (M.uniforms.texE0.value = R.tileA.tile.texture, M.uniforms.texE1.value = R.tileB.tile.texture, M.uniforms.availableE.value = !0) : (M.uniforms.texE0.value = null, M.uniforms.texE1.value = null, M.uniforms.availableE.value = !1), R = I.get(ee), (J = (Ct = R == null ? void 0 : R.tileA) == null ? void 0 : Ct.tile) != null && J.ready && ((Rt = (Q = R == null ? void 0 : R.tileB) == null ? void 0 : Q.tile) != null && Rt.ready) ? (M.uniforms.texS0.value = R.tileA.tile.texture, M.uniforms.texS1.value = R.tileB.tile.texture, M.uniforms.availableS.value = !0) : (M.uniforms.texS0.value = null, M.uniforms.texS1.value = null, M.uniforms.availableS.value = !1), R = I.get(L), (Ee = (we = R == null ? void 0 : R.tileA) == null ? void 0 : we.tile) != null && Ee.ready && ((pe = (Je = R == null ? void 0 : R.tileB) == null ? void 0 : Je.tile) != null && pe.ready) ? (M.uniforms.texW0.value = R.tileA.tile.texture, M.uniforms.texW1.value = R.tileB.tile.texture, M.uniforms.availableW.value = !0) : (M.uniforms.texW0.value = null, M.uniforms.texW1.value = null, M.uniforms.availableW.value = !1);
      }
    setTimeout(() => {
      r.expireCache(h), l.expireCache(h);
      const U = this.getNextFrame(o, 1);
      if (U != null && U.data) {
        const ae = Object.keys(h);
        for (const Y of ae)
          U.data.getTile(Y, !0);
      }
    }, 0);
  }
  /**
   * This method is called from CustomLayerInterface before rendering.
   * This is used to apply the map matrix to the local camera
   * to te
   * @param _gl
   * @param matrix
   */
  prerender(e, o) {
    if (!this.isReady)
      return;
    this.animationTick();
    const i = new T.Matrix4().fromArray(o), r = new T.Matrix4().makeTranslation(0, 0, 0).scale(new T.Vector3(1, -1, 1));
    this.camera.projectionMatrix = i.multiply(r), this.updateSlippyTiles(), this.prerenderInternal();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  prerenderInternal() {
  }
  /**
   * This method is called from CustomLayerInterface and is used to render the local tiles
   * into the MapTiler SDK context
   * @param _gl
   * @param _matrix
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e, o) {
    if (!this.isReady)
      return;
    const i = this.getRendererOrThrow();
    i.state.reset(), this.renderInternal(), i.render(this.scene, this.camera), (this.getAnimationSpeed() > 0 || this.repaintOnPausedAnimation) && this.forceRepaint();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  renderInternal() {
  }
  /**
   * Get layer image decoded value (decoded means on the real world interval such as provided [decode.min, decode.max])
   * @param lng
   * @param lat
   * @param source
   * @returns
   */
  pickFrame(e, o, i, r = {}) {
    var E;
    if (!this.isReady)
      return null;
    const l = _t(e, o);
    if (!this.map) return null;
    const s = r.load ?? !1, h = r.highestRes ?? !1 ? this.tilegrid.getMaxZoom() : Math.min(~~((E = this.map) == null ? void 0 : E.getZoom()), this.tilegrid.getMaxZoom()), d = 2 ** h, f = (0.5 + l[0]) % 1 * d, v = (1 - (l[1] + 0.5)) * d, x = this.getTilePlacement(i, s, h, Math.floor(f), Math.floor(v));
    if (x == null || x.tile.texture == null)
      return null;
    if (this.coloringFragments) {
      const y = ze(
        x.tile.texture.image,
        x.xy[0] + x.size * (f % 1),
        1 - x.xy[1] - x.size + x.size * (v % 1)
      );
      return this.coloringFragments.flatMap((w) => w.decodeChannel(y));
    }
    if (this.multiChannelColoringFragment) {
      const y = ze(
        x.tile.texture.image,
        x.xy[0] + x.size * (f % 1),
        1 - x.xy[1] - x.size + x.size * (v % 1)
      );
      return this.multiChannelColoringFragment.decodeChannel(y);
    }
    return null;
  }
  pickFrameBilinear(e, o, i, r = {}) {
    var Je;
    const l = r.load ?? !1, s = r.highestRes ?? !1, c = _t(e, o);
    if (!this.map) return null;
    const h = s ? this.tilegrid.getMaxZoom() : Math.min(~~((Je = this.map) == null ? void 0 : Je.getZoom()), this.tilegrid.getMaxZoom()), d = 2 ** h;
    let f = (0.5 + c[0]) % 1 * d, v = (1 - (c[1] + 0.5)) * d;
    const x = this.getTilePlacement(i, l, h, Math.floor(f), Math.floor(v));
    if (x == null || x.tile.texture == null)
      return null;
    const y = 1 / x.tile.texture.image.width;
    f -= y / 2, v -= y / 2;
    const w = {
      x: ~~(f / y) * y,
      y: ~~(v / y) * y
    }, S = {
      x: w.x + y,
      y: w.y
    }, P = {
      x: w.x + y,
      y: w.y + y
    }, I = {
      x: w.x,
      y: w.y + y
    }, A = this.getTilePlacement(i, l, h, Math.floor(w.x), Math.floor(w.y)), D = this.getTilePlacement(i, l, h, Math.floor(S.x), Math.floor(S.y)), k = this.getTilePlacement(i, l, h, Math.floor(P.x), Math.floor(P.y)), O = this.getTilePlacement(i, l, h, Math.floor(I.x), Math.floor(I.y));
    if (A == null || A.tile.texture == null || D == null || D.tile.texture == null || k == null || k.tile.texture == null || O == null || O.tile.texture == null)
      return null;
    const Se = ze(
      x.tile.texture.image,
      x.xy[0] + x.size * (f % 1),
      // x position in [0, 1]
      1 - x.xy[1] - x.size + x.size * (v % 1)
      // y position in [0, 1]
    ), Z = ze(
      A.tile.texture.image,
      A.xy[0] + A.size * (w.x % 1),
      // x position in [0, 1]
      1 - A.xy[1] - A.size + A.size * (w.y % 1)
      // y position in [0, 1]
    ), le = ze(
      D.tile.texture.image,
      D.xy[0] + D.size * (S.x % 1),
      // x position in [0, 1]
      1 - D.xy[1] - D.size + D.size * (S.y % 1)
      // y position in [0, 1]
    ), ye = ze(
      k.tile.texture.image,
      k.xy[0] + k.size * (P.x % 1),
      // x position in [0, 1]
      1 - k.xy[1] - k.size + k.size * (P.y % 1)
      // y position in [0, 1]
    ), Te = ze(
      O.tile.texture.image,
      O.xy[0] + O.size * (I.x % 1),
      // x position in [0, 1]
      1 - O.xy[1] - O.size + O.size * (I.y % 1)
      // y position in [0, 1]
    ), J = (v - w.y) / (I.y - w.y), Q = 1 - J, we = (f - w.x) / (S.x - w.x), Ee = 1 - we;
    if (this.coloringFragments) {
      const pe = {
        r: Z.r * Q + Te.r * J,
        g: Z.g * Q + Te.g * J,
        b: Z.b * Q + Te.b * J,
        a: Z.a * Q + Te.a * J
      }, U = {
        r: le.r * Q + ye.r * J,
        g: le.g * Q + ye.g * J,
        b: le.b * Q + ye.b * J,
        a: le.a * Q + ye.a * J
      }, ae = {
        r: pe.r * Ee + U.r * we,
        g: pe.g * Ee + U.g * we,
        b: pe.b * Ee + U.b * we,
        a: pe.a * Ee + U.a * we
      };
      return this.coloringFragments.flatMap((Y) => Y.decodeChannel(ae));
    }
    if (this.multiChannelColoringFragment) {
      if (Z.a !== le.a || Z.a !== ye.a || Z.a !== Te.a)
        return this.multiChannelColoringFragment.decodeChannel(Se);
      const pe = this.multiChannelColoringFragment.decodeChannel(Z), U = this.multiChannelColoringFragment.decodeChannel(le), ae = this.multiChannelColoringFragment.decodeChannel(ye), Y = this.multiChannelColoringFragment.decodeChannel(Te), H = pe[0] * Q + Y[0] * J, M = U[0] * Q + ae[0] * J;
      return [H * Ee + M * we, pe[1]];
    }
    return null;
  }
  /**
   * Picks the best currently available values at the position.
   *
   * The values are read from the already loaded tiles at the current time.
   *
   * Return the interpolated array of decoded values
   * of the same length as the number of specified coloring fragments.
   *
   * If the coloring fragments uses more channels (e.g. "rg"),
   * the corresponding value is an array of `[r value, g value, sqrt(r^2 + g^2)]`.
   *
   * @param lng
   * @param lat
   * @returns Array of decoded interpolated values. In case of using a multi-channel coloring fragment, the returned value is an array where the first value is the value and the second is the category
   */
  pick(e, o, i = {}) {
    if (!this.isReady)
      return null;
    const { frameA: r, frameB: l, mix: s } = this.getCurrentFrames();
    if (!r || !l) return null;
    const c = !!i.bilinear, h = i.load ?? !1, d = i.highestRes ?? !1, f = c ? this.pickFrameBilinear(e, o, r.data, { load: h, highestRes: d }) : this.pickFrame(e, o, r.data, { load: h, highestRes: d });
    let v = f;
    return r.data !== l.data && (v = c ? this.pickFrameBilinear(e, o, l.data, { load: h, highestRes: d }) : this.pickFrame(e, o, l.data, { load: h, highestRes: d })), f ? v ? this.coloringFragments ? f.flatMap((x, E) => {
      const y = v[E];
      return Array.isArray(x) && Array.isArray(y) ? x.map((w, S) => {
        const P = y[S];
        return w * (1 - s) + P * s;
      }) : x * (1 - s) + y * s;
    }) : this.multiChannelColoringFragment ? this.timeInterpolation ? [
      f[0] * (1 - s) + v[0] * s,
      // value
      s < 0.5 ? f[1] : v[1]
      // category
    ] : [
      s < 0.5 ? f[0] : v[0],
      // value
      s < 0.5 ? f[1] : v[1]
      // category
    ] : null : f : v;
  }
  forceRepaint() {
    try {
      this.getMapOrThrow().triggerRepaint();
    } catch {
    }
  }
  /**
   * Get the current mixed image as a ImageData, meaning with pixel data, width, height and number of channels
   * @param options.zxy The tile ID
   * @param options.blurKernel Size of the bluring kernel
   * @param options.outputSize Size of the outpout image (-1 means same as input). Note that the bluring is applied on an image of this size.
   * @returns
   */
  computeCurrentMixedImage({
    zxy: e = "0/0/0",
    blurKernel: o = 0,
    outputSize: i = -1,
    channel: r = "r"
  }) {
    var w, S, P, I;
    if (!this.isReady)
      return null;
    const l = this.getCurrentFrames(), s = l.mix, c = (S = (w = l.frameA) == null ? void 0 : w.data.getTile(e, !1)) == null ? void 0 : S.texture, h = (I = (P = l.frameB) == null ? void 0 : P.data.getTile(e, !1)) == null ? void 0 : I.texture, d = i < 0 ? Number.parseInt(c == null ? void 0 : c.image.width) : i, f = i < 0 ? Number.parseInt(c == null ? void 0 : c.image.height) : i;
    this.bluringNodePasses.length || this.bluringNodePasses.push(new Nt(d, f), new Nt(d, f), new Nt(d, f));
    const v = this.bluringNodePasses[0], x = this.bluringNodePasses[1], E = this.bluringNodePasses[2];
    if (v.setSize(d, f), x.setSize(d, f), x.setSize(d, f), v.setFragmentShader(Fi), v.setDefine("CHANNEL", r), v.setUniform("imageA", c), v.setUniform("imageB", h), v.setUniform("mixValue", s), v.process(), o === 0) {
      const A = v.getPixelData();
      return {
        data: A,
        channels: A.length / (d * f),
        width: d,
        height: f
      };
    }
    if (![5, 9, 13, 19].includes(o))
      throw new Error(`The kernel bluring kernel size ${o} is not available.`);
    x.setUniform("direction", new T.Vector2(1, 0)), x.setUniform("kernelSize", o), x.setUniform("imgToBlur", v.getOutputTexture()), x.setFragmentShader(Jt), x.process(), E.setUniform("direction", new T.Vector2(0, 1)), E.setUniform("kernelSize", o), E.setUniform("imgToBlur", x.getOutputTexture()), E.setFragmentShader(Jt), E.process();
    const y = E.getPixelData();
    for (const A of this.bluringNodePasses)
      A.dispose();
    return {
      data: y,
      channels: y.length / (d * f),
      width: d,
      height: f
    };
  }
  /**
   * Enables data interpolation between keyframes when true. Only shows keyframe data when false.
   * @param ti
   */
  setTimeInterpolation(e) {
    this.isReady && (this.material.uniforms.timeInterpolation.value = e);
  }
  /**
   * Enable smoothing category color when true. Hard edge between categories when false.
   * This seeting applies only to TileLayers using MultiChannelGradientColoringFragment
   * as the other types of oloring fragment do not use categories.
   * @param cst
   */
  setCategorySmoothTransition(e) {
    this.isReady && (this.material.uniforms.categorySmoothTransition.value = e, this.forceRepaint());
  }
  /**
   * If `true`, enables the local smoothing
   * @param s
   */
  setLocalSmoothing(e) {
    this.material.uniforms.localSmoothing.value = e, this.forceRepaint();
  }
  /**
   * Defines the size of the smoothing kernel
   * @param d
   */
  setMaxSmoothingDistance(e) {
    this.material.uniforms.maxSmoothingDistance.value = e, this.forceRepaint();
  }
  /**
   * Defines by what factor the smoothing kernel size is reduced with increasing zoom level
   * @param f
   */
  setSmoothingDistanceDecayFactor(e) {
    this.material.uniforms.smoothingDistanceDecayFactor.value = e, this.forceRepaint();
  }
  /**
   * Get whether or not the frames continues to rendered on a paused animation
   * @returns
   */
  getRepaintOnPausedAnimation() {
    return this.repaintOnPausedAnimation;
  }
  /**
   * If `true`, even the paused animation is rendered up to 60 times
   * per seconds. If `false`, the rendering is paused when the animation is paused.
   * Pausing the animation has side effects:
   * - it lowers energy consumtion
   * - it prevents overheating
   * - it pauses time-independant annimation (arrows, particles)
   * @param r
   */
  setRepaintOnPausedAnimation(e) {
    this.repaintOnPausedAnimation = e, this.forceRepaint();
  }
}
var Wi = "precision highp float;precision highp sampler2D;uniform float opacity;uniform sampler2D tex0;in vec2 coord;out vec4 fragColor;void main(){vec4 c=texture(tex0,coord);if(c.a<1.0/16.0){discard;}if(opacity<0.0001){discard;}fragColor=c;fragColor.a*=opacity;}", Gi = "precision highp float;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;in vec3 position;in vec2 uv;out vec2 coord;void main(){coord=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}", Vi = "precision highp float;precision highp sampler2D;out vec4 fragColor;in float speed;void main(){vec2 uv=vec2(gl_PointCoord.x-0.5,1.0-gl_PointCoord.y-0.5);float dFromCenter=sqrt(uv.x*uv.x+uv.y*uv.y);if(dFromCenter>0.5){discard;return;}if(speed==0.){discard;return;}float colorFactor=min(1.0,speed/COLOR_SPEED);fragColor=mix(COLOR_A,COLOR_B,colorFactor);float opacityFactor=smoothstep(0.05,0.1,speed);fragColor.a*=opacityFactor;}", Bi = `#version 300 es
precision highp float;uniform sampler2D rttTexture;uniform sampler2D rttTexturePrev;uniform float rttSize;uniform float screenSize;uniform float extrapolationFactor;uniform float renderStepSize;out float speed;vec4 advance(float position_){if(position_>(DENSITY/1000.0)*screenSize*screenSize){speed=0.0;return vec4(0.0);}float x=fract(position_/rttSize);float y=floor(position_/rttSize)/rttSize;vec4 color=texture(rttTexture,vec2(x,y));vec2 pos=color.ba+color.rg/255.0;vec4 colorPrev=texture(rttTexturePrev,vec2(x,y));vec2 posPrev=colorPrev.ba+colorPrev.rg/255.0;vec2 diff=pos-posPrev;pos+=diff*extrapolationFactor;speed=renderStepSize*step(0.0001,dot(posPrev,posPrev))*length(diff*screenSize);return vec4(pos,diff);}void main(){float position_=floor(position/2.0);float vertex=2.0*fract(position/2.0);vec4 posdiff=advance(position_);vec2 pos=posdiff.xy;vec2 dir=normalize(posdiff.zw);vec2 uv=(float(SIZE)/screenSize)*vec2(vertex,-vertex)*dir.yx;pos=2.0*(pos-uv)-1.0;gl_Position=vec4(pos.x,-pos.y,0.,1.);}`, ki = "precision highp float;precision highp sampler2D;in float position;uniform sampler2D rttTexture;uniform sampler2D rttTexturePrev;uniform float rttSize;uniform float screenSize;uniform float extrapolationFactor;uniform float renderStepSize;uniform bool fastIsLarger;out float speed;float factor=1.;vec4 advance(float position_){if(position_>(DENSITY/1000.0)*screenSize*screenSize){speed=0.0;return vec4(0.0);}float x=fract(position_/rttSize);float y=floor(position_/rttSize)/rttSize;vec4 color=texture(rttTexture,vec2(x,y));vec2 pos=color.ba+color.rg/255.0;vec4 colorPrev=texture(rttTexturePrev,vec2(x,y));vec2 posPrev=colorPrev.ba+colorPrev.rg/255.0;vec2 diff=pos-posPrev;pos+=diff*extrapolationFactor;speed=renderStepSize*step(0.0001,dot(posPrev,posPrev))*length(diff*screenSize);return vec4(pos,diff);}void main(){vec4 posdiff=advance(position);gl_PointSize=fastIsLarger ?(SIZE+SIZE*log(speed+1.))/2. : SIZE;gl_Position=vec4(2.0*posdiff.x-1.0,-(2.0*posdiff.y-1.0),0.,1.);}", Yi = `precision highp float;precision highp sampler2D;
#define M_PI 3.14159265358
uniform float tileScale;uniform vec2 tilePosition;uniform vec2 tex0xy;uniform vec2 tex1xy;uniform float tex0size;uniform float tex1size;uniform bool useAlphaAsMask;uniform sampler2D rttTexture;uniform vec2 rttXY;uniform float rttScale;uniform float time;uniform sampler2D tex0;uniform sampler2D tex1;uniform float timestep;uniform float canvasDiagonal;uniform float angleDirectionShiftSkip;uniform bool uniformSpeed;uniform float tileGridPass;in vec2 rttCoord;out vec4 fragColor;float modI(float a,float b){float m=a-floor((a+0.5)/b)*b;return floor(m+0.5);}void main(){vec4 color=texture(rttTexture,rttCoord);if(tileGridPass==0.&&modI(floor(color.r*255.),2.)==0.){fragColor=color;return;}if(tileGridPass==1.&&modI(floor(color.r*255.),2.)!=0.){fragColor=color;return;}vec2 pos=color.ba+color.rg/255.0;vec2 posInTile=(rttXY+rttScale*pos)/tileScale-tilePosition;float uniformSpeedFactor=uniformSpeed ?(4000./canvasDiagonal): 1.;if(posInTile.x>=0.&&posInTile.x<=1.&&posInTile.y>=0.&&posInTile.y<=1.){posInTile.y=1.0-posInTile.y;vec2 tex0coord=tex0xy+posInTile*tex0size;vec2 tex1coord=tex1xy+posInTile*tex1size;vec4 tex0Color=texture(tex0,tex0coord);vec4 tex1Color=texture(tex1,tex1coord);if(useAlphaAsMask&&(tex0Color.a<1.||tex1Color.a<1.)){fragColor=color;return;}vec2 uv;bool skipRendering=false;if(D_WAVES){vec2 value0=tex0Color.D_CHANNELS;vec2 value1=tex1Color.D_CHANNELS;float dir0=2.0*M_PI*(-value0.x-0.25);float dir1=2.0*M_PI*(-value1.x-0.25);float speed=sqrt(1.0/mix(value0.y,value1.y,time));uv=vec2(mix(cos(dir0),cos(dir1),time),mix(sin(dir0),sin(dir1),time))*(D_MIN+(D_MAX-D_MIN)*speed);}else{vec4 lookup=mix(tex0Color,tex1Color,time);vec2 value=lookup.D_CHANNELS;uv=D_MIN+(D_MAX-D_MIN)*value;if(angleDirectionShiftSkip<89.999){vec2 offset=vec2(uv.x,-uv.y)*timestep*uniformSpeedFactor;vec2 nextPos=pos+offset;vec2 posNextInTile=(rttXY+rttScale*nextPos)/tileScale-tilePosition;posNextInTile.y=1.0-posNextInTile.y;vec2 tex0coordNext=tex0xy+posNextInTile*tex0size;vec2 tex1coordNext=tex1xy+posNextInTile*tex1size;vec4 tex0ColorNext=texture(tex0,tex0coordNext);vec4 tex1ColorNext=texture(tex1,tex1coordNext);vec4 lookupNext=mix(tex0ColorNext,tex1ColorNext,time);vec2 valueNext=lookupNext.D_CHANNELS;vec2 uvNext=D_MIN+(D_MAX-D_MIN)*valueNext;skipRendering=dot(normalize(uv),normalize(uvNext))<cos(angleDirectionShiftSkip*M_PI/180.);}}vec2 offset=vec2(uv.x,-uv.y)*timestep*uniformSpeedFactor;if(skipRendering){offset=vec2(0.,0.);}vec2 newPos=pos+offset;fragColor=vec4(fract(newPos*255.0),floor(newPos*255.0)/255.0);float red255=floor(fragColor.r*255.);if(tileGridPass==0.){if(modI(red255,2.)!=0.){red255-=1.;}}else{if(modI(red255,2.)==0.){red255+=1.;}}fragColor.r=red255/255.;}else{fragColor=color;}}`, Xi = "precision highp float;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;in vec3 position;in vec2 uv;out vec2 rttCoord;void main(){rttCoord=uv;gl_Position=projectionMatrix*vec4(position,1.);}";
class $i extends st {
  /**
   * @param id Unique identifier of the layer in the map.
   * @param options
   * @param particleOptions
   * @param coloringFragments If not null, the same data will also be displayed as raster.
   */
  constructor(e, o, i, r) {
    super(e, null, null);
    u(this, "rttScene", new T.Scene());
    u(this, "rttCamera");
    u(this, "rttMaterial");
    u(this, "rttMesh");
    u(this, "particleTexturePrev");
    u(this, "particleTexture0");
    u(this, "particleTexture1");
    u(this, "particleMaterial");
    u(this, "particles");
    u(this, "particleBackground");
    u(this, "accumulator");
    u(this, "accumulatorDrawMesh");
    u(this, "flipFlop", !1);
    u(this, "numParticles");
    u(this, "particleDensity");
    u(this, "refreshInterval");
    u(this, "fadeFactor");
    u(this, "particleColor");
    u(this, "particleFastColor");
    u(this, "particleFastSpeed");
    u(this, "particleSize");
    u(this, "drawAsLines");
    u(this, "particleSpeed");
    u(this, "pixelRatio");
    u(this, "prevRenderTime", 0);
    u(this, "lastRenderTime", 0);
    u(this, "forceRender", !0);
    u(this, "rttTimestep", 200);
    u(this, "tileGridPass", 0);
    o && i && this.initParticle(o, i, r);
  }
  initParticle(e, o, i) {
    if (this.init(e, i, null), this.extentScale = 1.2, this.numParticles = 128, o.maxAmount != null)
      if (o.maxAmount >= 4 && o.maxAmount && !(o.maxAmount & o.maxAmount - 1))
        this.numParticles = o.maxAmount;
      else
        throw new Error("The number of particles needs to be power of two and at least 4");
    const r = window.devicePixelRatio;
    this.particleDensity = o.density ?? 2, this.particleDensity /= r * r, this.refreshInterval = o.refreshInterval ?? 800, this.fadeFactor = o.fadeFactor ?? 0.1, this.particleColor = $e(o.color ?? [255, 255, 255, 192]), this.particleFastColor = o.fastColor ? $e(o.fastColor) : this.particleColor, this.particleFastSpeed = (o.fastSpeed ?? 2) * r, this.particleSize = o.size ?? 1.5, this.drawAsLines = o.drawAsLines ?? !1, this.particleSpeed = (o.speed ?? 1e-3) / 1e3, this.pixelRatio = o.pixelRatio ?? (r > 1 ? 1 : 2), this.particleTexturePrev = this.generateRandomizeParticleTexture(this.numParticles, this.numParticles), this.particleTexture0 = new T.WebGLRenderTarget(this.numParticles, this.numParticles, {
      stencilBuffer: !1,
      depthBuffer: !1
    }), this.particleTexture0.texture = this.particleTexturePrev.clone(), this.particleTexture1 = this.particleTexture0.clone(), this.rttMaterial = new T.RawShaderMaterial({
      glslVersion: T.GLSL3,
      uniforms: {
        tileGridPass: { value: this.tileGridPass },
        uniformSpeed: { value: o.uniformSpeed ?? !1 },
        canvasDiagonal: { value: 0 },
        angleDirectionShiftSkip: {
          value: o.angleDirectionShiftSkip ?? 90
        },
        rttXY: { value: [0, 0] },
        rttScale: { value: 1 },
        rttTexture: {
          value: this.particleTexture0.texture
        },
        tileScale: { value: 0 },
        useAlphaAsMask: { value: o.useAlphaAsMask ?? !1 },
        tilePosition: { value: [0, 0] },
        time: { value: 0 },
        timestep: { value: 0 },
        tex0xy: { value: [0, 0] },
        tex1xy: { value: [0, 0] },
        tex0size: { value: 1 },
        tex1size: { value: 1 },
        tex0: {
          value: null
        },
        tex1: {
          value: null
        }
      },
      vertexShader: Xi,
      fragmentShader: Yi,
      defines: {
        D_MIN: (o.decodeMin ?? 0).toFixed(2),
        D_MAX: (o.decodeMax ?? 1).toFixed(2),
        D_CHANNELS: o.decodeChannels ?? "rg",
        D_WAVES: o.decodeAsWaves ? "true" : "false"
      },
      depthTest: !1,
      depthWrite: !1
    }), this.rttCamera = new T.OrthographicCamera(
      -this.numParticles / 2,
      this.numParticles / 2,
      this.numParticles / 2,
      -this.numParticles / 2,
      -100,
      100
    ), this.rttMesh = new T.Mesh(new T.PlaneGeometry(this.numParticles, this.numParticles), this.rttMaterial), this.rttScene.add(this.rttMesh), this.accumulator = new T.WebGLRenderTarget(16, 16, {
      minFilter: T.LinearFilter,
      magFilter: T.LinearFilter,
      stencilBuffer: !1,
      format: T.RGBAFormat,
      depthBuffer: !1
    }), this.particleBackground = new T.Mesh(
      new T.PlaneGeometry(2, 2),
      new T.RawShaderMaterial({
        glslVersion: T.GLSL3,
        transparent: !0,
        blending: T.CustomBlending,
        blendEquationAlpha: T.ReverseSubtractEquation,
        vertexShader: "precision highp float;in vec3 position;void main(){gl_Position=vec4(position,1.);}",
        fragmentShader: `precision highp float;out vec4 fragColor;void main(){fragColor=vec4(.0,.0,.0,${this.fadeFactor.toFixed(
          2
        )});}`
      })
    );
    const l = r * this.pixelRatio * this.particleSize, s = r * this.particleSize;
    if (this.particleMaterial = new T.RawShaderMaterial({
      glslVersion: T.GLSL3,
      uniforms: {
        fastIsLarger: { value: o.fastIsLarger ?? !1 },
        rttSize: { value: this.numParticles },
        rttTexture: {
          value: this.particleTexture1.texture
        },
        rttTexturePrev: {
          value: this.particleTexturePrev
        },
        screenSize: { value: 1 },
        extrapolationFactor: { value: 0 },
        renderStepSize: { value: 0 }
      },
      vertexShader: this.drawAsLines ? Bi : ki,
      fragmentShader: Vi,
      defines: {
        COLOR_A: this.particleColor,
        COLOR_B: this.particleFastColor,
        COLOR_SPEED: this.particleFastSpeed.toFixed(2),
        DENSITY: this.particleDensity.toFixed(2),
        SIZE: (this.drawAsLines ? s : l).toFixed(1)
      },
      transparent: !0,
      depthTest: !1,
      depthWrite: !1,
      linewidth: this.pixelRatio
      // not guaranteed to work, but try anyway
    }), this.drawAsLines) {
      const c = new Float32Array(Array(2 * this.numParticles * this.numParticles).keys()), h = new T.BufferGeometry();
      h.setAttribute("position", new T.Float32BufferAttribute(c, 1)), this.particles = new T.LineSegments(h, this.particleMaterial);
    } else {
      const c = new Float32Array(Array(this.numParticles * this.numParticles).keys()), h = new T.BufferGeometry();
      h.setAttribute("position", new T.Float32BufferAttribute(c, 1)), this.particles = new T.Points(h, this.particleMaterial);
    }
    this.particles.frustumCulled = !1, this.accumulatorDrawMesh = new T.Mesh(
      new T.PlaneGeometry(1, 1),
      new T.RawShaderMaterial({
        glslVersion: T.GLSL3,
        premultipliedAlpha: !0,
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
        uniforms: {
          opacity: { value: 1 },
          tex0: {
            value: this.accumulator.texture
          }
        },
        vertexShader: Gi,
        fragmentShader: Wi
      })
    ), this.scene.add(this.accumulatorDrawMesh), setInterval(() => {
      this.renderer && this.randomizeParticles(!1);
    }, this.refreshInterval), this.on("extentChanged", () => {
      this.refresh();
    });
  }
  onAdd(e, o) {
    super.onAdd(e, o);
  }
  generateRandomizeParticleTexture(e, o) {
    const i = new Uint8Array(4 * e * o);
    for (let r = 0; r < i.length; r++)
      i[r] = Math.floor(256 * Math.random());
    return new T.DataTexture(i, e, o);
  }
  randomizeParticles(e) {
    if (!this.renderer)
      return;
    let o = this.numParticles, i = this.numParticles;
    const r = new T.Vector2(0, 0);
    if (!e) {
      const s = this.numParticles / 4;
      o = s, i = s, r.x = Math.floor(Math.random() * this.numParticles / s) * s, r.y = Math.floor(Math.random() * this.numParticles / s) * s;
    }
    const l = this.generateRandomizeParticleTexture(o, i);
    this.renderer.copyTextureToTexture(r, l, this.particleTexturePrev), this.renderer.copyTextureToTexture(r, l, this.particleTexture0.texture), this.renderer.copyTextureToTexture(r, l, this.particleTexture1.texture), l.dispose(), this.forceRender = e;
  }
  /**
   * Returns the ratio between the number of actually visible particle
   * (to statisfy the specified density) and the maximum amount (maxAmount).
   *
   * Value >1 mean that more particles would be utilized if availabe.
   *
   * Useful for debugging and fine-tuning client application.
   */
  getParticleUtilization() {
    const e = this.particleMaterial.uniforms.screenSize.value;
    return this.particleDensity / 1e3 * e * e / (this.numParticles * this.numParticles);
  }
  setOpacity(e) {
    super.setOpacity(e), this.accumulatorDrawMesh.material.uniforms.opacity.value = e;
  }
  disposeObjects() {
    super.disposeObjects(), this.particleTexturePrev.dispose(), this.particleTexture0.texture.dispose(), this.particleTexture0.dispose(), this.particleTexture1.texture.dispose(), this.particleTexture1.dispose(), this.accumulator.texture.dispose(), this.accumulator.dispose(), this.rttMesh.geometry.dispose(), this.rttMesh.material.dispose(), this.particleBackground.geometry.dispose(), this.particleBackground.material.dispose(), this.particles.geometry.dispose(), this.particles.material.dispose(), this.accumulatorDrawMesh.geometry.dispose(), this.accumulatorDrawMesh.material.dispose();
  }
  onResize() {
    super.onResize();
    const e = this.getMapOrThrow().getCanvas(), o = e.width, i = e.height;
    let r = Math.round(this.pixelRatio * this.extentScale * Math.max(o, i));
    const l = Math.sqrt(o * o + i * i) * (devicePixelRatio === 1 ? 2 : 1);
    this.rttMaterial.uniforms.canvasDiagonal.value = l, r = Math.min(r, this.getRendererOrThrow().capabilities.maxTextureSize), this.accumulator.setSize(r, r), this.particleMaterial.uniforms.screenSize.value = r / this.pixelRatio, this.scene.remove(this.accumulatorDrawMesh), this.scene.add(this.accumulatorDrawMesh);
  }
  onMoveEnd() {
  }
  refresh() {
    const e = this.getVisibleExtent(this.extentScale);
    if (!e) throw new Error("The extent is null");
    const o = Math.max(e[2] - e[0], e[3] - e[1]) / Tt, i = [
      0.5 + (e[2] + e[0]) / 2 / Tt - o / 2,
      0.5 - (e[3] + e[1]) / 2 / Tt - o / 2
    ];
    this.rttMaterial.uniforms.rttScale.value = o, this.rttMaterial.uniforms.rttXY.value = i;
    const r = this.getRendererOrThrow();
    r.setRenderTarget(this.accumulator), r.setClearAlpha(0), r.clearColor(), r.setRenderTarget(null), this.randomizeParticles(!0);
  }
  prerenderInternal() {
    const e = performance.now(), o = e - this.lastRenderTime, i = this.forceRender || o > this.rttTimestep || !this.prevRenderTime;
    if (i) {
      this.forceRender = !1, this.rttMaterial.uniforms.timestep.value = this.particleSpeed * o, this.getRendererOrThrow().setRenderTarget(this.flipFlop ? this.particleTexture1 : this.particleTexture0), this.getRendererOrThrow().copyFramebufferToTexture(new T.Vector2(0, 0), this.particleTexturePrev), this.prevRenderTime = this.lastRenderTime, this.lastRenderTime = e;
      const c = this.slippyTiles.length;
      for (let h = 0; h < c; h++) {
        const d = this.slippyTiles[0].length;
        for (let f = 0; f < d; f++) {
          const v = this.slippyTiles[h][f];
          if (!v.visible)
            continue;
          const E = v.material.uniforms;
          if (!E) continue;
          const y = v.scale.x;
          this.rttMaterial.uniforms.tileScale.value = y, this.rttMaterial.uniforms.tilePosition.value = [
            v.position.x / y - 0.5,
            -v.position.y / y - 0.5
          ], this.rttMaterial.uniforms.tileGridPass.value = this.tileGridPass, this.rttMaterial.uniforms.time.value = E.time.value, this.rttMaterial.uniforms.tex0.value = E.tex0.value, this.rttMaterial.uniforms.tex0xy.value = E.tex0xy.value, this.rttMaterial.uniforms.tex0size.value = E.tex0size.value, this.rttMaterial.uniforms.tex1.value = E.tex1.value, this.rttMaterial.uniforms.tex1xy.value = E.tex1xy.value, this.rttMaterial.uniforms.tex1size.value = E.tex1size.value, this.rttMaterial.uniforms.rttTexture.value = (this.flipFlop ? this.particleTexture1 : this.particleTexture0).texture;
          const w = this.getRendererOrThrow();
          w.setRenderTarget(this.flipFlop ? this.particleTexture0 : this.particleTexture1), w.render(this.rttScene, this.rttCamera), this.flipFlop = !this.flipFlop;
        }
      }
      this.particleMaterial.uniforms.rttTexture.value = (this.flipFlop ? this.particleTexture1 : this.particleTexture0).texture, this.tileGridPass = +!this.tileGridPass;
    }
    const r = this.lastRenderTime - this.prevRenderTime, l = i ? 0 : o / r;
    this.particleMaterial.uniforms.extrapolationFactor.value = l, this.particleMaterial.uniforms.renderStepSize.value = r / 1e3;
    const s = this.getRendererOrThrow();
    s.setRenderTarget(this.accumulator), s.render(this.particleBackground, this.camera), s.render(this.particles, this.camera), s.setRenderTarget(null);
  }
  renderInternal() {
    const e = this.rttMaterial.uniforms.rttScale.value;
    this.accumulatorDrawMesh.position.x = 0.5 * e + this.rttMaterial.uniforms.rttXY.value[0], this.accumulatorDrawMesh.position.y = -0.5 * e - this.rttMaterial.uniforms.rttXY.value[1], this.accumulatorDrawMesh.scale.x = this.accumulatorDrawMesh.scale.y = e;
  }
}
const g = class g extends Array {
  constructor(e = {}) {
    super();
    u(this, "min", 0);
    u(this, "max", 1);
    "min" in e && (this.min = e.min), "max" in e && (this.max = e.max), "stops" in e && this.setStops(e.stops, { clone: !1 });
  }
  /**
   * Converts a array-definition color ramp definition into a usable ColorRamp instance.
   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
   * @param cr
   * @returns
   */
  static fromArrayDefinition(e) {
    return new g({
      stops: e.map((o) => ({
        value: o[0],
        color: o[1]
      }))
    });
  }
  setStops(e, o = { clone: !0 }) {
    const i = o.clone ? this.clone() : this;
    i.length = 0;
    let r = Number.POSITIVE_INFINITY, l = Number.NEGATIVE_INFINITY;
    for (let s = 0; s < e.length; s += 1)
      r = Math.min(r, e[s].value), l = Math.max(l, e[s].value), i.push({
        value: e[s].value,
        color: e[s].color.slice()
        // we want to make sure we do a deep copy and not a reference
      });
    return i.sort((s, c) => s.value < c.value ? -1 : 1), this.min = r, this.max = l, i;
  }
  scale(e, o, i = { clone: !0 }) {
    const r = i.clone, l = this[0].value, c = this.at(-1).value - l, h = o - e, d = [];
    for (let f = 0; f < this.length; f += 1) {
      const E = (this[f].value - l) / c * h + e;
      r ? d.push({
        value: E,
        color: this[f].color.slice()
      }) : this[f].value = E;
    }
    return r ? new g({ stops: d }) : this;
  }
  // for some reason, I had to reimplement this
  at(e) {
    return e < 0 ? this[this.length + e] : this[e];
  }
  clone() {
    return new g({ stops: this.getRawColorStops() });
  }
  getRawColorStops() {
    const e = [];
    for (let o = 0; o < this.length; o += 1)
      e.push(this[o]);
    return e;
  }
  reverse(e = { clone: !0 }) {
    const o = e.clone ? this.clone() : this;
    for (let i = 0; i < ~~(o.length / 2); i += 1) {
      const r = o[i].color;
      o[i].color = o.at(-(i + 1)).color, o.at(-(i + 1)).color = r;
    }
    return o;
  }
  getBounds() {
    return { min: this.min, max: this.max };
  }
  getColor(e, o = { smooth: !0 }) {
    if (e <= this[0].value)
      return this[0].color;
    if (e >= this.at(-1).value)
      return this.at(-1).color;
    for (let i = 0; i < this.length - 1; i += 1) {
      if (e > this[i + 1].value)
        continue;
      const r = this[i].color;
      if (!o.smooth)
        return r.slice();
      const l = this[i].value, s = this[i + 1].value, c = this[i + 1].color, h = (s - e) / (s - l);
      return r.map(
        (d, f) => Math.round(d * h + c[f] * (1 - h))
      );
    }
    return [0, 0, 0];
  }
  getCanvasStrip(e = {
    horizontal: !0,
    size: 512,
    smooth: !0
  }) {
    const o = document.createElement("canvas");
    o.width = e.horizontal ? e.size : 1, o.height = e.horizontal ? 1 : e.size;
    const i = o.getContext("2d");
    if (!i) throw new Error("Canvs context is missing");
    const r = i.getImageData(0, 0, o.width, o.height), l = r.data, s = e.size, c = this[0].value, f = (this.at(-1).value - c) / s;
    for (let v = 0; v < s; v += 1) {
      const x = this.getColor(c + v * f, {
        smooth: e.smooth
      });
      l[v * 4] = x[0], l[v * 4 + 1] = x[1], l[v * 4 + 2] = x[2], l[v * 4 + 3] = x.length > 3 ? x[3] : 255;
    }
    return i.putImageData(r, 0, 0), o;
  }
};
u(g, "builtin", {
  /**
   * A fully transparent [0, 0, 0, 0] colorramp to hide data.
   * Defined in interval [0, 1], without unit.
   */
  NULL: new g({
    stops: [
      { value: 0, color: [0, 0, 0, 0] },
      { value: 1, color: [0, 0, 0, 0] }
    ]
  }),
  /**
   * Classic jet color ramp.
   * Defined in interval [0, 1], without unit.
   */
  JET: new g({
    stops: [
      { value: 0, color: [0, 0, 131] },
      { value: 0.125, color: [0, 60, 170] },
      { value: 0.375, color: [5, 255, 255] },
      { value: 0.625, color: [255, 255, 0] },
      { value: 0.875, color: [250, 0, 0] },
      { value: 1, color: [128, 0, 0] }
    ]
  }),
  /**
   * Classic HSV color ramp (hue, saturation, value).
   * Defined in interval [0, 1], without unit.
   */
  HSV: new g({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 0.169, color: [253, 255, 2] },
      { value: 0.173, color: [247, 255, 2] },
      { value: 0.337, color: [0, 252, 4] },
      { value: 0.341, color: [0, 252, 10] },
      { value: 0.506, color: [1, 249, 255] },
      { value: 0.671, color: [2, 0, 253] },
      { value: 0.675, color: [8, 0, 253] },
      { value: 0.839, color: [255, 0, 251] },
      { value: 0.843, color: [255, 0, 245] },
      { value: 1, color: [255, 0, 6] }
    ]
  }),
  /**
   * Classic hot color ramp.
   * Defined in interval [0, 1], without unit.
   */
  HOT: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.3, color: [230, 0, 0] },
      { value: 0.6, color: [255, 210, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic spring color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SPRING: new g({
    stops: [
      { value: 0, color: [255, 0, 255] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic summer color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SUMMER: new g({
    stops: [
      { value: 0, color: [0, 128, 102] },
      { value: 1, color: [255, 255, 102] }
    ]
  }),
  /**
   * Classic autommn color ramp.
   * Defined in interval [0, 1], without unit.
   */
  AUTOMN: new g({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic winter color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WINTER: new g({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [0, 255, 128] }
    ]
  }),
  /**
   * Classic bone color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BONE: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.376, color: [84, 84, 116] },
      { value: 0.753, color: [169, 200, 200] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic copper color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COPPER: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.804, color: [255, 160, 102] },
      { value: 1, color: [255, 199, 127] }
    ]
  }),
  /**
   * Classic greys color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREYS: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic yignbu color ramp (blue to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIGNBU: new g({
    stops: [
      { value: 0, color: [8, 29, 88] },
      { value: 0.125, color: [37, 52, 148] },
      { value: 0.25, color: [34, 94, 168] },
      { value: 0.375, color: [29, 145, 192] },
      { value: 0.5, color: [65, 182, 196] },
      { value: 0.625, color: [127, 205, 187] },
      { value: 0.75, color: [199, 233, 180] },
      { value: 0.875, color: [237, 248, 217] },
      { value: 1, color: [255, 255, 217] }
    ]
  }),
  /**
   * Classic greens color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREENS: new g({
    stops: [
      { value: 0, color: [0, 68, 27] },
      { value: 0.125, color: [0, 109, 44] },
      { value: 0.25, color: [35, 139, 69] },
      { value: 0.375, color: [65, 171, 93] },
      { value: 0.5, color: [116, 196, 118] },
      { value: 0.625, color: [161, 217, 155] },
      { value: 0.75, color: [199, 233, 192] },
      { value: 0.875, color: [229, 245, 224] },
      { value: 1, color: [247, 252, 245] }
    ]
  }),
  /**
   * Classic yiorrd color ramp (red to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIORRD: new g({
    stops: [
      { value: 0, color: [128, 0, 38] },
      { value: 0.125, color: [189, 0, 38] },
      { value: 0.25, color: [227, 26, 28] },
      { value: 0.375, color: [252, 78, 42] },
      { value: 0.5, color: [253, 141, 60] },
      { value: 0.625, color: [254, 178, 76] },
      { value: 0.75, color: [254, 217, 118] },
      { value: 0.875, color: [255, 237, 160] },
      { value: 1, color: [255, 255, 204] }
    ]
  }),
  /**
   * Classic blue-red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLUERED: new g({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rdbu color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RDBU: new g({
    stops: [
      { value: 0, color: [5, 10, 172] },
      { value: 0.35, color: [106, 137, 247] },
      { value: 0.5, color: [190, 190, 190] },
      { value: 0.6, color: [220, 170, 132] },
      { value: 0.7, color: [230, 145, 90] },
      { value: 1, color: [178, 10, 28] }
    ]
  }),
  /**
   * Classic picnic color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PICNIC: new g({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 0.1, color: [51, 153, 255] },
      { value: 0.2, color: [102, 204, 255] },
      { value: 0.3, color: [153, 204, 255] },
      { value: 0.4, color: [204, 204, 255] },
      { value: 0.5, color: [255, 255, 255] },
      { value: 0.6, color: [255, 204, 255] },
      { value: 0.7, color: [255, 153, 255] },
      { value: 0.8, color: [255, 102, 204] },
      { value: 0.9, color: [255, 102, 102] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rainbow color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW: new g({
    stops: [
      { value: 0, color: [150, 0, 90] },
      { value: 0.125, color: [0, 0, 200] },
      { value: 0.25, color: [0, 25, 255] },
      { value: 0.375, color: [0, 152, 255] },
      { value: 0.5, color: [44, 255, 150] },
      { value: 0.625, color: [151, 255, 0] },
      { value: 0.75, color: [255, 234, 0] },
      { value: 0.875, color: [255, 111, 0] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic Portland color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PORTLAND: new g({
    stops: [
      { value: 0, color: [12, 51, 131] },
      { value: 0.25, color: [10, 136, 186] },
      { value: 0.5, color: [242, 211, 56] },
      { value: 0.75, color: [242, 143, 56] },
      { value: 1, color: [217, 30, 30] }
    ]
  }),
  /**
   * Classic blackbody color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLACKBODY: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.2, color: [230, 0, 0] },
      { value: 0.4, color: [230, 210, 0] },
      { value: 0.7, color: [255, 255, 255] },
      { value: 1, color: [160, 200, 255] }
    ]
  }),
  /**
   * Classic earth color ramp.
   * Defined in interval [0, 1], without unit.
   */
  EARTH: new g({
    stops: [
      { value: 0, color: [0, 0, 130] },
      { value: 0.1, color: [0, 180, 180] },
      { value: 0.2, color: [40, 210, 40] },
      { value: 0.4, color: [230, 230, 50] },
      { value: 0.6, color: [120, 70, 20] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic electric color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ELECTRIC: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.15, color: [30, 0, 100] },
      { value: 0.4, color: [120, 0, 100] },
      { value: 0.6, color: [160, 90, 0] },
      { value: 0.8, color: [230, 200, 0] },
      { value: 1, color: [255, 250, 220] }
    ]
  }),
  /**
   * Classic viridis color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VIRIDIS: new g({
    stops: [
      { value: 0, color: [68, 1, 84] },
      { value: 0.13, color: [71, 44, 122] },
      { value: 0.25, color: [59, 81, 139] },
      { value: 0.38, color: [44, 113, 142] },
      { value: 0.5, color: [33, 144, 141] },
      { value: 0.63, color: [39, 173, 129] },
      { value: 0.75, color: [92, 200, 99] },
      { value: 0.88, color: [170, 220, 50] },
      { value: 1, color: [253, 231, 37] }
    ]
  }),
  /**
   * Classic inferno color ramp.
   * Defined in interval [0, 1], without unit.
   */
  INFERNO: new g({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [31, 12, 72] },
      { value: 0.25, color: [85, 15, 109] },
      { value: 0.38, color: [136, 34, 106] },
      { value: 0.5, color: [186, 54, 85] },
      { value: 0.63, color: [227, 89, 51] },
      { value: 0.75, color: [249, 140, 10] },
      { value: 0.88, color: [249, 201, 50] },
      { value: 1, color: [252, 255, 164] }
    ]
  }),
  /**
   * Classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  MAGMA: new g({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [28, 16, 68] },
      { value: 0.25, color: [79, 18, 123] },
      { value: 0.38, color: [129, 37, 129] },
      { value: 0.5, color: [181, 54, 122] },
      { value: 0.63, color: [229, 80, 100] },
      { value: 0.75, color: [251, 135, 97] },
      { value: 0.88, color: [254, 194, 135] },
      { value: 1, color: [252, 253, 191] }
    ]
  }),
  /**
   * Classic plasma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PLASMA: new g({
    stops: [
      { value: 0, color: [13, 8, 135] },
      { value: 0.13, color: [75, 3, 161] },
      { value: 0.25, color: [125, 3, 168] },
      { value: 0.38, color: [168, 34, 150] },
      { value: 0.5, color: [203, 70, 121] },
      { value: 0.63, color: [229, 107, 93] },
      { value: 0.75, color: [248, 148, 65] },
      { value: 0.88, color: [253, 195, 40] },
      { value: 1, color: [240, 249, 33] }
    ]
  }),
  /**
   * Classic warm color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WARM: new g({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [172, 0, 187] },
      { value: 0.25, color: [219, 0, 170] },
      { value: 0.38, color: [255, 0, 130] },
      { value: 0.5, color: [255, 63, 74] },
      { value: 0.63, color: [255, 123, 0] },
      { value: 0.75, color: [234, 176, 0] },
      { value: 0.88, color: [190, 228, 0] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic cool color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COOL: new g({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [116, 0, 218] },
      { value: 0.25, color: [98, 74, 237] },
      { value: 0.38, color: [68, 146, 231] },
      { value: 0.5, color: [0, 204, 197] },
      { value: 0.63, color: [0, 247, 146] },
      { value: 0.75, color: [0, 255, 88] },
      { value: 0.88, color: [40, 255, 8] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic rainboz soft color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW_SOFT: new g({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.1, color: [199, 0, 180] },
      { value: 0.2, color: [255, 0, 121] },
      { value: 0.3, color: [255, 108, 0] },
      { value: 0.4, color: [222, 194, 0] },
      { value: 0.5, color: [150, 255, 0] },
      { value: 0.6, color: [0, 255, 55] },
      { value: 0.7, color: [0, 246, 150] },
      { value: 0.8, color: [50, 167, 222] },
      { value: 0.9, color: [103, 51, 235] },
      { value: 1, color: [124, 0, 186] }
    ]
  }),
  /**
   * Classic bathymetry color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BATHYMETRY: new g({
    stops: [
      { value: 0, color: [40, 26, 44] },
      { value: 0.13, color: [59, 49, 90] },
      { value: 0.25, color: [64, 76, 139] },
      { value: 0.38, color: [63, 110, 151] },
      { value: 0.5, color: [72, 142, 158] },
      { value: 0.63, color: [85, 174, 163] },
      { value: 0.75, color: [120, 206, 163] },
      { value: 0.88, color: [187, 230, 172] },
      { value: 1, color: [253, 254, 204] }
    ]
  }),
  /**
   * Classic cdom color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CDOM: new g({
    stops: [
      { value: 0, color: [47, 15, 62] },
      { value: 0.13, color: [87, 23, 86] },
      { value: 0.25, color: [130, 28, 99] },
      { value: 0.38, color: [171, 41, 96] },
      { value: 0.5, color: [206, 67, 86] },
      { value: 0.63, color: [230, 106, 84] },
      { value: 0.75, color: [242, 149, 103] },
      { value: 0.88, color: [249, 193, 135] },
      { value: 1, color: [254, 237, 176] }
    ]
  }),
  /**
   * Classic chlorophyll color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CHLOROPHYLL: new g({
    stops: [
      { value: 0, color: [18, 36, 20] },
      { value: 0.13, color: [25, 63, 41] },
      { value: 0.25, color: [24, 91, 59] },
      { value: 0.38, color: [13, 119, 72] },
      { value: 0.5, color: [18, 148, 80] },
      { value: 0.63, color: [80, 173, 89] },
      { value: 0.75, color: [132, 196, 122] },
      { value: 0.88, color: [175, 221, 162] },
      { value: 1, color: [215, 249, 208] }
    ]
  }),
  /**
   * Classic density color ramp.
   * Defined in interval [0, 1], without unit.
   */
  DENSITY: new g({
    stops: [
      { value: 0, color: [54, 14, 36] },
      { value: 0.13, color: [89, 23, 80] },
      { value: 0.25, color: [110, 45, 132] },
      { value: 0.38, color: [120, 77, 178] },
      { value: 0.5, color: [120, 113, 213] },
      { value: 0.63, color: [115, 151, 228] },
      { value: 0.75, color: [134, 185, 227] },
      { value: 0.88, color: [177, 214, 227] },
      { value: 1, color: [230, 241, 241] }
    ]
  }),
  /**
   * Classic freesurface blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_BLUE: new g({
    stops: [
      { value: 0, color: [30, 4, 110] },
      { value: 0.13, color: [47, 14, 176] },
      { value: 0.25, color: [41, 45, 236] },
      { value: 0.38, color: [25, 99, 212] },
      { value: 0.5, color: [68, 131, 200] },
      { value: 0.63, color: [114, 156, 197] },
      { value: 0.75, color: [157, 181, 203] },
      { value: 0.88, color: [200, 208, 216] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic freesurface red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_RED: new g({
    stops: [
      { value: 0, color: [60, 9, 18] },
      { value: 0.13, color: [100, 17, 27] },
      { value: 0.25, color: [142, 20, 29] },
      { value: 0.38, color: [177, 43, 27] },
      { value: 0.5, color: [192, 87, 63] },
      { value: 0.63, color: [205, 125, 105] },
      { value: 0.75, color: [216, 162, 148] },
      { value: 0.88, color: [227, 199, 193] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic oxygen color ramp.
   * Defined in interval [0, 1], without unit.
   */
  OXYGEN: new g({
    stops: [
      { value: 0, color: [64, 5, 5] },
      { value: 0.13, color: [106, 6, 15] },
      { value: 0.25, color: [144, 26, 7] },
      { value: 0.38, color: [168, 64, 3] },
      { value: 0.5, color: [188, 100, 4] },
      { value: 0.63, color: [206, 136, 11] },
      { value: 0.75, color: [220, 174, 25] },
      { value: 0.88, color: [231, 215, 44] },
      { value: 1, color: [248, 254, 105] }
    ]
  }),
  /**
   * Classic par color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PAR: new g({
    stops: [
      { value: 0, color: [51, 20, 24] },
      { value: 0.13, color: [90, 32, 35] },
      { value: 0.25, color: [129, 44, 34] },
      { value: 0.38, color: [159, 68, 25] },
      { value: 0.5, color: [182, 99, 19] },
      { value: 0.63, color: [199, 134, 22] },
      { value: 0.75, color: [212, 171, 35] },
      { value: 0.88, color: [221, 210, 54] },
      { value: 1, color: [225, 253, 75] }
    ]
  }),
  /**
   * Classic phase color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PHASE: new g({
    stops: [
      { value: 0, color: [145, 105, 18] },
      { value: 0.13, color: [184, 71, 38] },
      { value: 0.25, color: [186, 58, 115] },
      { value: 0.38, color: [160, 71, 185] },
      { value: 0.5, color: [110, 97, 218] },
      { value: 0.63, color: [50, 123, 164] },
      { value: 0.75, color: [31, 131, 110] },
      { value: 0.88, color: [77, 129, 34] },
      { value: 1, color: [145, 105, 18] }
    ]
  }),
  /**
   * Classic salinity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SALINITY: new g({
    stops: [
      { value: 0, color: [42, 24, 108] },
      { value: 0.13, color: [33, 50, 162] },
      { value: 0.25, color: [15, 90, 145] },
      { value: 0.38, color: [40, 118, 137] },
      { value: 0.5, color: [59, 146, 135] },
      { value: 0.63, color: [79, 175, 126] },
      { value: 0.75, color: [120, 203, 104] },
      { value: 0.88, color: [193, 221, 100] },
      { value: 1, color: [253, 239, 154] }
    ]
  }),
  /**
   * Classic temperature color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TEMPERATURE: new g({
    stops: [
      { value: 0, color: [4, 35, 51] },
      { value: 0.13, color: [23, 51, 122] },
      { value: 0.25, color: [85, 59, 157] },
      { value: 0.38, color: [129, 79, 143] },
      { value: 0.5, color: [175, 95, 130] },
      { value: 0.63, color: [222, 112, 101] },
      { value: 0.75, color: [249, 146, 66] },
      { value: 0.88, color: [249, 196, 65] },
      { value: 1, color: [232, 250, 91] }
    ]
  }),
  /**
   * Classic turbidity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TURBIDITY: new g({
    stops: [
      { value: 0, color: [34, 31, 27] },
      { value: 0.13, color: [65, 50, 41] },
      { value: 0.25, color: [98, 69, 52] },
      { value: 0.38, color: [131, 89, 57] },
      { value: 0.5, color: [161, 112, 59] },
      { value: 0.63, color: [185, 140, 66] },
      { value: 0.75, color: [202, 174, 88] },
      { value: 0.88, color: [216, 209, 126] },
      { value: 1, color: [233, 246, 171] }
    ]
  }),
  /**
   * Classic velocity blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_BLUE: new g({
    stops: [
      { value: 0, color: [17, 32, 64] },
      { value: 0.13, color: [35, 52, 116] },
      { value: 0.25, color: [29, 81, 156] },
      { value: 0.38, color: [31, 113, 162] },
      { value: 0.5, color: [50, 144, 169] },
      { value: 0.63, color: [87, 173, 176] },
      { value: 0.75, color: [149, 196, 189] },
      { value: 0.88, color: [203, 221, 211] },
      { value: 1, color: [254, 251, 230] }
    ]
  }),
  /**
   * Classic velocity green color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_GREEN: new g({
    stops: [
      { value: 0, color: [23, 35, 19] },
      { value: 0.13, color: [24, 64, 38] },
      { value: 0.25, color: [11, 95, 45] },
      { value: 0.38, color: [39, 123, 35] },
      { value: 0.5, color: [95, 146, 12] },
      { value: 0.63, color: [152, 165, 18] },
      { value: 0.75, color: [201, 186, 69] },
      { value: 0.88, color: [233, 216, 137] },
      { value: 1, color: [255, 253, 205] }
    ]
  }),
  /**
   * Classic cube helix color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CUBEHELIX: new g({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.07, color: [22, 5, 59] },
      { value: 0.13, color: [60, 4, 105] },
      { value: 0.2, color: [109, 1, 135] },
      { value: 0.27, color: [161, 0, 147] },
      { value: 0.33, color: [210, 2, 142] },
      { value: 0.4, color: [251, 11, 123] },
      { value: 0.47, color: [255, 29, 97] },
      { value: 0.53, color: [255, 54, 69] },
      { value: 0.6, color: [255, 85, 46] },
      { value: 0.67, color: [255, 120, 34] },
      { value: 0.73, color: [255, 157, 37] },
      { value: 0.8, color: [241, 191, 57] },
      { value: 0.87, color: [224, 220, 93] },
      { value: 0.93, color: [218, 241, 142] },
      { value: 1, color: [227, 253, 198] }
    ]
  }),
  /**
   * The cividis color ramp is color blind friendly.
   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239
   * Defined in interval [0, 1], without unit.
   */
  CIVIDIS: new g({
    stops: [
      { value: 0, color: [0, 32, 77, 255] },
      { value: 0.125, color: [5, 54, 110, 255] },
      { value: 0.25, color: [65, 77, 108, 255] },
      { value: 0.375, color: [97, 100, 111, 255] },
      { value: 0.5, color: [125, 124, 121, 255] },
      { value: 0.625, color: [156, 149, 120, 255] },
      { value: 0.75, color: [190, 175, 111, 255] },
      { value: 0.875, color: [225, 204, 94, 255] },
      { value: 1, color: [255, 235, 70, 255] }
    ]
  }),
  /**
   * Classic turbo color ramp.
   * This is a luminance-constant alternative to the jet, making it more
   * clor-blind friendly.
   * Defined in interval [0, 1], without unit.
   */
  TURBO: new g({
    stops: [
      { value: 0, color: [48, 18, 59, 255] },
      { value: 0.125, color: [70, 107, 227, 255] },
      { value: 0.25, color: [40, 187, 236, 255] },
      { value: 0.375, color: [49, 242, 153, 255] },
      { value: 0.5, color: [162, 252, 60, 255] },
      { value: 0.625, color: [237, 208, 58, 255] },
      { value: 0.75, color: [251, 128, 34, 255] },
      { value: 0.875, color: [210, 49, 5, 255] },
      { value: 1, color: [122, 4, 3, 255] }
    ]
  }),
  /**
   * The rocket color ramp is perceptually uniform, which makes it more
   * color bliend friendly than the classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ROCKET: new g({
    stops: [
      { value: 0, color: [250, 235, 221, 0] },
      { value: 0.133, color: [250, 235, 221, 255] },
      { value: 0.266, color: [246, 170, 130, 255] },
      { value: 0.4, color: [240, 96, 67, 255] },
      { value: 0.533, color: [203, 27, 79, 255] },
      { value: 0.666, color: [132, 30, 90, 255] },
      { value: 0.8, color: [63, 27, 68, 255] },
      { value: 1, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * The mako color ramp is perceptually uniform and can be seen as
   * a color blind friendly alternative to bathymetry or yignbu.
   * Defined in interval [0, 1], without unit.
   */
  MAKO: new g({
    stops: [
      { value: 0, color: [11, 4, 5, 255] },
      { value: 0.125, color: [43, 28, 53, 255] },
      { value: 0.25, color: [62, 53, 107, 255] },
      { value: 0.375, color: [59, 86, 152, 255] },
      { value: 0.5, color: [53, 123, 162, 255] },
      { value: 0.625, color: [53, 158, 170, 255] },
      { value: 0.75, color: [73, 193, 173, 255] },
      { value: 0.875, color: [150, 221, 181, 255] },
      { value: 1, color: [222, 245, 229, 255] }
    ]
  }),
  // --------- specialized --------------
  /**
   * Elevation terrain, values are in meter.
   * Defined in interval [-10001, 8000].
   */
  TERRAIN: new g({
    stops: [
      { value: -10001, color: [0, 20, 60] },
      { value: -5e3, color: [0, 10, 30] },
      { value: -1e3, color: [0, 30, 80] },
      { value: -100, color: [0, 38, 115] },
      { value: 0, color: [122, 200, 255] },
      { value: 10, color: [51, 102, 0] },
      { value: 500, color: [129, 195, 31] },
      { value: 800, color: [255, 255, 204] },
      { value: 1200, color: [244, 189, 69] },
      { value: 2e3, color: [132, 75, 0] },
      { value: 3e3, color: [102, 51, 12] },
      { value: 8e3, color: [255, 255, 255] }
    ]
  }),
  /**
   * Atmospheric pressure, values in hPa (or millibar)
   * Defined in interval [900, 1080].
   */
  PRESSURE: new g({
    stops: [
      { value: 900, color: [0, 0, 100, 250] },
      { value: 950, color: [0, 0, 255, 250] },
      { value: 980, color: [0, 0, 255, 120] },
      { value: 1e3, color: [255, 255, 255, 0] },
      { value: 1020, color: [255, 0, 0, 120] },
      { value: 1080, color: [255, 0, 0, 250] }
    ]
  }),
  /**
   * Atmospheric pressure, values in hPa (or millibar).
   * Defined in interval [900, 1080].
   */
  PRESSURE_2: new g({
    stops: [
      { value: 900, color: [8, 16, 48, 255] },
      { value: 950, color: [0, 32, 96, 255] },
      { value: 976, color: [0, 52, 146, 255] },
      { value: 986, color: [0, 90, 148, 255] },
      { value: 995, color: [0, 117, 146, 255] },
      { value: 1002, color: [26, 140, 147, 255] },
      { value: 1007, color: [103, 162, 155, 255] },
      { value: 1011, color: [155, 183, 172, 255] },
      { value: 1013, color: [182, 182, 182, 255] },
      { value: 1015, color: [176, 174, 152, 255] },
      { value: 1019, color: [167, 147, 107, 255] },
      { value: 1024, color: [163, 116, 67, 255] },
      { value: 1030, color: [159, 81, 44, 255] },
      { value: 1038, color: [142, 47, 57, 255] },
      { value: 1046, color: [111, 24, 64, 255] },
      { value: 1080, color: [48, 8, 24, 255] }
    ]
  }),
  /**
   * Atmospheric pressure, values in hPa (or millibar).
   * Defined in interval [900, 1080].
   */
  PRESSURE_3: new g({
    stops: [
      { value: 900, color: [40, 46, 117, 255] },
      { value: 950, color: [40, 51, 121, 255] },
      { value: 976, color: [42, 63, 125, 255] },
      { value: 986, color: [55, 97, 141, 255] },
      { value: 995, color: [69, 115, 150, 255] },
      { value: 1002, color: [87, 144, 168, 255] },
      { value: 1007, color: [125, 184, 194, 255] },
      { value: 1011, color: [195, 226, 226, 255] },
      { value: 1013, color: [245, 220, 196, 255] },
      { value: 1015, color: [232, 191, 160, 255] },
      { value: 1019, color: [219, 154, 125, 255] },
      { value: 1024, color: [210, 115, 98, 255] },
      { value: 1030, color: [194, 72, 67, 255] },
      { value: 1038, color: [199, 61, 60, 255] },
      { value: 1046, color: [177, 50, 54, 255] },
      { value: 1080, color: [159, 42, 48, 255] }
    ]
  }),
  /**
   * Atmospheric pressure, values in hPa (or millibar).
   * Defined in interval [900, 1080]. The main difference
   * with PRESSURE_3 is the true neutral zone (pale gray)
   * from 1012.5 to 1013.5hPa
   */
  PRESSURE_4: new g({
    stops: [
      { value: 900, color: [40, 46, 117, 255] },
      { value: 950, color: [40, 51, 121, 255] },
      { value: 976, color: [42, 63, 125, 255] },
      { value: 986, color: [55, 97, 141, 255] },
      { value: 995, color: [69, 115, 150, 255] },
      { value: 1002, color: [87, 144, 168, 255] },
      { value: 1007, color: [125, 184, 194, 255] },
      { value: 1012.5, color: [226, 226, 226, 255] },
      { value: 1013.5, color: [226, 226, 226, 255] },
      { value: 1015, color: [232, 191, 160, 255] },
      { value: 1019, color: [219, 154, 125, 255] },
      { value: 1024, color: [210, 115, 98, 255] },
      { value: 1030, color: [194, 72, 67, 255] },
      { value: 1038, color: [199, 61, 60, 255] },
      { value: 1046, color: [177, 50, 54, 255] },
      { value: 1080, color: [159, 42, 48, 255] }
    ]
  }),
  /**
   * Temperatures in degree Celsius.
   * Defined in interval [-70.15, 46.85].
   */
  TEMPERATURE_2: new g({
    stops: [
      { value: -70.15, color: [115, 70, 105, 255] },
      { value: -55.15, color: [202, 172, 195, 255] },
      { value: -40.15, color: [162, 70, 145, 255] },
      { value: -25.15, color: [143, 89, 169, 255] },
      { value: -15.15, color: [157, 219, 217, 255] },
      { value: -8.15, color: [106, 191, 181, 255] },
      { value: -4.15, color: [100, 166, 189, 255] },
      { value: 0, color: [93, 133, 198, 255] },
      { value: 0.85, color: [68, 125, 99, 255] },
      { value: 9.85, color: [128, 147, 24, 255] },
      { value: 20.85, color: [243, 183, 4, 255] },
      { value: 29.85, color: [232, 83, 25, 255] },
      { value: 46.85, color: [71, 14, 0, 255] }
    ]
  }),
  /**
   * Temperatures in degrees Celsius.
   * Defined in interval [-65, 55].
   */
  TEMPERATURE_3: new g({
    stops: [
      { value: -65, color: [3, 78, 77, 255] },
      { value: -55, color: [4, 98, 96, 255] },
      { value: -40, color: [5, 122, 120, 255] },
      { value: -30, color: [6, 152, 149, 255] },
      { value: -20, color: [8, 201, 198, 255] },
      { value: -15, color: [20, 245, 241, 255] },
      { value: -10, color: [108, 237, 249, 255] },
      { value: -5, color: [133, 205, 250, 255] },
      { value: 0, color: [186, 227, 252, 255] },
      { value: 5, color: [238, 221, 145, 255] },
      { value: 10, color: [232, 183, 105, 255] },
      { value: 15, color: [232, 137, 69, 255] },
      { value: 20, color: [231, 107, 24, 255] },
      { value: 25, color: [236, 84, 19, 255] },
      { value: 30, color: [236, 44, 19, 255] },
      { value: 40, color: [123, 23, 10, 255] },
      { value: 55, color: [91, 11, 0, 255] }
    ]
  }),
  /**
   * Precipitation in mm per hour.
   *  Defined in interval [0, 50].
   */
  PRECIPITATION: new g({
    stops: [
      { value: 0, color: [111, 111, 111, 0] },
      { value: 0.6, color: [60, 116, 160, 180] },
      { value: 6, color: [59, 161, 161, 255] },
      { value: 8, color: [59, 161, 61, 255] },
      { value: 10, color: [130, 161, 59, 255] },
      { value: 15, color: [161, 161, 59, 255] },
      { value: 20, color: [161, 59, 59, 255] },
      { value: 31, color: [161, 59, 161, 255] },
      { value: 50, color: [168, 168, 168, 255] }
    ]
  }),
  /**
   * precipitation in mm per hour.
   *  Defined in interval [0, 50].
   */
  PRECIPITATION_2: new g({
    stops: [
      { value: 0, color: [255, 255, 255, 0] },
      { value: 0.1, color: [171, 218, 252, 255] },
      { value: 1, color: [98, 186, 249, 255] },
      { value: 2, color: [87, 160, 240, 255] },
      { value: 4, color: [112, 128, 250, 255] },
      { value: 6, color: [128, 102, 245, 255] },
      { value: 8, color: [152, 102, 245, 255] },
      { value: 10, color: [154, 87, 172, 255] },
      { value: 15, color: [228, 88, 126, 255] },
      { value: 20, color: [247, 135, 95, 255] },
      { value: 30, color: [249, 206, 64, 255] },
      { value: 50, color: [250, 248, 168, 52] }
    ]
  }),
  /**
   * Radar color ramp from NOAA in dBZ.
   *  Defined in interval [0, 75].
   */
  RADAR: new g({
    stops: [
      { value: 0, color: [7, 235, 236, 0] },
      { value: 4, color: [7, 235, 236, 80] },
      { value: 5, color: [7, 235, 236, 255] },
      { value: 10, color: [0, 159, 246, 255] },
      { value: 15, color: [0, 0, 247, 255] },
      { value: 20, color: [3, 255, 0, 255] },
      { value: 25, color: [0, 200, 2, 255] },
      { value: 30, color: [1, 144, 0, 255] },
      { value: 35, color: [255, 255, 0, 255] },
      { value: 40, color: [231, 192, 0, 255] },
      { value: 45, color: [255, 145, 3, 255] },
      { value: 50, color: [255, 0, 0, 255] },
      { value: 55, color: [215, 0, 0, 255] },
      { value: 60, color: [192, 0, 0, 255] },
      { value: 65, color: [255, 0, 255, 255] },
      { value: 70, color: [155, 85, 200, 255] },
      { value: 75, color: [235, 235, 235, 255] }
    ]
  }),
  /**
   * Intended to be used with Radar data to create a slighly blue-tinted greyscale
   * to represent cloud coverage. Values are in dBZ.
   * Defined in interval [4, 60].
   */
  RADAR_CLOUD: new g({
    stops: [
      { value: 4, color: [134, 134, 176, 0] },
      { value: 7, color: [134, 134, 176, 30] },
      { value: 10, color: [134, 134, 176, 60] },
      { value: 20, color: [110, 110, 145, 80] },
      { value: 35, color: [77, 77, 105, 140] },
      { value: 45, color: [58, 58, 87, 180] },
      { value: 60, color: [26, 26, 51, 220] }
    ]
  }),
  /**
   * This atmospheric pressure color ramp is based on cividis,
   * hence it is more clor bliend friendly. Values are in hPa (or millibar).
   * Defined in interval [900, 1080].
   */
  PRESSURE_CIVIDIS: new g({
    stops: [
      { value: 900, color: [0, 32, 77, 255] },
      { value: 950, color: [0, 37, 82, 255] },
      { value: 976, color: [15, 56, 110, 255] },
      { value: 986, color: [49, 68, 107, 255] },
      { value: 995, color: [70, 80, 107, 255] },
      { value: 1002, color: [87, 92, 109, 255] },
      { value: 1007, color: [102, 105, 112, 255] },
      { value: 1011, color: [117, 117, 117, 255] },
      { value: 1013, color: [132, 130, 121, 255] },
      { value: 1015, color: [149, 143, 120, 255] },
      { value: 1019, color: [166, 157, 117, 255] },
      { value: 1024, color: [184, 171, 112, 255] },
      { value: 1030, color: [203, 186, 105, 255] },
      { value: 1038, color: [221, 201, 95, 255] },
      { value: 1046, color: [250, 229, 65, 255] },
      { value: 1080, color: [255, 234, 70, 255] }
    ]
  }),
  /**
   * This rocket color ramp scaled for radar data is a color blind
   * friendly alternative. Values are in dBZ.
   * Defined in interval [0, 75]
   */
  RADAR_ROCKET: new g({
    stops: [
      { value: 0, color: [250, 235, 221, 0] },
      { value: 0.1, color: [250, 235, 221, 255] },
      { value: 10, color: [246, 180, 142, 255] },
      { value: 20, color: [243, 118, 81, 255] },
      { value: 30, color: [225, 51, 66, 255] },
      { value: 40, color: [174, 23, 89, 255] },
      { value: 50, color: [112, 31, 87, 255] },
      { value: 60, color: [54, 25, 62, 255] },
      { value: 75, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * This rocket color ramp scaled for wind speed is a color blind
   * friendly alternative. Values are in m/sec.
   * Defined in interval [0, 30]
   */
  WIND_ROCKET: new g({
    stops: [
      { value: 0, color: [250, 235, 221, 255] },
      { value: 1, color: [246, 187, 151, 255] },
      { value: 3, color: [244, 135, 94, 255] },
      { value: 5, color: [236, 75, 62, 255] },
      { value: 10, color: [203, 27, 79, 255] },
      { value: 15, color: [150, 28, 91, 255] },
      { value: 20, color: [97, 31, 83, 255] },
      { value: 25, color: [48, 23, 58, 255] },
      { value: 30, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * This mako color ramps is scale for precipitation is a color blind
   * friendly alternative. Values are in mm/hour
   * Defined in interval [0, 50].
   */
  MAKO_PRECIPITATION: new g({
    stops: [
      { value: 0, color: [255, 255, 255, 0] },
      { value: 0.1, color: [222, 245, 229, 255] },
      { value: 1, color: [168, 225, 188, 255] },
      { value: 2, color: [96, 206, 172, 255] },
      { value: 4, color: [61, 180, 173, 255] },
      { value: 6, color: [52, 151, 169, 255] },
      { value: 8, color: [53, 123, 162, 255] },
      { value: 10, color: [57, 93, 156, 255] },
      { value: 15, color: [65, 64, 129, 255] },
      { value: 20, color: [56, 42, 84, 255] },
      { value: 30, color: [38, 23, 42, 255] },
      { value: 50, color: [11, 4, 5, 255] }
    ]
  }),
  /**
   * Based on the turbo color ramp, this one is scaled
   * to render temperatures in degree Celcius.
   * This is a perceptually uniform alternative to jet, making it more color bliend friendly.
   * Defined in interval [-65, 55].
   */
  TEMPERATURE_TURBO: new g({
    stops: [
      { value: -65, color: [48, 18, 59, 255] },
      { value: -55, color: [64, 64, 162, 255] },
      { value: -40, color: [70, 107, 227, 255] },
      { value: -30, color: [66, 147, 255, 255] },
      { value: -20, color: [40, 187, 236, 255] },
      { value: -15, color: [24, 220, 195, 255] },
      { value: -10, color: [49, 242, 153, 255] },
      { value: -5, color: [107, 254, 100, 255] },
      { value: 0, color: [162, 252, 60, 255] },
      { value: 5, color: [204, 237, 52, 255] },
      { value: 10, color: [237, 208, 58, 255] },
      { value: 15, color: [253, 173, 53, 255] },
      { value: 20, color: [231, 107, 24, 255] },
      { value: 25, color: [236, 82, 15, 255] },
      { value: 30, color: [210, 49, 5, 255] },
      { value: 40, color: [172, 23, 1, 255] },
      { value: 55, color: [122, 4, 3, 255] }
    ]
  })
});
let Ge = g;
const te = {
  maxAmount: 128,
  color: [255, 255, 255, 0],
  density: 200,
  size: 1,
  speed: 15e-4,
  refreshInterval: 200,
  fadeFactor: 0.04,
  opacity: 1,
  colorramp: Ge.builtin.VIRIDIS,
  smooth: !0,
  fastColor: [255, 255, 255, 255],
  fastSpeed: 3,
  fastIsLarger: !0
};
class ir extends $i {
  constructor(e = {}) {
    super(e.id || "MapTiler Wind", null, null, null);
    u(this, "constructorOptions");
    u(this, "isSourceReady", !1);
    u(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, o) {
    const i = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    F.hasData() || await F.fetchLatest(i, r);
    const l = F.getWindData();
    if (!l) throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? te.colorramp.scale(0, 40), this.initParticle(
      {
        minZoom: l.metadata.minzoom,
        maxZoom: l.metadata.maxzoom
      },
      {
        decodeChannels: l.metadata.weather_variable.decoding.channels.toLowerCase(),
        decodeMin: l.metadata.weather_variable.decoding.min,
        decodeMax: l.metadata.weather_variable.decoding.max,
        decodeAsWaves: !1,
        maxAmount: this.constructorOptions.maxAmount ?? te.maxAmount,
        color: this.constructorOptions.color ?? te.color,
        fastColor: this.constructorOptions.fastColor ?? te.fastColor,
        fastSpeed: this.constructorOptions.fastSpeed ?? te.fastSpeed,
        density: this.constructorOptions.density ?? te.density,
        size: this.constructorOptions.size ?? te.size,
        speed: this.constructorOptions.speed ?? te.speed,
        refreshInterval: this.constructorOptions.refreshInterval ?? te.refreshInterval,
        fadeFactor: this.constructorOptions.fadeFactor ?? te.fadeFactor,
        angleDirectionShiftSkip: 30,
        uniformSpeed: !0,
        fastIsLarger: this.constructorOptions.fastIsLarger ?? te.fastIsLarger
      },
      [
        new lt({
          decode: {
            channel: l.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: l.metadata.weather_variable.decoding.min,
            max: l.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? te.smooth,
          opacity: this.constructorOptions.opacity ?? te.opacity
        })
      ]
    ), super.onAdd(e, o);
    const s = F.getSourcesAndTimestamps(l, i, r);
    for (const h of s)
      this.addSource(h.timestamp, h.source);
    const c = +/* @__PURE__ */ new Date() / 1e3;
    c >= this.getAnimationStart() && c <= this.getAnimationEnd() && this.setAnimationTime(c), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the wind speed and direction in multiple measurement units at a given location
   * @param lng
   * @param lat
   * @param options: bilinear interpolation (boolean) is disabled by default for better performance
   * @returns
   */
  pickAt(e, o, i = {}) {
    const r = super.pick(e, o, i);
    if (!r) return null;
    const l = r[0], s = r[1], c = Math.sqrt(l ** 2 + s ** 2), d = Math.atan2(l, s) * 180 / Math.PI;
    return {
      speedMetersPerSecond: c,
      speedKilometersPerHour: c * 3.6,
      speedMilesPerHour: c * 2.23694,
      speedFeetPerSecond: c * 3.28084,
      speedKnots: c * 1.94384,
      directionAngle: d,
      compassDirection: Bo(d + 180)
    };
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
class rr extends st {
  constructor(e = {}) {
    super(e.id || "MapTiler Pressure", null, null, null);
    u(this, "constructorOptions");
    u(this, "isSourceReady", !1);
    u(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, o) {
    const i = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    F.hasData() || await F.fetchLatest(i, r);
    const l = F.getPressureData();
    if (!l) throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? Ge.builtin.PRESSURE_2, this.init(
      {
        minZoom: l.metadata.minzoom,
        maxZoom: l.metadata.maxzoom,
        repaintOnPausedAnimation: !1
      },
      [
        new lt({
          decode: {
            channel: l.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: l.metadata.weather_variable.decoding.min,
            max: l.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? !0,
          opacity: this.constructorOptions.opacity ?? 1
        })
      ]
    ), super.onAdd(e, o);
    const s = F.getSourcesAndTimestamps(l, i, r);
    for (const h of s)
      this.addSource(h.timestamp, h.source);
    const c = +/* @__PURE__ */ new Date() / 1e3;
    c >= this.getAnimationStart() && c <= this.getAnimationEnd() && this.setAnimationTime(c), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the air pressure in hPa at a given location
   * @param lng
   * @param lat
   * @param options: bilinear interpolation (boolean) is disabled by default for better performance
   * @returns
   */
  pickAt(e, o, i = {}) {
    const r = super.pick(e, o, i);
    return r ? {
      value: r[0]
    } : null;
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
class nr extends st {
  constructor(e = {}) {
    super(e.id || "MapTiler Temperature", null, null, null);
    u(this, "constructorOptions");
    u(this, "isSourceReady", !1);
    u(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, o) {
    const i = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    F.hasData() || await F.fetchLatest(i, r);
    const l = F.getTemperatureData();
    if (!l) throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? Ge.builtin.TEMPERATURE_2, this.init(
      {
        minZoom: l.metadata.minzoom,
        maxZoom: l.metadata.maxzoom,
        repaintOnPausedAnimation: !1
      },
      [
        new lt({
          decode: {
            channel: l.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: l.metadata.weather_variable.decoding.min,
            max: l.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? !0,
          opacity: this.constructorOptions.opacity ?? 1
        })
      ]
    ), super.onAdd(e, o);
    const s = F.getSourcesAndTimestamps(l, i, r);
    for (const h of s)
      this.addSource(h.timestamp, h.source);
    const c = +/* @__PURE__ */ new Date() / 1e3;
    c >= this.getAnimationStart() && c <= this.getAnimationEnd() && this.setAnimationTime(c), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the temperature in multiple measurement units at a given location
   * @param lng
   * @param lat
   * @param options: bilinear interpolation (boolean) is disabled by default for better performance
   * @returns
   */
  pickAt(e, o, i = {}) {
    const r = super.pick(e, o, i);
    if (!r) return null;
    const l = r[0];
    return {
      value: l,
      valueImperial: 32 + l * 9 / 5
    };
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
class lr extends st {
  constructor(e = {}) {
    super(e.id || "MapTiler Precipitation", null, null, null);
    u(this, "constructorOptions");
    u(this, "isSourceReady", !1);
    u(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, o) {
    const i = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    F.hasData() || await F.fetchLatest(i, r);
    const l = F.getPrecipitationData();
    if (!l) throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? Ge.builtin.PRECIPITATION, this.init(
      {
        minZoom: l.metadata.minzoom,
        maxZoom: l.metadata.maxzoom,
        repaintOnPausedAnimation: !1
      },
      [
        new lt({
          decode: {
            channel: l.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: l.metadata.weather_variable.decoding.min,
            max: l.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? !0,
          opacity: this.constructorOptions.opacity ?? 1
        })
      ]
    ), super.onAdd(e, o);
    const s = F.getSourcesAndTimestamps(l, i, r);
    for (const h of s)
      this.addSource(h.timestamp, h.source);
    const c = +/* @__PURE__ */ new Date() / 1e3;
    c >= this.getAnimationStart() && c <= this.getAnimationEnd() && this.setAnimationTime(c), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the amount of precipitation in mm/h
   * @param lng
   * @param lat
   * @param options: bilinear interpolation (boolean) is disabled by default for better performance
   * @returns
   */
  pickAt(e, o, i = {}) {
    const r = super.pick(e, o, i);
    return r ? {
      value: r[0],
      valueImperial: r[0] / 2.54
    } : null;
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
class ar extends st {
  constructor(e = {}) {
    super(e.id || "MapTiler Radar", null, null, null);
    u(this, "constructorOptions");
    u(this, "isSourceReady", !1);
    u(this, "colorRamp");
    this.constructorOptions = e;
  }
  async onAdd(e, o) {
    const i = e.getSdkConfig().apiKey, r = e.getMaptilerSessionId();
    F.hasData() || await F.fetchLatest(i, r);
    const l = F.getRadarData();
    if (!l) throw new Error("The latest weather data is not avaialble");
    this.colorRamp = this.constructorOptions.colorramp ?? Ge.builtin.RADAR, this.init(
      {
        minZoom: l.metadata.minzoom,
        maxZoom: l.metadata.maxzoom,
        repaintOnPausedAnimation: !1
      },
      [
        new lt({
          decode: {
            channel: l.metadata.weather_variable.decoding.channels.toLowerCase(),
            min: l.metadata.weather_variable.decoding.min,
            max: l.metadata.weather_variable.decoding.max
          },
          stops: this.colorRamp,
          smooth: this.constructorOptions.smooth ?? !0,
          opacity: this.constructorOptions.opacity ?? 1
        })
      ]
    ), super.onAdd(e, o);
    const s = F.getSourcesAndTimestamps(l, i, r);
    for (const h of s)
      this.addSource(h.timestamp, h.source);
    const c = +/* @__PURE__ */ new Date() / 1e3;
    c >= this.getAnimationStart() && c <= this.getAnimationEnd() && this.setAnimationTime(c), this.isSourceReady = !0, this.emit("sourceReady", { map: e, layer: this });
  }
  /**
   * Check if the data source that fuels the layer has been fully fetched and processed
   * @returns
   */
  getIsSourceReady() {
    return this.isSourceReady;
  }
  /**
   * Get the radar reflectivity in dBZ at a given location
   * @param lng
   * @param lat
   * @param options: bilinear interpolation (boolean) is disabled by default for better performance
   * @returns
   */
  pickAt(e, o, i = {}) {
    const r = super.pick(e, o, i);
    return r ? {
      value: r[0]
    } : null;
  }
  /**
   * Get the color ramp in use by the layer
   * @returns
   */
  getColorRamp() {
    return this.colorRamp;
  }
  /**
   * Async function corresponding to the "sourceReady" event.
   * Resolves directly if source is already ready, or awaits the "sourceReady"
   * event if not.
   */
  onSourceReadyAsync() {
    return new Promise((e) => {
      if (this.isSourceReady)
        return e();
      this.once("sourceReady", () => {
        e();
      });
    });
  }
}
export {
  Lo as ChannelIndices,
  Ge as ColorRamp,
  co as ColoringFragmentBase,
  Tt as EARTH_PERIMETER_M,
  Vo as EARTH_RADIUS_M,
  lt as GradientColoringFragment,
  bi as InstancePool,
  or as MultiChannelGradientColoringFragment,
  tr as OpacityColoringFragment,
  $i as ParticleLayer,
  lr as PrecipitationLayer,
  rr as PressureLayer,
  ar as RadarLayer,
  nr as TemperatureLayer,
  st as TileLayer,
  F as WeatherDataHandler,
  Oe as WeatherVariableID,
  ir as WindLayer,
  er as addLayerWhenReady,
  $e as floatifyColor,
  Bo as getCardinalDirection,
  Yo as getTileCoverage,
  Wo as latToUnit,
  Ji as makeUnitColor,
  Qi as pixelToLat,
  ze as sampleImage,
  Go as unitToLat,
  ko as wgs84ToMaplibreMerc,
  Qe as wgs84ToMerc,
  Xt as wgs84ToTileIndex,
  _t as wgs84ToUnit
};
