var hv = Object.defineProperty;
var Ic = (n) => {
  throw TypeError(n);
};
var cv = (n, t, e) => t in n ? hv(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var Ye = (n, t, e) => cv(n, typeof t != "symbol" ? t + "" : t, e), kc = (n, t, e) => t.has(n) || Ic("Cannot " + e);
var fn = (n, t, e) => (kc(n, t, "read from private field"), e ? e.call(n) : t.get(n)), _u = (n, t, e) => t.has(n) ? Ic("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), Mo = (n, t, e, i) => (kc(n, t, "write to private field"), i ? i.call(n, e) : t.set(n, e), e);
import { Feature as qn } from "ol";
class je {
  /**
   * @param {string} type Type.
   */
  constructor(t) {
    this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
const Dd = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class fv {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function gv(n, t, e) {
  let i, s;
  e = e || er;
  let u = 0, h = n.length, c = !1;
  for (; u < h; )
    i = u + (h - u >> 1), s = +e(n[i], t), s < 0 ? u = i + 1 : (h = i, c = !s);
  return c ? u : ~u;
}
function er(n, t) {
  return n > t ? 1 : n < t ? -1 : 0;
}
function Fd(n, t, e) {
  if (n[0] <= t)
    return 0;
  const i = n.length;
  if (t <= n[i - 1])
    return i - 1;
  if (typeof e == "function") {
    for (let s = 1; s < i; ++s) {
      const u = n[s];
      if (u === t)
        return s;
      if (u < t)
        return e(t, n[s - 1], u) > 0 ? s - 1 : s;
    }
    return i - 1;
  }
  if (e > 0) {
    for (let s = 1; s < i; ++s)
      if (n[s] < t)
        return s - 1;
    return i - 1;
  }
  if (e < 0) {
    for (let s = 1; s < i; ++s)
      if (n[s] <= t)
        return s;
    return i - 1;
  }
  for (let s = 1; s < i; ++s) {
    if (n[s] == t)
      return s;
    if (n[s] < t)
      return n[s - 1] - t < t - n[s] ? s - 1 : s;
  }
  return i - 1;
}
function dv(n, t, e) {
  for (; t < e; ) {
    const i = n[t];
    n[t] = n[e], n[e] = i, ++t, --e;
  }
}
function Mn(n, t) {
  const e = Array.isArray(t) ? t : [t], i = e.length;
  for (let s = 0; s < i; s++)
    n[n.length] = e[s];
}
function cs(n, t) {
  const e = n.length;
  if (e !== t.length)
    return !1;
  for (let i = 0; i < e; i++)
    if (n[i] !== t[i])
      return !1;
  return !0;
}
function mv() {
  return !0;
}
function ts() {
}
function Gd(n) {
  let t = !1, e, i, s;
  return function() {
    const u = Array.prototype.slice.call(arguments);
    return (!t || this !== s || !cs(u, i)) && (t = !0, s = this, i = u, e = n.apply(this, arguments)), e;
  };
}
function Hl(n) {
  for (const t in n)
    delete n[t];
}
function es(n) {
  let t;
  for (t in n)
    return !1;
  return !t;
}
class Bd extends fv {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(t) {
    super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(t, e) {
    if (!t || !e)
      return;
    const i = this.listeners_ || (this.listeners_ = {}), s = i[t] || (i[t] = []);
    s.includes(e) || s.push(e);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(t) {
    const e = typeof t == "string", i = e ? t : t.type, s = this.listeners_ && this.listeners_[i];
    if (!s)
      return;
    const u = e ? new je(t) : (
      /** @type {Event} */
      t
    );
    u.target || (u.target = this.eventTarget_ || this);
    const h = this.dispatching_ || (this.dispatching_ = {}), c = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    i in h || (h[i] = 0, c[i] = 0), ++h[i];
    let g;
    for (let m = 0, y = s.length; m < y; ++m)
      if ("handleEvent" in s[m] ? g = /** @type {import("../events.js").ListenerObject} */
      s[m].handleEvent(u) : g = /** @type {import("../events.js").ListenerFunction} */
      s[m].call(this, u), g === !1 || u.propagationStopped) {
        g = !1;
        break;
      }
    if (--h[i] === 0) {
      let m = c[i];
      for (delete c[i]; m--; )
        this.removeEventListener(i, ts);
      delete h[i];
    }
    return g;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && Hl(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(t) {
    return this.listeners_ && this.listeners_[t] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(t) {
    return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(t, e) {
    if (!this.listeners_)
      return;
    const i = this.listeners_[t];
    if (!i)
      return;
    const s = i.indexOf(e);
    s !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (i[s] = ts, ++this.pendingRemovals_[t]) : (i.splice(s, 1), i.length === 0 && delete this.listeners_[t]));
  }
}
const pn = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function On(n, t, e, i, s) {
  if (i && i !== n && (e = e.bind(i)), s) {
    const h = e;
    e = function() {
      n.removeEventListener(t, e), h.apply(this, arguments);
    };
  }
  const u = {
    target: n,
    type: t,
    listener: e
  };
  return n.addEventListener(t, e), u;
}
function bc(n, t, e, i) {
  return On(n, t, e, i, !0);
}
function Kn(n) {
  n && n.target && (n.target.removeEventListener(n.type, n.listener), Hl(n));
}
class vo extends Bd {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(pn.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(t, e) {
    if (Array.isArray(t)) {
      const i = t.length, s = new Array(i);
      for (let u = 0; u < i; ++u)
        s[u] = On(this, t[u], e);
      return s;
    }
    return On(
      this,
      /** @type {string} */
      t,
      e
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(t, e) {
    let i;
    if (Array.isArray(t)) {
      const s = t.length;
      i = new Array(s);
      for (let u = 0; u < s; ++u)
        i[u] = bc(this, t[u], e);
    } else
      i = bc(
        this,
        /** @type {string} */
        t,
        e
      );
    return e.ol_key = i, i;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(t, e) {
    const i = (
      /** @type {Object} */
      e.ol_key
    );
    if (i)
      yv(i);
    else if (Array.isArray(t))
      for (let s = 0, u = t.length; s < u; ++s)
        this.removeEventListener(t[s], e);
    else
      this.removeEventListener(t, e);
  }
}
vo.prototype.on;
vo.prototype.once;
vo.prototype.un;
function yv(n) {
  if (Array.isArray(n))
    for (let t = 0, e = n.length; t < e; ++t)
      Kn(n[t]);
  else
    Kn(
      /** @type {import("./events.js").EventsKey} */
      n
    );
}
function zt() {
  throw new Error("Unimplemented abstract method.");
}
let pv = 0;
function de(n) {
  return n.ol_uid || (n.ol_uid = String(++pv));
}
class Cc extends je {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(t, e, i) {
    super(t), this.key = e, this.oldValue = i;
  }
}
class fr extends vo {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, de(this), this.values_ = null, t !== void 0 && this.setProperties(t);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(t) {
    let e;
    return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(t, e) {
    let i;
    i = `change:${t}`, this.hasListener(i) && this.dispatchEvent(new Cc(i, t, e)), i = Dd.PROPERTYCHANGE, this.hasListener(i) && this.dispatchEvent(new Cc(i, t, e));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(t, e) {
    this.addEventListener(`change:${t}`, e);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(t, e) {
    this.removeEventListener(`change:${t}`, e);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(t, e, i) {
    const s = this.values_ || (this.values_ = {});
    if (i)
      s[t] = e;
    else {
      const u = s[t];
      s[t] = e, u !== e && this.notify(t, u);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(t, e) {
    for (const i in t)
      this.set(i, t[i], e);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(t) {
    t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(t, e) {
    if (this.values_ && t in this.values_) {
      const i = this.values_[t];
      delete this.values_[t], es(this.values_) && (this.values_ = null), e || this.notify(t, i);
    }
  }
}
const vv = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, Mi = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "";
Mi.includes("firefox");
const _v = Mi.includes("safari") && !Mi.includes("chrom");
_v && (Mi.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(Mi));
Mi.includes("webkit") && Mi.includes("edge");
Mi.includes("macintosh");
const zd = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Ev = typeof Image < "u" && Image.prototype.decode;
(function() {
  let n = !1;
  try {
    const t = Object.defineProperty({}, "passive", {
      get: function() {
        n = !0;
      }
    });
    window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
  } catch {
  }
  return n;
})();
function Ue(n, t, e, i) {
  let s;
  return e && e.length ? s = /** @type {HTMLCanvasElement} */
  e.shift() : zd ? s = new OffscreenCanvas(n || 300, t || 300) : s = document.createElement("canvas"), n && (s.width = n), t && (s.height = t), /** @type {CanvasRenderingContext2D} */
  s.getContext("2d", i);
}
let Eu;
function nl() {
  return Eu || (Eu = Ue(1, 1)), Eu;
}
function xv(n) {
  const t = n.canvas;
  t.width = 1, t.height = 1, n.clearRect(0, 0, 1, 1);
}
function Rc(n) {
  return n && n.parentNode ? n.parentNode.removeChild(n) : null;
}
class Sv extends fr {
  /**
   * @param {Options} options Control options.
   */
  constructor(t) {
    super();
    const e = t.element;
    e && !t.target && !e.style.pointerEvents && (e.style.pointerEvents = "auto"), this.element = e || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    Rc(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.map_ && Rc(this.element);
    for (let e = 0, i = this.listenerKeys.length; e < i; ++e)
      Kn(this.listenerKeys[e]);
    this.listenerKeys.length = 0, this.map_ = t, t && ((this.target_ ? this.target_ : t.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== ts && this.listenerKeys.push(
      On(t, vv.POSTRENDER, this.render, this)
    ), t.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(t) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(t) {
    this.target_ = typeof t == "string" ? document.getElementById(t) : t;
  }
}
const wv = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), Lc = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], Yd = function(n) {
  const t = n.match(wv);
  if (!t)
    return null;
  const e = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let i = 0, s = Lc.length; i < s; ++i) {
    const u = t[i + 1];
    u !== void 0 && (e[Lc[i]] = u);
  }
  return e.families = e.family.split(/,\s?/), e;
}, Wd = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class Xd {
  /**
   * @param {Options} options Projection options.
   */
  constructor(t) {
    this.code_ = t.code, this.units_ = /** @type {import("./Units.js").Units} */
    t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || Wd[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(t) {
    this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(t) {
    this.defaultTileGrid_ = t;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(t) {
    this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(t) {
    this.worldExtent_ = t;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(t) {
    this.getPointResolutionFunc_ = t;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const _o = 6378137, Vr = Math.PI * _o, Iv = [-Vr, -Vr, Vr, Vr], kv = [-180, -85, 180, 85], Oo = _o * Math.log(Math.tan(Math.PI / 2));
class Pr extends Xd {
  /**
   * @param {string} code Code.
   */
  constructor(t) {
    super({
      code: t,
      units: "m",
      extent: Iv,
      global: !0,
      worldExtent: kv,
      getPointResolution: function(e, i) {
        return e / Math.cosh(i[1] / _o);
      }
    });
  }
}
const Tc = [
  new Pr("EPSG:3857"),
  new Pr("EPSG:102100"),
  new Pr("EPSG:102113"),
  new Pr("EPSG:900913"),
  new Pr("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new Pr("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function bv(n, t, e) {
  const i = n.length;
  e = e > 1 ? e : 2, t === void 0 && (e > 2 ? t = n.slice() : t = new Array(i));
  for (let s = 0; s < i; s += e) {
    t[s] = Vr * n[s] / 180;
    let u = _o * Math.log(Math.tan(Math.PI * (+n[s + 1] + 90) / 360));
    u > Oo ? u = Oo : u < -Oo && (u = -Oo), t[s + 1] = u;
  }
  return t;
}
function Cv(n, t, e) {
  const i = n.length;
  e = e > 1 ? e : 2, t === void 0 && (e > 2 ? t = n.slice() : t = new Array(i));
  for (let s = 0; s < i; s += e)
    t[s] = 180 * n[s] / Vr, t[s + 1] = 360 * Math.atan(Math.exp(n[s + 1] / _o)) / Math.PI - 90;
  return t;
}
const Rv = 6378137, Nc = [-180, -90, 180, 90], Lv = Math.PI * Rv / 180;
class Vi extends Xd {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(t, e) {
    super({
      code: t,
      units: "degrees",
      extent: Nc,
      axisOrientation: e,
      global: !0,
      metersPerUnit: Lv,
      worldExtent: Nc
    });
  }
}
const Mc = [
  new Vi("CRS:84"),
  new Vi("EPSG:4326", "neu"),
  new Vi("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Vi("urn:ogc:def:crs:OGC:2:84"),
  new Vi("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Vi("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Vi("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let il = {};
function Tv(n) {
  return il[n] || il[n.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function Nv(n, t) {
  il[n] = t;
}
let $r = {};
function la(n, t, e) {
  const i = n.getCode(), s = t.getCode();
  i in $r || ($r[i] = {}), $r[i][s] = e;
}
function Mv(n, t) {
  let e;
  return n in $r && t in $r[n] && (e = $r[n][t]), e;
}
const ae = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function Ov(n, t, e) {
  const i = Math.min.apply(null, n), s = Math.min.apply(null, t), u = Math.max.apply(null, n), h = Math.max.apply(null, t);
  return or(i, s, u, h, e);
}
function Kl(n, t, e) {
  return e ? (e[0] = n[0] - t, e[1] = n[1] - t, e[2] = n[2] + t, e[3] = n[3] + t, e) : [
    n[0] - t,
    n[1] - t,
    n[2] + t,
    n[3] + t
  ];
}
function Av(n, t) {
  return n.slice();
}
function gr(n, t, e) {
  let i, s;
  return t < n[0] ? i = n[0] - t : n[2] < t ? i = t - n[2] : i = 0, e < n[1] ? s = n[1] - e : n[3] < e ? s = e - n[3] : s = 0, i * i + s * s;
}
function rl(n, t) {
  return $l(n, t[0], t[1]);
}
function Zr(n, t) {
  return n[0] <= t[0] && t[2] <= n[2] && n[1] <= t[1] && t[3] <= n[3];
}
function $l(n, t, e) {
  return n[0] <= t && t <= n[2] && n[1] <= e && e <= n[3];
}
function sl(n, t) {
  const e = n[0], i = n[1], s = n[2], u = n[3], h = t[0], c = t[1];
  let g = ae.UNKNOWN;
  return h < e ? g = g | ae.LEFT : h > s && (g = g | ae.RIGHT), c < i ? g = g | ae.BELOW : c > u && (g = g | ae.ABOVE), g === ae.UNKNOWN && (g = ae.INTERSECTING), g;
}
function sr() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function or(n, t, e, i, s) {
  return s ? (s[0] = n, s[1] = t, s[2] = e, s[3] = i, s) : [n, t, e, i];
}
function Wa(n) {
  return or(1 / 0, 1 / 0, -1 / 0, -1 / 0, n);
}
function qd(n, t) {
  const e = n[0], i = n[1];
  return or(e, i, e, i, t);
}
function Jl(n, t, e, i, s) {
  const u = Wa(s);
  return jd(u, n, t, e, i);
}
function Ud(n, t) {
  return n[0] == t[0] && n[2] == t[2] && n[1] == t[1] && n[3] == t[3];
}
function Pv(n, t) {
  return t[0] < n[0] && (n[0] = t[0]), t[2] > n[2] && (n[2] = t[2]), t[1] < n[1] && (n[1] = t[1]), t[3] > n[3] && (n[3] = t[3]), n;
}
function Dv(n, t) {
  t[0] < n[0] && (n[0] = t[0]), t[0] > n[2] && (n[2] = t[0]), t[1] < n[1] && (n[1] = t[1]), t[1] > n[3] && (n[3] = t[1]);
}
function jd(n, t, e, i, s) {
  for (; e < i; e += s)
    Fv(n, t[e], t[e + 1]);
  return n;
}
function Fv(n, t, e) {
  n[0] = Math.min(n[0], t), n[1] = Math.min(n[1], e), n[2] = Math.max(n[2], t), n[3] = Math.max(n[3], e);
}
function Gv(n, t) {
  let e;
  return e = t(Vd(n)), e || (e = t(Zd(n)), e) || (e = t(Kd(n)), e) || (e = t(Hd(n)), e) ? e : !1;
}
function Vd(n) {
  return [n[0], n[1]];
}
function Zd(n) {
  return [n[2], n[1]];
}
function ar(n) {
  return [(n[0] + n[2]) / 2, (n[1] + n[3]) / 2];
}
function Bv(n, t, e, i, s) {
  const [u, h, c, g, m, y, p, _] = zv(
    n,
    t,
    e,
    i
  );
  return or(
    Math.min(u, c, m, p),
    Math.min(h, g, y, _),
    Math.max(u, c, m, p),
    Math.max(h, g, y, _),
    s
  );
}
function zv(n, t, e, i) {
  const s = t * i[0] / 2, u = t * i[1] / 2, h = Math.cos(e), c = Math.sin(e), g = s * h, m = s * c, y = u * h, p = u * c, _ = n[0], E = n[1];
  return [
    _ - g + p,
    E - m - y,
    _ - g - p,
    E - m + y,
    _ + g - p,
    E + m + y,
    _ + g + p,
    E + m - y,
    _ - g + p,
    E - m - y
  ];
}
function ni(n) {
  return n[3] - n[1];
}
function Hd(n) {
  return [n[0], n[3]];
}
function Kd(n) {
  return [n[2], n[3]];
}
function Me(n) {
  return n[2] - n[0];
}
function mn(n, t) {
  return n[0] <= t[2] && n[2] >= t[0] && n[1] <= t[3] && n[3] >= t[1];
}
function Ql(n) {
  return n[2] < n[0] || n[3] < n[1];
}
function Yv(n, t) {
  return t ? (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t) : n;
}
function Wv(n, t, e) {
  let i = !1;
  const s = sl(n, t), u = sl(n, e);
  if (s === ae.INTERSECTING || u === ae.INTERSECTING)
    i = !0;
  else {
    const h = n[0], c = n[1], g = n[2], m = n[3], y = t[0], p = t[1], _ = e[0], E = e[1], S = (E - p) / (_ - y);
    let I, b;
    u & ae.ABOVE && !(s & ae.ABOVE) && (I = _ - (E - m) / S, i = I >= h && I <= g), !i && u & ae.RIGHT && !(s & ae.RIGHT) && (b = E - (_ - g) * S, i = b >= c && b <= m), !i && u & ae.BELOW && !(s & ae.BELOW) && (I = _ - (E - c) / S, i = I >= h && I <= g), !i && u & ae.LEFT && !(s & ae.LEFT) && (b = E - (_ - h) * S, i = b >= c && b <= m);
  }
  return i;
}
function Xv(n, t, e, i) {
  if (Ql(n))
    return Wa(e);
  let s = [];
  s = [
    n[0],
    n[1],
    n[2],
    n[1],
    n[2],
    n[3],
    n[0],
    n[3]
  ], t(s, s, 2);
  const u = [], h = [];
  for (let c = 0, g = s.length; c < g; c += 2)
    u.push(s[c]), h.push(s[c + 1]);
  return Ov(u, h, e);
}
function $d(n, t) {
  const e = t.getExtent(), i = ar(n);
  if (t.canWrapX() && (i[0] < e[0] || i[0] >= e[2])) {
    const s = Me(e), h = Math.floor(
      (i[0] - e[0]) / s
    ) * s;
    n[0] -= h, n[2] -= h;
  }
  return n;
}
function qv(n, t) {
  if (t.canWrapX()) {
    const e = t.getExtent();
    if (!isFinite(n[0]) || !isFinite(n[2]))
      return [[e[0], n[1], e[2], n[3]]];
    $d(n, t);
    const i = Me(e);
    if (Me(n) > i)
      return [[e[0], n[1], e[2], n[3]]];
    if (n[0] < e[0])
      return [
        [n[0] + i, n[1], e[2], n[3]],
        [e[0], n[1], n[2], n[3]]
      ];
    if (n[2] > e[2])
      return [
        [n[0], n[1], e[2], n[3]],
        [e[0], n[1], n[2] - i, n[3]]
      ];
  }
  return [n];
}
function we(n, t, e) {
  return Math.min(Math.max(n, t), e);
}
function Uv(n, t, e, i, s, u) {
  const h = s - e, c = u - i;
  if (h !== 0 || c !== 0) {
    const g = ((n - e) * h + (t - i) * c) / (h * h + c * c);
    g > 1 ? (e = s, i = u) : g > 0 && (e += h * g, i += c * g);
  }
  return nr(n, t, e, i);
}
function nr(n, t, e, i) {
  const s = e - n, u = i - t;
  return s * s + u * u;
}
function jv(n) {
  return n * Math.PI / 180;
}
function ol(n, t) {
  const e = n % t;
  return e * t < 0 ? e + t : e;
}
function Xe(n, t, e) {
  return n + e * (t - n);
}
function Vv(n, t) {
  const e = Math.pow(10, t);
  return Math.round(n * e) / e;
}
function Zv(n, t) {
  return n[0] += +t[0], n[1] += +t[1], n;
}
function ha(n, t) {
  let e = !0;
  for (let i = n.length - 1; i >= 0; --i)
    if (n[i] != t[i]) {
      e = !1;
      break;
    }
  return e;
}
function Hv(n, t) {
  const e = Math.cos(t), i = Math.sin(t), s = n[0] * e - n[1] * i, u = n[1] * e + n[0] * i;
  return n[0] = s, n[1] = u, n;
}
function Kv(n, t) {
  if (t.canWrapX()) {
    const e = Me(t.getExtent()), i = $v(n, t, e);
    i && (n[0] -= i * e);
  }
  return n;
}
function $v(n, t, e) {
  const i = t.getExtent();
  let s = 0;
  return t.canWrapX() && (n[0] < i[0] || n[0] > i[2]) && (e = e || Me(i), s = Math.floor(
    (n[0] - i[0]) / e
  )), s;
}
function Jv(...n) {
  console.warn(...n);
}
let al = !0;
function Jd(n) {
  al = !1;
}
function Qd(n, t) {
  if (t !== void 0) {
    for (let e = 0, i = n.length; e < i; ++e)
      t[e] = n[e];
    t = t;
  } else
    t = n.slice();
  return t;
}
function Qv(n, t) {
  if (t !== void 0 && n !== t) {
    for (let e = 0, i = n.length; e < i; ++e)
      t[e] = n[e];
    n = t;
  }
  return n;
}
function t_(n) {
  Nv(n.getCode(), n), la(n, n, Qd);
}
function e_(n) {
  n.forEach(t_);
}
function ur(n) {
  return typeof n == "string" ? Tv(
    /** @type {string} */
    n
  ) : (
    /** @type {Projection} */
    n || null
  );
}
function Oc(n) {
  e_(n), n.forEach(function(t) {
    n.forEach(function(e) {
      t !== e && la(t, e, Qd);
    });
  });
}
function n_(n, t, e, i) {
  n.forEach(function(s) {
    t.forEach(function(u) {
      la(s, u, e), la(u, s, i);
    });
  });
}
function th(n, t) {
  return n ? typeof n == "string" ? ur(n) : (
    /** @type {Projection} */
    n
  ) : ur(t);
}
function Ao(n, t) {
  return Jd(), tm(
    n,
    "EPSG:4326",
    t !== void 0 ? t : "EPSG:3857"
  );
}
function Ac(n, t) {
  const e = tm(
    n,
    t !== void 0 ? t : "EPSG:3857",
    "EPSG:4326"
  ), i = e[0];
  return (i < -180 || i > 180) && (e[0] = ol(i + 180, 360) - 180), e;
}
function i_(n, t) {
  const e = n.getCode(), i = t.getCode();
  let s = Mv(e, i);
  return s || (s = Qv), s;
}
function ca(n, t) {
  const e = ur(n), i = ur(t);
  return i_(e, i);
}
function tm(n, t, e) {
  return ca(t, e)(n, void 0, n.length);
}
function r_(n, t, e, i) {
  const s = ca(t, e);
  return Xv(n, s, void 0);
}
function Pc(n, t) {
  return n;
}
function fi(n, t) {
  return al && !ha(n, [0, 0]) && n[0] >= -180 && n[0] <= 180 && n[1] >= -90 && n[1] <= 90 && (al = !1, Jv(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), n;
}
function em(n, t) {
  return n;
}
function Gs(n, t) {
  return n;
}
function s_() {
  Oc(Tc), Oc(Mc), n_(
    Mc,
    Tc,
    bv,
    Cv
  );
}
s_();
const Hr = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, Dc = {
  LENGTH: "length"
};
class Po extends je {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(t, e, i) {
    super(t), this.element = e, this.index = i;
  }
}
class o_ extends fr {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(t, e) {
    if (super(), this.on, this.once, this.un, e = e || {}, this.unique_ = !!e.unique, this.array_ = t || [], this.unique_)
      for (let i = 0, s = this.array_.length; i < s; ++i)
        this.assertUnique_(this.array_[i], i);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(t) {
    for (let e = 0, i = t.length; e < i; ++e)
      this.push(t[e]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(t) {
    const e = this.array_;
    for (let i = 0, s = e.length; i < s; ++i)
      t(e[i], i, e);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(t) {
    return this.array_[t];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Dc.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(t, e) {
    if (t < 0 || t > this.getLength())
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(
      new Po(Hr.ADD, e, t)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(t) {
    this.unique_ && this.assertUnique_(t);
    const e = this.getLength();
    return this.insertAt(e, t), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(t) {
    const e = this.array_;
    for (let i = 0, s = e.length; i < s; ++i)
      if (e[i] === t)
        return this.removeAt(i);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(t) {
    if (t < 0 || t >= this.getLength())
      return;
    const e = this.array_[t];
    return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Po(Hr.REMOVE, e, t)
    ), e;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(t, e) {
    const i = this.getLength();
    if (t >= i) {
      this.insertAt(t, e);
      return;
    }
    if (t < 0)
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(e, t);
    const s = this.array_[t];
    this.array_[t] = e, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Po(Hr.REMOVE, s, t)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Po(Hr.ADD, e, t)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(Dc.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(t, e) {
    for (let i = 0, s = this.array_.length; i < s; ++i)
      if (this.array_[i] === t && i !== e)
        throw new Error("Duplicate item added to a unique collection");
  }
}
const Dt = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
function Se(n, t) {
  if (!n)
    throw new Error(t);
}
class a_ extends fr {
  /**
   * @param {Options} options Layer options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, this.background_ = t.background;
    const e = Object.assign({}, t);
    typeof t.properties == "object" && (delete e.properties, Object.assign(e, t.properties)), e[Dt.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, Se(
      typeof e[Dt.OPACITY] == "number",
      "Layer opacity must be a number"
    ), e[Dt.VISIBLE] = t.visible !== void 0 ? t.visible : !0, e[Dt.Z_INDEX] = t.zIndex, e[Dt.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, e[Dt.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, e[Dt.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, e[Dt.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = e.className !== void 0 ? e.className : "ol-layer", delete e.className, this.setProperties(e), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(t) {
    const e = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: t === void 0 ? !0 : t
    }, i = this.getZIndex();
    return e.opacity = we(Math.round(this.getOpacity() * 100) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = i === void 0 && !e.managed ? 1 / 0 : i, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return zt();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return zt();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Dt.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Dt.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Dt.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Dt.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Dt.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Dt.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return zt();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Dt.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(Dt.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(t) {
    this.background_ = t, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(t) {
    this.set(Dt.EXTENT, t);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(t) {
    this.set(Dt.MAX_RESOLUTION, t);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(t) {
    this.set(Dt.MIN_RESOLUTION, t);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(t) {
    this.set(Dt.MAX_ZOOM, t);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(t) {
    this.set(Dt.MIN_ZOOM, t);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(t) {
    Se(typeof t == "number", "Layer opacity must be a number"), this.set(Dt.OPACITY, t);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(t) {
    this.set(Dt.VISIBLE, t);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(t) {
    this.set(Dt.Z_INDEX, t);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const Hi = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, nn = {
  ANIMATING: 0,
  INTERACTING: 1
}, gn = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, u_ = 256;
function Fc(n, t, e) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(i, s, u, h, c) {
      if (!i)
        return;
      if (!s && !t)
        return i;
      const g = t ? 0 : u[0] * s, m = t ? 0 : u[1] * s, y = c ? c[0] : 0, p = c ? c[1] : 0;
      let _ = n[0] + g / 2 + y, E = n[2] - g / 2 + y, S = n[1] + m / 2 + p, I = n[3] - m / 2 + p;
      _ > E && (_ = (E + _) / 2, E = _), S > I && (S = (I + S) / 2, I = S);
      let b = we(i[0], _, E), C = we(i[1], S, I);
      if (h && e && s) {
        const R = 30 * s;
        b += -R * Math.log(1 + Math.max(0, _ - i[0]) / R) + R * Math.log(1 + Math.max(0, i[0] - E) / R), C += -R * Math.log(1 + Math.max(0, S - i[1]) / R) + R * Math.log(1 + Math.max(0, i[1] - I) / R);
      }
      return [b, C];
    }
  );
}
function l_(n) {
  return n;
}
function eh(n, t, e, i) {
  const s = Me(t) / e[0], u = ni(t) / e[1];
  return i ? Math.min(n, Math.max(s, u)) : Math.min(n, Math.min(s, u));
}
function nh(n, t, e) {
  let i = Math.min(n, t);
  const s = 50;
  return i *= Math.log(1 + s * Math.max(0, n / t - 1)) / s + 1, e && (i = Math.max(i, e), i /= Math.log(1 + s * Math.max(0, e / n - 1)) / s + 1), we(i, e / 2, t * 2);
}
function h_(n, t, e, i) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(s, u, h, c) {
    if (s !== void 0) {
      const g = n[0], m = n[n.length - 1], y = e ? eh(
        g,
        e,
        h,
        i
      ) : g;
      if (c)
        return t ? nh(
          s,
          y,
          m
        ) : we(s, m, y);
      const p = Math.min(y, s), _ = Math.floor(Fd(n, p, u));
      return n[_] > y && _ < n.length - 1 ? n[_ + 1] : n[_];
    }
  };
}
function c_(n, t, e, i, s, u) {
  return i = i !== void 0 ? i : !0, e = e !== void 0 ? e : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(h, c, g, m) {
    if (h !== void 0) {
      const y = s ? eh(
        t,
        s,
        g,
        u
      ) : t;
      if (m)
        return i ? nh(
          h,
          y,
          e
        ) : we(h, e, y);
      const p = 1e-9, _ = Math.ceil(
        Math.log(t / y) / Math.log(n) - p
      ), E = -c * (0.5 - p) + 0.5, S = Math.min(y, h), I = Math.floor(
        Math.log(t / S) / Math.log(n) + E
      ), b = Math.max(_, I), C = t / Math.pow(n, b);
      return we(C, e, y);
    }
  };
}
function Gc(n, t, e, i, s) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(u, h, c, g) {
    if (u !== void 0) {
      const m = i ? eh(
        n,
        i,
        c,
        s
      ) : n;
      return !e || !g ? we(u, t, m) : nh(
        u,
        m,
        t
      );
    }
  };
}
function f_(n) {
  if (n !== void 0)
    return 0;
}
function Bc(n) {
  if (n !== void 0)
    return n;
}
function g_(n) {
  const t = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(e, i) {
      if (i)
        return e;
      if (e !== void 0)
        return e = Math.floor(e / t + 0.5) * t, e;
    }
  );
}
function d_(n) {
  const t = jv(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(e, i) {
      return i || e === void 0 ? e : Math.abs(e) <= t ? 0 : e;
    }
  );
}
function m_(n) {
  return Math.pow(n, 3);
}
function y_(n) {
  return 1 - m_(1 - n);
}
function p_(n) {
  return 3 * n * n - 2 * n * n * n;
}
new Array(6);
function $n() {
  return [1, 0, 0, 1, 0, 0];
}
function v_(n, t) {
  return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
}
function Ne(n, t) {
  const e = t[0], i = t[1];
  return t[0] = n[0] * e + n[2] * i + n[4], t[1] = n[1] * e + n[3] * i + n[5], t;
}
function dr(n, t, e, i, s, u, h, c) {
  const g = Math.sin(u), m = Math.cos(u);
  return n[0] = i * m, n[1] = s * g, n[2] = -i * g, n[3] = s * m, n[4] = h * i * m - c * i * g + t, n[5] = h * s * g + c * s * m + e, n;
}
function __(n, t) {
  const e = E_(t);
  Se(e !== 0, "Transformation matrix cannot be inverted");
  const i = t[0], s = t[1], u = t[2], h = t[3], c = t[4], g = t[5];
  return n[0] = h / e, n[1] = -s / e, n[2] = -u / e, n[3] = i / e, n[4] = (u * g - h * c) / e, n[5] = -(i * g - s * c) / e, n;
}
function E_(n) {
  return n[0] * n[3] - n[1] * n[2];
}
const zc = [1e6, 1e6, 1e6, 1e6, 2, 2];
function x_(n) {
  return "matrix(" + n.map(
    (e, i) => Math.round(e * zc[i]) / zc[i]
  ).join(", ") + ")";
}
function Ri(n, t, e, i, s, u) {
  u = u || [];
  let h = 0;
  for (let c = t; c < e; c += i) {
    const g = n[c], m = n[c + 1];
    u[h++] = s[0] * g + s[2] * m + s[4], u[h++] = s[1] * g + s[3] * m + s[5];
  }
  return u && u.length != h && (u.length = h), u;
}
function nm(n, t, e, i, s, u, h) {
  h = h || [];
  const c = Math.cos(s), g = Math.sin(s), m = u[0], y = u[1];
  let p = 0;
  for (let _ = t; _ < e; _ += i) {
    const E = n[_] - m, S = n[_ + 1] - y;
    h[p++] = m + E * c - S * g, h[p++] = y + E * g + S * c;
    for (let I = _ + 2; I < _ + i; ++I)
      h[p++] = n[I];
  }
  return h && h.length != p && (h.length = p), h;
}
function S_(n, t, e, i, s, u, h, c) {
  c = c || [];
  const g = h[0], m = h[1];
  let y = 0;
  for (let p = t; p < e; p += i) {
    const _ = n[p] - g, E = n[p + 1] - m;
    c[y++] = g + s * _, c[y++] = m + u * E;
    for (let S = p + 2; S < p + i; ++S)
      c[y++] = n[S];
  }
  return c && c.length != y && (c.length = y), c;
}
function w_(n, t, e, i, s, u, h) {
  h = h || [];
  let c = 0;
  for (let g = t; g < e; g += i) {
    h[c++] = n[g] + s, h[c++] = n[g + 1] + u;
    for (let m = g + 2; m < g + i; ++m)
      h[c++] = n[m];
  }
  return h && h.length != c && (h.length = c), h;
}
const Yc = $n();
class im extends fr {
  constructor() {
    super(), this.extent_ = sr(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = Gd(
      (t, e, i) => {
        if (!i)
          return this.getSimplifiedGeometry(e);
        const s = this.clone();
        return s.applyTransform(i), s.getSimplifiedGeometry(e);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(t, e) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      t,
      e
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return zt();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    return zt();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    const i = this.getClosestPoint([t, e]);
    return i[0] === t && i[1] === e;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(t, e) {
    return e = e || [NaN, NaN], this.closestPointXY(t[0], t[1], e, 1 / 0), e;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(t) {
    return this.containsXY(t[0], t[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return zt();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(t) {
    if (this.extentRevision_ != this.getRevision()) {
      const e = this.computeExtent(this.extent_);
      (isNaN(e[0]) || isNaN(e[1])) && Wa(e), this.extentRevision_ = this.getRevision();
    }
    return Yv(this.extent_, t);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, e) {
    zt();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, e, i) {
    zt();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(t) {
    return this.getSimplifiedGeometry(t * t);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return zt();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return zt();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(t) {
    zt();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(t) {
    return zt();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, e) {
    zt();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(t, e) {
    const i = ur(t), s = i.getUnits() == "tile-pixels" ? function(u, h, c) {
      const g = i.getExtent(), m = i.getWorldExtent(), y = ni(m) / ni(g);
      return dr(
        Yc,
        m[0],
        m[3],
        y,
        -y,
        0,
        0,
        0
      ), Ri(
        u,
        0,
        u.length,
        c,
        Yc,
        h
      ), ca(i, e)(
        u,
        h,
        c
      );
    } : ca(i, e);
    return this.applyTransform(s), this;
  }
}
class mr extends im {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return Jl(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return zt();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const e = this.getSimplifiedGeometryInternal(t);
    return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(t, e) {
    this.stride = Wc(t), this.layout = t, this.flatCoordinates = e;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(t, e) {
    zt();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(t, e, i) {
    let s;
    if (t)
      s = Wc(t);
    else {
      for (let u = 0; u < i; ++u) {
        if (e.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        e = /** @type {Array<unknown>} */
        e[0];
      }
      s = e.length, t = I_(s);
    }
    this.layout = t, this.stride = s;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(t) {
    this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, e) {
    const i = this.getFlatCoordinates();
    if (i) {
      const s = this.getStride();
      nm(
        i,
        0,
        i.length,
        s,
        t,
        e,
        i
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, e, i) {
    e === void 0 && (e = t), i || (i = ar(this.getExtent()));
    const s = this.getFlatCoordinates();
    if (s) {
      const u = this.getStride();
      S_(
        s,
        0,
        s.length,
        u,
        t,
        e,
        i,
        s
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, e) {
    const i = this.getFlatCoordinates();
    if (i) {
      const s = this.getStride();
      w_(
        i,
        0,
        i.length,
        s,
        t,
        e,
        i
      ), this.changed();
    }
  }
}
function I_(n) {
  let t;
  return n == 2 ? t = "XY" : n == 3 ? t = "XYZ" : n == 4 && (t = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  t;
}
function Wc(n) {
  let t;
  return n == "XY" ? t = 2 : n == "XYZ" || n == "XYM" ? t = 3 : n == "XYZM" && (t = 4), /** @type {number} */
  t;
}
function k_(n, t, e) {
  const i = n.getFlatCoordinates();
  if (!i)
    return null;
  const s = n.getStride();
  return Ri(
    i,
    0,
    i.length,
    s,
    t,
    e
  );
}
function Xc(n, t, e, i, s, u, h) {
  const c = n[t], g = n[t + 1], m = n[e] - c, y = n[e + 1] - g;
  let p;
  if (m === 0 && y === 0)
    p = t;
  else {
    const _ = ((s - c) * m + (u - g) * y) / (m * m + y * y);
    if (_ > 1)
      p = e;
    else if (_ > 0) {
      for (let E = 0; E < i; ++E)
        h[E] = Xe(
          n[t + E],
          n[e + E],
          _
        );
      h.length = i;
      return;
    } else
      p = t;
  }
  for (let _ = 0; _ < i; ++_)
    h[_] = n[p + _];
  h.length = i;
}
function ih(n, t, e, i, s) {
  let u = n[t], h = n[t + 1];
  for (t += i; t < e; t += i) {
    const c = n[t], g = n[t + 1], m = nr(u, h, c, g);
    m > s && (s = m), u = c, h = g;
  }
  return s;
}
function rh(n, t, e, i, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    const c = e[u];
    s = ih(n, t, c, i, s), t = c;
  }
  return s;
}
function b_(n, t, e, i, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    const c = e[u];
    s = rh(n, t, c, i, s), t = c[c.length - 1];
  }
  return s;
}
function sh(n, t, e, i, s, u, h, c, g, m, y) {
  if (t == e)
    return m;
  let p, _;
  if (s === 0) {
    if (_ = nr(
      h,
      c,
      n[t],
      n[t + 1]
    ), _ < m) {
      for (p = 0; p < i; ++p)
        g[p] = n[t + p];
      return g.length = i, _;
    }
    return m;
  }
  y = y || [NaN, NaN];
  let E = t + i;
  for (; E < e; )
    if (Xc(
      n,
      E - i,
      E,
      i,
      h,
      c,
      y
    ), _ = nr(h, c, y[0], y[1]), _ < m) {
      for (m = _, p = 0; p < i; ++p)
        g[p] = y[p];
      g.length = i, E += i;
    } else
      E += i * Math.max(
        (Math.sqrt(_) - Math.sqrt(m)) / s | 0,
        1
      );
  if (u && (Xc(
    n,
    e - i,
    t,
    i,
    h,
    c,
    y
  ), _ = nr(h, c, y[0], y[1]), _ < m)) {
    for (m = _, p = 0; p < i; ++p)
      g[p] = y[p];
    g.length = i;
  }
  return m;
}
function oh(n, t, e, i, s, u, h, c, g, m, y) {
  y = y || [NaN, NaN];
  for (let p = 0, _ = e.length; p < _; ++p) {
    const E = e[p];
    m = sh(
      n,
      t,
      E,
      i,
      s,
      u,
      h,
      c,
      g,
      m,
      y
    ), t = E;
  }
  return m;
}
function C_(n, t, e, i, s, u, h, c, g, m, y) {
  y = y || [NaN, NaN];
  for (let p = 0, _ = e.length; p < _; ++p) {
    const E = e[p];
    m = oh(
      n,
      t,
      E,
      i,
      s,
      u,
      h,
      c,
      g,
      m,
      y
    ), t = E[E.length - 1];
  }
  return m;
}
function R_(n, t, e, i) {
  for (let s = 0, u = e.length; s < u; ++s)
    n[t++] = e[s];
  return t;
}
function Xa(n, t, e, i) {
  for (let s = 0, u = e.length; s < u; ++s) {
    const h = e[s];
    for (let c = 0; c < i; ++c)
      n[t++] = h[c];
  }
  return t;
}
function ah(n, t, e, i, s) {
  s = s || [];
  let u = 0;
  for (let h = 0, c = e.length; h < c; ++h) {
    const g = Xa(
      n,
      t,
      e[h],
      i
    );
    s[u++] = g, t = g;
  }
  return s.length = u, s;
}
function L_(n, t, e, i, s) {
  s = s || [];
  let u = 0;
  for (let h = 0, c = e.length; h < c; ++h) {
    const g = ah(
      n,
      t,
      e[h],
      i,
      s[u]
    );
    g.length === 0 && (g[0] = t), s[u++] = g, t = g[g.length - 1];
  }
  return s.length = u, s;
}
function qa(n, t, e, i, s, u, h) {
  const c = (e - t) / i;
  if (c < 3) {
    for (; t < e; t += i)
      u[h++] = n[t], u[h++] = n[t + 1];
    return h;
  }
  const g = new Array(c);
  g[0] = 1, g[c - 1] = 1;
  const m = [t, e - i];
  let y = 0;
  for (; m.length > 0; ) {
    const p = m.pop(), _ = m.pop();
    let E = 0;
    const S = n[_], I = n[_ + 1], b = n[p], C = n[p + 1];
    for (let R = _ + i; R < p; R += i) {
      const T = n[R], O = n[R + 1], M = Uv(T, O, S, I, b, C);
      M > E && (y = R, E = M);
    }
    E > s && (g[(y - t) / i] = 1, _ + i < y && m.push(_, y), y + i < p && m.push(y, p));
  }
  for (let p = 0; p < c; ++p)
    g[p] && (u[h++] = n[t + p * i], u[h++] = n[t + p * i + 1]);
  return h;
}
function rm(n, t, e, i, s, u, h, c) {
  for (let g = 0, m = e.length; g < m; ++g) {
    const y = e[g];
    h = qa(
      n,
      t,
      y,
      i,
      s,
      u,
      h
    ), c.push(h), t = y;
  }
  return h;
}
function Zi(n, t) {
  return t * Math.round(n / t);
}
function T_(n, t, e, i, s, u, h) {
  if (t == e)
    return h;
  let c = Zi(n[t], s), g = Zi(n[t + 1], s);
  t += i, u[h++] = c, u[h++] = g;
  let m, y;
  do
    if (m = Zi(n[t], s), y = Zi(n[t + 1], s), t += i, t == e)
      return u[h++] = m, u[h++] = y, h;
  while (m == c && y == g);
  for (; t < e; ) {
    const p = Zi(n[t], s), _ = Zi(n[t + 1], s);
    if (t += i, p == m && _ == y)
      continue;
    const E = m - c, S = y - g, I = p - c, b = _ - g;
    if (E * b == S * I && (E < 0 && I < E || E == I || E > 0 && I > E) && (S < 0 && b < S || S == b || S > 0 && b > S)) {
      m = p, y = _;
      continue;
    }
    u[h++] = m, u[h++] = y, c = m, g = y, m = p, y = _;
  }
  return u[h++] = m, u[h++] = y, h;
}
function uh(n, t, e, i, s, u, h, c) {
  for (let g = 0, m = e.length; g < m; ++g) {
    const y = e[g];
    h = T_(
      n,
      t,
      y,
      i,
      s,
      u,
      h
    ), c.push(h), t = y;
  }
  return h;
}
function N_(n, t, e, i, s, u, h, c) {
  for (let g = 0, m = e.length; g < m; ++g) {
    const y = e[g], p = [];
    h = uh(
      n,
      t,
      y,
      i,
      s,
      u,
      h,
      p
    ), c.push(p), t = y[y.length - 1];
  }
  return h;
}
function xi(n, t, e, i, s) {
  s = s !== void 0 ? s : [];
  let u = 0;
  for (let h = t; h < e; h += i)
    s[u++] = n.slice(h, h + i);
  return s.length = u, s;
}
function $s(n, t, e, i, s) {
  s = s !== void 0 ? s : [];
  let u = 0;
  for (let h = 0, c = e.length; h < c; ++h) {
    const g = e[h];
    s[u++] = xi(
      n,
      t,
      g,
      i,
      s[u]
    ), t = g;
  }
  return s.length = u, s;
}
function ul(n, t, e, i, s) {
  s = s !== void 0 ? s : [];
  let u = 0;
  for (let h = 0, c = e.length; h < c; ++h) {
    const g = e[h];
    s[u++] = g.length === 1 && g[0] === t ? [] : $s(
      n,
      t,
      g,
      i,
      s[u]
    ), t = g[g.length - 1];
  }
  return s.length = u, s;
}
function sm(n, t, e, i) {
  let s = 0, u = n[e - i], h = n[e - i + 1];
  for (; t < e; t += i) {
    const c = n[t], g = n[t + 1];
    s += h * c - u * g, u = c, h = g;
  }
  return s / 2;
}
function om(n, t, e, i) {
  let s = 0;
  for (let u = 0, h = e.length; u < h; ++u) {
    const c = e[u];
    s += sm(n, t, c, i), t = c;
  }
  return s;
}
function M_(n, t, e, i) {
  let s = 0;
  for (let u = 0, h = e.length; u < h; ++u) {
    const c = e[u];
    s += om(n, t, c, i), t = c[c.length - 1];
  }
  return s;
}
class Js extends mr {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new Js(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    return s < gr(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      ih(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), sh(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      i,
      s
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return sm(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return xi(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [];
    return e.length = qa(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      0
    ), new Js(e, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Xa(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
class Li extends mr {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.setCoordinates(t, e);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const t = new Li(this.flatCoordinates.slice(), this.layout);
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    const u = this.flatCoordinates, h = nr(
      t,
      e,
      u[0],
      u[1]
    );
    if (h < s) {
      const c = this.stride;
      for (let g = 0; g < c; ++g)
        i[g] = u[g];
      return i.length = c, h;
    }
    return s;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return qd(this.flatCoordinates, t);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return $l(t, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = R_(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
function O_(n, t, e, i, s) {
  return !Gv(
    s,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(h) {
      return !Ki(
        n,
        t,
        e,
        i,
        h[0],
        h[1]
      );
    }
  );
}
function Ki(n, t, e, i, s, u) {
  let h = 0, c = n[e - i], g = n[e - i + 1];
  for (; t < e; t += i) {
    const m = n[t], y = n[t + 1];
    g <= u ? y > u && (m - c) * (u - g) - (s - c) * (y - g) > 0 && h++ : y <= u && (m - c) * (u - g) - (s - c) * (y - g) < 0 && h--, c = m, g = y;
  }
  return h !== 0;
}
function lh(n, t, e, i, s, u) {
  if (e.length === 0 || !Ki(n, t, e[0], i, s, u))
    return !1;
  for (let h = 1, c = e.length; h < c; ++h)
    if (Ki(n, e[h - 1], e[h], i, s, u))
      return !1;
  return !0;
}
function A_(n, t, e, i, s, u) {
  if (e.length === 0)
    return !1;
  for (let h = 0, c = e.length; h < c; ++h) {
    const g = e[h];
    if (lh(n, t, g, i, s, u))
      return !0;
    t = g[g.length - 1];
  }
  return !1;
}
function hh(n, t, e, i, s, u, h) {
  let c, g, m, y, p, _, E;
  const S = s[u + 1], I = [];
  for (let R = 0, T = e.length; R < T; ++R) {
    const O = e[R];
    for (y = n[O - i], _ = n[O - i + 1], c = t; c < O; c += i)
      p = n[c], E = n[c + 1], (S <= _ && E <= S || _ <= S && S <= E) && (m = (S - _) / (E - _) * (p - y) + y, I.push(m)), y = p, _ = E;
  }
  let b = NaN, C = -1 / 0;
  for (I.sort(er), y = I[0], c = 1, g = I.length; c < g; ++c) {
    p = I[c];
    const R = Math.abs(p - y);
    R > C && (m = (y + p) / 2, lh(n, t, e, i, m, S) && (b = m, C = R)), y = p;
  }
  return isNaN(b) && (b = s[u]), h ? (h.push(b, S, C), h) : [b, S, C];
}
function am(n, t, e, i, s) {
  let u = [];
  for (let h = 0, c = e.length; h < c; ++h) {
    const g = e[h];
    u = hh(
      n,
      t,
      g,
      i,
      s,
      2 * h,
      u
    ), t = g[g.length - 1];
  }
  return u;
}
function um(n, t, e, i, s) {
  let u;
  for (t += i; t < e; t += i)
    if (u = s(
      n.slice(t - i, t),
      n.slice(t, t + i)
    ), u)
      return u;
  return !1;
}
function Ua(n, t, e, i, s) {
  const u = jd(
    sr(),
    n,
    t,
    e,
    i
  );
  return mn(s, u) ? Zr(s, u) || u[0] >= s[0] && u[2] <= s[2] || u[1] >= s[1] && u[3] <= s[3] ? !0 : um(
    n,
    t,
    e,
    i,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(h, c) {
      return Wv(s, h, c);
    }
  ) : !1;
}
function P_(n, t, e, i, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    if (Ua(n, t, e[u], i, s))
      return !0;
    t = e[u];
  }
  return !1;
}
function D_(n, t, e, i, s) {
  return !!(Ua(n, t, e, i, s) || Ki(
    n,
    t,
    e,
    i,
    s[0],
    s[1]
  ) || Ki(
    n,
    t,
    e,
    i,
    s[0],
    s[3]
  ) || Ki(
    n,
    t,
    e,
    i,
    s[2],
    s[1]
  ) || Ki(
    n,
    t,
    e,
    i,
    s[2],
    s[3]
  ));
}
function lm(n, t, e, i, s) {
  if (!D_(n, t, e[0], i, s))
    return !1;
  if (e.length === 1)
    return !0;
  for (let u = 1, h = e.length; u < h; ++u)
    if (O_(
      n,
      e[u - 1],
      e[u],
      i,
      s
    ) && !Ua(
      n,
      e[u - 1],
      e[u],
      i,
      s
    ))
      return !1;
  return !0;
}
function F_(n, t, e, i, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    const c = e[u];
    if (lm(n, t, c, i, s))
      return !0;
    t = c[c.length - 1];
  }
  return !1;
}
function G_(n, t, e, i) {
  for (; t < e - i; ) {
    for (let s = 0; s < i; ++s) {
      const u = n[t + s];
      n[t + s] = n[e - i + s], n[e - i + s] = u;
    }
    t += i, e -= i;
  }
}
function ch(n, t, e, i) {
  let s = 0, u = n[e - i], h = n[e - i + 1];
  for (; t < e; t += i) {
    const c = n[t], g = n[t + 1];
    s += (c - u) * (g + h), u = c, h = g;
  }
  return s === 0 ? void 0 : s > 0;
}
function hm(n, t, e, i, s) {
  s = s !== void 0 ? s : !1;
  for (let u = 0, h = e.length; u < h; ++u) {
    const c = e[u], g = ch(
      n,
      t,
      c,
      i
    );
    if (u === 0) {
      if (s && g || !s && !g)
        return !1;
    } else if (s && !g || !s && g)
      return !1;
    t = c;
  }
  return !0;
}
function B_(n, t, e, i, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    const c = e[u];
    if (!hm(n, t, c, i, s))
      return !1;
    c.length && (t = c[c.length - 1]);
  }
  return !0;
}
function ll(n, t, e, i, s) {
  s = s !== void 0 ? s : !1;
  for (let u = 0, h = e.length; u < h; ++u) {
    const c = e[u], g = ch(
      n,
      t,
      c,
      i
    );
    (u === 0 ? s && g || !s && !g : s && !g || !s && g) && G_(n, t, c, i), t = c;
  }
  return t;
}
function qc(n, t, e, i, s) {
  for (let u = 0, h = e.length; u < h; ++u)
    t = ll(
      n,
      t,
      e[u],
      i,
      s
    );
  return t;
}
function z_(n, t) {
  const e = [];
  let i = 0, s = 0, u;
  for (let h = 0, c = t.length; h < c; ++h) {
    const g = t[h], m = ch(n, i, g, 2);
    if (u === void 0 && (u = m), m === u)
      e.push(t.slice(s, h + 1));
    else {
      if (e.length === 0)
        continue;
      e[e.length - 1].push(t[s]);
    }
    s = h + 1, i = g;
  }
  return e;
}
class Oi extends mr {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(t, e, i) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, e !== void 0 && i ? (this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ), this.ends_ = i) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      t,
      e
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(t) {
    this.flatCoordinates ? Mn(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const t = new Oi(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    return s < gr(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      rh(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), oh(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      i,
      s
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    return lh(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t,
      e
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return om(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(t) {
    let e;
    return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), ll(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, $s(e, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const t = ar(this.getExtent());
      this.flatInteriorPoint_ = hh(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Li(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(t) {
    return t < 0 || this.ends_.length <= t ? null : new Js(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const t = this.layout, e = this.flatCoordinates, i = this.ends_, s = [];
    let u = 0;
    for (let h = 0, c = i.length; h < c; ++h) {
      const g = i[h], m = new Js(
        e.slice(u, g),
        t
      );
      s.push(m), u = g;
    }
    return s;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      hm(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = ll(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], i = [];
    return e.length = uh(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(t),
      e,
      0,
      i
    ), new Oi(e, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return lm(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = ah(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
}
function Uc(n) {
  if (Ql(n))
    throw new Error("Cannot create polygon from empty extent");
  const t = n[0], e = n[1], i = n[2], s = n[3], u = [
    t,
    e,
    t,
    s,
    i,
    s,
    i,
    e,
    t,
    e
  ];
  return new Oi(u, "XY", [u.length]);
}
const xu = 0;
class jc extends fr {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = th(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && Jd(), t.center && (t.center = fi(t.center, this.projection_)), t.extent && (t.extent = Gs(t.extent, this.projection_)), this.applyOptions_(t);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(t) {
    const e = Object.assign({}, t);
    for (const c in gn)
      delete e[c];
    this.setProperties(e, !0);
    const i = W_(t);
    this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = i.minZoom;
    const s = Y_(t), u = i.constraint, h = X_(t);
    this.constraints_ = {
      center: s,
      resolution: u,
      rotation: h
    }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(
      t.center !== void 0 ? t.center : null
    ), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(t) {
    let e = this.padding_;
    this.padding_ = t;
    const i = this.getCenterInternal();
    if (i) {
      const s = t || [0, 0, 0, 0];
      e = e || [0, 0, 0, 0];
      const u = this.getResolution(), h = u / 2 * (s[3] - e[3] + e[1] - s[1]), c = u / 2 * (s[0] - e[0] + e[2] - s[2]);
      this.setCenterInternal([i[0] + h, i[1] - c]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(t) {
    const e = this.getProperties();
    return e.resolution !== void 0 ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), Object.assign({}, e, t);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(t) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const e = new Array(arguments.length);
    for (let i = 0; i < e.length; ++i) {
      let s = arguments[i];
      s.center && (s = Object.assign({}, s), s.center = fi(
        s.center,
        this.getProjection()
      )), s.anchor && (s = Object.assign({}, s), s.anchor = fi(
        s.anchor,
        this.getProjection()
      )), e[i] = s;
    }
    this.animateInternal.apply(this, e);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(t) {
    let e = arguments.length, i;
    e > 1 && typeof arguments[e - 1] == "function" && (i = arguments[e - 1], --e);
    let s = 0;
    for (; s < e && !this.isDef(); ++s) {
      const y = arguments[s];
      y.center && this.setCenterInternal(y.center), y.zoom !== void 0 ? this.setZoom(y.zoom) : y.resolution && this.setResolution(y.resolution), y.rotation !== void 0 && this.setRotation(y.rotation);
    }
    if (s === e) {
      i && Do(i, !0);
      return;
    }
    let u = Date.now(), h = this.targetCenter_.slice(), c = this.targetResolution_, g = this.targetRotation_;
    const m = [];
    for (; s < e; ++s) {
      const y = (
        /** @type {AnimationOptions} */
        arguments[s]
      ), p = {
        start: u,
        complete: !1,
        anchor: y.anchor,
        duration: y.duration !== void 0 ? y.duration : 1e3,
        easing: y.easing || p_,
        callback: i
      };
      if (y.center && (p.sourceCenter = h, p.targetCenter = y.center.slice(), h = p.targetCenter), y.zoom !== void 0 ? (p.sourceResolution = c, p.targetResolution = this.getResolutionForZoom(y.zoom), c = p.targetResolution) : y.resolution && (p.sourceResolution = c, p.targetResolution = y.resolution, c = p.targetResolution), y.rotation !== void 0) {
        p.sourceRotation = g;
        const _ = ol(y.rotation - g + Math.PI, 2 * Math.PI) - Math.PI;
        p.targetRotation = g + _, g = p.targetRotation;
      }
      q_(p) ? p.complete = !0 : u += p.duration, m.push(p);
    }
    this.animations_.push(m), this.setHint(nn.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[nn.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[nn.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(nn.ANIMATING, -this.hints_[nn.ANIMATING]);
    let t;
    for (let e = 0, i = this.animations_.length; e < i; ++e) {
      const s = this.animations_[e];
      if (s[0].callback && Do(s[0].callback, !1), !t)
        for (let u = 0, h = s.length; u < h; ++u) {
          const c = s[u];
          if (!c.complete) {
            t = c.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const t = Date.now();
    let e = !1;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const s = this.animations_[i];
      let u = !0;
      for (let h = 0, c = s.length; h < c; ++h) {
        const g = s[h];
        if (g.complete)
          continue;
        const m = t - g.start;
        let y = g.duration > 0 ? m / g.duration : 1;
        y >= 1 ? (g.complete = !0, y = 1) : u = !1;
        const p = g.easing(y);
        if (g.sourceCenter) {
          const _ = g.sourceCenter[0], E = g.sourceCenter[1], S = g.targetCenter[0], I = g.targetCenter[1];
          this.nextCenter_ = g.targetCenter;
          const b = _ + p * (S - _), C = E + p * (I - E);
          this.targetCenter_ = [b, C];
        }
        if (g.sourceResolution && g.targetResolution) {
          const _ = p === 1 ? g.targetResolution : g.sourceResolution + p * (g.targetResolution - g.sourceResolution);
          if (g.anchor) {
            const E = this.getViewportSize_(this.getRotation()), S = this.constraints_.resolution(
              _,
              0,
              E,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              S,
              g.anchor
            );
          }
          this.nextResolution_ = g.targetResolution, this.targetResolution_ = _, this.applyTargetState_(!0);
        }
        if (g.sourceRotation !== void 0 && g.targetRotation !== void 0) {
          const _ = p === 1 ? ol(g.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : g.sourceRotation + p * (g.targetRotation - g.sourceRotation);
          if (g.anchor) {
            const E = this.constraints_.rotation(
              _,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              E,
              g.anchor
            );
          }
          this.nextRotation_ = g.targetRotation, this.targetRotation_ = _;
        }
        if (this.applyTargetState_(!0), e = !0, !g.complete)
          break;
      }
      if (u) {
        this.animations_[i] = null, this.setHint(nn.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const h = s[0].callback;
        h && Do(h, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), e && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(t, e) {
    let i;
    const s = this.getCenterInternal();
    return s !== void 0 && (i = [s[0] - e[0], s[1] - e[1]], Hv(i, t - this.getRotation()), Zv(i, e)), i;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(t, e) {
    let i;
    const s = this.getCenterInternal(), u = this.getResolution();
    if (s !== void 0 && u !== void 0) {
      const h = e[0] - t * (e[0] - s[0]) / u, c = e[1] - t * (e[1] - s[1]) / u;
      i = [h, c];
    }
    return i;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(t) {
    const e = this.viewportSize_;
    if (t) {
      const i = e[0], s = e[1];
      return [
        Math.abs(i * Math.cos(t)) + Math.abs(s * Math.sin(t)),
        Math.abs(i * Math.sin(t)) + Math.abs(s * Math.cos(t))
      ];
    }
    return e;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(t) {
    this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const t = this.getCenterInternal();
    return t && Pc(t, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(gn.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(t) {
    return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(t) {
    const e = this.calculateExtentInternal(t);
    return em(e, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(t) {
    t = t || this.getViewportSizeMinusPadding_();
    const e = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    Se(e, "The view center is not defined");
    const i = (
      /** @type {!number} */
      this.getResolution()
    );
    Se(i !== void 0, "The view resolution is not defined");
    const s = (
      /** @type {!number} */
      this.getRotation()
    );
    return Se(s !== void 0, "The view rotation is not defined"), Bv(e, i, s, t);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(t) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(gn.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(t, e) {
    return this.getResolutionForExtentInternal(
      Gs(t, this.getProjection()),
      e
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(t, e) {
    e = e || this.getViewportSizeMinusPadding_();
    const i = Me(t) / e[0], s = ni(t) / e[1];
    return Math.max(i, s);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(t) {
    t = t || 2;
    const e = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, s = Math.log(e / i) / Math.log(t);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(u) {
        return e / Math.pow(t, u * s);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(gn.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(t) {
    const e = Math.log(t || 2), i = this.getConstrainedResolution(this.maxResolution_), s = this.minResolution_, u = Math.log(i / s) / e;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(h) {
        return Math.log(i / h) / e / u;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(t) {
    let e = this.getViewportSize_(t);
    const i = this.padding_;
    return i && (e = [
      e[0] - i[1] - i[3],
      e[1] - i[0] - i[2]
    ]), e;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const t = this.getProjection(), e = this.getResolution(), i = this.getRotation();
    let s = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const u = this.padding_;
    if (u) {
      const h = this.getViewportSizeMinusPadding_();
      s = Su(
        s,
        this.getViewportSize_(),
        [h[0] / 2 + u[3], h[1] / 2 + u[0]],
        e,
        i
      );
    }
    return {
      center: s.slice(0),
      projection: t !== void 0 ? t : null,
      resolution: e,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: i,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let t;
    const e = this.getResolution();
    return e !== void 0 && (t = this.getZoomForResolution(e)), t;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(t) {
    let e = this.minZoom_ || 0, i, s;
    if (this.resolutions_) {
      const u = Fd(this.resolutions_, t, 1);
      e = u, i = this.resolutions_[u], u == this.resolutions_.length - 1 ? s = 2 : s = i / this.resolutions_[u + 1];
    } else
      i = this.maxResolution_, s = this.zoomFactor_;
    return e + Math.log(i / t) / Math.log(s);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(t) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const e = we(
        Math.floor(t),
        0,
        this.resolutions_.length - 2
      ), i = this.resolutions_[e] / this.resolutions_[e + 1];
      return this.resolutions_[e] / Math.pow(i, we(t - e, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(t, e) {
    let i;
    if (Se(
      Array.isArray(t) || typeof /** @type {?} */
      t.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(t)) {
      Se(
        !Ql(t),
        "Cannot fit empty extent provided as `geometry`"
      );
      const s = Gs(t, this.getProjection());
      i = Uc(s);
    } else if (t.getType() === "Circle") {
      const s = Gs(
        t.getExtent(),
        this.getProjection()
      );
      i = Uc(s), i.rotate(this.getRotation(), ar(s));
    } else
      i = t;
    this.fitInternal(i, e);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(t) {
    const e = this.getRotation(), i = Math.cos(e), s = Math.sin(-e), u = t.getFlatCoordinates(), h = t.getStride();
    let c = 1 / 0, g = 1 / 0, m = -1 / 0, y = -1 / 0;
    for (let p = 0, _ = u.length; p < _; p += h) {
      const E = u[p] * i - u[p + 1] * s, S = u[p] * s + u[p + 1] * i;
      c = Math.min(c, E), g = Math.min(g, S), m = Math.max(m, E), y = Math.max(y, S);
    }
    return [c, g, m, y];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(t, e) {
    e = e || {};
    let i = e.size;
    i || (i = this.getViewportSizeMinusPadding_());
    const s = e.padding !== void 0 ? e.padding : [0, 0, 0, 0], u = e.nearest !== void 0 ? e.nearest : !1;
    let h;
    e.minResolution !== void 0 ? h = e.minResolution : e.maxZoom !== void 0 ? h = this.getResolutionForZoom(e.maxZoom) : h = 0;
    const c = this.rotatedExtentForGeometry(t);
    let g = this.getResolutionForExtentInternal(c, [
      i[0] - s[1] - s[3],
      i[1] - s[0] - s[2]
    ]);
    g = isNaN(g) ? h : Math.max(g, h), g = this.getConstrainedResolution(g, u ? 0 : 1);
    const m = this.getRotation(), y = Math.sin(m), p = Math.cos(m), _ = ar(c);
    _[0] += (s[1] - s[3]) / 2 * g, _[1] += (s[0] - s[2]) / 2 * g;
    const E = _[0] * p - _[1] * y, S = _[1] * p + _[0] * y, I = this.getConstrainedCenter([E, S], g), b = e.callback ? e.callback : ts;
    e.duration !== void 0 ? this.animateInternal(
      {
        resolution: g,
        center: I,
        duration: e.duration,
        easing: e.easing
      },
      b
    ) : (this.targetResolution_ = g, this.targetCenter_ = I, this.applyTargetState_(!1, !0), Do(b, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(t, e, i) {
    this.centerOnInternal(
      fi(t, this.getProjection()),
      e,
      i
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(t, e, i) {
    this.setCenterInternal(
      Su(
        t,
        e,
        i,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(t, e, i, s) {
    let u;
    const h = this.padding_;
    if (h && t) {
      const c = this.getViewportSizeMinusPadding_(-i), g = Su(
        t,
        s,
        [c[0] / 2 + h[3], c[1] / 2 + h[0]],
        e,
        i
      );
      u = [
        t[0] - g[0],
        t[1] - g[1]
      ];
    }
    return u;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(t) {
    const e = Pc(this.targetCenter_, this.getProjection());
    this.setCenter([
      e[0] + t[0],
      e[1] + t[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(t) {
    const e = this.targetCenter_;
    this.setCenterInternal([
      e[0] + t[0],
      e[1] + t[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(t, e) {
    e = e && fi(e, this.getProjection()), this.adjustResolutionInternal(t, e);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(t, e) {
    const i = this.getAnimating() || this.getInteracting(), s = this.getViewportSize_(this.getRotation()), u = this.constraints_.resolution(
      this.targetResolution_ * t,
      0,
      s,
      i
    );
    e && (this.targetCenter_ = this.calculateCenterZoom(u, e)), this.targetResolution_ *= t, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(t, e) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(t, e) {
    e && (e = fi(e, this.getProjection())), this.adjustRotationInternal(t, e);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(t, e) {
    const i = this.getAnimating() || this.getInteracting(), s = this.constraints_.rotation(
      this.targetRotation_ + t,
      i
    );
    e && (this.targetCenter_ = this.calculateCenterRotate(s, e)), this.targetRotation_ += t, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(t) {
    this.setCenterInternal(
      t && fi(t, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(t) {
    this.targetCenter_ = t, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(t, e) {
    return this.hints_[t] += e, this.changed(), this.hints_[t];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(t) {
    this.targetResolution_ = t, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(t) {
    this.targetRotation_ = t, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(t) {
    this.setResolution(this.getResolutionForZoom(t));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(t, e) {
    const i = this.getAnimating() || this.getInteracting() || e, s = this.constraints_.rotation(
      this.targetRotation_,
      i
    ), u = this.getViewportSize_(s), h = this.constraints_.resolution(
      this.targetResolution_,
      0,
      u,
      i
    ), c = this.constraints_.center(
      this.targetCenter_,
      h,
      u,
      i,
      this.calculateCenterShift(
        this.targetCenter_,
        h,
        s,
        u
      )
    );
    this.get(gn.ROTATION) !== s && this.set(gn.ROTATION, s), this.get(gn.RESOLUTION) !== h && (this.set(gn.RESOLUTION, h), this.set("zoom", this.getZoom(), !0)), (!c || !this.get(gn.CENTER) || !ha(this.get(gn.CENTER), c)) && this.set(gn.CENTER, c), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(t, e, i) {
    t = t !== void 0 ? t : 200;
    const s = e || 0, u = this.constraints_.rotation(this.targetRotation_), h = this.getViewportSize_(u), c = this.constraints_.resolution(
      this.targetResolution_,
      s,
      h
    ), g = this.constraints_.center(
      this.targetCenter_,
      c,
      h,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        c,
        u,
        h
      )
    );
    if (t === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = c, this.targetRotation_ = u, this.targetCenter_ = g, this.applyTargetState_();
      return;
    }
    i = i || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== c || this.getRotation() !== u || !this.getCenterInternal() || !ha(this.getCenterInternal(), g)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: u,
      center: g,
      resolution: c,
      duration: t,
      easing: y_,
      anchor: i
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(nn.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(t, e, i) {
    i = i && fi(i, this.getProjection()), this.endInteractionInternal(t, e, i);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(t, e, i) {
    this.getInteracting() && (this.setHint(nn.INTERACTING, -1), this.resolveConstraints(t, e, i));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(t, e) {
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      t,
      e || this.getResolution(),
      i
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(t, e) {
    const i = this.getResolutionForZoom(t);
    return this.getZoomForResolution(
      this.getConstrainedResolution(i, e)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(t, e) {
    e = e || 0;
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(t, e, i);
  }
}
function Do(n, t) {
  setTimeout(function() {
    n(t);
  }, 0);
}
function Y_(n) {
  if (n.extent !== void 0) {
    const e = n.smoothExtentConstraint !== void 0 ? n.smoothExtentConstraint : !0;
    return Fc(n.extent, n.constrainOnlyCenter, e);
  }
  const t = th(n.projection, "EPSG:3857");
  if (n.multiWorld !== !0 && t.isGlobal()) {
    const e = t.getExtent().slice();
    return e[0] = -1 / 0, e[2] = 1 / 0, Fc(e, !1, !1);
  }
  return l_;
}
function W_(n) {
  let t, e, i, h = n.minZoom !== void 0 ? n.minZoom : xu, c = n.maxZoom !== void 0 ? n.maxZoom : 28;
  const g = n.zoomFactor !== void 0 ? n.zoomFactor : 2, m = n.multiWorld !== void 0 ? n.multiWorld : !1, y = n.smoothResolutionConstraint !== void 0 ? n.smoothResolutionConstraint : !0, p = n.showFullExtent !== void 0 ? n.showFullExtent : !1, _ = th(n.projection, "EPSG:3857"), E = _.getExtent();
  let S = n.constrainOnlyCenter, I = n.extent;
  if (!m && !I && _.isGlobal() && (S = !1, I = E), n.resolutions !== void 0) {
    const b = n.resolutions;
    e = b[h], i = b[c] !== void 0 ? b[c] : b[b.length - 1], n.constrainResolution ? t = h_(
      b,
      y,
      !S && I,
      p
    ) : t = Gc(
      e,
      i,
      y,
      !S && I,
      p
    );
  } else {
    const C = (E ? Math.max(Me(E), ni(E)) : (
      // use an extent that can fit the whole world if need be
      360 * Wd.degrees / _.getMetersPerUnit()
    )) / u_ / Math.pow(2, xu), R = C / Math.pow(2, 28 - xu);
    e = n.maxResolution, e !== void 0 ? h = 0 : e = C / Math.pow(g, h), i = n.minResolution, i === void 0 && (n.maxZoom !== void 0 ? n.maxResolution !== void 0 ? i = e / Math.pow(g, c) : i = C / Math.pow(g, c) : i = R), c = h + Math.floor(
      Math.log(e / i) / Math.log(g)
    ), i = e / Math.pow(g, c - h), n.constrainResolution ? t = c_(
      g,
      e,
      i,
      y,
      !S && I,
      p
    ) : t = Gc(
      e,
      i,
      y,
      !S && I,
      p
    );
  }
  return {
    constraint: t,
    maxResolution: e,
    minResolution: i,
    minZoom: h,
    zoomFactor: g
  };
}
function X_(n) {
  if (n.enableRotation !== void 0 ? n.enableRotation : !0) {
    const e = n.constrainRotation;
    return e === void 0 || e === !0 ? d_() : e === !1 ? Bc : typeof e == "number" ? g_(e) : Bc;
  }
  return f_;
}
function q_(n) {
  return !(n.sourceCenter && n.targetCenter && !ha(n.sourceCenter, n.targetCenter) || n.sourceResolution !== n.targetResolution || n.sourceRotation !== n.targetRotation);
}
function Su(n, t, e, i, s) {
  const u = Math.cos(-s);
  let h = Math.sin(-s), c = n[0] * u - n[1] * h, g = n[1] * u + n[0] * h;
  c += (t[0] / 2 - e[0]) * i, g += (e[1] - t[1] / 2) * i, h = -h;
  const m = c * u - g * h, y = g * u + c * h;
  return [m, y];
}
class U_ extends a_ {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(t) {
    const e = Object.assign({}, t);
    delete e.source, super(e), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(
      Dt.SOURCE,
      this.handleSourcePropertyChange_
    );
    const i = t.source ? (
      /** @type {SourceType} */
      t.source
    ) : null;
    this.setSource(i);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return t = t || [], t.push(this), t;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return t = t || [], t.push(this.getLayerState()), t;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Dt.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const t = this.getSource();
    return t ? t.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (Kn(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const t = this.getSource();
    t && (this.sourceChangeKey_ = On(
      t,
      pn.CHANGE,
      this.handleSourceChange_,
      this
    ), t.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(t) {
    let e;
    const i = this.getMapInternal();
    !t && i && (t = i.getView()), t instanceof jc ? e = {
      viewState: t.getState(),
      extent: t.calculateExtent()
    } : e = t, !e.layerStatesArray && i && (e.layerStatesArray = i.getLayerGroup().getLayerStatesArray());
    let s;
    e.layerStatesArray ? s = e.layerStatesArray.find(
      (h) => h.layer === this
    ) : s = this.getLayerState();
    const u = this.getExtent();
    return j_(s, e.viewState) && (!u || mn(u, e.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(t) {
    if (!this.isVisible(t))
      return [];
    let e;
    const i = this.getSource();
    if (i && (e = i.getAttributions()), !e)
      return [];
    const s = t instanceof jc ? t.getViewStateAndExtent() : t;
    let u = e(s);
    return Array.isArray(u) || (u = [u]), u;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(t, e) {
    const i = this.getRenderer();
    return i.prepareFrame(t) ? (this.rendered = !0, i.renderFrame(t, e)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(t, e) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(t) {
    const e = this.getRenderer();
    e && e.renderDeferred(t);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(t) {
    t || this.unrender(), this.set(Dt.MAP, t);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Dt.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.mapPrecomposeKey_ && (Kn(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (Kn(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = On(
      t,
      Hi.PRECOMPOSE,
      function(e) {
        const s = /** @type {import("../render/Event.js").default} */ e.frameState.layerStatesArray, u = this.getLayerState(!1);
        Se(
          !s.some(function(h) {
            return h.layer === u.layer;
          }),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        ), s.push(u);
      },
      this
    ), this.mapRenderKey_ = On(this, pn.CHANGE, t.render, t), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(t) {
    this.set(Dt.SOURCE, t);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function j_(n, t) {
  if (!n.visible)
    return !1;
  const e = t.resolution;
  if (e < n.minResolution || e >= n.maxResolution)
    return !1;
  const i = t.zoom;
  return i > n.minZoom && i <= n.maxZoom;
}
function V_(n, t, e, i, s) {
  cm(n, t, e || 0, i || n.length - 1, s || Z_);
}
function cm(n, t, e, i, s) {
  for (; i > e; ) {
    if (i - e > 600) {
      var u = i - e + 1, h = t - e + 1, c = Math.log(u), g = 0.5 * Math.exp(2 * c / 3), m = 0.5 * Math.sqrt(c * g * (u - g) / u) * (h - u / 2 < 0 ? -1 : 1), y = Math.max(e, Math.floor(t - h * g / u + m)), p = Math.min(i, Math.floor(t + (u - h) * g / u + m));
      cm(n, t, y, p, s);
    }
    var _ = n[t], E = e, S = i;
    for (Rs(n, e, t), s(n[i], _) > 0 && Rs(n, e, i); E < S; ) {
      for (Rs(n, E, S), E++, S--; s(n[E], _) < 0; ) E++;
      for (; s(n[S], _) > 0; ) S--;
    }
    s(n[e], _) === 0 ? Rs(n, e, S) : (S++, Rs(n, S, i)), S <= t && (e = S + 1), t <= S && (i = S - 1);
  }
}
function Rs(n, t, e) {
  var i = n[t];
  n[t] = n[e], n[e] = i;
}
function Z_(n, t) {
  return n < t ? -1 : n > t ? 1 : 0;
}
let fm = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let e = this.data;
    const i = [];
    if (!Go(t, e)) return i;
    const s = this.toBBox, u = [];
    for (; e; ) {
      for (let h = 0; h < e.children.length; h++) {
        const c = e.children[h], g = e.leaf ? s(c) : c;
        Go(t, g) && (e.leaf ? i.push(c) : Iu(t, g) ? this._all(c, i) : u.push(c));
      }
      e = u.pop();
    }
    return i;
  }
  collides(t) {
    let e = this.data;
    if (!Go(t, e)) return !1;
    const i = [];
    for (; e; ) {
      for (let s = 0; s < e.children.length; s++) {
        const u = e.children[s], h = e.leaf ? this.toBBox(u) : u;
        if (Go(t, h)) {
          if (e.leaf || Iu(t, h)) return !0;
          i.push(u);
        }
      }
      e = i.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let i = 0; i < t.length; i++)
        this.insert(t[i]);
      return this;
    }
    let e = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = e;
    else if (this.data.height === e.height)
      this._splitRoot(this.data, e);
    else {
      if (this.data.height < e.height) {
        const i = this.data;
        this.data = e, e = i;
      }
      this._insert(e, this.data.height - e.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = Wr([]), this;
  }
  remove(t, e) {
    if (!t) return this;
    let i = this.data;
    const s = this.toBBox(t), u = [], h = [];
    let c, g, m;
    for (; i || u.length; ) {
      if (i || (i = u.pop(), g = u[u.length - 1], c = h.pop(), m = !0), i.leaf) {
        const y = H_(t, i.children, e);
        if (y !== -1)
          return i.children.splice(y, 1), u.push(i), this._condense(u), this;
      }
      !m && !i.leaf && Iu(i, s) ? (u.push(i), h.push(c), c = 0, g = i, i = i.children[0]) : g ? (c++, i = g.children[c], m = !1) : i = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, e) {
    return t.minX - e.minX;
  }
  compareMinY(t, e) {
    return t.minY - e.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, e) {
    const i = [];
    for (; t; )
      t.leaf ? e.push(...t.children) : i.push(...t.children), t = i.pop();
    return e;
  }
  _build(t, e, i, s) {
    const u = i - e + 1;
    let h = this._maxEntries, c;
    if (u <= h)
      return c = Wr(t.slice(e, i + 1)), Dr(c, this.toBBox), c;
    s || (s = Math.ceil(Math.log(u) / Math.log(h)), h = Math.ceil(u / Math.pow(h, s - 1))), c = Wr([]), c.leaf = !1, c.height = s;
    const g = Math.ceil(u / h), m = g * Math.ceil(Math.sqrt(h));
    Vc(t, e, i, m, this.compareMinX);
    for (let y = e; y <= i; y += m) {
      const p = Math.min(y + m - 1, i);
      Vc(t, y, p, g, this.compareMinY);
      for (let _ = y; _ <= p; _ += g) {
        const E = Math.min(_ + g - 1, p);
        c.children.push(this._build(t, _, E, s - 1));
      }
    }
    return Dr(c, this.toBBox), c;
  }
  _chooseSubtree(t, e, i, s) {
    for (; s.push(e), !(e.leaf || s.length - 1 === i); ) {
      let u = 1 / 0, h = 1 / 0, c;
      for (let g = 0; g < e.children.length; g++) {
        const m = e.children[g], y = wu(m), p = J_(t, m) - y;
        p < h ? (h = p, u = y < u ? y : u, c = m) : p === h && y < u && (u = y, c = m);
      }
      e = c || e.children[0];
    }
    return e;
  }
  _insert(t, e, i) {
    const s = i ? t : this.toBBox(t), u = [], h = this._chooseSubtree(s, this.data, e, u);
    for (h.children.push(t), zs(h, s); e >= 0 && u[e].children.length > this._maxEntries; )
      this._split(u, e), e--;
    this._adjustParentBBoxes(s, u, e);
  }
  // split overflowed node into two
  _split(t, e) {
    const i = t[e], s = i.children.length, u = this._minEntries;
    this._chooseSplitAxis(i, u, s);
    const h = this._chooseSplitIndex(i, u, s), c = Wr(i.children.splice(h, i.children.length - h));
    c.height = i.height, c.leaf = i.leaf, Dr(i, this.toBBox), Dr(c, this.toBBox), e ? t[e - 1].children.push(c) : this._splitRoot(i, c);
  }
  _splitRoot(t, e) {
    this.data = Wr([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Dr(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, e, i) {
    let s, u = 1 / 0, h = 1 / 0;
    for (let c = e; c <= i - e; c++) {
      const g = Bs(t, 0, c, this.toBBox), m = Bs(t, c, i, this.toBBox), y = Q_(g, m), p = wu(g) + wu(m);
      y < u ? (u = y, s = c, h = p < h ? p : h) : y === u && p < h && (h = p, s = c);
    }
    return s || i - e;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, e, i) {
    const s = t.leaf ? this.compareMinX : K_, u = t.leaf ? this.compareMinY : $_, h = this._allDistMargin(t, e, i, s), c = this._allDistMargin(t, e, i, u);
    h < c && t.children.sort(s);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, e, i, s) {
    t.children.sort(s);
    const u = this.toBBox, h = Bs(t, 0, e, u), c = Bs(t, i - e, i, u);
    let g = Fo(h) + Fo(c);
    for (let m = e; m < i - e; m++) {
      const y = t.children[m];
      zs(h, t.leaf ? u(y) : y), g += Fo(h);
    }
    for (let m = i - e - 1; m >= e; m--) {
      const y = t.children[m];
      zs(c, t.leaf ? u(y) : y), g += Fo(c);
    }
    return g;
  }
  _adjustParentBBoxes(t, e, i) {
    for (let s = i; s >= 0; s--)
      zs(e[s], t);
  }
  _condense(t) {
    for (let e = t.length - 1, i; e >= 0; e--)
      t[e].children.length === 0 ? e > 0 ? (i = t[e - 1].children, i.splice(i.indexOf(t[e]), 1)) : this.clear() : Dr(t[e], this.toBBox);
  }
};
function H_(n, t, e) {
  if (!e) return t.indexOf(n);
  for (let i = 0; i < t.length; i++)
    if (e(n, t[i])) return i;
  return -1;
}
function Dr(n, t) {
  Bs(n, 0, n.children.length, t, n);
}
function Bs(n, t, e, i, s) {
  s || (s = Wr(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
  for (let u = t; u < e; u++) {
    const h = n.children[u];
    zs(s, n.leaf ? i(h) : h);
  }
  return s;
}
function zs(n, t) {
  return n.minX = Math.min(n.minX, t.minX), n.minY = Math.min(n.minY, t.minY), n.maxX = Math.max(n.maxX, t.maxX), n.maxY = Math.max(n.maxY, t.maxY), n;
}
function K_(n, t) {
  return n.minX - t.minX;
}
function $_(n, t) {
  return n.minY - t.minY;
}
function wu(n) {
  return (n.maxX - n.minX) * (n.maxY - n.minY);
}
function Fo(n) {
  return n.maxX - n.minX + (n.maxY - n.minY);
}
function J_(n, t) {
  return (Math.max(t.maxX, n.maxX) - Math.min(t.minX, n.minX)) * (Math.max(t.maxY, n.maxY) - Math.min(t.minY, n.minY));
}
function Q_(n, t) {
  const e = Math.max(n.minX, t.minX), i = Math.max(n.minY, t.minY), s = Math.min(n.maxX, t.maxX), u = Math.min(n.maxY, t.maxY);
  return Math.max(0, s - e) * Math.max(0, u - i);
}
function Iu(n, t) {
  return n.minX <= t.minX && n.minY <= t.minY && t.maxX <= n.maxX && t.maxY <= n.maxY;
}
function Go(n, t) {
  return t.minX <= n.maxX && t.minY <= n.maxY && t.maxX >= n.minX && t.maxY >= n.minY;
}
function Wr(n) {
  return {
    children: n,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Vc(n, t, e, i, s) {
  const u = [t, e];
  for (; u.length; ) {
    if (e = u.pop(), t = u.pop(), e - t <= i) continue;
    const h = t + Math.ceil((e - t) / i / 2) * i;
    V_(n, h, t, e, s), u.push(t, h, h, e);
  }
}
const wt = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
function Qs(n, t) {
  return Array.isArray(n) ? n : (t === void 0 ? t = [n, n] : (t[0] = n, t[1] = n), t);
}
class ja {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = Qs(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new ja({
      opacity: this.getOpacity(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return zt();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(t) {
    return zt();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return zt();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return zt();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return zt();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return zt();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return zt();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(t) {
    this.displacement_ = t;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(t) {
    this.opacity_ = t;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = Qs(t);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    zt();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    zt();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    zt();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
const to = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
};
var me = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"]
};
me.whitepoint = {
  //1931 2
  2: {
    //incadescent
    A: [109.85, 100, 35.585],
    // B:[],
    C: [98.074, 100, 118.232],
    D50: [96.422, 100, 82.521],
    D55: [95.682, 100, 92.149],
    //daylight
    D65: [95.045592705167, 100, 108.9057750759878],
    D75: [94.972, 100, 122.638],
    //flourescent
    // F1: [],
    F2: [99.187, 100, 67.395],
    // F3: [],
    // F4: [],
    // F5: [],
    // F6:[],
    F7: [95.044, 100, 108.755],
    // F8: [],
    // F9: [],
    // F10: [],
    F11: [100.966, 100, 64.37],
    // F12: [],
    E: [100, 100, 100]
  },
  //1964  10
  10: {
    //incadescent
    A: [111.144, 100, 35.2],
    C: [97.285, 100, 116.145],
    D50: [96.72, 100, 81.427],
    D55: [95.799, 100, 90.926],
    //daylight
    D65: [94.811, 100, 107.304],
    D75: [94.416, 100, 120.641],
    //flourescent
    F2: [103.28, 100, 69.026],
    F7: [95.792, 100, 107.687],
    F11: [103.866, 100, 65.627],
    E: [100, 100, 100]
  }
};
me.max = me.whitepoint[2].D65;
me.rgb = function(n, t) {
  t = t || me.whitepoint[2].E;
  var e = n[0] / t[0], i = n[1] / t[1], s = n[2] / t[2], u, h, c;
  return u = e * 3.240969941904521 + i * -1.537383177570093 + s * -0.498610760293, h = e * -0.96924363628087 + i * 1.87596750150772 + s * 0.041555057407175, c = e * 0.055630079696993 + i * -0.20397695888897 + s * 1.056971514242878, u = u > 31308e-7 ? 1.055 * Math.pow(u, 1 / 2.4) - 0.055 : u = u * 12.92, h = h > 31308e-7 ? 1.055 * Math.pow(h, 1 / 2.4) - 0.055 : h = h * 12.92, c = c > 31308e-7 ? 1.055 * Math.pow(c, 1 / 2.4) - 0.055 : c = c * 12.92, u = Math.min(Math.max(0, u), 1), h = Math.min(Math.max(0, h), 1), c = Math.min(Math.max(0, c), 1), [u * 255, h * 255, c * 255];
};
to.xyz = function(n, t) {
  var e = n[0] / 255, i = n[1] / 255, s = n[2] / 255;
  e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92, s = s > 0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
  var u = e * 0.41239079926595 + i * 0.35758433938387 + s * 0.18048078840183, h = e * 0.21263900587151 + i * 0.71516867876775 + s * 0.072192315360733, c = e * 0.019330818715591 + i * 0.11919477979462 + s * 0.95053215224966;
  return t = t || me.whitepoint[2].E, [u * t[0], h * t[1], c * t[2]];
};
const fh = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(n, t, e) {
    var i, s, u, h, c, g, m, y, p, _, E, S, I;
    if (u = n[0], h = n[1], c = n[2], u === 0) return [0, 0, 0];
    var b = 0.0011070564598794539;
    return t = t || "D65", e = e || 2, p = me.whitepoint[e][t][0], _ = me.whitepoint[e][t][1], E = me.whitepoint[e][t][2], S = 4 * p / (p + 15 * _ + 3 * E), I = 9 * _ / (p + 15 * _ + 3 * E), i = h / (13 * u) + S || 0, s = c / (13 * u) + I || 0, m = u > 8 ? _ * Math.pow((u + 16) / 116, 3) : _ * u * b, g = m * 9 * i / (4 * s) || 0, y = m * (12 - 3 * i - 20 * s) / (4 * s) || 0, [g, m, y];
  }
};
me.luv = function(n, t, e) {
  var i, s, u, h, c, g, m, y, p, _, E, S, I, b = 0.008856451679035631, C = 903.2962962962961;
  t = t || "D65", e = e || 2, p = me.whitepoint[e][t][0], _ = me.whitepoint[e][t][1], E = me.whitepoint[e][t][2], S = 4 * p / (p + 15 * _ + 3 * E), I = 9 * _ / (p + 15 * _ + 3 * E), g = n[0], m = n[1], y = n[2], i = 4 * g / (g + 15 * m + 3 * y) || 0, s = 9 * m / (g + 15 * m + 3 * y) || 0;
  var R = m / _;
  return u = R <= b ? C * R : 116 * Math.pow(R, 1 / 3) - 16, h = 13 * u * (i - S), c = 13 * u * (s - I), [u, h, c];
};
var gm = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(n) {
    var t = n[0], e = n[1], i = n[2], s, u, h;
    return h = i / 360 * 2 * Math.PI, s = e * Math.cos(h), u = e * Math.sin(h), [t, s, u];
  },
  xyz: function(n) {
    return fh.xyz(gm.luv(n));
  }
};
fh.lchuv = function(n) {
  var t = n[0], e = n[1], i = n[2], s = Math.sqrt(e * e + i * i), u = Math.atan2(i, e), h = u * 360 / 2 / Math.PI;
  return h < 0 && (h += 360), [t, s, h];
};
me.lchuv = function(n) {
  return fh.lchuv(me.luv(n));
};
const Zc = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var Hc = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function t0(n) {
  var y, p;
  var t, e = [], i = 1, s;
  if (typeof n == "number")
    return { space: "rgb", values: [n >>> 16, (n & 65280) >>> 8, n & 255], alpha: 1 };
  if (typeof n == "number") return { space: "rgb", values: [n >>> 16, (n & 65280) >>> 8, n & 255], alpha: 1 };
  if (n = String(n).toLowerCase(), Zc[n])
    e = Zc[n].slice(), s = "rgb";
  else if (n === "transparent")
    i = 0, s = "rgb", e = [0, 0, 0];
  else if (n[0] === "#") {
    var u = n.slice(1), h = u.length, c = h <= 4;
    i = 1, c ? (e = [
      parseInt(u[0] + u[0], 16),
      parseInt(u[1] + u[1], 16),
      parseInt(u[2] + u[2], 16)
    ], h === 4 && (i = parseInt(u[3] + u[3], 16) / 255)) : (e = [
      parseInt(u[0] + u[1], 16),
      parseInt(u[2] + u[3], 16),
      parseInt(u[4] + u[5], 16)
    ], h === 8 && (i = parseInt(u[6] + u[7], 16) / 255)), e[0] || (e[0] = 0), e[1] || (e[1] = 0), e[2] || (e[2] = 0), s = "rgb";
  } else if (t = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(n)) {
    var g = t[1];
    s = g.replace(/a$/, "");
    var m = s === "cmyk" ? 4 : s === "gray" ? 1 : 3;
    e = t[2].trim().split(/\s*[,\/]\s*|\s+/), s === "color" && (s = e.shift()), e = e.map(function(_, E) {
      if (_[_.length - 1] === "%")
        return _ = parseFloat(_) / 100, E === 3 ? _ : s === "rgb" ? _ * 255 : s[0] === "h" || s[0] === "l" && !E ? _ * 100 : s === "lab" ? _ * 125 : s === "lch" ? E < 2 ? _ * 150 : _ * 360 : s[0] === "o" && !E ? _ : s === "oklab" ? _ * 0.4 : s === "oklch" ? E < 2 ? _ * 0.4 : _ * 360 : _;
      if (s[E] === "h" || E === 2 && s[s.length - 1] === "h") {
        if (Hc[_] !== void 0) return Hc[_];
        if (_.endsWith("deg")) return parseFloat(_);
        if (_.endsWith("turn")) return parseFloat(_) * 360;
        if (_.endsWith("grad")) return parseFloat(_) * 360 / 400;
        if (_.endsWith("rad")) return parseFloat(_) * 180 / Math.PI;
      }
      return _ === "none" ? 0 : parseFloat(_);
    }), i = e.length > m ? e.pop() : 1;
  } else /[0-9](?:\s|\/|,)/.test(n) && (e = n.match(/([0-9]+)/g).map(function(_) {
    return parseFloat(_);
  }), s = ((p = (y = n.match(/([a-z])/ig)) == null ? void 0 : y.join("")) == null ? void 0 : p.toLowerCase()) || "rgb");
  return {
    space: s,
    values: e,
    alpha: i
  };
}
const ku = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(n) {
    var t = n[0] / 360, e = n[1] / 100, i = n[2] / 100, s, u, h, c, g, m = 0;
    if (e === 0) return g = i * 255, [g, g, g];
    for (u = i < 0.5 ? i * (1 + e) : i + e - i * e, s = 2 * i - u, c = [0, 0, 0]; m < 3; )
      h = t + 1 / 3 * -(m - 1), h < 0 ? h++ : h > 1 && h--, g = 6 * h < 1 ? s + (u - s) * 6 * h : 2 * h < 1 ? u : 3 * h < 2 ? s + (u - s) * (2 / 3 - h) * 6 : s, c[m++] = g * 255;
    return c;
  }
};
to.hsl = function(n) {
  var t = n[0] / 255, e = n[1] / 255, i = n[2] / 255, s = Math.min(t, e, i), u = Math.max(t, e, i), h = u - s, c, g, m;
  return u === s ? c = 0 : t === u ? c = (e - i) / h : e === u ? c = 2 + (i - t) / h : i === u && (c = 4 + (t - e) / h), c = Math.min(c * 60, 360), c < 0 && (c += 360), m = (s + u) / 2, u === s ? g = 0 : m <= 0.5 ? g = h / (u + s) : g = h / (2 - u - s), [c, g * 100, m * 100];
};
function e0(n) {
  Array.isArray(n) && n.raw && (n = String.raw(...arguments)), n instanceof Number && (n = +n);
  var t, e = t0(n);
  if (!e.space) return [];
  const i = e.space[0] === "h" ? ku.min : to.min, s = e.space[0] === "h" ? ku.max : to.max;
  return t = Array(3), t[0] = Math.min(Math.max(e.values[0], i[0]), s[0]), t[1] = Math.min(Math.max(e.values[1], i[1]), s[1]), t[2] = Math.min(Math.max(e.values[2], i[2]), s[2]), e.space[0] === "h" && (t = ku.rgb(t)), t.push(Math.min(Math.max(e.alpha, 0), 1)), t;
}
function n0(n) {
  return typeof n == "string" ? n : dh(n);
}
const i0 = 1024, Ls = {};
let bu = 0;
function r0(n) {
  if (n.length === 4)
    return n;
  const t = n.slice();
  return t[3] = 1, t;
}
function Kc(n) {
  const t = me.lchuv(to.xyz(n));
  return t[3] = n[3], t;
}
function s0(n) {
  const t = me.rgb(gm.xyz(n));
  return t[3] = n[3], t;
}
function gh(n) {
  if (Ls.hasOwnProperty(n))
    return Ls[n];
  if (bu >= i0) {
    let e = 0;
    for (const i in Ls)
      e++ & 3 || (delete Ls[i], --bu);
  }
  const t = e0(n);
  if (t.length !== 4)
    throw new Error('Failed to parse "' + n + '" as color');
  for (const e of t)
    if (isNaN(e))
      throw new Error('Failed to parse "' + n + '" as color');
  return dm(t), Ls[n] = t, ++bu, t;
}
function eo(n) {
  return Array.isArray(n) ? n : gh(n);
}
function dm(n) {
  return n[0] = we(n[0] + 0.5 | 0, 0, 255), n[1] = we(n[1] + 0.5 | 0, 0, 255), n[2] = we(n[2] + 0.5 | 0, 0, 255), n[3] = we(n[3], 0, 1), n;
}
function dh(n) {
  let t = n[0];
  t != (t | 0) && (t = t + 0.5 | 0);
  let e = n[1];
  e != (e | 0) && (e = e + 0.5 | 0);
  let i = n[2];
  i != (i | 0) && (i = i + 0.5 | 0);
  const s = n[3] === void 0 ? 1 : Math.round(n[3] * 1e3) / 1e3;
  return "rgba(" + t + "," + e + "," + i + "," + s + ")";
}
function o0(n) {
  try {
    return gh(n), !0;
  } catch {
    return !1;
  }
}
function a0(n, t) {
  return new Promise((e, i) => {
    function s() {
      h(), e(n);
    }
    function u() {
      h(), i(new Error("Image load error"));
    }
    function h() {
      n.removeEventListener("load", s), n.removeEventListener("error", u);
    }
    n.addEventListener("load", s), n.addEventListener("error", u);
  });
}
function u0(n, t) {
  return t && (n.src = t), n.src && Ev ? new Promise(
    (e, i) => n.decode().then(() => e(n)).catch(
      (s) => n.complete && n.width ? e(n) : i(s)
    )
  ) : a0(n);
}
class l0 {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let t = 0;
      for (const e in this.cache_) {
        const i = this.cache_[e];
        !(t++ & 3) && !i.hasListener() && (delete this.cache_[e], delete this.patternCache_[e], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(t, e, i) {
    const s = Cu(t, e, i);
    return s in this.cache_ ? this.cache_[s] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(t, e, i) {
    const s = Cu(t, e, i);
    return s in this.patternCache_ ? this.patternCache_[s] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(t, e, i, s, u) {
    const h = Cu(t, e, i), c = h in this.cache_;
    this.cache_[h] = s, u && (s.getImageState() === wt.IDLE && s.load(), s.getImageState() === wt.LOADING ? s.ready().then(() => {
      this.patternCache_[h] = nl().createPattern(
        s.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[h] = nl().createPattern(
      s.getImage(1),
      "repeat"
    )), c || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(t) {
    this.maxCacheSize_ = t, this.expire();
  }
}
function Cu(n, t, e) {
  const i = e ? eo(e) : "null";
  return t + ":" + n + ":" + i;
}
const Si = new l0();
let Ts = null;
class h0 extends Bd {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(t, e, i, s, u) {
    super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = i, this.canvas_ = {}, this.color_ = u, this.imageState_ = s === void 0 ? wt.IDLE : s, this.size_ = t && t.width && t.height ? [t.width, t.height] : null, this.src_ = e, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === wt.LOADED) {
      Ts || (Ts = Ue(1, 1, void 0, {
        willReadFrequently: !0
      })), Ts.drawImage(this.image_, 0, 0);
      try {
        Ts.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        Ts = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(pn.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = wt.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = wt.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(t) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(t) {
    return this.replaceColor_(t), this.canvas_[t] ? t : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const t = this.size_[0], e = this.size_[1], i = Ue(t, e);
        i.fillRect(0, 0, t, e), this.hitDetectionImage_ = i.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === wt.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = wt.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && u0(this.image_, this.src_).then((t) => {
        this.image_ = t, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(t) {
    if (!this.color_ || this.canvas_[t] || this.imageState_ !== wt.LOADED)
      return;
    const e = this.image_, i = document.createElement("canvas");
    i.width = Math.ceil(e.width * t), i.height = Math.ceil(e.height * t);
    const s = i.getContext("2d");
    s.scale(t, t), s.drawImage(e, 0, 0), s.globalCompositeOperation = "multiply", s.fillStyle = n0(this.color_), s.fillRect(0, 0, i.width / t, i.height / t), s.globalCompositeOperation = "destination-in", s.drawImage(e, 0, 0), this.canvas_[t] = i;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((t) => {
      this.imageState_ === wt.LOADED || this.imageState_ === wt.ERROR ? t() : this.addEventListener(pn.CHANGE, function e() {
        (this.imageState_ === wt.LOADED || this.imageState_ === wt.ERROR) && (this.removeEventListener(pn.CHANGE, e), t());
      });
    })), this.ready_;
  }
}
function mh(n, t, e, i, s, u) {
  let h = t === void 0 ? void 0 : Si.get(t, e, s);
  return h || (h = new h0(
    n,
    n instanceof HTMLImageElement ? n.src || void 0 : t,
    e,
    i,
    s
  ), Si.set(t, e, s, h, u)), u && h && !Si.getPattern(t, e, s) && Si.set(t, e, s, h, u), h;
}
function Tn(n) {
  return n ? Array.isArray(n) ? dh(n) : typeof n == "object" && "src" in n ? c0(n) : n : null;
}
function c0(n) {
  if (!n.offset || !n.size)
    return Si.getPattern(n.src, "anonymous", n.color);
  const t = n.src + ":" + n.offset, e = Si.getPattern(
    t,
    void 0,
    n.color
  );
  if (e)
    return e;
  const i = Si.get(n.src, "anonymous", null);
  if (i.getImageState() !== wt.LOADED)
    return null;
  const s = Ue(
    n.size[0],
    n.size[1]
  );
  return s.drawImage(
    i.getImage(1),
    n.offset[0],
    n.offset[1],
    n.size[0],
    n.size[1],
    0,
    0,
    n.size[0],
    n.size[1]
  ), mh(
    s.canvas,
    t,
    void 0,
    wt.LOADED,
    n.color,
    !0
  ), Si.getPattern(t, void 0, n.color);
}
const mm = "10px sans-serif", Oe = "#000", ns = "round", Jn = [], Qn = 0, is = "round", no = 10, io = "#000", ro = "center", fa = "middle", $i = [0, 0, 0, 0], so = 1, gi = new fr();
let Xr = null, hl;
const cl = {}, f0 = function() {
  const t = "32px ", e = ["monospace", "serif"], i = e.length, s = "wmytzilWMYTZIL@#/&?$%10";
  let u, h;
  function c(m, y, p) {
    let _ = !0;
    for (let E = 0; E < i; ++E) {
      const S = e[E];
      if (h = ga(
        m + " " + y + " " + t + S,
        s
      ), p != S) {
        const I = ga(
          m + " " + y + " " + t + p + "," + S,
          s
        );
        _ = _ && I != h;
      }
    }
    return !!_;
  }
  function g() {
    let m = !0;
    const y = gi.getKeys();
    for (let p = 0, _ = y.length; p < _; ++p) {
      const E = y[p];
      gi.get(E) < 100 && (c.apply(this, E.split(`
`)) ? (Hl(cl), Xr = null, hl = void 0, gi.set(E, 100)) : (gi.set(E, gi.get(E) + 1, !0), m = !1));
    }
    m && (clearInterval(u), u = void 0);
  }
  return function(m) {
    const y = Yd(m);
    if (!y)
      return;
    const p = y.families;
    for (let _ = 0, E = p.length; _ < E; ++_) {
      const S = p[_], I = y.style + `
` + y.weight + `
` + S;
      gi.get(I) === void 0 && (gi.set(I, 100, !0), c(y.style, y.weight, S) || (gi.set(I, 0, !0), u === void 0 && (u = setInterval(g, 32))));
    }
  };
}(), g0 = /* @__PURE__ */ function() {
  let n;
  return function(t) {
    let e = cl[t];
    if (e == null) {
      if (zd) {
        const i = Yd(t), s = ym(t, "g");
        e = (isNaN(Number(i.lineHeight)) ? 1.2 : Number(i.lineHeight)) * (s.actualBoundingBoxAscent + s.actualBoundingBoxDescent);
      } else
        n || (n = document.createElement("div"), n.innerHTML = "M", n.style.minHeight = "0", n.style.maxHeight = "none", n.style.height = "auto", n.style.padding = "0", n.style.border = "none", n.style.position = "absolute", n.style.display = "block", n.style.left = "-99999px"), n.style.font = t, document.body.appendChild(n), e = n.offsetHeight, document.body.removeChild(n);
      cl[t] = e;
    }
    return e;
  };
}();
function ym(n, t) {
  return Xr || (Xr = Ue(1, 1)), n != hl && (Xr.font = n, hl = Xr.font), Xr.measureText(t);
}
function ga(n, t) {
  return ym(n, t).width;
}
function $c(n, t, e) {
  if (t in e)
    return e[t];
  const i = t.split(`
`).reduce((s, u) => Math.max(s, ga(n, u)), 0);
  return e[t] = i, i;
}
function d0(n, t) {
  const e = [], i = [], s = [];
  let u = 0, h = 0, c = 0, g = 0;
  for (let m = 0, y = t.length; m <= y; m += 2) {
    const p = t[m];
    if (p === `
` || m === y) {
      u = Math.max(u, h), s.push(h), h = 0, c += g;
      continue;
    }
    const _ = t[m + 1] || n.font, E = ga(_, p);
    e.push(E), h += E;
    const S = g0(_);
    i.push(S), g = Math.max(g, S);
  }
  return { width: u, height: c, widths: e, heights: i, lineWidths: s };
}
function m0(n, t, e, i, s, u, h, c, g, m, y) {
  n.save(), e !== 1 && (n.globalAlpha === void 0 ? n.globalAlpha = (p) => p.globalAlpha *= e : n.globalAlpha *= e), t && n.transform.apply(n, t), /** @type {*} */
  i.contextInstructions ? (n.translate(g, m), n.scale(y[0], y[1]), y0(
    /** @type {Label} */
    i,
    n
  )) : y[0] < 0 || y[1] < 0 ? (n.translate(g, m), n.scale(y[0], y[1]), n.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    s,
    u,
    h,
    c,
    0,
    0,
    h,
    c
  )) : n.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    s,
    u,
    h,
    c,
    g,
    m,
    h * y[0],
    c * y[1]
  ), n.restore();
}
function y0(n, t) {
  const e = n.contextInstructions;
  for (let i = 0, s = e.length; i < s; i += 2)
    Array.isArray(e[i + 1]) ? t[e[i]].apply(
      t,
      e[i + 1]
    ) : t[e[i]] = e[i + 1];
}
class Va extends ja {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    super({
      opacity: 1,
      rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      scale: t.scale !== void 0 ? t.scale : 1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    }), this.canvases_, this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius_ = t.radius, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? wt.LOADING : wt.LOADED, this.imageState_ === wt.LOADING && this.ready().then(() => this.imageState_ = wt.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale(), e = new Va({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return e.setOpacity(this.getOpacity()), e;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const t = this.size_, e = this.getDisplacement(), i = this.getScaleArray();
    return [
      t[0] / 2 - e[0] / i[0],
      t[1] / 2 + e[1] / i[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(t) {
    let e = this.canvases_[t];
    if (!e) {
      const i = this.renderOptions_, s = Ue(
        i.size * t,
        i.size * t
      );
      this.draw_(i, s, t), e = s.canvas, this.canvases_[t] = e;
    }
    return e;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return t;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(t, e, i) {
    if (e === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter")
      return e;
    let s = this.radius_, u = this.radius2_ === void 0 ? s : this.radius2_;
    if (s < u) {
      const G = s;
      s = u, u = G;
    }
    const h = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, c = 2 * Math.PI / h, g = u * Math.sin(c), m = Math.sqrt(u * u - g * g), y = s - m, p = Math.sqrt(g * g + y * y), _ = p / g;
    if (t === "miter" && _ <= i)
      return _ * e;
    const E = e / 2 / _, S = e / 2 * (y / p), b = Math.sqrt((s + E) * (s + E) + S * S) - s;
    if (this.radius2_ === void 0 || t === "bevel")
      return b * 2;
    const C = s * Math.sin(c), R = Math.sqrt(s * s - C * C), T = u - R, M = Math.sqrt(C * C + T * T) / C;
    if (M <= i) {
      const G = M * e / 2 - u - s;
      return 2 * Math.max(b, G);
    }
    return b * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let t = ns, e = is, i = 0, s = null, u = 0, h, c = 0;
    this.stroke_ && (h = Tn(this.stroke_.getColor() ?? io), c = this.stroke_.getWidth() ?? so, s = this.stroke_.getLineDash(), u = this.stroke_.getLineDashOffset() ?? 0, e = this.stroke_.getLineJoin() ?? is, t = this.stroke_.getLineCap() ?? ns, i = this.stroke_.getMiterLimit() ?? no);
    const g = this.calculateLineJoinSize_(e, c, i), m = Math.max(this.radius_, this.radius2_ || 0), y = Math.ceil(2 * m + g);
    return {
      strokeStyle: h,
      strokeWidth: c,
      size: y,
      lineCap: t,
      lineDash: s,
      lineDashOffset: u,
      lineJoin: e,
      miterLimit: i
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const t = this.renderOptions_.size;
    this.canvases_ = {}, this.hitDetectionCanvas_ = null, this.size_ = [t, t];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(t, e, i) {
    if (e.scale(i, i), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) {
      let s = this.fill_.getColor();
      s === null && (s = Oe), e.fillStyle = Tn(s), e.fill();
    }
    t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(t) {
    let e;
    if (this.fill_) {
      let i = this.fill_.getColor(), s = 0;
      typeof i == "string" && (i = eo(i)), i === null ? s = 1 : Array.isArray(i) && (s = i.length === 4 ? i[3] : 1), s === 0 && (e = Ue(t.size, t.size), this.drawHitDetectionCanvas_(t, e));
    }
    return e ? e.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(t) {
    let e = this.points_;
    const i = this.radius_;
    if (e === 1 / 0)
      t.arc(0, 0, i, 0, 2 * Math.PI);
    else {
      const s = this.radius2_ === void 0 ? i : this.radius2_;
      this.radius2_ !== void 0 && (e *= 2);
      const u = this.angle_ - Math.PI / 2, h = 2 * Math.PI / e;
      for (let c = 0; c < e; c++) {
        const g = u + c * h, m = c % 2 === 0 ? i : s;
        t.lineTo(m * Math.cos(g), m * Math.sin(g));
      }
      t.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(t, e) {
    e.translate(t.size / 2, t.size / 2), this.createPath_(e), e.fillStyle = Oe, e.fill(), t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
  }
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
class Za extends Va {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || { radius: 5 }, super({
      points: 1 / 0,
      fill: t.fill,
      radius: t.radius,
      stroke: t.stroke,
      scale: t.scale !== void 0 ? t.scale : 1,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale(), e = new Za({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return e.setOpacity(this.getOpacity()), e;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(t) {
    this.radius_ = t, this.render();
  }
}
class lr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.patternImage_ = null, this.color_ = null, t.color !== void 0 && this.setColor(t.color);
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new lr({
      color: Array.isArray(t) ? t.slice() : t || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(t) {
    if (t !== null && typeof t == "object" && "src" in t) {
      const e = mh(
        null,
        t.src,
        "anonymous",
        void 0,
        t.offset ? null : t.color ? t.color : null,
        !(t.offset && t.size)
      );
      e.ready().then(() => {
        this.patternImage_ = null;
      }), e.getImageState() === wt.IDLE && e.load(), e.getImageState() === wt.LOADING && (this.patternImage_ = e);
    }
    this.color_ = t;
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
class rs {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new rs({
      color: Array.isArray(t) ? t.slice() : t || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(t) {
    this.color_ = t;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(t) {
    this.lineCap_ = t;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(t) {
    this.lineDash_ = t;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(t) {
    this.lineDashOffset_ = t;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(t) {
    this.lineJoin_ = t;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(t) {
    this.miterLimit_ = t;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(t) {
    this.width_ = t;
  }
}
class Ti {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(t) {
    t = t || {}, this.geometry_ = null, this.geometryFunction_ = Jc, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let t = this.getGeometry();
    return t && typeof t == "object" && (t = /** @type {import("../geom/Geometry.js").default} */
    t.clone()), new Ti({
      geometry: t ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(t) {
    this.renderer_ = t;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(t) {
    this.hitDetectionRenderer_ = t;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(t) {
    this.image_ = t;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(t) {
    typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(e) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e.get(t)
      );
    } : t ? t !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t
      );
    }) : this.geometryFunction_ = Jc, this.geometry_ = t;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(t) {
    this.zIndex_ = t;
  }
}
function p0(n) {
  let t;
  if (typeof n == "function")
    t = n;
  else {
    let e;
    Array.isArray(n) ? e = n : (Se(
      typeof /** @type {?} */
      n.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), e = [
      /** @type {Style} */
      n
    ]), t = function() {
      return e;
    };
  }
  return t;
}
let Ru = null;
function v0(n, t) {
  if (!Ru) {
    const e = new lr({
      color: "rgba(255,255,255,0.4)"
    }), i = new rs({
      color: "#3399CC",
      width: 1.25
    });
    Ru = [
      new Ti({
        image: new Za({
          fill: e,
          stroke: i,
          radius: 5
        }),
        fill: e,
        stroke: i
      })
    ];
  }
  return Ru;
}
function Jc(n) {
  return n.getGeometry();
}
function Qc(n, t, e, i) {
  return e !== void 0 && i !== void 0 ? [e / n, i / t] : e !== void 0 ? e / n : i !== void 0 ? i / t : 1;
}
class Eo extends ja {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = t.opacity !== void 0 ? t.opacity : 1, i = t.rotation !== void 0 ? t.rotation : 0, s = t.scale !== void 0 ? t.scale : 1, u = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
    super({
      opacity: e,
      rotation: i,
      scale: s,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      rotateWithView: u,
      declutterMode: t.declutterMode
    }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
    const h = t.img !== void 0 ? t.img : null;
    let c = t.src;
    Se(
      !(c !== void 0 && h),
      "`image` and `src` cannot be provided at the same time"
    ), (c === void 0 || c.length === 0) && h && (c = /** @type {HTMLImageElement} */
    h.src || de(h)), Se(
      c !== void 0 && c.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), Se(
      !((t.width !== void 0 || t.height !== void 0) && t.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let g;
    if (t.src !== void 0 ? g = wt.IDLE : h !== void 0 && (h instanceof HTMLImageElement ? h.complete ? g = h.src ? wt.LOADED : wt.IDLE : g = wt.LOADING : g = wt.LOADED), this.color_ = t.color !== void 0 ? eo(t.color) : null, this.iconImage_ = mh(
      h,
      /** @type {string} */
      c,
      this.crossOrigin_,
      g,
      this.color_
    ), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null, t.width !== void 0 || t.height !== void 0) {
      let m, y;
      if (t.size)
        [m, y] = t.size;
      else {
        const p = this.getImage(1);
        if (p.width && p.height)
          m = p.width, y = p.height;
        else if (p instanceof HTMLImageElement) {
          this.initialOptions_ = t;
          const _ = () => {
            if (this.unlistenImageChange(_), !this.initialOptions_)
              return;
            const E = this.iconImage_.getSize();
            this.setScale(
              Qc(
                E[0],
                E[1],
                t.width,
                t.height
              )
            );
          };
          this.listenImageChange(_);
          return;
        }
      }
      m !== void 0 && this.setScale(
        Qc(m, y, t.width, t.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let t, e, i;
    return this.initialOptions_ ? (e = this.initialOptions_.width, i = this.initialOptions_.height) : (t = this.getScale(), t = Array.isArray(t) ? t.slice() : t), new Eo({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: t,
      width: e,
      height: i,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let t = this.normalizedAnchor_;
    if (!t) {
      t = this.anchor_;
      const s = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!s)
          return null;
        t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= s[0]), this.anchorYUnits_ == "fraction" && (t[1] *= s[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!s)
          return null;
        t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + s[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + s[1]);
      }
      this.normalizedAnchor_ = t;
    }
    const e = this.getDisplacement(), i = this.getScaleArray();
    return [
      t[0] - e[0] / i[0],
      t[1] + e[1] / i[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(t) {
    this.anchor_ = t, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */
  getImage(t) {
    return this.iconImage_.getImage(t);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(t) {
    return this.iconImage_.getPixelRatio(t);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let t = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const e = this.getSize(), i = this.iconImage_.getSize();
      if (!e || !i)
        return null;
      t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = i[0] - e[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = i[1] - e[1] - t[1]);
    }
    return this.origin_ = t, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const t = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * t[0];
    if (this.iconImage_.getImageState() == wt.LOADED)
      return this.iconImage_.getSize()[0] * t[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const t = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * t[1];
    if (this.iconImage_.getImageState() == wt.LOADED)
      return this.iconImage_.getSize()[1] * t[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(t) {
    delete this.initialOptions_, super.setScale(t);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    this.iconImage_.addEventListener(pn.CHANGE, t);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    this.iconImage_.removeEventListener(pn.CHANGE, t);
  }
  ready() {
    return this.iconImage_.ready();
  }
}
const _0 = "#333";
class Ha {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.scale_ = t.scale, this.scaleArray_ = Qs(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.repeat_ = t.repeat, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new lr({ color: _0 }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding, this.declutterMode_ = t.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new Ha({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(t) {
    this.overflow_ = t;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(t) {
    this.font_ = t;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(t) {
    this.maxAngle_ = t;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(t) {
    this.offsetX_ = t;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(t) {
    this.offsetY_ = t;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(t) {
    this.placement_ = t;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(t) {
    this.repeat_ = t;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = Qs(t !== void 0 ? t : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(t) {
    this.textAlign_ = t;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(t) {
    this.justify_ = t;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(t) {
    this.textBaseline_ = t;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(t) {
    this.backgroundFill_ = t;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(t) {
    this.backgroundStroke_ = t;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(t) {
    this.padding_ = t;
  }
}
let fs = 0;
const gs = 0, te = 1 << fs++, st = 1 << fs++, qe = 1 << fs++, le = 1 << fs++, ii = 1 << fs++, xe = Math.pow(2, fs) - 1, pm = {
  [te]: "boolean",
  [st]: "number",
  [qe]: "string",
  [le]: "color",
  [ii]: "number[]"
}, E0 = Object.keys(pm).map(Number).sort(er);
function Ie(n) {
  const t = [];
  for (const e of E0)
    x0(n, e) && t.push(pm[e]);
  return t.length === 0 ? "untyped" : t.length < 3 ? t.join(" or ") : t.slice(0, -1).join(", ") + ", or " + t[t.length - 1];
}
function x0(n, t) {
  return (n & t) === t;
}
function An(n, t) {
  return !!(n & t);
}
function Ka(n, t) {
  return n === t;
}
class wi {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
}
class S0 {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(t, e, ...i) {
    this.type = t, this.operator = e, this.args = i;
  }
}
function vm() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    style: {}
  };
}
function w0(n) {
  switch (n) {
    case "string":
      return qe;
    case "color":
      return le;
    case "number":
      return st;
    case "boolean":
      return te;
    case "number[]":
      return ii;
    default:
      throw new Error(`Unrecognized type hint: ${n}`);
  }
}
function At(n, t, e) {
  switch (typeof n) {
    case "boolean":
      return new wi(te, n);
    case "number":
      return new wi(st, n);
    case "string": {
      let s = qe;
      return o0(n) && (s |= le), Ka(s & e, gs) || (s &= e), new wi(s, n);
    }
  }
  if (!Array.isArray(n))
    throw new Error("Expression must be an array or a primitive value");
  if (n.length === 0)
    throw new Error("Empty expression");
  if (typeof n[0] == "string")
    return P0(n, t, e);
  for (const s of n)
    if (typeof s != "number")
      throw new Error("Expected an array of numbers");
  let i = ii;
  return (n.length === 3 || n.length === 4) && (i |= le), e && (i &= e), new wi(i, n);
}
const q = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string"
}, I0 = {
  [q.Get]: vt(
    ([n, t]) => t !== void 0 ? w0(
      /** @type {string} */
      /** @type {LiteralExpression} */
      t.value
    ) : xe,
    St(1, 2),
    k0
  ),
  [q.Var]: vt(
    ([n]) => n.type,
    St(1, 1),
    b0
  ),
  [q.Id]: vt(st | qe, Ns, C0),
  [q.Concat]: vt(
    qe,
    St(2, 1 / 0),
    Lt(xe)
  ),
  [q.GeometryType]: vt(qe, Ns, R0),
  [q.Resolution]: vt(st, Ns),
  [q.Zoom]: vt(st, Ns),
  [q.Time]: vt(st, Ns),
  [q.Any]: vt(
    te,
    St(2, 1 / 0),
    Lt(te)
  ),
  [q.All]: vt(
    te,
    St(2, 1 / 0),
    Lt(te)
  ),
  [q.Not]: vt(
    te,
    St(1, 1),
    Lt(te)
  ),
  [q.Equal]: vt(
    te,
    St(2, 2),
    Lt(xe),
    di
  ),
  [q.NotEqual]: vt(
    te,
    St(2, 2),
    Lt(xe),
    di
  ),
  [q.GreaterThan]: vt(
    te,
    St(2, 2),
    Lt(xe),
    di
  ),
  [q.GreaterThanOrEqualTo]: vt(
    te,
    St(2, 2),
    Lt(xe),
    di
  ),
  [q.LessThan]: vt(
    te,
    St(2, 2),
    Lt(xe),
    di
  ),
  [q.LessThanOrEqualTo]: vt(
    te,
    St(2, 2),
    Lt(xe),
    di
  ),
  [q.Multiply]: vt(
    (n) => {
      let t = st | le;
      for (let e = 0; e < n.length; e++)
        t &= n[e].type;
      return t;
    },
    St(2, 1 / 0),
    Lt(st | le),
    di
  ),
  [q.Coalesce]: vt(
    (n) => {
      let t = xe;
      for (let e = 1; e < n.length; e += 2)
        t &= n[e].type;
      return t &= n[n.length - 1].type, t;
    },
    St(2, 1 / 0),
    Lt(xe),
    di
  ),
  [q.Divide]: vt(
    st,
    St(2, 2),
    Lt(st)
  ),
  [q.Add]: vt(
    st,
    St(2, 1 / 0),
    Lt(st)
  ),
  [q.Subtract]: vt(
    st,
    St(2, 2),
    Lt(st)
  ),
  [q.Clamp]: vt(
    st,
    St(3, 3),
    Lt(st)
  ),
  [q.Mod]: vt(
    st,
    St(2, 2),
    Lt(st)
  ),
  [q.Pow]: vt(
    st,
    St(2, 2),
    Lt(st)
  ),
  [q.Abs]: vt(
    st,
    St(1, 1),
    Lt(st)
  ),
  [q.Floor]: vt(
    st,
    St(1, 1),
    Lt(st)
  ),
  [q.Ceil]: vt(
    st,
    St(1, 1),
    Lt(st)
  ),
  [q.Round]: vt(
    st,
    St(1, 1),
    Lt(st)
  ),
  [q.Sin]: vt(
    st,
    St(1, 1),
    Lt(st)
  ),
  [q.Cos]: vt(
    st,
    St(1, 1),
    Lt(st)
  ),
  [q.Atan]: vt(
    st,
    St(1, 2),
    Lt(st)
  ),
  [q.Sqrt]: vt(
    st,
    St(1, 1),
    Lt(st)
  ),
  [q.Match]: vt(
    (n) => {
      let t = xe;
      for (let e = 2; e < n.length; e += 2)
        t &= n[e].type;
      return t &= n[n.length - 1].type, t;
    },
    St(4, 1 / 0),
    tf,
    T0
  ),
  [q.Between]: vt(
    te,
    St(3, 3),
    Lt(st)
  ),
  [q.Interpolate]: vt(
    (n) => {
      let t = le | st;
      for (let e = 3; e < n.length; e += 2)
        t &= n[e].type;
      return t;
    },
    St(6, 1 / 0),
    tf,
    N0
  ),
  [q.Case]: vt(
    (n) => {
      let t = xe;
      for (let e = 1; e < n.length; e += 2)
        t &= n[e].type;
      return t &= n[n.length - 1].type, t;
    },
    St(3, 1 / 0),
    L0,
    M0
  ),
  [q.In]: vt(te, St(2, 2), O0),
  [q.Number]: vt(
    st,
    St(1, 1 / 0),
    Lt(xe)
  ),
  [q.String]: vt(
    qe,
    St(1, 1 / 0),
    Lt(xe)
  ),
  [q.Array]: vt(
    (n) => n.length === 3 || n.length === 4 ? ii | le : ii,
    St(1, 1 / 0),
    Lt(st)
  ),
  [q.Color]: vt(
    le,
    St(1, 4),
    Lt(st)
  ),
  [q.Band]: vt(
    st,
    St(1, 3),
    Lt(st)
  ),
  [q.Palette]: vt(le, St(2, 2), A0),
  [q.ToString]: vt(
    qe,
    St(1, 1),
    Lt(te | st | qe | le)
  )
};
function k0(n, t) {
  const e = At(n[1], t);
  if (!(e instanceof wi))
    throw new Error("Expected a literal argument for get operation");
  if (typeof e.value != "string")
    throw new Error("Expected a string argument for get operation");
  if (t.properties.add(e.value), n.length === 3) {
    const i = At(n[2], t);
    return [e, i];
  }
  return [e];
}
function b0(n, t, e, i) {
  const s = n[1];
  if (typeof s != "string")
    throw new Error("Expected a string argument for var operation");
  if (t.variables.add(s), !("variables" in t.style) || t.style.variables[s] === void 0)
    return [new wi(xe, s)];
  const u = t.style.variables[s], h = (
    /** @type {LiteralExpression} */
    At(u, t)
  );
  if (h.value = s, i && !An(i, h.type))
    throw new Error(
      `The variable ${s} has type ${Ie(
        h.type
      )} but the following type was expected: ${Ie(i)}`
    );
  return [h];
}
function C0(n, t) {
  t.featureId = !0;
}
function R0(n, t) {
  t.geometryType = !0;
}
function Ns(n, t) {
  const e = n[0];
  if (n.length !== 1)
    throw new Error(`Expected no arguments for ${e} operation`);
  return [];
}
function St(n, t) {
  return function(e, i) {
    const s = e[0], u = e.length - 1;
    if (n === t) {
      if (u !== n) {
        const h = n === 1 ? "" : "s";
        throw new Error(
          `Expected ${n} argument${h} for ${s}, got ${u}`
        );
      }
    } else if (u < n || u > t) {
      const h = t === 1 / 0 ? `${n} or more` : `${n} to ${t}`;
      throw new Error(
        `Expected ${h} arguments for ${s}, got ${u}`
      );
    }
  };
}
function Lt(n) {
  return function(t, e) {
    const i = t[0], s = t.length - 1, u = new Array(s);
    for (let h = 0; h < s; ++h) {
      const c = At(t[h + 1], e);
      if (!An(n, c.type)) {
        const g = Ie(n), m = Ie(c.type);
        throw new Error(
          `Unexpected type for argument ${h} of ${i} operation, got ${g} but expected ${m}`
        );
      }
      c.type &= n, u[h] = c;
    }
    return u;
  };
}
function di(n, t, e) {
  const i = n[0], s = n.length - 1;
  let u = xe;
  for (let c = 0; c < e.length; ++c)
    u &= e[c].type;
  if (u === gs)
    throw new Error(
      `No common type could be found for arguments of ${i} operation`
    );
  const h = new Array(s);
  for (let c = 0; c < s; ++c)
    h[c] = At(n[c + 1], t, u);
  return h;
}
function L0(n, t) {
  const e = n[0], i = n.length - 1;
  if (i % 2 === 0)
    throw new Error(
      `An odd amount of arguments was expected for operation ${e}, got ${JSON.stringify(
        i
      )} instead`
    );
}
function tf(n, t) {
  const e = n[0], i = n.length - 1;
  if (i % 2 === 1)
    throw new Error(
      `An even amount of arguments was expected for operation ${e}, got ${JSON.stringify(
        i
      )} instead`
    );
}
function T0(n, t, e, i) {
  const s = n.length - 1;
  let h = At(n[1], t).type;
  const c = At(n[n.length - 1], t);
  let g = i !== void 0 ? i & c.type : c.type;
  const m = new Array(s - 2);
  for (let p = 0; p < s - 2; p += 2) {
    const _ = At(n[p + 2], t), E = At(n[p + 3], t);
    h &= _.type, g &= E.type, m[p] = _, m[p + 1] = E;
  }
  const y = qe | st | te;
  if (!An(y, h))
    throw new Error(
      `Expected an input of type ${Ie(
        y
      )} for the interpolate operation, got ${Ie(h)} instead`
    );
  if (Ka(g, gs))
    throw new Error(
      "Could not find a common output type for the following match operation: " + JSON.stringify(n)
    );
  for (let p = 0; p < s - 2; p += 2) {
    const _ = At(n[p + 2], t, h), E = At(n[p + 3], t, g);
    m[p] = _, m[p + 1] = E;
  }
  return [
    At(n[1], t, h),
    ...m,
    At(n[n.length - 1], t, g)
  ];
}
function N0(n, t, e, i) {
  const s = n[1];
  let u;
  switch (s[0]) {
    case "linear":
      u = 1;
      break;
    case "exponential":
      if (u = s[1], typeof u != "number")
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(u)} instead`
        );
      break;
    default:
      u = null;
  }
  if (!u)
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(s)}`
    );
  u = At(u, t);
  let h = At(n[2], t);
  if (!An(st, h.type))
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${Ie(h.type)} instead`
    );
  h = At(n[2], t, st);
  const c = new Array(n.length - 3);
  for (let g = 0; g < c.length; g += 2) {
    let m = At(n[g + 3], t);
    if (!An(st, m.type))
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${Ie(m.type)} at position ${g + 2} instead`
      );
    let y = At(n[g + 4], t);
    if (!An(st | le, y.type))
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${Ie(y.type)} at position ${g + 3} instead`
      );
    m = At(n[g + 3], t, st), y = At(n[g + 4], t, st | le), c[g] = m, c[g + 1] = y;
  }
  return [u, h, ...c];
}
function M0(n, t, e, i) {
  const s = At(n[n.length - 1], t);
  let u = i !== void 0 ? i & s.type : s.type;
  const h = new Array(n.length - 1);
  for (let c = 0; c < h.length - 1; c += 2) {
    const g = At(n[c + 1], t), m = At(n[c + 2], t);
    if (!An(te, g.type))
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${Ie(g.type)} at position ${c} instead`
      );
    u &= m.type, h[c] = g, h[c + 1] = m;
  }
  if (Ka(u, gs))
    throw new Error(
      "Could not find a common output type for the following case operation: " + JSON.stringify(n)
    );
  for (let c = 0; c < h.length - 1; c += 2)
    h[c + 1] = At(n[c + 2], t, u);
  return h[h.length - 1] = At(
    n[n.length - 1],
    t,
    u
  ), h;
}
function O0(n, t) {
  let e = (
    /** @type {any} */
    n[2]
  );
  if (!Array.isArray(e))
    throw new Error(
      'The "in" operator was provided a literal value which was not an array as second argument.'
    );
  if (typeof e[0] == "string") {
    if (e[0] !== "literal")
      throw new Error(
        'For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.'
      );
    if (!Array.isArray(e[1]))
      throw new Error(
        'The "in" operator was provided a literal value which was not an array as second argument.'
      );
    e = e[1];
  }
  let i = qe | st;
  const s = new Array(e.length);
  for (let h = 0; h < s.length; h++) {
    const c = At(e[h], t);
    i &= c.type, s[h] = c;
  }
  if (Ka(i, gs))
    throw new Error(
      "Could not find a common type for the following in operation: " + JSON.stringify(n)
    );
  return [At(n[1], t, i), ...s];
}
function A0(n, t) {
  const e = At(n[1], t, st);
  if (e.type !== st)
    throw new Error(
      `The first argument of palette must be an number, got ${Ie(
        e.type
      )} instead`
    );
  const i = n[2];
  if (!Array.isArray(i))
    throw new Error("The second argument of palette must be an array");
  const s = new Array(i.length);
  for (let u = 0; u < s.length; u++) {
    const h = At(i[u], t, le);
    if (!(h instanceof wi))
      throw new Error(
        `The palette color at index ${u} must be a literal value`
      );
    if (!An(h.type, le))
      throw new Error(
        `The palette color at index ${u} should be of type color, got ${Ie(
          h.type
        )} instead`
      );
    s[u] = h;
  }
  return [e, ...s];
}
function vt(n, ...t) {
  return function(e, i, s) {
    const u = e[0];
    let h = [];
    for (let g = 0; g < t.length; g++)
      h = t[g](e, i, h, s) || h;
    let c = typeof n == "function" ? n(h) : n;
    if (s !== void 0) {
      if (!An(c, s))
        throw new Error(
          `The following expression was expected to return ${Ie(
            s
          )}, but returns ${Ie(c)} instead: ${JSON.stringify(
            e
          )}`
        );
      c &= s;
    }
    if (c === gs)
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          e
        )}`
      );
    return new S0(c, u, ...h);
  };
}
function P0(n, t, e) {
  const i = n[0], s = I0[i];
  if (!s)
    throw new Error(`Unknown operator: ${i}`);
  return s(n, t, e);
}
function _m(n) {
  if (!n)
    return "";
  const t = n.getType();
  switch (t) {
    case "Point":
    case "LineString":
    case "Polygon":
      return t;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        t.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return _m(
        /** @type {import("../geom/GeometryCollection.js").default} */
        n.getGeometries()[0]
      );
    default:
      return "";
  }
}
function Em() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function ai(n, t, e) {
  const i = At(n, e);
  if (!An(t, i.type)) {
    const s = Ie(t), u = Ie(i.type);
    throw new Error(
      `Expected expression to be of type ${s}, got ${u}`
    );
  }
  return _n(i);
}
function _n(n, t) {
  if (n instanceof wi) {
    if (n.type === le && typeof n.value == "string") {
      const i = gh(n.value);
      return function() {
        return i;
      };
    }
    return function() {
      return n.value;
    };
  }
  const e = n.operator;
  switch (e) {
    case q.Number:
    case q.String:
    case q.Coalesce:
      return D0(n);
    case q.Get:
    case q.Var:
      return F0(n);
    case q.Id:
      return (i) => i.featureId;
    case q.GeometryType:
      return (i) => i.geometryType;
    case q.Concat: {
      const i = n.args.map((s) => _n(s));
      return (s) => "".concat(...i.map((u) => u(s).toString()));
    }
    case q.Resolution:
      return (i) => i.resolution;
    case q.Any:
    case q.All:
    case q.Between:
    case q.In:
    case q.Not:
      return B0(n);
    case q.Equal:
    case q.NotEqual:
    case q.LessThan:
    case q.LessThanOrEqualTo:
    case q.GreaterThan:
    case q.GreaterThanOrEqualTo:
      return G0(n);
    case q.Multiply:
    case q.Divide:
    case q.Add:
    case q.Subtract:
    case q.Clamp:
    case q.Mod:
    case q.Pow:
    case q.Abs:
    case q.Floor:
    case q.Ceil:
    case q.Round:
    case q.Sin:
    case q.Cos:
    case q.Atan:
    case q.Sqrt:
      return z0(n);
    case q.Case:
      return Y0(n);
    case q.Match:
      return W0(n);
    case q.Interpolate:
      return X0(n);
    case q.ToString:
      return q0(n);
    default:
      throw new Error(`Unsupported operator ${e}`);
  }
}
function D0(n, t) {
  const e = n.operator, i = n.args.length, s = new Array(i);
  for (let u = 0; u < i; ++u)
    s[u] = _n(n.args[u]);
  switch (e) {
    case q.Coalesce:
      return (u) => {
        for (let h = 0; h < i; ++h) {
          const c = s[h](u);
          if (typeof c < "u" && c !== null)
            return c;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case q.Number:
    case q.String:
      return (u) => {
        for (let h = 0; h < i; ++h) {
          const c = s[h](u);
          if (typeof c === e)
            return c;
        }
        throw new Error(`Expected one of the values to be a ${e}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${e}`);
  }
}
function F0(n, t) {
  const i = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    n.args[0].value
  );
  switch (n.operator) {
    case q.Get:
      return (s) => s.properties[i];
    case q.Var:
      return (s) => s.variables[i];
    default:
      throw new Error(`Unsupported accessor operator ${n.operator}`);
  }
}
function G0(n, t) {
  const e = n.operator, i = _n(n.args[0]), s = _n(n.args[1]);
  switch (e) {
    case q.Equal:
      return (u) => i(u) === s(u);
    case q.NotEqual:
      return (u) => i(u) !== s(u);
    case q.LessThan:
      return (u) => i(u) < s(u);
    case q.LessThanOrEqualTo:
      return (u) => i(u) <= s(u);
    case q.GreaterThan:
      return (u) => i(u) > s(u);
    case q.GreaterThanOrEqualTo:
      return (u) => i(u) >= s(u);
    default:
      throw new Error(`Unsupported comparison operator ${e}`);
  }
}
function B0(n, t) {
  const e = n.operator, i = n.args.length, s = new Array(i);
  for (let u = 0; u < i; ++u)
    s[u] = _n(n.args[u]);
  switch (e) {
    case q.Any:
      return (u) => {
        for (let h = 0; h < i; ++h)
          if (s[h](u))
            return !0;
        return !1;
      };
    case q.All:
      return (u) => {
        for (let h = 0; h < i; ++h)
          if (!s[h](u))
            return !1;
        return !0;
      };
    case q.Between:
      return (u) => {
        const h = s[0](u), c = s[1](u), g = s[2](u);
        return h >= c && h <= g;
      };
    case q.In:
      return (u) => {
        const h = s[0](u);
        for (let c = 1; c < i; ++c)
          if (h === s[c](u))
            return !0;
        return !1;
      };
    case q.Not:
      return (u) => !s[0](u);
    default:
      throw new Error(`Unsupported logical operator ${e}`);
  }
}
function z0(n, t) {
  const e = n.operator, i = n.args.length, s = new Array(i);
  for (let u = 0; u < i; ++u)
    s[u] = _n(n.args[u]);
  switch (e) {
    case q.Multiply:
      return (u) => {
        let h = 1;
        for (let c = 0; c < i; ++c)
          h *= s[c](u);
        return h;
      };
    case q.Divide:
      return (u) => s[0](u) / s[1](u);
    case q.Add:
      return (u) => {
        let h = 0;
        for (let c = 0; c < i; ++c)
          h += s[c](u);
        return h;
      };
    case q.Subtract:
      return (u) => s[0](u) - s[1](u);
    case q.Clamp:
      return (u) => {
        const h = s[0](u), c = s[1](u);
        if (h < c)
          return c;
        const g = s[2](u);
        return h > g ? g : h;
      };
    case q.Mod:
      return (u) => s[0](u) % s[1](u);
    case q.Pow:
      return (u) => Math.pow(s[0](u), s[1](u));
    case q.Abs:
      return (u) => Math.abs(s[0](u));
    case q.Floor:
      return (u) => Math.floor(s[0](u));
    case q.Ceil:
      return (u) => Math.ceil(s[0](u));
    case q.Round:
      return (u) => Math.round(s[0](u));
    case q.Sin:
      return (u) => Math.sin(s[0](u));
    case q.Cos:
      return (u) => Math.cos(s[0](u));
    case q.Atan:
      return i === 2 ? (u) => Math.atan2(s[0](u), s[1](u)) : (u) => Math.atan(s[0](u));
    case q.Sqrt:
      return (u) => Math.sqrt(s[0](u));
    default:
      throw new Error(`Unsupported numeric operator ${e}`);
  }
}
function Y0(n, t) {
  const e = n.args.length, i = new Array(e);
  for (let s = 0; s < e; ++s)
    i[s] = _n(n.args[s]);
  return (s) => {
    for (let u = 0; u < e - 1; u += 2)
      if (i[u](s))
        return i[u + 1](s);
    return i[e - 1](s);
  };
}
function W0(n, t) {
  const e = n.args.length, i = new Array(e);
  for (let s = 0; s < e; ++s)
    i[s] = _n(n.args[s]);
  return (s) => {
    const u = i[0](s);
    for (let h = 1; h < e; h += 2)
      if (u === i[h](s))
        return i[h + 1](s);
    return i[e - 1](s);
  };
}
function X0(n, t) {
  const e = n.args.length, i = new Array(e);
  for (let s = 0; s < e; ++s)
    i[s] = _n(n.args[s]);
  return (s) => {
    const u = i[0](s), h = i[1](s);
    let c, g;
    for (let m = 2; m < e; m += 2) {
      const y = i[m](s);
      let p = i[m + 1](s);
      const _ = Array.isArray(p);
      if (_ && (p = r0(p)), y >= h)
        return m === 2 ? p : _ ? U0(
          u,
          h,
          c,
          g,
          y,
          p
        ) : Ys(
          u,
          h,
          c,
          g,
          y,
          p
        );
      c = y, g = p;
    }
    return g;
  };
}
function q0(n, t) {
  const e = n.operator, i = n.args.length, s = new Array(i);
  for (let u = 0; u < i; ++u)
    s[u] = _n(n.args[u]);
  switch (e) {
    case q.ToString:
      return (u) => {
        const h = s[0](u);
        return n.args[0].type === le ? dh(h) : h.toString();
      };
    default:
      throw new Error(`Unsupported convert operator ${e}`);
  }
}
function Ys(n, t, e, i, s, u) {
  const h = s - e;
  if (h === 0)
    return i;
  const c = t - e, g = n === 1 ? c / h : (Math.pow(n, c) - 1) / (Math.pow(n, h) - 1);
  return i + g * (u - i);
}
function U0(n, t, e, i, s, u) {
  if (s - e === 0)
    return i;
  const c = Kc(i), g = Kc(u);
  let m = g[2] - c[2];
  m > 180 ? m -= 360 : m < -180 && (m += 360);
  const y = [
    Ys(n, t, e, c[0], s, g[0]),
    Ys(n, t, e, c[1], s, g[1]),
    c[2] + Ys(n, t, e, 0, s, m),
    Ys(n, t, e, i[3], s, u[3])
  ];
  return dm(s0(y));
}
function j0(n) {
  return !0;
}
function V0(n) {
  const t = vm(), e = Z0(n, t), i = Em();
  return function(s, u) {
    if (i.properties = s.getPropertiesInternal(), i.resolution = u, t.featureId) {
      const h = s.getId();
      h !== void 0 ? i.featureId = h : i.featureId = null;
    }
    return t.geometryType && (i.geometryType = _m(
      s.getGeometry()
    )), e(i);
  };
}
function ef(n) {
  const t = vm(), e = n.length, i = new Array(e);
  for (let h = 0; h < e; ++h)
    i[h] = fl(n[h], t);
  const s = Em(), u = new Array(e);
  return function(h, c) {
    if (s.properties = h.getPropertiesInternal(), s.resolution = c, t.featureId) {
      const m = h.getId();
      m !== void 0 ? s.featureId = m : s.featureId = null;
    }
    let g = 0;
    for (let m = 0; m < e; ++m) {
      const y = i[m](s);
      y && (u[g] = y, g += 1);
    }
    return u.length = g, u;
  };
}
function Z0(n, t) {
  const e = n.length, i = new Array(e);
  for (let s = 0; s < e; ++s) {
    const u = n[s], h = "filter" in u ? ai(u.filter, te, t) : j0;
    let c;
    if (Array.isArray(u.style)) {
      const g = u.style.length;
      c = new Array(g);
      for (let m = 0; m < g; ++m)
        c[m] = fl(u.style[m], t);
    } else
      c = [fl(u.style, t)];
    i[s] = { filter: h, styles: c };
  }
  return function(s) {
    const u = [];
    let h = !1;
    for (let c = 0; c < e; ++c) {
      const g = i[c].filter;
      if (g(s) && !(n[c].else && h)) {
        h = !0;
        for (const m of i[c].styles) {
          const y = m(s);
          y && u.push(y);
        }
      }
    }
    return u;
  };
}
function fl(n, t) {
  const e = oo(n, "", t), i = ao(n, "", t), s = H0(n, t), u = K0(n, t), h = Ae(n, "z-index", t);
  if (!e && !i && !s && !u && !es(n))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(n)
    );
  const c = new Ti();
  return function(g) {
    let m = !0;
    if (e) {
      const y = e(g);
      y && (m = !1), c.setFill(y);
    }
    if (i) {
      const y = i(g);
      y && (m = !1), c.setStroke(y);
    }
    if (s) {
      const y = s(g);
      y && (m = !1), c.setText(y);
    }
    if (u) {
      const y = u(g);
      y && (m = !1), c.setImage(y);
    }
    return h && c.setZIndex(h(g)), m ? null : c;
  };
}
function oo(n, t, e) {
  let i;
  if (t + "fill-pattern-src" in n ? i = t1(n, t + "fill-", e) : i = yh(
    n,
    t + "fill-color",
    e
  ), !i)
    return null;
  const s = new lr();
  return function(u) {
    const h = i(u);
    return h === "none" ? null : (s.setColor(h), s);
  };
}
function ao(n, t, e) {
  const i = Ae(
    n,
    t + "stroke-width",
    e
  ), s = yh(
    n,
    t + "stroke-color",
    e
  );
  if (!i && !s)
    return null;
  const u = Zn(
    n,
    t + "stroke-line-cap",
    e
  ), h = Zn(
    n,
    t + "stroke-line-join",
    e
  ), c = xm(
    n,
    t + "stroke-line-dash",
    e
  ), g = Ae(
    n,
    t + "stroke-line-dash-offset",
    e
  ), m = Ae(
    n,
    t + "stroke-miter-limit",
    e
  ), y = new rs();
  return function(p) {
    if (s) {
      const _ = s(p);
      if (_ === "none")
        return null;
      y.setColor(_);
    }
    if (i && y.setWidth(i(p)), u) {
      const _ = u(p);
      if (_ !== "butt" && _ !== "round" && _ !== "square")
        throw new Error("Expected butt, round, or square line cap");
      y.setLineCap(_);
    }
    if (h) {
      const _ = h(p);
      if (_ !== "bevel" && _ !== "round" && _ !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      y.setLineJoin(_);
    }
    return c && y.setLineDash(c(p)), g && y.setLineDashOffset(g(p)), m && y.setMiterLimit(m(p)), y;
  };
}
function H0(n, t) {
  const e = "text-", i = Zn(n, e + "value", t);
  if (!i)
    return null;
  const s = oo(n, e, t), u = oo(
    n,
    e + "background-",
    t
  ), h = ao(n, e, t), c = ao(
    n,
    e + "background-",
    t
  ), g = Zn(n, e + "font", t), m = Ae(
    n,
    e + "max-angle",
    t
  ), y = Ae(
    n,
    e + "offset-x",
    t
  ), p = Ae(
    n,
    e + "offset-y",
    t
  ), _ = uo(
    n,
    e + "overflow",
    t
  ), E = Zn(
    n,
    e + "placement",
    t
  ), S = Ae(n, e + "repeat", t), I = $a(n, e + "scale", t), b = uo(
    n,
    e + "rotate-with-view",
    t
  ), C = Ae(
    n,
    e + "rotation",
    t
  ), R = Zn(n, e + "align", t), T = Zn(
    n,
    e + "justify",
    t
  ), O = Zn(
    n,
    e + "baseline",
    t
  ), M = xm(
    n,
    e + "padding",
    t
  ), G = Ja(
    n,
    e + "declutter-mode"
  ), D = new Ha({ declutterMode: G });
  return function(F) {
    if (D.setText(i(F)), s && D.setFill(s(F)), u && D.setBackgroundFill(u(F)), h && D.setStroke(h(F)), c && D.setBackgroundStroke(c(F)), g && D.setFont(g(F)), m && D.setMaxAngle(m(F)), y && D.setOffsetX(y(F)), p && D.setOffsetY(p(F)), _ && D.setOverflow(_(F)), E) {
      const A = E(F);
      if (A !== "point" && A !== "line")
        throw new Error("Expected point or line for text-placement");
      D.setPlacement(A);
    }
    if (S && D.setRepeat(S(F)), I && D.setScale(I(F)), b && D.setRotateWithView(b(F)), C && D.setRotation(C(F)), R) {
      const A = R(F);
      if (A !== "left" && A !== "center" && A !== "right" && A !== "end" && A !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      D.setTextAlign(A);
    }
    if (T) {
      const A = T(F);
      if (A !== "left" && A !== "right" && A !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      D.setJustify(A);
    }
    if (O) {
      const A = O(F);
      if (A !== "bottom" && A !== "top" && A !== "middle" && A !== "alphabetic" && A !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      D.setTextBaseline(A);
    }
    return M && D.setPadding(M(F)), D;
  };
}
function K0(n, t) {
  return "icon-src" in n ? $0(n, t) : "shape-points" in n ? J0(n, t) : "circle-radius" in n ? Q0(n, t) : null;
}
function $0(n, t) {
  const e = "icon-", i = e + "src", s = Sm(n[i], i), u = da(
    n,
    e + "anchor",
    t
  ), h = $a(n, e + "scale", t), c = Ae(
    n,
    e + "opacity",
    t
  ), g = da(
    n,
    e + "displacement",
    t
  ), m = Ae(
    n,
    e + "rotation",
    t
  ), y = uo(
    n,
    e + "rotate-with-view",
    t
  ), p = rf(n, e + "anchor-origin"), _ = sf(
    n,
    e + "anchor-x-units"
  ), E = sf(
    n,
    e + "anchor-y-units"
  ), S = r1(n, e + "color"), I = n1(n, e + "cross-origin"), b = i1(n, e + "offset"), C = rf(n, e + "offset-origin"), R = ma(n, e + "width"), T = ma(n, e + "height"), O = e1(n, e + "size"), M = Ja(
    n,
    e + "declutter-mode"
  ), G = new Eo({
    src: s,
    anchorOrigin: p,
    anchorXUnits: _,
    anchorYUnits: E,
    color: S,
    crossOrigin: I,
    offset: b,
    offsetOrigin: C,
    height: T,
    width: R,
    size: O,
    declutterMode: M
  });
  return function(D) {
    return c && G.setOpacity(c(D)), g && G.setDisplacement(g(D)), m && G.setRotation(m(D)), y && G.setRotateWithView(y(D)), h && G.setScale(h(D)), u && G.setAnchor(u(D)), G;
  };
}
function J0(n, t) {
  const e = "shape-", i = e + "points", s = e + "radius", u = gl(n[i], i), h = gl(n[s], s), c = oo(n, e, t), g = ao(n, e, t), m = $a(n, e + "scale", t), y = da(
    n,
    e + "displacement",
    t
  ), p = Ae(
    n,
    e + "rotation",
    t
  ), _ = uo(
    n,
    e + "rotate-with-view",
    t
  ), E = ma(n, e + "radius2"), S = ma(n, e + "angle"), I = Ja(
    n,
    e + "declutter-mode"
  ), b = new Va({
    points: u,
    radius: h,
    radius2: E,
    angle: S,
    declutterMode: I
  });
  return function(C) {
    return c && b.setFill(c(C)), g && b.setStroke(g(C)), y && b.setDisplacement(y(C)), p && b.setRotation(p(C)), _ && b.setRotateWithView(_(C)), m && b.setScale(m(C)), b;
  };
}
function Q0(n, t) {
  const e = "circle-", i = oo(n, e, t), s = ao(n, e, t), u = Ae(n, e + "radius", t), h = $a(n, e + "scale", t), c = da(
    n,
    e + "displacement",
    t
  ), g = Ae(
    n,
    e + "rotation",
    t
  ), m = uo(
    n,
    e + "rotate-with-view",
    t
  ), y = Ja(
    n,
    e + "declutter-mode"
  ), p = new Za({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: y
  });
  return function(_) {
    return u && p.setRadius(u(_)), i && p.setFill(i(_)), s && p.setStroke(s(_)), c && p.setDisplacement(c(_)), g && p.setRotation(g(_)), m && p.setRotateWithView(m(_)), h && p.setScale(h(_)), p;
  };
}
function Ae(n, t, e) {
  if (!(t in n))
    return;
  const i = ai(n[t], st, e);
  return function(s) {
    return gl(i(s), t);
  };
}
function Zn(n, t, e) {
  if (!(t in n))
    return null;
  const i = ai(n[t], qe, e);
  return function(s) {
    return Sm(i(s), t);
  };
}
function t1(n, t, e) {
  const i = Zn(
    n,
    t + "pattern-src",
    e
  ), s = nf(
    n,
    t + "pattern-offset",
    e
  ), u = nf(
    n,
    t + "pattern-size",
    e
  ), h = yh(
    n,
    t + "color",
    e
  );
  return function(c) {
    return {
      src: i(c),
      offset: s && s(c),
      size: u && u(c),
      color: h && h(c)
    };
  };
}
function uo(n, t, e) {
  if (!(t in n))
    return null;
  const i = ai(n[t], te, e);
  return function(s) {
    const u = i(s);
    if (typeof u != "boolean")
      throw new Error(`Expected a boolean for ${t}`);
    return u;
  };
}
function yh(n, t, e) {
  if (!(t in n))
    return null;
  const i = ai(
    n[t],
    le | qe,
    e
  );
  return function(s) {
    return wm(i(s), t);
  };
}
function xm(n, t, e) {
  if (!(t in n))
    return null;
  const i = ai(n[t], ii, e);
  return function(s) {
    return xo(i(s), t);
  };
}
function da(n, t, e) {
  if (!(t in n))
    return null;
  const i = ai(n[t], ii, e);
  return function(s) {
    const u = xo(i(s), t);
    if (u.length !== 2)
      throw new Error(`Expected two numbers for ${t}`);
    return u;
  };
}
function nf(n, t, e) {
  if (!(t in n))
    return null;
  const i = ai(n[t], ii, e);
  return function(s) {
    return Im(i(s), t);
  };
}
function $a(n, t, e) {
  if (!(t in n))
    return null;
  const i = ai(
    n[t],
    ii | st,
    e
  );
  return function(s) {
    return s1(i(s), t);
  };
}
function ma(n, t) {
  const e = n[t];
  if (e !== void 0) {
    if (typeof e != "number")
      throw new Error(`Expected a number for ${t}`);
    return e;
  }
}
function e1(n, t) {
  const e = n[t];
  if (e !== void 0) {
    if (typeof e == "number")
      return Qs(e);
    if (!Array.isArray(e))
      throw new Error(`Expected a number or size array for ${t}`);
    if (e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number")
      throw new Error(`Expected a number or size array for ${t}`);
    return e;
  }
}
function n1(n, t) {
  const e = n[t];
  if (e !== void 0) {
    if (typeof e != "string")
      throw new Error(`Expected a string for ${t}`);
    return e;
  }
}
function rf(n, t) {
  const e = n[t];
  if (e !== void 0) {
    if (e !== "bottom-left" && e !== "bottom-right" && e !== "top-left" && e !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${t}`
      );
    return e;
  }
}
function sf(n, t) {
  const e = n[t];
  if (e !== void 0) {
    if (e !== "pixels" && e !== "fraction")
      throw new Error(`Expected pixels or fraction for ${t}`);
    return e;
  }
}
function i1(n, t) {
  const e = n[t];
  if (e !== void 0)
    return xo(e, t);
}
function Ja(n, t) {
  const e = n[t];
  if (e !== void 0) {
    if (typeof e != "string")
      throw new Error(`Expected a string for ${t}`);
    if (e !== "declutter" && e !== "obstacle" && e !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${t}`);
    return e;
  }
}
function r1(n, t) {
  const e = n[t];
  if (e !== void 0)
    return wm(e, t);
}
function xo(n, t) {
  if (!Array.isArray(n))
    throw new Error(`Expected an array for ${t}`);
  const e = n.length;
  for (let i = 0; i < e; ++i)
    if (typeof n[i] != "number")
      throw new Error(`Expected an array of numbers for ${t}`);
  return n;
}
function Sm(n, t) {
  if (typeof n != "string")
    throw new Error(`Expected a string for ${t}`);
  return n;
}
function gl(n, t) {
  if (typeof n != "number")
    throw new Error(`Expected a number for ${t}`);
  return n;
}
function wm(n, t) {
  if (typeof n == "string")
    return n;
  const e = xo(n, t), i = e.length;
  if (i < 3 || i > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${t}`);
  return e;
}
function Im(n, t) {
  const e = xo(n, t);
  if (e.length !== 2)
    throw new Error(`Expected an array of two numbers for ${t}`);
  return e;
}
function s1(n, t) {
  return typeof n == "number" ? n : Im(n, t);
}
const of = {
  RENDER_ORDER: "renderOrder"
};
class o1 extends U_ {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = Object.assign({}, t);
    delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, super(e), this.declutter_ = t.declutter ? String(t.declutter) : void 0, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : !1, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(t) {
    return super.getFeatures(t);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(of.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(t, e) {
    const i = this.getDeclutter();
    i in t.declutter || (t.declutter[i] = new fm(9)), this.getRenderer().renderDeclutter(t, e);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(t) {
    this.set(of.RENDER_ORDER, t);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(t) {
    this.style_ = a1(t), this.styleFunction_ = t === null ? void 0 : p0(this.style_), this.changed();
  }
}
function a1(n) {
  if (n === void 0)
    return v0;
  if (!n)
    return null;
  if (typeof n == "function" || n instanceof Ti)
    return n;
  if (!Array.isArray(n))
    return ef([n]);
  if (n.length === 0)
    return [];
  const t = n.length, e = n[0];
  if (e instanceof Ti) {
    const s = new Array(t);
    for (let u = 0; u < t; ++u) {
      const h = n[u];
      if (!(h instanceof Ti))
        throw new Error("Expected a list of style instances");
      s[u] = h;
    }
    return s;
  }
  if ("style" in e) {
    const s = new Array(t);
    for (let u = 0; u < t; ++u) {
      const h = n[u];
      if (!("style" in h))
        throw new Error("Expected a list of rules with a style property");
      s[u] = h;
    }
    return V0(s);
  }
  return ef(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    n
  );
}
class u1 extends je {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(t, e, i, s) {
    super(t), this.inversePixelTransform = e, this.frameState = i, this.context = s;
  }
}
function $t() {
}
function l1(n, t) {
  for (const e in t) n[e] = t[e];
  return (
    /** @type {T & S} */
    n
  );
}
function km(n) {
  return n();
}
function af() {
  return /* @__PURE__ */ Object.create(null);
}
function ui(n) {
  n.forEach(km);
}
function bm(n) {
  return typeof n == "function";
}
function yr(n, t) {
  return n != n ? t == t : n !== t || n && typeof n == "object" || typeof n == "function";
}
let Bo;
function ke(n, t) {
  return n === t ? !0 : (Bo || (Bo = document.createElement("a")), Bo.href = t, n === Bo.href);
}
function h1(n) {
  return Object.keys(n).length === 0;
}
function c1(n, t, e, i) {
  if (n) {
    const s = Cm(n, t, e, i);
    return n[0](s);
  }
}
function Cm(n, t, e, i) {
  return n[1] && i ? l1(e.ctx.slice(), n[1](i(t))) : e.ctx;
}
function f1(n, t, e, i) {
  if (n[2] && i) {
    const s = n[2](i(e));
    if (t.dirty === void 0)
      return s;
    if (typeof s == "object") {
      const u = [], h = Math.max(t.dirty.length, s.length);
      for (let c = 0; c < h; c += 1)
        u[c] = t.dirty[c] | s[c];
      return u;
    }
    return t.dirty | s;
  }
  return t.dirty;
}
function g1(n, t, e, i, s, u) {
  if (s) {
    const h = Cm(t, e, i, u);
    n.p(h, s);
  }
}
function d1(n) {
  if (n.ctx.length > 32) {
    const t = [], e = n.ctx.length / 32;
    for (let i = 0; i < e; i++)
      t[i] = -1;
    return t;
  }
  return -1;
}
function uf(n) {
  return n ?? "";
}
function Rt(n, t) {
  n.appendChild(t);
}
function Jt(n, t, e) {
  n.insertBefore(t, e || null);
}
function Vt(n) {
  n.parentNode && n.parentNode.removeChild(n);
}
function Yt(n) {
  return document.createElement(n);
}
function ti(n) {
  return document.createElementNS("http://www.w3.org/2000/svg", n);
}
function Ai(n) {
  return document.createTextNode(n);
}
function We() {
  return Ai(" ");
}
function m1() {
  return Ai("");
}
function Le(n, t, e, i) {
  return n.addEventListener(t, e, i), () => n.removeEventListener(t, e, i);
}
function y1(n) {
  return function(t) {
    return t.preventDefault(), n.call(this, t);
  };
}
function V(n, t, e) {
  e == null ? n.removeAttribute(t) : n.getAttribute(t) !== e && n.setAttribute(t, e);
}
function p1(n) {
  return Array.from(n.childNodes);
}
function lo(n, t) {
  t = "" + t, n.data !== t && (n.data = /** @type {string} */
  t);
}
function lf(n, t) {
  n.value = t ?? "";
}
function Ii(n, t, e) {
  n.classList.toggle(t, !!e);
}
function v1(n, t, { bubbles: e = !1, cancelable: i = !1 } = {}) {
  return new CustomEvent(n, { detail: t, bubbles: e, cancelable: i });
}
let ho;
function Us(n) {
  ho = n;
}
function Rm() {
  if (!ho) throw new Error("Function called outside component initialization");
  return ho;
}
function _1(n) {
  Rm().$$.on_destroy.push(n);
}
function E1() {
  const n = Rm();
  return (t, e, { cancelable: i = !1 } = {}) => {
    const s = n.$$.callbacks[t];
    if (s) {
      const u = v1(
        /** @type {string} */
        t,
        e,
        { cancelable: i }
      );
      return s.slice().forEach((h) => {
        h.call(n, u);
      }), !u.defaultPrevented;
    }
    return !0;
  };
}
function hf(n, t) {
  const e = n.$$.callbacks[t.type];
  e && e.slice().forEach((i) => i.call(this, t));
}
const qr = [], dl = [];
let Jr = [];
const cf = [], x1 = /* @__PURE__ */ Promise.resolve();
let ml = !1;
function S1() {
  ml || (ml = !0, x1.then(Lm));
}
function yl(n) {
  Jr.push(n);
}
const Lu = /* @__PURE__ */ new Set();
let Fr = 0;
function Lm() {
  if (Fr !== 0)
    return;
  const n = ho;
  do {
    try {
      for (; Fr < qr.length; ) {
        const t = qr[Fr];
        Fr++, Us(t), w1(t.$$);
      }
    } catch (t) {
      throw qr.length = 0, Fr = 0, t;
    }
    for (Us(null), qr.length = 0, Fr = 0; dl.length; ) dl.pop()();
    for (let t = 0; t < Jr.length; t += 1) {
      const e = Jr[t];
      Lu.has(e) || (Lu.add(e), e());
    }
    Jr.length = 0;
  } while (qr.length);
  for (; cf.length; )
    cf.pop()();
  ml = !1, Lu.clear(), Us(n);
}
function w1(n) {
  if (n.fragment !== null) {
    n.update(), ui(n.before_update);
    const t = n.dirty;
    n.dirty = [-1], n.fragment && n.fragment.p(n.ctx, t), n.after_update.forEach(yl);
  }
}
function I1(n) {
  const t = [], e = [];
  Jr.forEach((i) => n.indexOf(i) === -1 ? t.push(i) : e.push(i)), e.forEach((i) => i()), Jr = t;
}
const Ho = /* @__PURE__ */ new Set();
let Ji;
function Ko() {
  Ji = {
    r: 0,
    c: [],
    p: Ji
    // parent group
  };
}
function $o() {
  Ji.r || ui(Ji.c), Ji = Ji.p;
}
function ee(n, t) {
  n && n.i && (Ho.delete(n), n.i(t));
}
function ue(n, t, e, i) {
  if (n && n.o) {
    if (Ho.has(n)) return;
    Ho.add(n), Ji.c.push(() => {
      Ho.delete(n), i && (e && n.d(1), i());
    }), n.o(t);
  } else i && i();
}
function ff(n) {
  return (n == null ? void 0 : n.length) !== void 0 ? n : Array.from(n);
}
function k1(n, t) {
  ue(n, 1, 1, () => {
    t.delete(n.key);
  });
}
function b1(n, t, e, i, s, u, h, c, g, m, y, p) {
  let _ = n.length, E = u.length, S = _;
  const I = {};
  for (; S--; ) I[n[S].key] = S;
  const b = [], C = /* @__PURE__ */ new Map(), R = /* @__PURE__ */ new Map(), T = [];
  for (S = E; S--; ) {
    const D = p(s, u, S), F = e(D);
    let A = h.get(F);
    A ? T.push(() => A.p(D, t)) : (A = m(F, D), A.c()), C.set(F, b[S] = A), F in I && R.set(F, Math.abs(S - I[F]));
  }
  const O = /* @__PURE__ */ new Set(), M = /* @__PURE__ */ new Set();
  function G(D) {
    ee(D, 1), D.m(c, y), h.set(D.key, D), y = D.first, E--;
  }
  for (; _ && E; ) {
    const D = b[E - 1], F = n[_ - 1], A = D.key, j = F.key;
    D === F ? (y = D.first, _--, E--) : C.has(j) ? !h.has(A) || O.has(A) ? G(D) : M.has(j) ? _-- : R.get(A) > R.get(j) ? (M.add(A), G(D)) : (O.add(j), _--) : (g(F, h), _--);
  }
  for (; _--; ) {
    const D = n[_];
    C.has(D.key) || g(D, h);
  }
  for (; E; ) G(b[E - 1]);
  return ui(T), b;
}
function Pi(n) {
  n && n.c();
}
function ri(n, t, e) {
  const { fragment: i, after_update: s } = n.$$;
  i && i.m(t, e), yl(() => {
    const u = n.$$.on_mount.map(km).filter(bm);
    n.$$.on_destroy ? n.$$.on_destroy.push(...u) : ui(u), n.$$.on_mount = [];
  }), s.forEach(yl);
}
function si(n, t) {
  const e = n.$$;
  e.fragment !== null && (I1(e.after_update), ui(e.on_destroy), e.fragment && e.fragment.d(t), e.on_destroy = e.fragment = null, e.ctx = []);
}
function C1(n, t) {
  n.$$.dirty[0] === -1 && (qr.push(n), S1(), n.$$.dirty.fill(0)), n.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function pr(n, t, e, i, s, u, h = null, c = [-1]) {
  const g = ho;
  Us(n);
  const m = n.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: u,
    update: $t,
    not_equal: s,
    bound: af(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (g ? g.$$.context : [])),
    // everything else
    callbacks: af(),
    dirty: c,
    skip_bound: !1,
    root: t.target || g.$$.root
  };
  h && h(m.root);
  let y = !1;
  if (m.ctx = e ? e(n, t.props || {}, (p, _, ...E) => {
    const S = E.length ? E[0] : _;
    return m.ctx && s(m.ctx[p], m.ctx[p] = S) && (!m.skip_bound && m.bound[p] && m.bound[p](S), y && C1(n, p)), _;
  }) : [], m.update(), y = !0, ui(m.before_update), m.fragment = i ? i(m.ctx) : !1, t.target) {
    if (t.hydrate) {
      const p = p1(t.target);
      m.fragment && m.fragment.l(p), p.forEach(Vt);
    } else
      m.fragment && m.fragment.c();
    t.intro && ee(n.$$.fragment), ri(n, t.target, t.anchor), Lm();
  }
  Us(g);
}
class vr {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Ye(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Ye(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    si(this, 1), this.$destroy = $t;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(t, e) {
    if (!bm(e))
      return $t;
    const i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return i.push(e), () => {
      const s = i.indexOf(e);
      s !== -1 && i.splice(s, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(t) {
    this.$$set && !h1(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
const R1 = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(R1);
function L1(n) {
  let t, e;
  return {
    c() {
      t = ti("svg"), e = ti("path"), V(e, "d", "M13.12.706a.982.982 0 0 0-1.391 0L6.907 5.517 2.087.696a.982.982 0 1 0-1.391 1.39l4.821 4.821L.696 11.73a.982.982 0 1 0 1.39 1.39l4.821-4.821 4.822 4.821a.982.982 0 1 0 1.39-1.39L8.298 6.908l4.821-4.822a.988.988 0 0 0 0-1.38Z"), V(t, "viewBox", "0 0 14 14"), V(t, "width", "13"), V(t, "height", "13"), V(t, "class", "svelte-en2qvf");
    },
    m(i, s) {
      Jt(i, t, s), Rt(t, e);
    },
    p: $t,
    i: $t,
    o: $t,
    d(i) {
      i && Vt(t);
    }
  };
}
class Tm extends vr {
  constructor(t) {
    super(), pr(this, t, null, L1, yr, {});
  }
}
function T1(n) {
  let t, e;
  return {
    c() {
      t = ti("svg"), e = ti("path"), V(e, "d", "M15 0C6.705 0 0 6.705 0 15C0 23.295 6.705 30 15 30C23.295 30 30 23.295 30 15C30 6.705 23.295 0 15 0ZM22.5 20.385L20.385 22.5L15 17.115L9.615 22.5L7.5 20.385L12.885 15L7.5 9.615L9.615 7.5L15 12.885L20.385 7.5L22.5 9.615L17.115 15L22.5 20.385Z"), V(t, "viewBox", "0 0 30 30"), V(t, "fill", "none"), V(t, "xmlns", "http://www.w3.org/2000/svg"), V(t, "class", "svelte-d2loi5");
    },
    m(i, s) {
      Jt(i, t, s), Rt(t, e);
    },
    p: $t,
    i: $t,
    o: $t,
    d(i) {
      i && Vt(t);
    }
  };
}
class Nm extends vr {
  constructor(t) {
    super(), pr(this, t, null, T1, yr, {});
  }
}
function N1(n) {
  let t, e;
  return {
    c() {
      t = Yt("img"), ke(t.src, e = /*iconsBaseUrl*/
      n[3] + "area.svg") || V(t, "src", e), V(
        t,
        "alt",
        /*placeType*/
        n[6]
      ), V(t, "class", "svelte-ltkwvy");
    },
    m(i, s) {
      Jt(i, t, s);
    },
    p(i, s) {
      s & /*iconsBaseUrl*/
      8 && !ke(t.src, e = /*iconsBaseUrl*/
      i[3] + "area.svg") && V(t, "src", e), s & /*placeType*/
      64 && V(
        t,
        "alt",
        /*placeType*/
        i[6]
      );
    },
    d(i) {
      i && Vt(t);
    }
  };
}
function M1(n) {
  let t, e;
  return {
    c() {
      t = Yt("img"), ke(t.src, e = /*iconsBaseUrl*/
      n[3] + "reverse.svg") || V(t, "src", e), V(
        t,
        "alt",
        /*placeType*/
        n[6]
      ), V(t, "class", "svelte-ltkwvy");
    },
    m(i, s) {
      Jt(i, t, s);
    },
    p(i, s) {
      s & /*iconsBaseUrl*/
      8 && !ke(t.src, e = /*iconsBaseUrl*/
      i[3] + "reverse.svg") && V(t, "src", e), s & /*placeType*/
      64 && V(
        t,
        "alt",
        /*placeType*/
        i[6]
      );
    },
    d(i) {
      i && Vt(t);
    }
  };
}
function O1(n) {
  let t, e;
  return {
    c() {
      t = Yt("img"), ke(t.src, e = /*iconsBaseUrl*/
      n[3] + "poi.svg") || V(t, "src", e), V(
        t,
        "alt",
        /*placeType*/
        n[6]
      ), V(t, "class", "svelte-ltkwvy");
    },
    m(i, s) {
      Jt(i, t, s);
    },
    p(i, s) {
      s & /*iconsBaseUrl*/
      8 && !ke(t.src, e = /*iconsBaseUrl*/
      i[3] + "poi.svg") && V(t, "src", e), s & /*placeType*/
      64 && V(
        t,
        "alt",
        /*placeType*/
        i[6]
      );
    },
    d(i) {
      i && Vt(t);
    }
  };
}
function A1(n) {
  let t, e;
  return {
    c() {
      t = Yt("img"), ke(t.src, e = /*iconsBaseUrl*/
      n[3] + "postal_code.svg") || V(t, "src", e), V(
        t,
        "alt",
        /*placeType*/
        n[6]
      ), V(t, "class", "svelte-ltkwvy");
    },
    m(i, s) {
      Jt(i, t, s);
    },
    p(i, s) {
      s & /*iconsBaseUrl*/
      8 && !ke(t.src, e = /*iconsBaseUrl*/
      i[3] + "postal_code.svg") && V(t, "src", e), s & /*placeType*/
      64 && V(
        t,
        "alt",
        /*placeType*/
        i[6]
      );
    },
    d(i) {
      i && Vt(t);
    }
  };
}
function P1(n) {
  let t, e;
  return {
    c() {
      t = Yt("img"), ke(t.src, e = /*iconsBaseUrl*/
      n[3] + "street.svg") || V(t, "src", e), V(
        t,
        "alt",
        /*placeType*/
        n[6]
      ), V(t, "class", "svelte-ltkwvy");
    },
    m(i, s) {
      Jt(i, t, s);
    },
    p(i, s) {
      s & /*iconsBaseUrl*/
      8 && !ke(t.src, e = /*iconsBaseUrl*/
      i[3] + "street.svg") && V(t, "src", e), s & /*placeType*/
      64 && V(
        t,
        "alt",
        /*placeType*/
        i[6]
      );
    },
    d(i) {
      i && Vt(t);
    }
  };
}
function D1(n) {
  let t, e;
  return {
    c() {
      t = Yt("img"), ke(t.src, e = /*iconsBaseUrl*/
      n[3] + "road.svg") || V(t, "src", e), V(
        t,
        "alt",
        /*placeType*/
        n[6]
      ), V(t, "class", "svelte-ltkwvy");
    },
    m(i, s) {
      Jt(i, t, s);
    },
    p(i, s) {
      s & /*iconsBaseUrl*/
      8 && !ke(t.src, e = /*iconsBaseUrl*/
      i[3] + "road.svg") && V(t, "src", e), s & /*placeType*/
      64 && V(
        t,
        "alt",
        /*placeType*/
        i[6]
      );
    },
    d(i) {
      i && Vt(t);
    }
  };
}
function F1(n) {
  let t, e;
  return {
    c() {
      t = Yt("img"), ke(t.src, e = /*iconsBaseUrl*/
      n[3] + "housenumber.svg") || V(t, "src", e), V(
        t,
        "alt",
        /*placeType*/
        n[6]
      ), V(t, "class", "svelte-ltkwvy");
    },
    m(i, s) {
      Jt(i, t, s);
    },
    p(i, s) {
      s & /*iconsBaseUrl*/
      8 && !ke(t.src, e = /*iconsBaseUrl*/
      i[3] + "housenumber.svg") && V(t, "src", e), s & /*placeType*/
      64 && V(
        t,
        "alt",
        /*placeType*/
        i[6]
      );
    },
    d(i) {
      i && Vt(t);
    }
  };
}
function G1(n) {
  let t, e, i, s;
  return {
    c() {
      t = Yt("img"), ke(t.src, e = /*imageUrl*/
      n[5]) || V(t, "src", e), V(
        t,
        "alt",
        /*category*/
        n[4]
      ), V(t, "class", "svelte-ltkwvy");
    },
    m(u, h) {
      Jt(u, t, h), i || (s = Le(
        t,
        "error",
        /*error_handler*/
        n[14]
      ), i = !0);
    },
    p(u, h) {
      h & /*imageUrl*/
      32 && !ke(t.src, e = /*imageUrl*/
      u[5]) && V(t, "src", e), h & /*category*/
      16 && V(
        t,
        "alt",
        /*category*/
        u[4]
      );
    },
    d(u) {
      u && Vt(t), i = !1, s();
    }
  };
}
function gf(n) {
  let t, e;
  return {
    c() {
      t = Yt("span"), e = Ai(
        /*placeType*/
        n[6]
      ), V(t, "class", "secondary svelte-ltkwvy");
    },
    m(i, s) {
      Jt(i, t, s), Rt(t, e);
    },
    p(i, s) {
      s & /*placeType*/
      64 && lo(
        e,
        /*placeType*/
        i[6]
      );
    },
    d(i) {
      i && Vt(t);
    }
  };
}
function B1(n) {
  var D, F;
  let t, e, i, s, u, h, c, g, m = (
    /*isReverse*/
    (n[7] ? (
      /*feature*/
      n[0].place_name
    ) : (
      /*feature*/
      n[0].place_name.replace(/,.*/, "")
    )) + ""
  ), y, p, _ = (
    /*showPlaceType*/
    n[2] === "always" || /*showPlaceType*/
    n[2] && !/*feature*/
    n[0].address && /*feature*/
    ((D = n[0].properties) == null ? void 0 : D.kind) !== "road" && /*feature*/
    ((F = n[0].properties) == null ? void 0 : F.kind) !== "road_relation" && !/*feature*/
    n[0].id.startsWith("address.") && !/*feature*/
    n[0].id.startsWith("postal_code.") && (!/*feature*/
    n[0].id.startsWith("poi.") || !/*imageUrl*/
    n[5]) && !/*isReverse*/
    n[7]
  ), E, S, I = (
    /*isReverse*/
    (n[7] ? "" : (
      /*feature*/
      n[0].place_name.replace(/[^,]*,?\s*/, "")
    )) + ""
  ), b, C, R;
  function T(A, j) {
    var et, U;
    return j & /*feature*/
    1 && (e = null), j & /*feature*/
    1 && (i = null), j & /*feature*/
    1 && (s = null), /*imageUrl*/
    A[5] ? G1 : (
      /*feature*/
      A[0].address ? F1 : (
        /*feature*/
        ((et = A[0].properties) == null ? void 0 : et.kind) === "road" || /*feature*/
        ((U = A[0].properties) == null ? void 0 : U.kind) === "road_relation" ? D1 : (e == null && (e = !!/*feature*/
        A[0].id.startsWith("address.")), e ? P1 : (i == null && (i = !!/*feature*/
        A[0].id.startsWith("postal_code.")), i ? A1 : (s == null && (s = !!/*feature*/
        A[0].id.startsWith("poi.")), s ? O1 : (
          /*isReverse*/
          A[7] ? M1 : N1
        ))))
      )
    );
  }
  let O = T(n, -1), M = O(n), G = _ && gf(n);
  return {
    c() {
      t = Yt("li"), M.c(), u = We(), h = Yt("span"), c = Yt("span"), g = Yt("span"), y = Ai(m), p = We(), G && G.c(), E = We(), S = Yt("span"), b = Ai(I), V(g, "class", "primary svelte-ltkwvy"), V(c, "class", "svelte-ltkwvy"), V(S, "class", "line2 svelte-ltkwvy"), V(h, "class", "texts svelte-ltkwvy"), V(t, "tabindex", "0"), V(
        t,
        "data-selected",
        /*selected*/
        n[1]
      ), V(t, "class", "svelte-ltkwvy"), Ii(
        t,
        "selected",
        /*selected*/
        n[1]
      );
    },
    m(A, j) {
      Jt(A, t, j), M.m(t, null), Rt(t, u), Rt(t, h), Rt(h, c), Rt(c, g), Rt(g, y), Rt(c, p), G && G.m(c, null), Rt(h, E), Rt(h, S), Rt(S, b), C || (R = [
        Le(
          t,
          "mouseenter",
          /*mouseenter_handler*/
          n[12]
        ),
        Le(
          t,
          "focus",
          /*focus_handler*/
          n[13]
        )
      ], C = !0);
    },
    p(A, [j]) {
      var et, U;
      O === (O = T(A, j)) && M ? M.p(A, j) : (M.d(1), M = O(A), M && (M.c(), M.m(t, u))), j & /*feature*/
      1 && m !== (m = /*isReverse*/
      (A[7] ? (
        /*feature*/
        A[0].place_name
      ) : (
        /*feature*/
        A[0].place_name.replace(/,.*/, "")
      )) + "") && lo(y, m), j & /*showPlaceType, feature, imageUrl*/
      37 && (_ = /*showPlaceType*/
      A[2] === "always" || /*showPlaceType*/
      A[2] && !/*feature*/
      A[0].address && /*feature*/
      ((et = A[0].properties) == null ? void 0 : et.kind) !== "road" && /*feature*/
      ((U = A[0].properties) == null ? void 0 : U.kind) !== "road_relation" && !/*feature*/
      A[0].id.startsWith("address.") && !/*feature*/
      A[0].id.startsWith("postal_code.") && (!/*feature*/
      A[0].id.startsWith("poi.") || !/*imageUrl*/
      A[5]) && !/*isReverse*/
      A[7]), _ ? G ? G.p(A, j) : (G = gf(A), G.c(), G.m(c, null)) : G && (G.d(1), G = null), j & /*feature*/
      1 && I !== (I = /*isReverse*/
      (A[7] ? "" : (
        /*feature*/
        A[0].place_name.replace(/[^,]*,?\s*/, "")
      )) + "") && lo(b, I), j & /*selected*/
      2 && V(
        t,
        "data-selected",
        /*selected*/
        A[1]
      ), j & /*selected*/
      2 && Ii(
        t,
        "selected",
        /*selected*/
        A[1]
      );
    },
    i: $t,
    o: $t,
    d(A) {
      A && Vt(t), M.d(), G && G.d(), C = !1, ui(R);
    }
  };
}
function z1(n, t, e) {
  var T;
  let i, s, { feature: u } = t, { selected: h = !1 } = t, { showPlaceType: c } = t, { missingIconsCache: g } = t, { iconsBaseUrl: m } = t;
  const y = (T = u.properties) == null ? void 0 : T.categories;
  let p, _, E = 0, S = u.place_type[0] === "reverse";
  function I() {
    _ && g.add(_), e(10, E++, E);
  }
  function b(O) {
    hf.call(this, n, O);
  }
  function C(O) {
    hf.call(this, n, O);
  }
  const R = () => I();
  return n.$$set = (O) => {
    "feature" in O && e(0, u = O.feature), "selected" in O && e(1, h = O.selected), "showPlaceType" in O && e(2, c = O.showPlaceType), "missingIconsCache" in O && e(9, g = O.missingIconsCache), "iconsBaseUrl" in O && e(3, m = O.iconsBaseUrl);
  }, n.$$.update = () => {
    var O, M, G, D;
    if (n.$$.dirty & /*loadIconAttempt, index, category, iconsBaseUrl, imageUrl, missingIconsCache*/
    3640)
      do
        e(11, i--, i), e(4, p = y == null ? void 0 : y[i]), e(5, _ = p ? m + p.replace(/ /g, "_") + ".svg" : void 0);
      while (i > -1 && (!_ || g.has(_)));
    n.$$.dirty & /*feature*/
    1 && e(6, s = u.id.startsWith("poi.") ? (M = (O = u.properties) == null ? void 0 : O.categories) == null ? void 0 : M.join(", ") : ((D = (G = u.properties) == null ? void 0 : G.place_type_name) == null ? void 0 : D[0]) ?? u.place_type[0]);
  }, e(11, i = (y == null ? void 0 : y.length) ?? 0), [
    u,
    h,
    c,
    m,
    p,
    _,
    s,
    S,
    I,
    g,
    E,
    i,
    b,
    C,
    R
  ];
}
class Y1 extends vr {
  constructor(t) {
    super(), pr(this, t, z1, B1, yr, {
      feature: 0,
      selected: 1,
      showPlaceType: 2,
      missingIconsCache: 9,
      iconsBaseUrl: 3
    });
  }
}
function W1(n) {
  let t;
  return {
    c() {
      t = Yt("div"), t.innerHTML = '<svg viewBox="0 0 18 18" width="24" height="24" class="svelte-7cmwmc"><path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"></path><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"></path></svg>', V(t, "class", "svelte-7cmwmc");
    },
    m(e, i) {
      Jt(e, t, i);
    },
    p: $t,
    i: $t,
    o: $t,
    d(e) {
      e && Vt(t);
    }
  };
}
class X1 extends vr {
  constructor(t) {
    super(), pr(this, t, null, W1, yr, {});
  }
}
function q1(n) {
  let t, e;
  return {
    c() {
      t = ti("svg"), e = ti("path"), V(e, "d", "M30.003-26.765C13.46-26.765 0-14.158 0 1.337c0 23.286 24.535 42.952 28.39 46.04.24.192.402.316.471.376.323.282.732.424 1.142.424.41 0 .82-.142 1.142-.424.068-.06.231-.183.471-.376 3.856-3.09 28.39-22.754 28.39-46.04 0-15.495-13.46-28.102-30.003-28.102Zm1.757 12.469c4.38 0 7.858 1.052 10.431 3.158 2.595 2.105 3.89 4.913 3.89 8.422 0 2.34-.53 4.362-1.593 6.063-1.063 1.702-3.086 3.616-6.063 5.742-2.042 1.51-3.337 2.659-3.89 3.446-.532.787-.8 1.82-.8 3.096v1.914h-8.449V15.18c0-2.041.434-3.815 1.306-5.325.872-1.51 2.467-3.118 4.785-4.82 2.233-1.594 3.7-2.89 4.402-3.889a5.582 5.582 0 0 0 1.087-3.35c0-1.382-.51-2.435-1.531-3.158-1.02-.723-2.45-1.087-4.28-1.087-3.19 0-6.826 1.047-10.91 3.131l-3.472-6.986c4.742-2.659 9.77-3.992 15.087-3.992Zm-1.88 37.324c1.765 0 3.124.472 4.08 1.408.98.936 1.47 2.276 1.47 4.02 0 1.68-.49 3.007-1.47 3.985-.977.957-2.336 1.435-4.08 1.435-1.787 0-3.171-.465-4.15-1.4-.978-.958-1.47-2.298-1.47-4.02 0-1.787.48-3.14 1.436-4.054.957-.915 2.355-1.374 4.184-1.374Z"), V(t, "viewBox", "0 0 60.006 21.412"), V(t, "width", "14"), V(t, "height", "20"), V(t, "class", "svelte-en2qvf");
    },
    m(i, s) {
      Jt(i, t, s), Rt(t, e);
    },
    p: $t,
    i: $t,
    o: $t,
    d(i) {
      i && Vt(t);
    }
  };
}
class U1 extends vr {
  constructor(t) {
    super(), pr(this, t, null, q1, yr, {});
  }
}
function j1(n) {
  let t, e, i;
  return {
    c() {
      t = ti("svg"), e = ti("circle"), i = ti("path"), V(e, "cx", "4.789"), V(e, "cy", "4.787"), V(e, "r", "3.85"), V(e, "class", "svelte-1aq105l"), V(i, "d", "M12.063 12.063 7.635 7.635"), V(i, "class", "svelte-1aq105l"), V(t, "xmlns", "http://www.w3.org/2000/svg"), V(t, "width", "13"), V(t, "height", "13"), V(t, "viewBox", "0 0 13 13"), V(t, "class", "svelte-1aq105l");
    },
    m(s, u) {
      Jt(s, t, u), Rt(t, e), Rt(t, i);
    },
    p: $t,
    i: $t,
    o: $t,
    d(s) {
      s && Vt(t);
    }
  };
}
class V1 extends vr {
  constructor(t) {
    super(), pr(this, t, null, j1, yr, {});
  }
}
function Z1(n, t, e) {
  const i = t[1], s = t[0], u = i - s;
  return n === i && e ? n : ((n - s) % u + u) % u + s;
}
function df(n) {
  const t = [...n];
  return t[2] < t[0] && (t[2] += 360), t;
}
let Ms;
async function H1(n, t, e) {
  const i = n == null ? void 0 : n.getCenterAndZoom();
  for (const s of t ?? [])
    if (!(i && (s.minZoom != null && s.minZoom > i[0] || s.maxZoom != null && s.maxZoom < i[0]))) {
      if (s.type === "fixed")
        return s.coordinates.join(",");
      t: if (s.type === "client-geolocation") {
        if (Ms && s.cachedLocationExpiry && Ms.time + s.cachedLocationExpiry > Date.now()) {
          if (!Ms.coords)
            break t;
          return Ms.coords;
        }
        let u;
        try {
          return u = await new Promise((h, c) => {
            e.signal.addEventListener("abort", () => {
              c(Error("aborted"));
            }), navigator.geolocation.getCurrentPosition(
              (g) => {
                h(
                  [g.coords.longitude, g.coords.latitude].map((m) => m.toFixed(6)).join(",")
                );
              },
              (g) => {
                c(g);
              },
              s
            );
          }), u;
        } catch {
        } finally {
          s.cachedLocationExpiry && (Ms = {
            time: Date.now(),
            coords: u
          });
        }
        if (e.signal.aborted)
          return;
      }
      if (s.type === "server-geolocation")
        return "ip";
      if (i && s.type === "map-center")
        return i[1].toFixed(6) + "," + i[2].toFixed(6);
    }
}
const K1 = /^(NORTH|SOUTH|[NS])?\s*([+-]?[0-8]?[0-9])\s*([\.:]|D(?:EG)?(?:REES)?)?\s*,?([6-9][0-9])\s*(['\.:]|M(?:IN)?(?:UTES)?)?\s*(NORTH|SOUTH|[NS])?(?:\s*[,/;]\s*|\s*)(EAST|WEST|[EW])?\s*([+-]?[0-1]?[0-9]?[0-9])\s*([\.:]|D(?:EG)?(?:REES)?)?\s*,?([6-9][0-9])\s*(['\.:]|M(?:IN)?(?:UTES)?)?\s*(EAST|WEST|[EW])?$/i, mf = /^([+-]?[0-8]?[0-9])\s+([0-5]?[0-9]\.\d{3,})[\s,]{1,}([+-]?[0-1]?[0-9]?[0-9])\s+([0-5]?[0-9]\.\d{3,})$/, yf = /^(NORTH|SOUTH|[NS])?[\s]*([+-]?[0-8]?[0-9](?:[\.,]\d{3,}))[\s]*([]?)[\s]*(NORTH|SOUTH|[NS])?[\s]*[,/;]?[\s]*(EAST|WEST|[EW])?[\s]*([+-]?[0-1]?[0-9]?[0-9](?:[\.,]\d{3,}))[\s]*([]?)[\s]*(EAST|WEST|[EW])?$/i, pf = /^(NORTH|SOUTH|[NS])?\s*([+-]?[0-8]?[0-9])\s*(\.)\s*([0-5]?[0-9])\s*(\.)\s*((?:[0-5]?[0-9])(?:[\.,]\d{1,3})?)?\s*(NORTH|SOUTH|[NS])?(?:\s*[,/;]\s*|\s*)(EAST|WEST|[EW])?\s*([+-]?[0-1]?[0-9]?[0-9])\s*(\.)\s*([0-5]?[0-9])\s*(\.)\s*((?:[0-5]?[0-9])(?:[\.,]\d{1,3})?)?\s*(EAST|WEST|[EW])?$/i, vf = /^(NORTH|SOUTH|[NS])?\s*([+-]?[0-8]?[0-9])\s*(D(?:EG)?(?:REES)?)\s*([0-5]?[0-9])\s*(M(?:IN)?(?:UTES)?)\s*((?:[0-5]?[0-9])(?:[\.,]\d{1,3})?)?\s*(S(?:EC)?(?:ONDS)?)?\s*(NORTH|SOUTH|[NS])?(?:\s*[,/;]\s*|\s*)(EAST|WEST|[EW])?\s*([+-]?[0-1]?[0-9]?[0-9])\s*(D(?:EG)?(?:REES)?)\s*([0-5]?[0-9])\s*(M(?:IN)?(?:UTES)?)\s*((?:[0-5]?[0-9])(?:[\.,]\d{1,3})?)?\s*(S(?:EC)?(?:ONDS)?)\s*(EAST|WEST|[EW])?$/i, _f = /^(NORTH|SOUTH|[NS])?\s*([+-]?[0-8]?[0-9])\s*([\.:]|D(?:EG)?(?:REES)?)?\s*,?([0-5]?[0-9](?:[\.,]\d{1,})?)?\s*(['\.:]|M(?:IN)?(?:UTES)?)?\s*,?((?:[0-5]?[0-9])(?:[\.,]\d{1,3})?)?\s*(''||||["\.])?\s*(NORTH|SOUTH|[NS])?(?:\s*[,/;]\s*|\s*)(EAST|WEST|[EW])?\s*([+-]?[0-1]?[0-9]?[0-9])\s*([\.:]|D(?:EG)?(?:REES)?)?\s*,?([0-5]?[0-9](?:[\.,]\d{1,})?)?\s*(['\.:]|M(?:IN)?(?:UTES)?)?\s*,?((?:[0-5]?[0-9])(?:[\.,]\d{1,3})?)?\s*(''||||["\.])?\s*(EAST|WEST|[EW])?$/i;
function $1(n) {
  if (!["DMS", "DM", "DD"].includes(n))
    throw new Error("invalid format specified");
  if (this.decimalCoordinates && this.decimalCoordinates.trim()) {
    const t = this.decimalCoordinates.split(",").map((E) => Number(E.trim())), e = Number(t[0]), i = Number(t[1]), s = Math.abs(e), u = Math.abs(i), h = e > 0 ? "N" : "S", c = i > 0 ? "E" : "W";
    let g;
    n == "DD" && (g = `${s} ${h}, ${u} ${c}`);
    const m = Math.floor(s), y = Math.floor(u), p = (s - m) * 60, _ = (u - y) * 60;
    if (n == "DM") {
      let E = Ef(p, 3).toFixed(3).padStart(6, "0"), S = Ef(_, 3).toFixed(3).padStart(6, "0");
      E.endsWith(".000") && S.endsWith(".000") && (E = E.replace(/\.000$/, ""), S = S.replace(/\.000$/, "")), g = `${m} ${E}' ${h}, ${y} ${S}' ${c}`;
    }
    if (n == "DMS") {
      const E = Math.floor(p), S = Math.floor(_);
      let I = ((p - E) * 60).toFixed(1).padStart(4, "0"), b = ((_ - S) * 60).toFixed(1).padStart(4, "0");
      const C = E.toString().padStart(2, "0"), R = S.toString().padStart(2, "0");
      I.endsWith(".0") && b.endsWith(".0") && (I = I.replace(/\.0$/, ""), b = b.replace(/\.0$/, "")), g = `${m} ${C}' ${I}" ${h}, ${y} ${R}' ${b}" ${c}`;
    }
    return g;
  } else
    throw new Error("no decimal coordinates to convert");
}
function Ef(n, t) {
  const e = Math.pow(10, t);
  return Math.round((n + Number.EPSILON) * e) / e;
}
function ph(n, t) {
  t || (t = 5), n = n.replace(/\s+/g, " ").trim();
  let e = null, i = null, s = "", u = "", h = null, c = [], g = !1;
  if (K1.test(n))
    throw new Error("invalid coordinate value");
  if (mf.test(n))
    if (c = mf.exec(n), g = Os(c), g)
      e = Math.abs(c[1]) + c[2] / 60, Number(c[1]) < 0 && (e *= -1), i = Math.abs(c[3]) + c[4] / 60, Number(c[3]) < 0 && (i *= -1), h = "DM";
    else
      throw new Error("invalid coordinate format");
  else if (yf.test(n))
    if (c = yf.exec(n), g = Os(c), g) {
      if (e = c[2], i = c[6], e.includes(",") && (e = e.replace(",", ".")), i.includes(",") && (i = i.replace(",", ".")), h = "DD", Number(Math.round(e)) == Number(e))
        throw new Error("integer only coordinate provided");
      if (Number(Math.round(i)) == Number(i))
        throw new Error("integer only coordinate provided");
      c[1] ? (s = c[1], u = c[5]) : c[4] && (s = c[4], u = c[8]);
    } else
      throw new Error("invalid decimal coordinate format");
  else if (pf.test(n))
    if (c = pf.exec(n), g = Os(c), g)
      e = Math.abs(parseInt(c[2])), c[4] && (e += c[4] / 60, h = "DM"), c[6] && (e += c[6].replace(",", ".") / 3600, h = "DMS"), parseInt(c[2]) < 0 && (e = -1 * e), i = Math.abs(parseInt(c[9])), c[11] && (i += c[11] / 60), c[13] && (i += c[13].replace(",", ".") / 3600), parseInt(c[9]) < 0 && (i = -1 * i), c[1] ? (s = c[1], u = c[8]) : c[7] && (s = c[7], u = c[14]);
    else
      throw new Error("invalid DMS coordinates format");
  else if (vf.test(n))
    if (c = vf.exec(n), g = Os(c), g)
      e = Math.abs(parseInt(c[2])), c[4] && (e += c[4] / 60, h = "DM"), c[6] && (e += c[6] / 3600, h = "DMS"), parseInt(c[2]) < 0 && (e = -1 * e), i = Math.abs(parseInt(c[10])), c[12] && (i += c[12] / 60), c[14] && (i += c[14] / 3600), parseInt(c[10]) < 0 && (i = -1 * i), c[1] ? (s = c[1], u = c[9]) : c[8] && (s = c[8], u = c[16]);
    else
      throw new Error("invalid DMS coordinates format");
  else if (_f.test(n)) {
    if (c = _f.exec(n), g = Os(c), c.filter((m) => m).length <= 5)
      throw new Error("invalid coordinates format");
    if (g)
      e = Math.abs(parseInt(c[2])), c[4] && (e += c[4].replace(",", ".") / 60, h = "DM"), c[6] && (e += c[6].replace(",", ".") / 3600, h = "DMS"), parseInt(c[2]) < 0 && (e = -1 * e), i = Math.abs(parseInt(c[10])), c[12] && (i += c[12].replace(",", ".") / 60), c[14] && (i += c[14].replace(",", ".") / 3600), parseInt(c[10]) < 0 && (i = -1 * i), c[1] ? (s = c[1], u = c[9]) : c[8] && (s = c[8], u = c[16]);
    else
      throw new Error("invalid coordinates format");
  }
  if (g) {
    if (Math.abs(i) >= 180)
      throw new Error("invalid longitude value");
    if (Math.abs(e) >= 90)
      throw new Error("invalid latitude value");
    if (s && !u || !s && u)
      throw new Error("invalid coordinates value");
    if (s && s == u)
      throw new Error("invalid coordinates format");
    e.toString().includes(",") && (e = e.replace(",", ".")), i.toString().includes(",") && (i = i.replace(",", "."));
    let m = /S|SOUTH/i;
    m.test(s) && e > 0 && (e = -1 * e), m = /W|WEST/i, m.test(u) && i > 0 && (i = -1 * i);
    const y = c[0].trim();
    let p, _;
    const E = /[,/;\u0020]/g, S = y.match(E);
    if (S == null) {
      const C = Math.floor(n.length / 2);
      p = y.substring(0, C).trim(), _ = y.substring(C).trim();
    } else {
      let C;
      S.length % 2 == 1 ? C = Math.floor(S.length / 2) : C = S.length / 2 - 1;
      let R = 0;
      if (C == 0)
        R = y.indexOf(S[0]), p = y.substring(0, R).trim(), _ = y.substring(R + 1).trim();
      else {
        let T = 0, O = 0;
        for (; T <= C; )
          R = y.indexOf(S[T], O), O = R + 1, T++;
        p = y.substring(0, R).trim(), _ = y.substring(R + 1).trim();
      }
    }
    const I = p.split(".");
    if (I.length == 2 && I[1] == 0 && I[1].length != 2)
      throw new Error("invalid coordinates format");
    const b = _.split(".");
    if (b.length == 2 && b[1] == 0 && b[1].length != 2)
      throw new Error("invalid coordinates format");
    if (/^\d+$/.test(p) || /^\d+$/.test(_))
      throw new Error("degree only coordinate/s provided");
    return e = Number(Number(e).toFixed(t)), i = Number(Number(i).toFixed(t)), Object.freeze({
      verbatimCoordinates: y,
      verbatimLatitude: p,
      verbatimLongitude: _,
      decimalLatitude: e,
      decimalLongitude: i,
      decimalCoordinates: `${e},${i}`,
      originalFormat: h,
      closeEnough: J1,
      toCoordinateFormat: $1
    });
  } else
    throw new Error("coordinates pattern match failed");
}
function Os(n) {
  if (!isNaN(n[0]))
    return !1;
  const t = [...n];
  if (t.shift(), t.length % 2 > 0)
    return !1;
  const e = /^[-+]?\d+([\.,]\d+)?$/, i = /[eastsouthnorthwest]+/i, s = t.length / 2;
  for (let u = 0; u < s; u++) {
    const h = t[u], c = t[u + s], g = e.test(h) && e.test(c), m = i.test(h) && i.test(c), y = h == c;
    if (!(h == null && c == null)) {
      if (h == null || c == null)
        return !1;
      if (g || m || y)
        continue;
      return !1;
    }
  }
  return !0;
}
function xf(n, t) {
  const e = Math.abs(n - t);
  return Number(e.toFixed(6)) <= 1e-5;
}
function J1(n) {
  if (!n)
    throw new Error("coords must be provided");
  if (n.includes(",")) {
    const t = n.split(",");
    if (Number(t[0]) == NaN || Number(t[1]) == NaN)
      throw new Error("coords are not valid decimals");
    return xf(this.decimalLatitude, Number(t[0])) && xf(this.decimalLongitude, t[1]);
  } else
    throw new Error("coords being tested must be separated by a comma");
}
const Q1 = Object.freeze({
  DMS: "DMS",
  DM: "DM",
  DD: "DD"
});
ph.to = Q1;
const tE = [
  {
    verbatimCoordinates: "40.123, -74.123",
    verbatimLatitude: "40.123",
    verbatimLongitude: "-74.123"
  },
  {
    verbatimCoordinates: "40.123 N 74.123 W",
    verbatimLatitude: "40.123 N",
    verbatimLongitude: "74.123 W"
  },
  {
    verbatimCoordinates: "40.123 N 74.123 W",
    verbatimLatitude: "40.123 N",
    verbatimLongitude: "74.123 W"
  },
  {
    verbatimCoordinates: '40 7 22.8" N 74 7 22.8" W',
    verbatimLatitude: '40 7 22.8" N',
    verbatimLongitude: '74 7 22.8" W'
  },
  {
    verbatimCoordinates: "40 7.38 , -74 7.38",
    verbatimLatitude: "40 7.38",
    verbatimLongitude: "-74 7.38"
  },
  {
    verbatimCoordinates: "N40722.8, W74722.8",
    verbatimLatitude: "N40722.8",
    verbatimLongitude: "W74722.8"
  },
  {
    verbatimCoordinates: '40722.8"N, 74722.8"W',
    verbatimLatitude: '40722.8"N',
    verbatimLongitude: '74722.8"W'
  },
  {
    verbatimCoordinates: `407'22.8"N, 747'22.8"W`,
    verbatimLatitude: `407'22.8"N`,
    verbatimLongitude: `747'22.8"W`
  },
  {
    verbatimCoordinates: "40 7 22.8, -74 7 22.8",
    verbatimLatitude: "40 7 22.8",
    verbatimLongitude: "-74 7 22.8"
  },
  {
    verbatimCoordinates: "40.123 -74.123",
    verbatimLatitude: "40.123",
    verbatimLongitude: "-74.123"
  },
  {
    verbatimCoordinates: "40.123,-74.123",
    verbatimLatitude: "40.123",
    verbatimLongitude: "-74.123"
  },
  {
    verbatimCoordinates: "40.123N74.123W",
    verbatimLatitude: "40.123N",
    verbatimLongitude: "74.123W"
  },
  {
    verbatimCoordinates: "4007.38N7407.38W",
    verbatimLatitude: "4007.38N",
    verbatimLongitude: "7407.38W"
  },
  {
    verbatimCoordinates: '40722.8"N, 74722.8"W',
    verbatimLatitude: '40722.8"N',
    verbatimLongitude: '74722.8"W'
  },
  {
    verbatimCoordinates: "400722.8N740722.8W",
    verbatimLatitude: "400722.8N",
    verbatimLongitude: "740722.8W"
  },
  {
    verbatimCoordinates: "N 40 7.38 W 74 7.38",
    verbatimLatitude: "N 40 7.38",
    verbatimLongitude: "W 74 7.38"
  },
  {
    verbatimCoordinates: "40:7:22.8N 74:7:22.8W",
    verbatimLatitude: "40:7:22.8N",
    verbatimLongitude: "74:7:22.8W"
  },
  {
    verbatimCoordinates: "40:7:23N,74:7:23W",
    verbatimLatitude: "40:7:23N",
    verbatimLongitude: "74:7:23W",
    decimalLatitude: 40.1230555555,
    decimalLongitude: -74.1230555555
  },
  {
    verbatimCoordinates: '40723"N 74723"W',
    verbatimLatitude: '40723"N',
    verbatimLongitude: '74723"W',
    decimalLatitude: 40.1230555555,
    decimalLongitude: -74.12305555555555
  },
  {
    verbatimCoordinates: '40723"S 74723"E',
    verbatimLatitude: '40723"S',
    verbatimLongitude: '74723"E',
    decimalLatitude: -40.1230555555,
    decimalLongitude: 74.12305555555555
  },
  {
    verbatimCoordinates: '40723" -74723"',
    verbatimLatitude: '40723"',
    verbatimLongitude: '-74723"',
    decimalLatitude: 40.1230555555,
    decimalLongitude: -74.123055555
  },
  {
    verbatimCoordinates: '40d 7 23" N 74d 7 23" W',
    verbatimLatitude: '40d 7 23" N',
    verbatimLongitude: '74d 7 23" W',
    decimalLatitude: 40.1230555555,
    decimalLongitude: -74.123055555
  },
  {
    verbatimCoordinates: "40.123N 74.123W",
    verbatimLatitude: "40.123N",
    verbatimLongitude: "74.123W"
  },
  {
    verbatimCoordinates: "40 7.38, -74 7.38",
    verbatimLatitude: "40 7.38",
    verbatimLongitude: "-74 7.38"
  },
  {
    verbatimCoordinates: "40 7.38, -74 7.38",
    verbatimLatitude: "40 7.38",
    verbatimLongitude: "-74 7.38"
  },
  {
    verbatimCoordinates: "40 7 22.8; -74 7 22.8",
    verbatimLatitude: "40 7 22.8",
    verbatimLongitude: "-74 7 22.8"
  }
], eE = {
  decimalLatitude: 40.123,
  decimalLongitude: -74.123
}, nE = [
  {
    verbatimCoordinates: `504'17.698"south, 1424'2.826"east`,
    verbatimLatitude: `504'17.698"south`,
    verbatimLongitude: `1424'2.826"east`,
    decimalLatitude: -50.07158277777778,
    decimalLongitude: 14.400785
  },
  {
    verbatimCoordinates: "50d4m17.698S 14d24m2.826E",
    verbatimLatitude: "50d4m17.698S",
    verbatimLongitude: "14d24m2.826E",
    decimalLatitude: -50.07158277777778,
    decimalLongitude: 14.400785
  },
  {
    verbatimCoordinates: "40:26:46N,79:56:55W",
    verbatimLatitude: "40:26:46N",
    verbatimLongitude: "79:56:55W",
    decimalLatitude: 40.44611111111111,
    decimalLongitude: -79.9486111111111
  },
  {
    verbatimCoordinates: "40:26:46.302N 79:56:55.903W",
    verbatimLatitude: "40:26:46.302N",
    verbatimLongitude: "79:56:55.903W",
    decimalLatitude: 40.446195,
    decimalLongitude: -79.94886194444445
  },
  {
    verbatimCoordinates: "402647N 795836W",
    verbatimLatitude: "402647N",
    verbatimLongitude: "795836W",
    decimalLatitude: 40.44638888888889,
    decimalLongitude: -79.97666666666667
  },
  {
    verbatimCoordinates: "40d 26 47 N 79d 58 36 W",
    verbatimLatitude: "40d 26 47 N",
    verbatimLongitude: "79d 58 36 W",
    decimalLatitude: 40.44638888888889,
    decimalLongitude: -79.97666666666667
  },
  {
    verbatimCoordinates: "40.446195N 79.948862W",
    verbatimLatitude: "40.446195N",
    verbatimLongitude: "79.948862W",
    decimalLatitude: 40.446195,
    decimalLongitude: -79.948862
  },
  {
    verbatimCoordinates: "40,446195 79,948862",
    verbatimLatitude: "40,446195",
    verbatimLongitude: "79,948862",
    decimalLatitude: 40.446195,
    decimalLongitude: 79.948862
  },
  {
    verbatimCoordinates: "40 26.7717, -79 56.93172",
    verbatimLatitude: "40 26.7717",
    verbatimLongitude: "-79 56.93172",
    decimalLatitude: 40.446195,
    decimalLongitude: -79.948862
  },
  {
    verbatimCoordinates: "40.446195, -79.948862",
    verbatimLatitude: "40.446195",
    verbatimLongitude: "-79.948862",
    decimalLatitude: 40.446195,
    decimalLongitude: -79.948862
  },
  {
    verbatimCoordinates: "40.123256; -74.123256",
    verbatimLatitude: "40.123256",
    verbatimLongitude: "-74.123256",
    decimalLatitude: 40.123256,
    decimalLongitude: -74.123256
  },
  {
    verbatimCoordinates: "1824S 2245E",
    verbatimLatitude: "1824S",
    verbatimLongitude: "2245E",
    decimalLatitude: -18.4,
    decimalLongitude: 22.75
  }
], iE = [
  {
    verbatimCoordinates: "10.432342S 10.6345345E",
    verbatimLatitude: "10.432342S",
    verbatimLongitude: "10.6345345E",
    decimalLatitude: -10.432342,
    decimalLongitude: 10.6345345
  },
  {
    verbatimCoordinates: "10.00S 10.00E",
    verbatimLatitude: "10.00S",
    verbatimLongitude: "10.00E",
    decimalLatitude: -10,
    decimalLongitude: 10
  },
  {
    verbatimCoordinates: "00.00S 01.00E",
    verbatimLatitude: "00.00S",
    verbatimLongitude: "01.00E",
    decimalLatitude: 0,
    decimalLongitude: 1
  },
  {
    verbatimCoordinates: "18.24S 22.45E",
    verbatimLatitude: "18.24S",
    verbatimLongitude: "22.45E",
    decimalLatitude: -18.4,
    decimalLongitude: 22.75
  },
  {
    verbatimCoordinates: "27deg 15min 45.2sec S 18deg 32min 53.7sec E",
    verbatimLatitude: "27deg 15min 45.2sec S",
    verbatimLongitude: "18deg 32min 53.7sec E",
    decimalLatitude: -27.262555555555554,
    decimalLongitude: 18.54825
  },
  {
    verbatimCoordinates: "-23.3245 S / 28.2344 E",
    verbatimLatitude: "-23.3245 S",
    verbatimLongitude: "28.2344 E",
    decimalLatitude: -23.3245,
    decimalLongitude: 28.2344
  },
  {
    verbatimCoordinates: "40 26.7717 -79 56.93172",
    verbatimLatitude: "40 26.7717",
    verbatimLongitude: "-79 56.93172",
    decimalLatitude: 40.446195,
    decimalLongitude: -79.948862
  },
  {
    verbatimCoordinates: "27.15.45S 18.32.53E",
    verbatimLatitude: "27.15.45S",
    verbatimLongitude: "18.32.53E",
    decimalLatitude: -27.2625,
    decimalLongitude: 18.548055
  },
  {
    verbatimCoordinates: "-27.15.45 18.32.53",
    verbatimLatitude: "-27.15.45",
    verbatimLongitude: "18.32.53",
    decimalLatitude: -27.2625,
    decimalLongitude: 18.548055
  },
  {
    verbatimCoordinates: "27.15.45.2S 18.32.53.4E",
    verbatimLatitude: "27.15.45.2S",
    verbatimLongitude: "18.32.53.4E",
    decimalLatitude: -27.262556,
    decimalLongitude: 18.548167
  },
  {
    verbatimCoordinates: "27.15.45,2S 18.32.53,4E",
    verbatimLatitude: "27.15.45,2S",
    verbatimLongitude: "18.32.53,4E",
    decimalLatitude: -27.262556,
    decimalLongitude: 18.548167
  },
  {
    verbatimCoordinates: "S23.43563   E22.45634 ",
    verbatimLatitude: "S23.43563 ",
    verbatimLongitude: "E22.45634 ",
    decimalLatitude: -23.43563,
    decimalLongitude: 22.45634
  },
  {
    verbatimCoordinates: "27,71372 S 23,07771 E",
    verbatimLatitude: "27,71372 S",
    verbatimLongitude: "23,07771 E",
    decimalLatitude: -27.71372,
    decimalLongitude: 23.07771
  },
  {
    verbatimCoordinates: "27.45.34 S 23.23.23 E",
    verbatimLatitude: "27.45.34 S",
    verbatimLongitude: "23.23.23 E",
    decimalLatitude: -27.759444,
    decimalLongitude: 23.38972222
  },
  {
    verbatimCoordinates: "S 27.45.34 E 23.23.23",
    verbatimLatitude: "S 27.45.34",
    verbatimLongitude: "E 23.23.23",
    decimalLatitude: -27.759444,
    decimalLongitude: 23.38972222
  },
  {
    verbatimCoordinates: "53 16.3863,4 52.8171",
    verbatimLatitude: "53 16.3863",
    verbatimLongitude: "4 52.8171",
    decimalLatitude: 53.273105,
    decimalLongitude: 4.88029
  },
  {
    verbatimCoordinates: "50 8.2914,-5 2.4447",
    verbatimLatitude: "50 8.2914",
    verbatimLongitude: "-5 2.4447",
    decimalLatitude: 50.13819,
    decimalLongitude: -5.040745
  },
  {
    verbatimCoordinates: "N 48 30,6410', E 18 57,4583'",
    verbatimLatitude: "N 48 30,6410'",
    verbatimLongitude: "E 18 57,4583'",
    decimalLatitude: 48.51068,
    decimalLongitude: 18.95764
  },
  {
    verbatimCoordinates: "1.23456, 18.33453",
    verbatimLatitude: "1.23456",
    verbatimLongitude: "18.33453",
    decimalLatitude: 1.23456,
    decimalLongitude: 18.33453
  }
];
function rE() {
  const n = [];
  return tE.forEach((t) => {
    t.decimalLatitude ? n.push(t) : n.push({ ...t, ...eE });
  }), [...n, ...nE, ...iE];
}
const sE = rE();
ph.formats = sE.map((n) => n.verbatimCoordinates);
const oE = ph;
function Sf(n, t, e) {
  const i = n.slice();
  return i[81] = t[e], i[83] = e, i;
}
function wf(n) {
  let t, e;
  return t = new X1({}), {
    c() {
      Pi(t.$$.fragment);
    },
    m(i, s) {
      ri(t, i, s), e = !0;
    },
    i(i) {
      e || (ee(t.$$.fragment, i), e = !0);
    },
    o(i) {
      ue(t.$$.fragment, i), e = !1;
    },
    d(i) {
      si(t, i);
    }
  };
}
function If(n) {
  let t, e, i, s, u;
  return e = new U1({}), {
    c() {
      t = Yt("button"), Pi(e.$$.fragment), V(t, "type", "button"), V(
        t,
        "title",
        /*reverseButtonTitle*/
        n[9]
      ), V(t, "class", "svelte-zh3kmv"), Ii(
        t,
        "active",
        /*reverseActive*/
        n[0]
      );
    },
    m(h, c) {
      Jt(h, t, c), ri(e, t, null), i = !0, s || (u = Le(
        t,
        "click",
        /*click_handler_2*/
        n[67]
      ), s = !0);
    },
    p(h, c) {
      (!i || c[0] & /*reverseButtonTitle*/
      512) && V(
        t,
        "title",
        /*reverseButtonTitle*/
        h[9]
      ), (!i || c[0] & /*reverseActive*/
      1) && Ii(
        t,
        "active",
        /*reverseActive*/
        h[0]
      );
    },
    i(h) {
      i || (ee(e.$$.fragment, h), i = !0);
    },
    o(h) {
      ue(e.$$.fragment, h), i = !1;
    },
    d(h) {
      h && Vt(t), si(e), s = !1, u();
    }
  };
}
function aE(n) {
  let t, e = [], i = /* @__PURE__ */ new Map(), s, u, h, c = ff(
    /*listFeatures*/
    n[14]
  );
  const g = (m) => (
    /*feature*/
    m[81].id + /*feature*/
    (m[81].address ? "," + /*feature*/
    m[81].address : "")
  );
  for (let m = 0; m < c.length; m += 1) {
    let y = Sf(n, c, m), p = g(y);
    i.set(p, e[m] = kf(p, y));
  }
  return {
    c() {
      t = Yt("ul");
      for (let m = 0; m < e.length; m += 1)
        e[m].c();
      V(t, "class", "svelte-zh3kmv");
    },
    m(m, y) {
      Jt(m, t, y);
      for (let p = 0; p < e.length; p += 1)
        e[p] && e[p].m(t, null);
      s = !0, u || (h = [
        Le(
          t,
          "mouseleave",
          /*mouseleave_handler*/
          n[71]
        ),
        Le(
          t,
          "blur",
          /*blur_handler_1*/
          n[72]
        )
      ], u = !0);
    },
    p(m, y) {
      y[0] & /*listFeatures, showPlaceType, selectedItemIndex, missingIconsCache, iconsBaseUrl, pick*/
      17880064 && (c = ff(
        /*listFeatures*/
        m[14]
      ), Ko(), e = b1(e, y, g, 1, m, c, i, t, k1, kf, null, Sf), $o());
    },
    i(m) {
      if (!s) {
        for (let y = 0; y < c.length; y += 1)
          ee(e[y]);
        s = !0;
      }
    },
    o(m) {
      for (let y = 0; y < e.length; y += 1)
        ue(e[y]);
      s = !1;
    },
    d(m) {
      m && Vt(t);
      for (let y = 0; y < e.length; y += 1)
        e[y].d();
      u = !1, ui(h);
    }
  };
}
function uE(n) {
  let t, e, i, s, u, h;
  return e = new Nm({}), {
    c() {
      t = Yt("div"), Pi(e.$$.fragment), i = We(), s = Yt("div"), u = Ai(
        /*noResultsMessage*/
        n[7]
      ), V(s, "class", "svelte-zh3kmv"), V(t, "class", "no-results svelte-zh3kmv");
    },
    m(c, g) {
      Jt(c, t, g), ri(e, t, null), Rt(t, i), Rt(t, s), Rt(s, u), h = !0;
    },
    p(c, g) {
      (!h || g[0] & /*noResultsMessage*/
      128) && lo(
        u,
        /*noResultsMessage*/
        c[7]
      );
    },
    i(c) {
      h || (ee(e.$$.fragment, c), h = !0);
    },
    o(c) {
      ue(e.$$.fragment, c), h = !1;
    },
    d(c) {
      c && Vt(t), si(e);
    }
  };
}
function lE(n) {
  let t = "", e;
  return {
    c() {
      e = Ai(t);
    },
    m(i, s) {
      Jt(i, e, s);
    },
    p: $t,
    i: $t,
    o: $t,
    d(i) {
      i && Vt(e);
    }
  };
}
function hE(n) {
  let t, e, i, s, u, h, c, g, m, y, p;
  return e = new Nm({}), g = new Tm({}), {
    c() {
      t = Yt("div"), Pi(e.$$.fragment), i = We(), s = Yt("div"), u = Ai(
        /*errorMessage*/
        n[6]
      ), h = We(), c = Yt("button"), Pi(g.$$.fragment), V(s, "class", "svelte-zh3kmv"), V(c, "class", "svelte-zh3kmv"), V(t, "class", "error svelte-zh3kmv");
    },
    m(_, E) {
      Jt(_, t, E), ri(e, t, null), Rt(t, i), Rt(t, s), Rt(s, u), Rt(t, h), Rt(t, c), ri(g, c, null), m = !0, y || (p = Le(
        c,
        "click",
        /*click_handler_3*/
        n[68]
      ), y = !0);
    },
    p(_, E) {
      (!m || E[0] & /*errorMessage*/
      64) && lo(
        u,
        /*errorMessage*/
        _[6]
      );
    },
    i(_) {
      m || (ee(e.$$.fragment, _), ee(g.$$.fragment, _), m = !0);
    },
    o(_) {
      ue(e.$$.fragment, _), ue(g.$$.fragment, _), m = !1;
    },
    d(_) {
      _ && Vt(t), si(e), si(g), y = !1, p();
    }
  };
}
function kf(n, t) {
  let e, i, s;
  function u() {
    return (
      /*mouseenter_handler*/
      t[69](
        /*i*/
        t[83]
      )
    );
  }
  function h() {
    return (
      /*focus_handler_1*/
      t[70](
        /*feature*/
        t[81]
      )
    );
  }
  return i = new Y1({
    props: {
      feature: (
        /*feature*/
        t[81]
      ),
      showPlaceType: (
        /*showPlaceType*/
        t[10]
      ),
      selected: (
        /*selectedItemIndex*/
        t[15] === /*i*/
        t[83]
      ),
      missingIconsCache: (
        /*missingIconsCache*/
        t[20]
      ),
      iconsBaseUrl: (
        /*iconsBaseUrl*/
        t[12]
      )
    }
  }), i.$on("mouseenter", u), i.$on("focus", h), {
    key: n,
    first: null,
    c() {
      e = m1(), Pi(i.$$.fragment), this.first = e;
    },
    m(c, g) {
      Jt(c, e, g), ri(i, c, g), s = !0;
    },
    p(c, g) {
      t = c;
      const m = {};
      g[0] & /*listFeatures*/
      16384 && (m.feature = /*feature*/
      t[81]), g[0] & /*showPlaceType*/
      1024 && (m.showPlaceType = /*showPlaceType*/
      t[10]), g[0] & /*selectedItemIndex, listFeatures*/
      49152 && (m.selected = /*selectedItemIndex*/
      t[15] === /*i*/
      t[83]), g[0] & /*iconsBaseUrl*/
      4096 && (m.iconsBaseUrl = /*iconsBaseUrl*/
      t[12]), i.$set(m);
    },
    i(c) {
      s || (ee(i.$$.fragment, c), s = !0);
    },
    o(c) {
      ue(i.$$.fragment, c), s = !1;
    },
    d(c) {
      c && Vt(e), si(i, c);
    }
  };
}
function cE(n) {
  let t, e, i, s, u, h, c, g, m, y, p, _, E, S, I, b, C, R, T, O, M, G = !1;
  u = new V1({}), p = new Tm({});
  let D = (
    /*abortController*/
    n[19] && wf()
  ), F = (
    /*enableReverse*/
    n[5] === !0 && If(n)
  );
  const A = (
    /*#slots*/
    n[59].default
  ), j = c1(
    A,
    n,
    /*$$scope*/
    n[58],
    null
  ), et = [hE, lE, uE, aE], U = [];
  function nt(z, K) {
    var Z, at;
    return (
      /*error*/
      z[18] ? 0 : (
        /*focusedDelayed*/
        z[16] ? (
          /*listFeatures*/
          ((Z = z[14]) == null ? void 0 : Z.length) === 0 ? 2 : (
            /*focusedDelayed*/
            z[16] && /*listFeatures*/
            ((at = z[14]) != null && at.length) ? 3 : -1
          )
        ) : 1
      )
    );
  }
  return ~(b = nt(n)) && (C = U[b] = et[b](n)), {
    c() {
      t = We(), e = Yt("form"), i = Yt("div"), s = Yt("button"), Pi(u.$$.fragment), h = We(), c = Yt("input"), g = We(), m = Yt("div"), y = Yt("button"), Pi(p.$$.fragment), _ = We(), D && D.c(), E = We(), F && F.c(), S = We(), j && j.c(), I = We(), C && C.c(), V(s, "class", "search-button svelte-zh3kmv"), V(s, "type", "button"), V(
        c,
        "placeholder",
        /*placeholder*/
        n[8]
      ), V(
        c,
        "aria-label",
        /*placeholder*/
        n[8]
      ), V(c, "class", "svelte-zh3kmv"), V(y, "type", "button"), V(
        y,
        "title",
        /*clearButtonTitle*/
        n[3]
      ), V(y, "class", "svelte-zh3kmv"), V(m, "class", "clear-button-container svelte-zh3kmv"), Ii(
        m,
        "displayable",
        /*searchValue*/
        n[1] !== ""
      ), V(i, "class", "input-group svelte-zh3kmv"), V(e, "tabindex", "0"), V(e, "class", R = uf(
        /*className*/
        n[2]
      ) + " svelte-zh3kmv"), Ii(
        e,
        "can-collapse",
        /*collapsed*/
        n[4] && /*searchValue*/
        n[1] === ""
      );
    },
    m(z, K) {
      Jt(z, t, K), Jt(z, e, K), Rt(e, i), Rt(i, s), ri(u, s, null), Rt(i, h), Rt(i, c), n[61](c), lf(
        c,
        /*searchValue*/
        n[1]
      ), Rt(i, g), Rt(i, m), Rt(m, y), ri(p, y, null), Rt(m, _), D && D.m(m, null), Rt(i, E), F && F.m(i, null), Rt(i, S), j && j.m(i, null), Rt(e, I), ~b && U[b].m(e, null), T = !0, O || (M = [
        Le(
          s,
          "click",
          /*click_handler*/
          n[60]
        ),
        Le(
          c,
          "input",
          /*input_1_input_handler*/
          n[62]
        ),
        Le(
          c,
          "focus",
          /*focus_handler*/
          n[63]
        ),
        Le(
          c,
          "blur",
          /*blur_handler*/
          n[64]
        ),
        Le(
          c,
          "keydown",
          /*handleKeyDown*/
          n[22]
        ),
        Le(
          c,
          "input",
          /*input_handler*/
          n[65]
        ),
        Le(
          y,
          "click",
          /*click_handler_1*/
          n[66]
        ),
        Le(e, "submit", y1(
          /*handleOnSubmit*/
          n[21]
        ))
      ], O = !0);
    },
    p(z, K) {
      (!T || K[0] & /*placeholder*/
      256) && V(
        c,
        "placeholder",
        /*placeholder*/
        z[8]
      ), (!T || K[0] & /*placeholder*/
      256) && V(
        c,
        "aria-label",
        /*placeholder*/
        z[8]
      ), K[0] & /*searchValue*/
      2 && c.value !== /*searchValue*/
      z[1] && lf(
        c,
        /*searchValue*/
        z[1]
      ), (!T || K[0] & /*clearButtonTitle*/
      8) && V(
        y,
        "title",
        /*clearButtonTitle*/
        z[3]
      ), /*abortController*/
      z[19] ? D ? K[0] & /*abortController*/
      524288 && ee(D, 1) : (D = wf(), D.c(), ee(D, 1), D.m(m, null)) : D && (Ko(), ue(D, 1, 1, () => {
        D = null;
      }), $o()), (!T || K[0] & /*searchValue*/
      2) && Ii(
        m,
        "displayable",
        /*searchValue*/
        z[1] !== ""
      ), /*enableReverse*/
      z[5] === !0 ? F ? (F.p(z, K), K[0] & /*enableReverse*/
      32 && ee(F, 1)) : (F = If(z), F.c(), ee(F, 1), F.m(i, S)) : F && (Ko(), ue(F, 1, 1, () => {
        F = null;
      }), $o()), j && j.p && (!T || K[1] & /*$$scope*/
      134217728) && g1(
        j,
        A,
        z,
        /*$$scope*/
        z[58],
        T ? f1(
          A,
          /*$$scope*/
          z[58],
          K,
          null
        ) : d1(
          /*$$scope*/
          z[58]
        ),
        null
      );
      let Z = b;
      b = nt(z), b === Z ? ~b && U[b].p(z, K) : (C && (Ko(), ue(U[Z], 1, 1, () => {
        U[Z] = null;
      }), $o()), ~b ? (C = U[b], C ? C.p(z, K) : (C = U[b] = et[b](z), C.c()), ee(C, 1), C.m(e, null)) : C = null), (!T || K[0] & /*className*/
      4 && R !== (R = uf(
        /*className*/
        z[2]
      ) + " svelte-zh3kmv")) && V(e, "class", R), (!T || K[0] & /*className, collapsed, searchValue*/
      22) && Ii(
        e,
        "can-collapse",
        /*collapsed*/
        z[4] && /*searchValue*/
        z[1] === ""
      );
    },
    i(z) {
      T || (ee(G), ee(u.$$.fragment, z), ee(p.$$.fragment, z), ee(D), ee(F), ee(j, z), ee(C), T = !0);
    },
    o(z) {
      ue(G), ue(u.$$.fragment, z), ue(p.$$.fragment, z), ue(D), ue(F), ue(j, z), ue(C), T = !1;
    },
    d(z) {
      z && (Vt(t), Vt(e)), si(u), n[61](null), si(p), D && D.d(), F && F.d(), j && j.d(z), ~b && U[b].d(), O = !1, ui(M);
    }
  };
}
function fE(n, t, e) {
  let i, { $$slots: s = {}, $$scope: u } = t, { class: h = void 0 } = t, { apiKey: c } = t, { bbox: g = void 0 } = t, { clearButtonTitle: m = "clear" } = t, { clearOnBlur: y = !1 } = t, { collapsed: p = !1 } = t, { country: _ = void 0 } = t, { debounceSearch: E = 200 } = t, { enableReverse: S = !1 } = t, { errorMessage: I = "Something went wrong" } = t, { filter: b = () => !0 } = t, { flyTo: C = !0 } = t, { fuzzyMatch: R = !0 } = t, { language: T = void 0 } = t, { limit: O = void 0 } = t, { mapController: M = void 0 } = t, { minLength: G = 2 } = t, { noResultsMessage: D = "Oops! Looks like you're trying to predict something that's not quite right. We can't seem to find what you're looking for. Maybe try double-checking your spelling or try a different search term. Keep on typing - we'll do our best to get you where you need to go!" } = t, { placeholder: F = "Search" } = t, { proximity: A = [{ type: "server-geolocation" }] } = t, { reverseActive: j = S === "always" } = t, { reverseButtonTitle: et = "toggle reverse geocoding" } = t, { searchValue: U = "" } = t, { showFullGeometry: nt = !0 } = t, { showPlaceType: z = "ifNeeded" } = t, { showResultsWhileTyping: K = !0 } = t, { selectFirst: Z = !0 } = t, { flyToSelected: at = !1 } = t, { markerOnSelected: gt = !0 } = t, { types: xt = void 0 } = t, { excludeTypes: Q = !1 } = t, { zoom: _t = 16 } = t, { maxZoom: Et = 18 } = t, { apiUrl: Wt = "https://api.maptiler.com/geocoding" } = t, { fetchParameters: X = {} } = t, { iconsBaseUrl: pe = "https://cdn.maptiler.com/maptiler-geocoding-control/v1.3.1/icons/" } = t, { adjustUrlQuery: Gn = () => {
  } } = t;
  function li() {
    ie.focus();
  }
  function B() {
    ie.blur();
  }
  function xr(Y, bt = !0, Tt = !1) {
    e(1, U = Y), bt ? (e(15, Gt = -1), xn()) : (fe(!Tt, Tt), setTimeout(() => {
      ie.focus(), ie.select();
    }));
  }
  function Ot() {
    e(14, mt = void 0), e(55, dt = void 0), e(15, Gt = -1);
  }
  function it() {
    e(54, Xt = []), e(55, dt = void 0);
  }
  let L = !1, mt, Xt, dt, an = "", ie, Gt = -1, H, Bn = [], Pe, re, hi, ht;
  const De = /* @__PURE__ */ new Set(), ce = E1();
  _1(() => {
    M && (M.setEventHandler(void 0), M.indicateReverse(!1), M.setSelectedMarker(-1), M.setMarkers(void 0, void 0));
  });
  function xn(Y) {
    if (re && (clearTimeout(re), re = void 0), Gt > -1 && mt)
      e(55, dt = mt[Gt]), e(1, U = dt.place_type[0] === "reverse" ? dt.place_name : dt.place_name.replace(/,.*/, "")), e(18, H = void 0), e(54, Xt = void 0), e(15, Gt = -1);
    else if (U) {
      const bt = Y || !rt(U);
      Ve(U, { exact: !0 }).then(() => {
        e(54, Xt = mt), e(55, dt = void 0), bt && It();
      }).catch((Tt) => e(18, H = Tt));
    }
  }
  function rt(Y) {
    try {
      return oE(Y, 6);
    } catch {
      return !1;
    }
  }
  async function Ve(Y, { byId: bt = !1, exact: Tt = !1 } = {}) {
    e(18, H = void 0), Pe == null || Pe.abort();
    const Ut = new AbortController();
    e(19, Pe = Ut);
    try {
      const yt = rt(Y), kt = new URLSearchParams();
      if (T !== void 0 && kt.set("language", Array.isArray(T) ? T.join(",") : T ?? ""), xt && kt.set("types", xt.join(",")), Q && kt.set("excludeTypes", String(Q)), g && kt.set("bbox", g.map((br) => br.toFixed(6)).join(",")), _ && kt.set("country", Array.isArray(_) ? _.join(",") : _), !bt && !yt) {
        const br = await H1(M, A, Ut);
        br && kt.set("proximity", br), (Tt || !K) && kt.set("autocomplete", "false"), kt.set("fuzzyMatch", String(R));
      }
      O !== void 0 && (!yt || (xt == null ? void 0 : xt.length) === 1) && kt.set("limit", String(O)), kt.set("key", c), Gn(kt);
      const Bt = Wt + "/" + encodeURIComponent(yt ? yt.decimalLongitude + "," + yt.decimalLatitude : Y) + ".json?" + kt.toString();
      if (Bt === an) {
        bt ? (e(14, mt = void 0), e(55, dt = Bn[0])) : e(14, mt = Bn);
        return;
      }
      an = Bt;
      const ve = await fetch(Bt, { signal: Ut.signal, ...X });
      if (!ve.ok)
        throw new Error(await ve.text());
      const wn = await ve.json();
      ce("response", { url: Bt, featureCollection: wn }), bt ? (e(14, mt = void 0), e(55, dt = wn.features[0]), Bn = [dt]) : (e(14, mt = wn.features.filter(b)), yt && mt.unshift({
        type: "Feature",
        properties: {},
        id: "reverse_" + yt.decimalLongitude + "_" + yt.decimalLatitude,
        text: yt.decimalLatitude + ", " + yt.decimalLongitude,
        place_name: yt.decimalLatitude + ", " + yt.decimalLongitude,
        place_type: ["reverse"],
        center: [yt.decimalLongitude, yt.decimalLatitude],
        bbox: [
          yt.decimalLongitude,
          yt.decimalLatitude,
          yt.decimalLongitude,
          yt.decimalLatitude
        ],
        geometry: {
          type: "Point",
          coordinates: [yt.decimalLongitude, yt.decimalLatitude]
        }
      }), Bn = mt, yt && ie.focus());
    } catch (yt) {
      if (yt && typeof yt == "object" && "name" in yt && yt.name === "AbortError")
        return;
      throw yt;
    } finally {
      Ut === Pe && e(19, Pe = void 0);
    }
  }
  function It() {
    var Tt;
    if (!(Xt != null && Xt.length) || !C)
      return;
    const Y = [180, 90, -180, -90], bt = !Xt.some((Ut) => !Ut.matching_text);
    for (const Ut of Xt)
      if (bt || !Ut.matching_text)
        for (const yt of [0, 1, 2, 3])
          Y[yt] = Math[yt < 2 ? "min" : "max"](Y[yt], ((Tt = Ut.bbox) == null ? void 0 : Tt[yt]) ?? Ut.center[yt % 2]);
    M && Xt.length > 0 && (dt && Y[0] === Y[2] && Y[1] === Y[3] ? M.flyTo(dt.center, _t) : M.fitBounds(df(Y), 50, Et));
  }
  function ct(Y) {
    e(0, j = S === "always"), e(14, mt = void 0), e(55, dt = void 0), e(15, Gt = -1), xr(Y[1].toFixed(6) + ", " + Z1(Y[0], [-180, 180], !0).toFixed(6), !1, !0);
  }
  function Sr(Y) {
    if (!mt)
      return;
    let bt = Y.key === "ArrowDown" ? 1 : Y.key === "ArrowUp" ? -1 : 0;
    bt && (Gt === (Z ? 0 : -1) && bt === -1 && e(15, Gt = mt.length), e(15, Gt += bt), Gt >= mt.length && e(15, Gt = -1), Gt < 0 && Z && e(15, Gt = 0), Y.preventDefault());
  }
  function fe(Y = !0, bt = !1) {
    if (e(18, H = void 0), K || bt) {
      if (re && clearTimeout(re), U.length < G)
        return;
      const Tt = U;
      re = window.setTimeout(
        () => {
          Ve(Tt).catch((Ut) => e(18, H = Ut));
        },
        Y ? E : 0
      );
    } else
      e(14, mt = void 0), e(18, H = void 0);
  }
  function zi(Y) {
    e(55, dt = Y), e(1, U = Y.place_name), e(15, Gt = -1);
  }
  const ut = () => ie.focus();
  function wr(Y) {
    dl[Y ? "unshift" : "push"](() => {
      ie = Y, e(17, ie);
    });
  }
  function Ir() {
    U = this.value, e(1, U), e(13, L), e(27, y);
  }
  const zn = () => e(13, L = !0), ge = () => e(13, L = !1), un = () => fe(), se = () => {
    e(1, U = ""), ie.focus();
  }, Sn = () => e(0, j = !j), Ze = () => e(18, H = void 0), kr = (Y) => e(15, Gt = Y), Yi = (Y) => zi(Y), Qt = () => {
    Z || e(15, Gt = -1);
  }, J = () => {
  };
  return n.$$set = (Y) => {
    "class" in Y && e(2, h = Y.class), "apiKey" in Y && e(25, c = Y.apiKey), "bbox" in Y && e(26, g = Y.bbox), "clearButtonTitle" in Y && e(3, m = Y.clearButtonTitle), "clearOnBlur" in Y && e(27, y = Y.clearOnBlur), "collapsed" in Y && e(4, p = Y.collapsed), "country" in Y && e(28, _ = Y.country), "debounceSearch" in Y && e(29, E = Y.debounceSearch), "enableReverse" in Y && e(5, S = Y.enableReverse), "errorMessage" in Y && e(6, I = Y.errorMessage), "filter" in Y && e(30, b = Y.filter), "flyTo" in Y && e(31, C = Y.flyTo), "fuzzyMatch" in Y && e(32, R = Y.fuzzyMatch), "language" in Y && e(33, T = Y.language), "limit" in Y && e(34, O = Y.limit), "mapController" in Y && e(35, M = Y.mapController), "minLength" in Y && e(36, G = Y.minLength), "noResultsMessage" in Y && e(7, D = Y.noResultsMessage), "placeholder" in Y && e(8, F = Y.placeholder), "proximity" in Y && e(37, A = Y.proximity), "reverseActive" in Y && e(0, j = Y.reverseActive), "reverseButtonTitle" in Y && e(9, et = Y.reverseButtonTitle), "searchValue" in Y && e(1, U = Y.searchValue), "showFullGeometry" in Y && e(38, nt = Y.showFullGeometry), "showPlaceType" in Y && e(10, z = Y.showPlaceType), "showResultsWhileTyping" in Y && e(39, K = Y.showResultsWhileTyping), "selectFirst" in Y && e(11, Z = Y.selectFirst), "flyToSelected" in Y && e(40, at = Y.flyToSelected), "markerOnSelected" in Y && e(41, gt = Y.markerOnSelected), "types" in Y && e(42, xt = Y.types), "excludeTypes" in Y && e(43, Q = Y.excludeTypes), "zoom" in Y && e(44, _t = Y.zoom), "maxZoom" in Y && e(45, Et = Y.maxZoom), "apiUrl" in Y && e(46, Wt = Y.apiUrl), "fetchParameters" in Y && e(47, X = Y.fetchParameters), "iconsBaseUrl" in Y && e(12, pe = Y.iconsBaseUrl), "adjustUrlQuery" in Y && e(48, Gn = Y.adjustUrlQuery), "$$scope" in Y && e(58, u = Y.$$scope);
  }, n.$$.update = () => {
    if (n.$$.dirty[0] & /*enableReverse*/
    32 && e(0, j = S === "always"), n.$$.dirty[0] & /*focused, clearOnBlur*/
    134225920 && setTimeout(() => {
      e(16, hi = L), y && !L && e(1, U = "");
    }), n.$$.dirty[0] & /*searchValue, listFeatures*/
    16386 | n.$$.dirty[1] & /*minLength*/
    32 && U.length < G && (e(55, dt = void 0), e(14, mt = void 0), e(18, H = void 0), e(54, Xt = mt)), n.$$.dirty[1] & /*showFullGeometry, picked*/
    16777344 && nt && dt && !dt.address && dt.geometry.type === "Point" && dt.place_type[0] !== "reverse" && Ve(dt.id, { byId: !0 }).catch((Y) => e(18, H = Y)), n.$$.dirty[1] & /*mapController, picked, prevIdToFly, flyTo, maxZoom, zoom*/
    50356241 && (M && dt && dt.id !== ht && C && (!dt.bbox || dt.bbox[0] === dt.bbox[2] && dt.bbox[1] === dt.bbox[3] ? M.flyTo(dt.center, dt.id.startsWith("poi.") || dt.id.startsWith("address.") ? Et : _t) : M.fitBounds(df(dt.bbox), 50, Et), e(14, mt = void 0), e(54, Xt = void 0), e(15, Gt = -1)), e(56, ht = dt == null ? void 0 : dt.id)), n.$$.dirty[0] & /*selectFirst, listFeatures*/
    18432 && Z && mt != null && mt.length && e(15, Gt = 0), n.$$.dirty[0] & /*selectFirst, searchValue*/
    2050 && (Z || e(15, Gt = -1)), n.$$.dirty[0] & /*listFeatures*/
    16384 | n.$$.dirty[1] & /*markedFeatures*/
    8388608 && Xt !== mt && e(54, Xt = void 0), n.$$.dirty[0] & /*reverseActive, listFeatures, focusedDelayed*/
    81921 | n.$$.dirty[1] & /*mapController, markedFeatures*/
    8388624 && M && M.setEventHandler((Y) => {
      switch (Y.type) {
        case "mapClick":
          j && ct(Y.coordinates);
          break;
        case "markerClick":
          {
            const bt = mt == null ? void 0 : mt.find((Tt) => Tt.id === Y.id);
            bt && zi(bt);
          }
          break;
        case "markerMouseEnter":
          Xt && e(15, Gt = hi ? (mt == null ? void 0 : mt.findIndex((bt) => bt.id === Y.id)) ?? -1 : -1);
          break;
        case "markerMouseLeave":
          Xt && e(15, Gt = -1);
          break;
      }
    }), n.$$.dirty[0] & /*listFeatures, selectedItemIndex*/
    49152 && e(57, i = mt == null ? void 0 : mt[Gt]), n.$$.dirty[1] & /*mapController, selected, flyTo, flyToSelected, maxZoom, zoom*/
    67133969 && M && i && C && at && M.flyTo(i.center, i.id.startsWith("poi.") || i.id.startsWith("address.") ? Et : _t), n.$$.dirty[1] & /*markerOnSelected, mapController*/
    1040 && (gt || M == null || M.setMarkers(void 0, void 0)), n.$$.dirty[1] & /*mapController, markerOnSelected, markedFeatures, selected*/
    75498512 && M && gt && !Xt && (M.setMarkers(i ? [i] : void 0, void 0), M.setSelectedMarker(i ? 0 : -1)), n.$$.dirty[1] & /*mapController, markedFeatures, picked*/
    25165840 && M && M.setMarkers(Xt, dt), n.$$.dirty[0] & /*selectedItemIndex*/
    32768 | n.$$.dirty[1] & /*markedFeatures, mapController*/
    8388624 && Xt && M && M.setSelectedMarker(Gt), n.$$.dirty[0] & /*searchValue*/
    2 | n.$$.dirty[1] & /*mapController*/
    16 && M) {
      const Y = rt(U);
      M.setReverseMarker(Y ? [Y.decimalLongitude, Y.decimalLatitude] : void 0);
    }
    n.$$.dirty[1] & /*selected*/
    67108864 && ce("select", i), n.$$.dirty[1] & /*picked*/
    16777216 && ce("pick", dt), n.$$.dirty[0] & /*focusedDelayed, listFeatures*/
    81920 && ce("optionsVisibilityChange", hi && !!mt), n.$$.dirty[0] & /*listFeatures*/
    16384 && ce("featuresListed", mt), n.$$.dirty[1] & /*markedFeatures*/
    8388608 && ce("featuresMarked", Xt), n.$$.dirty[0] & /*reverseActive*/
    1 && ce("reverseToggle", j), n.$$.dirty[0] & /*searchValue*/
    2 && ce("queryChange", U), n.$$.dirty[0] & /*reverseActive*/
    1 | n.$$.dirty[1] & /*mapController*/
    16 && M && M.indicateReverse(j);
  }, [
    j,
    U,
    h,
    m,
    p,
    S,
    I,
    D,
    F,
    et,
    z,
    Z,
    pe,
    L,
    mt,
    Gt,
    hi,
    ie,
    H,
    Pe,
    De,
    xn,
    Sr,
    fe,
    zi,
    c,
    g,
    y,
    _,
    E,
    b,
    C,
    R,
    T,
    O,
    M,
    G,
    A,
    nt,
    K,
    at,
    gt,
    xt,
    Q,
    _t,
    Et,
    Wt,
    X,
    Gn,
    li,
    B,
    xr,
    Ot,
    it,
    Xt,
    dt,
    ht,
    i,
    u,
    s,
    ut,
    wr,
    Ir,
    zn,
    ge,
    un,
    se,
    Sn,
    Ze,
    kr,
    Yi,
    Qt,
    J
  ];
}
let gE = class extends vr {
  constructor(t) {
    super(), pr(
      this,
      t,
      fE,
      cE,
      yr,
      {
        class: 2,
        apiKey: 25,
        bbox: 26,
        clearButtonTitle: 3,
        clearOnBlur: 27,
        collapsed: 4,
        country: 28,
        debounceSearch: 29,
        enableReverse: 5,
        errorMessage: 6,
        filter: 30,
        flyTo: 31,
        fuzzyMatch: 32,
        language: 33,
        limit: 34,
        mapController: 35,
        minLength: 36,
        noResultsMessage: 7,
        placeholder: 8,
        proximity: 37,
        reverseActive: 0,
        reverseButtonTitle: 9,
        searchValue: 1,
        showFullGeometry: 38,
        showPlaceType: 10,
        showResultsWhileTyping: 39,
        selectFirst: 11,
        flyToSelected: 40,
        markerOnSelected: 41,
        types: 42,
        excludeTypes: 43,
        zoom: 44,
        maxZoom: 45,
        apiUrl: 46,
        fetchParameters: 47,
        iconsBaseUrl: 12,
        adjustUrlQuery: 48,
        focus: 49,
        blur: 50,
        setQuery: 51,
        clearList: 52,
        clearMap: 53
      },
      null,
      [-1, -1, -1]
    );
  }
  get focus() {
    return this.$$.ctx[49];
  }
  get blur() {
    return this.$$.ctx[50];
  }
  get setQuery() {
    return this.$$.ctx[51];
  }
  get clearList() {
    return this.$$.ctx[52];
  }
  get clearMap() {
    return this.$$.ctx[53];
  }
};
class ya extends im {
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  constructor(t) {
    super(), this.geometries_ = t, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(Kn), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    const t = this.geometries_;
    for (let e = 0, i = t.length; e < i; ++e)
      this.changeEventsKeys_.push(
        On(t[e], pn.CHANGE, this.changed, this)
      );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const t = new ya(
      Tu(this.geometries_)
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    if (s < gr(this.getExtent(), t, e))
      return s;
    const u = this.geometries_;
    for (let h = 0, c = u.length; h < c; ++h)
      s = u[h].closestPointXY(
        t,
        e,
        i,
        s
      );
    return s;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    const i = this.geometries_;
    for (let s = 0, u = i.length; s < u; ++s)
      if (i[s].containsXY(t, e))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    Wa(t);
    const e = this.geometries_;
    for (let i = 0, s = e.length; i < s; ++i)
      Pv(t, e[i].getExtent());
    return t;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return Tu(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let t = [];
    const e = this.geometries_;
    for (let i = 0, s = e.length; i < s; ++i)
      e[i].getType() === this.getType() ? t = t.concat(
        /** @type {GeometryCollection} */
        e[i].getGeometriesArrayRecursive()
      ) : t.push(e[i]);
    return t;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const e = [], i = this.geometries_;
    let s = !1;
    for (let u = 0, h = i.length; u < h; ++u) {
      const c = i[u], g = c.getSimplifiedGeometry(t);
      e.push(g), g !== c && (s = !0);
    }
    return s ? new ya(
      e
    ) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const e = this.geometries_;
    for (let i = 0, s = e.length; i < s; ++i)
      if (e[i].intersectsExtent(t))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, e) {
    const i = this.geometries_;
    for (let s = 0, u = i.length; s < u; ++s)
      i[s].rotate(t, e);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, e, i) {
    i || (i = ar(this.getExtent()));
    const s = this.geometries_;
    for (let u = 0, h = s.length; u < h; ++u)
      s[u].scale(t, e, i);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(t) {
    this.setGeometriesArray(Tu(t));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(t) {
    this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(t) {
    const e = this.geometries_;
    for (let i = 0, s = e.length; i < s; ++i)
      e[i].applyTransform(t);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, e) {
    const i = this.geometries_;
    for (let s = 0, u = i.length; s < u; ++s)
      i[s].translate(t, e);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function Tu(n) {
  return n.map((t) => t.clone());
}
function pa(n, t, e, i, s, u, h) {
  let c, g;
  const m = (e - t) / i;
  if (m === 1)
    c = t;
  else if (m === 2)
    c = t, g = s;
  else if (m !== 0) {
    let y = n[t], p = n[t + 1], _ = 0;
    const E = [0];
    for (let b = t + i; b < e; b += i) {
      const C = n[b], R = n[b + 1];
      _ += Math.sqrt((C - y) * (C - y) + (R - p) * (R - p)), E.push(_), y = C, p = R;
    }
    const S = s * _, I = gv(E, S);
    I < 0 ? (g = (S - E[-I - 2]) / (E[-I - 1] - E[-I - 2]), c = t + (-I - 2) * i) : c = t + I * i;
  }
  h = h > 1 ? h : 2, u = u || new Array(h);
  for (let y = 0; y < h; ++y)
    u[y] = c === void 0 ? NaN : g === void 0 ? n[c + y] : Xe(n[c + y], n[c + i + y], g);
  return u;
}
function pl(n, t, e, i, s, u) {
  if (e == t)
    return null;
  let h;
  if (s < n[t + i - 1])
    return u ? (h = n.slice(t, t + i), h[i - 1] = s, h) : null;
  if (n[e - 1] < s)
    return u ? (h = n.slice(e - i, e), h[i - 1] = s, h) : null;
  if (s == n[t + i - 1])
    return n.slice(t, t + i);
  let c = t / i, g = e / i;
  for (; c < g; ) {
    const _ = c + g >> 1;
    s < n[(_ + 1) * i - 1] ? g = _ : c = _ + 1;
  }
  const m = n[c * i - 1];
  if (s == m)
    return n.slice((c - 1) * i, (c - 1) * i + i);
  const y = n[(c + 1) * i - 1], p = (s - m) / (y - m);
  h = [];
  for (let _ = 0; _ < i - 1; ++_)
    h.push(
      Xe(
        n[(c - 1) * i + _],
        n[c * i + _],
        p
      )
    );
  return h.push(s), h;
}
function dE(n, t, e, i, s, u, h) {
  if (h)
    return pl(
      n,
      t,
      e[e.length - 1],
      i,
      s,
      u
    );
  let c;
  if (s < n[i - 1])
    return u ? (c = n.slice(0, i), c[i - 1] = s, c) : null;
  if (n[n.length - 1] < s)
    return u ? (c = n.slice(n.length - i), c[i - 1] = s, c) : null;
  for (let g = 0, m = e.length; g < m; ++g) {
    const y = e[g];
    if (t != y) {
      if (s < n[t + i - 1])
        return null;
      if (s <= n[y - 1])
        return pl(
          n,
          t,
          y,
          i,
          s,
          !1
        );
      t = y;
    }
  }
  return null;
}
function Mm(n, t, e, i) {
  let s = n[t], u = n[t + 1], h = 0;
  for (let c = t + i; c < e; c += i) {
    const g = n[c], m = n[c + 1];
    h += Math.sqrt((g - s) * (g - s) + (m - u) * (m - u)), s = g, u = m;
  }
  return h;
}
class hr extends mr {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(t) {
    Mn(this.flatCoordinates, t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const t = new hr(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    return s < gr(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      ih(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), sh(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      e,
      i,
      s
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(t) {
    return um(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, e) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (e = e !== void 0 ? e : !1, pl(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return xi(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(t, e) {
    return pa(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return Mm(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
      0.5,
      this.flatMidpoint_ ?? void 0
    ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
    this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [];
    return e.length = qa(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      0
    ), new hr(e, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return Ua(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Xa(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
class co extends mr {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(t, e, i) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        t,
        e
      );
    else if (e !== void 0 && i)
      this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ), this.ends_ = i;
    else {
      const s = (
        /** @type {Array<LineString>} */
        t
      ), u = [], h = [];
      for (let g = 0, m = s.length; g < m; ++g) {
        const y = s[g];
        Mn(u, y.getFlatCoordinates()), h.push(u.length);
      }
      const c = s.length === 0 ? this.getLayout() : s[0].getLayout();
      this.setFlatCoordinates(c, u), this.ends_ = h;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(t) {
    Mn(this.flatCoordinates, t.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const t = new co(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    return s < gr(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      rh(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), oh(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      e,
      i,
      s
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, e, i) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (e = e !== void 0 ? e : !1, i = i !== void 0 ? i : !1, dE(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      e,
      i
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return $s(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(t) {
    return t < 0 || this.ends_.length <= t ? null : new hr(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const t = this.flatCoordinates, e = this.ends_, i = this.layout, s = [];
    let u = 0;
    for (let h = 0, c = e.length; h < c; ++h) {
      const g = e[h], m = new hr(
        t.slice(u, g),
        i
      );
      s.push(m), u = g;
    }
    return s;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const t = [], e = this.flatCoordinates;
    let i = 0;
    const s = this.ends_, u = this.stride;
    for (let h = 0, c = s.length; h < c; ++h) {
      const g = s[h], m = pa(
        e,
        i,
        g,
        u,
        0.5
      );
      Mn(t, m), i = g;
    }
    return t;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], i = [];
    return e.length = rm(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      e,
      0,
      i
    ), new co(e, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return P_(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = ah(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
}
class vh extends mr {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(t) {
    Mn(this.flatCoordinates, t.getFlatCoordinates()), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const t = new vh(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    if (s < gr(this.getExtent(), t, e))
      return s;
    const u = this.flatCoordinates, h = this.stride;
    for (let c = 0, g = u.length; c < g; c += h) {
      const m = nr(
        t,
        e,
        u[c],
        u[c + 1]
      );
      if (m < s) {
        s = m;
        for (let y = 0; y < h; ++y)
          i[y] = u[c + y];
        i.length = h;
      }
    }
    return s;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return xi(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(t) {
    const e = this.flatCoordinates.length / this.stride;
    return t < 0 || e <= t ? null : new Li(
      this.flatCoordinates.slice(
        t * this.stride,
        (t + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const t = this.flatCoordinates, e = this.layout, i = this.stride, s = [];
    for (let u = 0, h = t.length; u < h; u += i) {
      const c = new Li(t.slice(u, u + i), e);
      s.push(c);
    }
    return s;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const e = this.flatCoordinates, i = this.stride;
    for (let s = 0, u = e.length; s < u; s += i) {
      const h = e[s], c = e[s + 1];
      if ($l(t, h, c))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Xa(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
function Om(n, t, e, i) {
  const s = [];
  let u = sr();
  for (let h = 0, c = e.length; h < c; ++h) {
    const g = e[h];
    u = Jl(
      n,
      t,
      g[0],
      i
    ), s.push((u[0] + u[2]) / 2, (u[1] + u[3]) / 2), t = g[g.length - 1];
  }
  return s;
}
class fo extends mr {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(t, e, i) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i && !Array.isArray(t[0])) {
      const s = (
        /** @type {Array<Polygon>} */
        t
      ), u = [], h = [];
      for (let c = 0, g = s.length; c < g; ++c) {
        const m = s[c], y = u.length, p = m.getEnds();
        for (let _ = 0, E = p.length; _ < E; ++_)
          p[_] += y;
        Mn(u, m.getFlatCoordinates()), h.push(p);
      }
      e = s.length === 0 ? this.getLayout() : s[0].getLayout(), t = u, i = h;
    }
    e !== void 0 && i ? (this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ), this.endss_ = i) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      t,
      e
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(t) {
    let e;
    if (!this.flatCoordinates)
      this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push();
    else {
      const i = this.flatCoordinates.length;
      Mn(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice();
      for (let s = 0, u = e.length; s < u; ++s)
        e[s] += i;
    }
    this.endss_.push(e), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const t = this.endss_.length, e = new Array(t);
    for (let s = 0; s < t; ++s)
      e[s] = this.endss_[s].slice();
    const i = new fo(
      this.flatCoordinates.slice(),
      this.layout,
      e
    );
    return i.applyProperties(this), i;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, i, s) {
    return s < gr(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      b_(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), C_(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      i,
      s
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    return A_(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t,
      e
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return M_(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(t) {
    let e;
    return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), qc(
      e,
      0,
      this.endss_,
      this.stride,
      t
    )) : e = this.flatCoordinates, ul(
      e,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const t = Om(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = am(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.flatInteriorPoints_
    );
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new vh(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      B_(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = qc(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], i = [];
    return e.length = N_(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(t),
      e,
      0,
      i
    ), new fo(e, "XY", i);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(t) {
    if (t < 0 || this.endss_.length <= t)
      return null;
    let e;
    if (t === 0)
      e = 0;
    else {
      const u = this.endss_[t - 1];
      e = u[u.length - 1];
    }
    const i = this.endss_[t].slice(), s = i[i.length - 1];
    if (e !== 0)
      for (let u = 0, h = i.length; u < h; ++u)
        i[u] -= e;
    return new Oi(
      this.flatCoordinates.slice(e, s),
      this.layout,
      i
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const t = this.layout, e = this.flatCoordinates, i = this.endss_, s = [];
    let u = 0;
    for (let h = 0, c = i.length; h < c; ++h) {
      const g = i[h].slice(), m = g[g.length - 1];
      if (u !== 0)
        for (let p = 0, _ = g.length; p < _; ++p)
          g[p] -= u;
      const y = new Oi(
        e.slice(u, m),
        t,
        g
      );
      s.push(y), u = m;
    }
    return s;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return F_(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const i = L_(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.endss_
    );
    if (i.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const s = i[i.length - 1];
      this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1];
    }
    this.changed();
  }
}
const lt = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, zo = [lt.FILL], ki = [lt.STROKE], Qi = [lt.BEGIN_PATH], bf = [lt.CLOSE_PATH];
class Am {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(t, e, i, s, u) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(t) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(t) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(t, e, i) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(t, e, i) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(t, e, i) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(t, e, i) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(t, e, i) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(t, e, i) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(t, e, i) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(t, e, i) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(t, e, i) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(t, e, i) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, e) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(t, e) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(t, e) {
  }
}
class So extends Am {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, i, s) {
    super(), this.tolerance = t, this.maxExtent = e, this.pixelRatio = s, this.maxLineWidth = 0, this.resolution = i, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(t) {
    const e = this.pixelRatio;
    return e == 1 ? t : t.map(function(i) {
      return i * e;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(t, e) {
    const i = this.getBufferedMaxExtent(), s = this.tmpCoordinate_, u = this.coordinates;
    let h = u.length;
    for (let c = 0, g = t.length; c < g; c += e)
      s[0] = t[c], s[1] = t[c + 1], rl(i, s) && (u[h++] = s[0], u[h++] = s[1]);
    return h;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(t, e, i, s, u, h) {
    const c = this.coordinates;
    let g = c.length;
    const m = this.getBufferedMaxExtent();
    h && (e += s);
    let y = t[e], p = t[e + 1];
    const _ = this.tmpCoordinate_;
    let E = !0, S, I, b;
    for (S = e + s; S < i; S += s)
      _[0] = t[S], _[1] = t[S + 1], b = sl(m, _), b !== I ? (E && (c[g++] = y, c[g++] = p, E = !1), c[g++] = _[0], c[g++] = _[1]) : b === ae.INTERSECTING ? (c[g++] = _[0], c[g++] = _[1], E = !1) : E = !0, y = _[0], p = _[1], I = b;
    return (u && E || S === e + s) && (c[g++] = y, c[g++] = p), g;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(t, e, i, s, u) {
    for (let h = 0, c = i.length; h < c; ++h) {
      const g = i[h], m = this.appendFlatLineCoordinates(
        t,
        e,
        g,
        s,
        !1,
        !1
      );
      u.push(m), e = g;
    }
    return e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(t, e, i, s, u) {
    this.beginGeometry(t, e, u);
    const h = t.getType(), c = t.getStride(), g = this.coordinates.length;
    let m, y, p, _, E;
    switch (h) {
      case "MultiPolygon":
        m = /** @type {import("../../geom/MultiPolygon.js").default} */
        t.getOrientedFlatCoordinates(), _ = [];
        const S = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        E = 0;
        for (let I = 0, b = S.length; I < b; ++I) {
          const C = [];
          E = this.drawCustomCoordinates_(
            m,
            E,
            S[I],
            c,
            C
          ), _.push(C);
        }
        this.instructions.push([
          lt.CUSTOM,
          g,
          _,
          t,
          i,
          ul,
          u
        ]), this.hitDetectionInstructions.push([
          lt.CUSTOM,
          g,
          _,
          t,
          s || i,
          ul,
          u
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        p = [], m = h == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          t.getOrientedFlatCoordinates()
        ) : t.getFlatCoordinates(), E = this.drawCustomCoordinates_(
          m,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          t.getEnds(),
          c,
          p
        ), this.instructions.push([
          lt.CUSTOM,
          g,
          p,
          t,
          i,
          $s,
          u
        ]), this.hitDetectionInstructions.push([
          lt.CUSTOM,
          g,
          p,
          t,
          s || i,
          $s,
          u
        ]);
        break;
      case "LineString":
      case "Circle":
        m = t.getFlatCoordinates(), y = this.appendFlatLineCoordinates(
          m,
          0,
          m.length,
          c,
          !1,
          !1
        ), this.instructions.push([
          lt.CUSTOM,
          g,
          y,
          t,
          i,
          xi,
          u
        ]), this.hitDetectionInstructions.push([
          lt.CUSTOM,
          g,
          y,
          t,
          s || i,
          xi,
          u
        ]);
        break;
      case "MultiPoint":
        m = t.getFlatCoordinates(), y = this.appendFlatPointCoordinates(m, c), y > g && (this.instructions.push([
          lt.CUSTOM,
          g,
          y,
          t,
          i,
          xi,
          u
        ]), this.hitDetectionInstructions.push([
          lt.CUSTOM,
          g,
          y,
          t,
          s || i,
          xi,
          u
        ]));
        break;
      case "Point":
        m = t.getFlatCoordinates(), this.coordinates.push(m[0], m[1]), y = this.coordinates.length, this.instructions.push([
          lt.CUSTOM,
          g,
          y,
          t,
          i,
          void 0,
          u
        ]), this.hitDetectionInstructions.push([
          lt.CUSTOM,
          g,
          y,
          t,
          s || i,
          void 0,
          u
        ]);
        break;
    }
    this.endGeometry(e);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(t, e, i) {
    this.beginGeometryInstruction1_ = [
      lt.BEGIN_GEOMETRY,
      e,
      0,
      t,
      i
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      lt.BEGIN_GEOMETRY,
      e,
      0,
      t,
      i
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const t = this.hitDetectionInstructions;
    t.reverse();
    let e;
    const i = t.length;
    let s, u, h = -1;
    for (e = 0; e < i; ++e)
      s = t[e], u = /** @type {import("./Instruction.js").default} */
      s[0], u == lt.END_GEOMETRY ? h = e : u == lt.BEGIN_GEOMETRY && (s[2] = e, dv(this.hitDetectionInstructions, h, e), h = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, e) {
    const i = this.state;
    if (t) {
      const s = t.getColor();
      i.fillPatternScale = s && typeof s == "object" && "src" in s ? this.pixelRatio : 1, i.fillStyle = Tn(
        s || Oe
      );
    } else
      i.fillStyle = void 0;
    if (e) {
      const s = e.getColor();
      i.strokeStyle = Tn(
        s || io
      );
      const u = e.getLineCap();
      i.lineCap = u !== void 0 ? u : ns;
      const h = e.getLineDash();
      i.lineDash = h ? h.slice() : Jn;
      const c = e.getLineDashOffset();
      i.lineDashOffset = c || Qn;
      const g = e.getLineJoin();
      i.lineJoin = g !== void 0 ? g : is;
      const m = e.getWidth();
      i.lineWidth = m !== void 0 ? m : so;
      const y = e.getMiterLimit();
      i.miterLimit = y !== void 0 ? y : no, i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineDashOffset = void 0, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(t) {
    const e = t.fillStyle, i = [lt.SET_FILL_STYLE, e];
    return typeof e != "string" && i.push(t.fillPatternScale), i;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    this.instructions.push(this.createStroke(t));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(t) {
    return [
      lt.SET_STROKE_STYLE,
      t.strokeStyle,
      t.lineWidth * this.pixelRatio,
      t.lineCap,
      t.lineJoin,
      t.miterLimit,
      this.applyPixelRatio(t.lineDash),
      t.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(t, e) {
    const i = t.fillStyle;
    (typeof i != "string" || t.currentFillStyle != i) && (i !== void 0 && this.instructions.push(e.call(this, t)), t.currentFillStyle = i);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(t, e) {
    const i = t.strokeStyle, s = t.lineCap, u = t.lineDash, h = t.lineDashOffset, c = t.lineJoin, g = t.lineWidth, m = t.miterLimit;
    (t.currentStrokeStyle != i || t.currentLineCap != s || u != t.currentLineDash && !cs(t.currentLineDash, u) || t.currentLineDashOffset != h || t.currentLineJoin != c || t.currentLineWidth != g || t.currentMiterLimit != m) && (i !== void 0 && e.call(this, t), t.currentStrokeStyle = i, t.currentLineCap = s, t.currentLineDash = u, t.currentLineDashOffset = h, t.currentLineJoin = c, t.currentLineWidth = g, t.currentMiterLimit = m);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(t) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const e = [lt.END_GEOMETRY, t];
    this.instructions.push(e), this.hitDetectionInstructions.push(e);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = Av(this.maxExtent), this.maxLineWidth > 0)) {
      const t = this.resolution * (this.maxLineWidth + 1) / 2;
      Kl(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
class mE extends So {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, i, s) {
    super(t, e, i, s), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(t, e, i) {
    if (!this.image_ || this.maxExtent && !rl(this.maxExtent, t.getFlatCoordinates()))
      return;
    this.beginGeometry(t, e, i);
    const s = t.getFlatCoordinates(), u = t.getStride(), h = this.coordinates.length, c = this.appendFlatPointCoordinates(s, u);
    this.instructions.push([
      lt.DRAW_IMAGE,
      h,
      c,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      lt.DRAW_IMAGE,
      h,
      c,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(t, e, i) {
    if (!this.image_)
      return;
    this.beginGeometry(t, e, i);
    const s = t.getFlatCoordinates(), u = [];
    for (let g = 0, m = s.length; g < m; g += t.getStride())
      (!this.maxExtent || rl(this.maxExtent, s.slice(g, g + 2))) && u.push(
        s[g],
        s[g + 1]
      );
    const h = this.coordinates.length, c = this.appendFlatPointCoordinates(u, 2);
    this.instructions.push([
      lt.DRAW_IMAGE,
      h,
      c,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      lt.DRAW_IMAGE,
      h,
      c,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(t, e) {
    const i = t.getAnchor(), s = t.getSize(), u = t.getOrigin();
    this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = i[0], this.anchorY_ = i[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = s[1], this.opacity_ = t.getOpacity(), this.originX_ = u[0], this.originY_ = u[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = s[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
  }
}
class yE extends So {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, i, s) {
    super(t, e, i, s);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(t, e, i, s) {
    const u = this.coordinates.length, h = this.appendFlatLineCoordinates(
      t,
      e,
      i,
      s,
      !1,
      !1
    ), c = [
      lt.MOVE_TO_LINE_TO,
      u,
      h
    ];
    return this.instructions.push(c), this.hitDetectionInstructions.push(c), i;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(t, e, i) {
    const s = this.state, u = s.strokeStyle, h = s.lineWidth;
    if (u === void 0 || h === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, i), this.hitDetectionInstructions.push(
      [
        lt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        Jn,
        Qn
      ],
      Qi
    );
    const c = t.getFlatCoordinates(), g = t.getStride();
    this.drawFlatCoordinates_(
      c,
      0,
      c.length,
      g
    ), this.hitDetectionInstructions.push(ki), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(t, e, i) {
    const s = this.state, u = s.strokeStyle, h = s.lineWidth;
    if (u === void 0 || h === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, i), this.hitDetectionInstructions.push(
      [
        lt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        Jn,
        Qn
      ],
      Qi
    );
    const c = t.getEnds(), g = t.getFlatCoordinates(), m = t.getStride();
    let y = 0;
    for (let p = 0, _ = c.length; p < _; ++p)
      y = this.drawFlatCoordinates_(
        g,
        y,
        /** @type {number} */
        c[p],
        m
      );
    this.hitDetectionInstructions.push(ki), this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const t = this.state;
    return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(ki), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(ki), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(Qi);
  }
}
class Cf extends So {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, i, s) {
    super(t, e, i, s);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(t, e, i, s) {
    const u = this.state, h = u.fillStyle !== void 0, c = u.strokeStyle !== void 0, g = i.length;
    this.instructions.push(Qi), this.hitDetectionInstructions.push(Qi);
    for (let m = 0; m < g; ++m) {
      const y = i[m], p = this.coordinates.length, _ = this.appendFlatLineCoordinates(
        t,
        e,
        y,
        s,
        !0,
        !c
      ), E = [
        lt.MOVE_TO_LINE_TO,
        p,
        _
      ];
      this.instructions.push(E), this.hitDetectionInstructions.push(E), c && (this.instructions.push(bf), this.hitDetectionInstructions.push(bf)), e = y;
    }
    return h && (this.instructions.push(zo), this.hitDetectionInstructions.push(zo)), c && (this.instructions.push(ki), this.hitDetectionInstructions.push(ki)), e;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(t, e, i) {
    const s = this.state, u = s.fillStyle, h = s.strokeStyle;
    if (u === void 0 && h === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      lt.SET_FILL_STYLE,
      Oe
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      lt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      Jn,
      Qn
    ]);
    const c = t.getFlatCoordinates(), g = t.getStride(), m = this.coordinates.length;
    this.appendFlatLineCoordinates(
      c,
      0,
      c.length,
      g,
      !1,
      !1
    );
    const y = [lt.CIRCLE, m];
    this.instructions.push(Qi, y), this.hitDetectionInstructions.push(Qi, y), s.fillStyle !== void 0 && (this.instructions.push(zo), this.hitDetectionInstructions.push(zo)), s.strokeStyle !== void 0 && (this.instructions.push(ki), this.hitDetectionInstructions.push(ki)), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(t, e, i) {
    const s = this.state, u = s.fillStyle, h = s.strokeStyle;
    if (u === void 0 && h === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      lt.SET_FILL_STYLE,
      Oe
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      lt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      Jn,
      Qn
    ]);
    const c = t.getEnds(), g = t.getOrientedFlatCoordinates(), m = t.getStride();
    this.drawFlatCoordinatess_(
      g,
      0,
      /** @type {Array<number>} */
      c,
      m
    ), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(t, e, i) {
    const s = this.state, u = s.fillStyle, h = s.strokeStyle;
    if (u === void 0 && h === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, i), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      lt.SET_FILL_STYLE,
      Oe
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      lt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      Jn,
      Qn
    ]);
    const c = t.getEndss(), g = t.getOrientedFlatCoordinates(), m = t.getStride();
    let y = 0;
    for (let p = 0, _ = c.length; p < _; ++p)
      y = this.drawFlatCoordinatess_(
        g,
        y,
        c[p],
        m
      );
    this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const t = this.tolerance;
    if (t !== 0) {
      const e = this.coordinates;
      for (let i = 0, s = e.length; i < s; ++i)
        e[i] = Zi(e[i], t);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const t = this.state;
    t.fillStyle !== void 0 && this.updateFillStyle(t, this.createFill), t.strokeStyle !== void 0 && this.updateStrokeStyle(t, this.applyStroke);
  }
}
function pE(n, t, e, i, s) {
  const u = [];
  let h = e, c = 0, g = t.slice(e, 2);
  for (; c < n && h + s < i; ) {
    const [m, y] = g.slice(-2), p = t[h + s], _ = t[h + s + 1], E = Math.sqrt(
      (p - m) * (p - m) + (_ - y) * (_ - y)
    );
    if (c += E, c >= n) {
      const S = (n - c + E) / E, I = Xe(m, p, S), b = Xe(y, _, S);
      g.push(I, b), u.push(g), g = [I, b], c == n && (h += s), c = 0;
    } else if (c < n)
      g.push(
        t[h + s],
        t[h + s + 1]
      ), h += s;
    else {
      const S = E - c, I = Xe(m, p, S / E), b = Xe(y, _, S / E);
      g.push(I, b), u.push(g), g = [I, b], c = 0, h += s;
    }
  }
  return c > 0 && u.push(g), u;
}
function vE(n, t, e, i, s) {
  let u = e, h = e, c = 0, g = 0, m = e, y, p, _, E, S, I, b, C, R, T;
  for (p = e; p < i; p += s) {
    const O = t[p], M = t[p + 1];
    S !== void 0 && (R = O - S, T = M - I, E = Math.sqrt(R * R + T * T), b !== void 0 && (g += _, y = Math.acos((b * R + C * T) / (_ * E)), y > n && (g > c && (c = g, u = m, h = p), g = 0, m = p - s)), _ = E, b = R, C = T), S = O, I = M;
  }
  return g += E, g > c ? [m, p] : [u, h];
}
const va = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class _E extends So {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, i, s) {
    super(t, e, i, s), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[Oe] = { fillStyle: Oe }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const t = super.finish();
    return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(t, e, i) {
    const s = this.textFillState_, u = this.textStrokeState_, h = this.textState_;
    if (this.text_ === "" || !h || !s && !u)
      return;
    const c = this.coordinates;
    let g = c.length;
    const m = t.getType();
    let y = null, p = t.getStride();
    if (h.placement === "line" && (m == "LineString" || m == "MultiLineString" || m == "Polygon" || m == "MultiPolygon")) {
      if (!mn(this.maxExtent, t.getExtent()))
        return;
      let _;
      if (y = t.getFlatCoordinates(), m == "LineString")
        _ = [y.length];
      else if (m == "MultiLineString")
        _ = /** @type {import("../../geom/MultiLineString.js").default} */
        t.getEnds();
      else if (m == "Polygon")
        _ = /** @type {import("../../geom/Polygon.js").default} */
        t.getEnds().slice(0, 1);
      else if (m == "MultiPolygon") {
        const b = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        _ = [];
        for (let C = 0, R = b.length; C < R; ++C)
          _.push(b[C][0]);
      }
      this.beginGeometry(t, e, i);
      const E = h.repeat, S = E ? void 0 : h.textAlign;
      let I = 0;
      for (let b = 0, C = _.length; b < C; ++b) {
        let R;
        E ? R = pE(
          E * this.resolution,
          y,
          I,
          _[b],
          p
        ) : R = [y.slice(I, _[b])];
        for (let T = 0, O = R.length; T < O; ++T) {
          const M = R[T];
          let G = 0, D = M.length;
          if (S == null) {
            const A = vE(
              h.maxAngle,
              M,
              0,
              M.length,
              2
            );
            G = A[0], D = A[1];
          }
          for (let A = G; A < D; A += p)
            c.push(M[A], M[A + 1]);
          const F = c.length;
          I = _[b], this.drawChars_(g, F), g = F;
        }
      }
      this.endGeometry(e);
    } else {
      let _ = h.overflow ? null : [];
      switch (m) {
        case "Point":
        case "MultiPoint":
          y = /** @type {import("../../geom/MultiPoint.js").default} */
          t.getFlatCoordinates();
          break;
        case "LineString":
          y = /** @type {import("../../geom/LineString.js").default} */
          t.getFlatMidpoint();
          break;
        case "Circle":
          y = /** @type {import("../../geom/Circle.js").default} */
          t.getCenter();
          break;
        case "MultiLineString":
          y = /** @type {import("../../geom/MultiLineString.js").default} */
          t.getFlatMidpoints(), p = 2;
          break;
        case "Polygon":
          y = /** @type {import("../../geom/Polygon.js").default} */
          t.getFlatInteriorPoint(), h.overflow || _.push(y[2] / this.resolution), p = 3;
          break;
        case "MultiPolygon":
          const R = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getFlatInteriorPoints()
          );
          y = [];
          for (let T = 0, O = R.length; T < O; T += 3)
            h.overflow || _.push(R[T + 2] / this.resolution), y.push(R[T], R[T + 1]);
          if (y.length === 0)
            return;
          p = 2;
          break;
      }
      const E = this.appendFlatPointCoordinates(y, p);
      if (E === g)
        return;
      if (_ && (E - g) / 2 !== y.length / p) {
        let R = g / 2;
        _ = _.filter((T, O) => {
          const M = c[(R + O) * 2] === y[O * p] && c[(R + O) * 2 + 1] === y[O * p + 1];
          return M || --R, M;
        });
      }
      this.saveTextStates_(), (h.backgroundFill || h.backgroundStroke) && (this.setFillStrokeStyle(
        h.backgroundFill,
        h.backgroundStroke
      ), h.backgroundFill && this.updateFillStyle(this.state, this.createFill), h.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, e, i);
      let S = h.padding;
      if (S != $i && (h.scale[0] < 0 || h.scale[1] < 0)) {
        let R = h.padding[0], T = h.padding[1], O = h.padding[2], M = h.padding[3];
        h.scale[0] < 0 && (T = -T, M = -M), h.scale[1] < 0 && (R = -R, O = -O), S = [R, T, O, M];
      }
      const I = this.pixelRatio;
      this.instructions.push([
        lt.DRAW_IMAGE,
        g,
        E,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        S == $i ? $i : S.map(function(R) {
          return R * I;
        }),
        !!h.backgroundFill,
        !!h.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        _
      ]);
      const b = 1 / I, C = this.state.fillStyle;
      h.backgroundFill && (this.state.fillStyle = Oe, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([
        lt.DRAW_IMAGE,
        g,
        E,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [b, b],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        S,
        !!h.backgroundFill,
        !!h.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? Oe : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        _
      ]), h.backgroundFill && (this.state.fillStyle = C, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(e);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const t = this.textStrokeState_, e = this.textState_, i = this.textFillState_, s = this.strokeKey_;
    t && (s in this.strokeStates || (this.strokeStates[s] = {
      strokeStyle: t.strokeStyle,
      lineCap: t.lineCap,
      lineDashOffset: t.lineDashOffset,
      lineWidth: t.lineWidth,
      lineJoin: t.lineJoin,
      miterLimit: t.miterLimit,
      lineDash: t.lineDash
    }));
    const u = this.textKey_;
    u in this.textStates || (this.textStates[u] = {
      font: e.font,
      textAlign: e.textAlign || ro,
      justify: e.justify,
      textBaseline: e.textBaseline || fa,
      scale: e.scale
    });
    const h = this.fillKey_;
    i && (h in this.fillStates || (this.fillStates[h] = {
      fillStyle: i.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(t, e) {
    const i = this.textStrokeState_, s = this.textState_, u = this.strokeKey_, h = this.textKey_, c = this.fillKey_;
    this.saveTextStates_();
    const g = this.pixelRatio, m = va[s.textBaseline], y = this.textOffsetY_ * g, p = this.text_, _ = i ? i.lineWidth * Math.abs(s.scale[0]) / 2 : 0;
    this.instructions.push([
      lt.DRAW_CHARS,
      t,
      e,
      m,
      s.overflow,
      c,
      s.maxAngle,
      g,
      y,
      u,
      _ * g,
      p,
      h,
      1,
      this.declutterMode_
    ]), this.hitDetectionInstructions.push([
      lt.DRAW_CHARS,
      t,
      e,
      m,
      s.overflow,
      c && Oe,
      s.maxAngle,
      g,
      y,
      u,
      _ * g,
      p,
      h,
      1 / g,
      this.declutterMode_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(t, e) {
    let i, s, u;
    if (!t)
      this.text_ = "";
    else {
      const h = t.getFill();
      h ? (s = this.textFillState_, s || (s = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = s), s.fillStyle = Tn(
        h.getColor() || Oe
      )) : (s = null, this.textFillState_ = s);
      const c = t.getStroke();
      if (!c)
        u = null, this.textStrokeState_ = u;
      else {
        u = this.textStrokeState_, u || (u = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = u);
        const S = c.getLineDash(), I = c.getLineDashOffset(), b = c.getWidth(), C = c.getMiterLimit();
        u.lineCap = c.getLineCap() || ns, u.lineDash = S ? S.slice() : Jn, u.lineDashOffset = I === void 0 ? Qn : I, u.lineJoin = c.getLineJoin() || is, u.lineWidth = b === void 0 ? so : b, u.miterLimit = C === void 0 ? no : C, u.strokeStyle = Tn(
          c.getColor() || io
        );
      }
      i = this.textState_;
      const g = t.getFont() || mm;
      f0(g);
      const m = t.getScaleArray();
      i.overflow = t.getOverflow(), i.font = g, i.maxAngle = t.getMaxAngle(), i.placement = t.getPlacement(), i.textAlign = t.getTextAlign(), i.repeat = t.getRepeat(), i.justify = t.getJustify(), i.textBaseline = t.getTextBaseline() || fa, i.backgroundFill = t.getBackgroundFill(), i.backgroundStroke = t.getBackgroundStroke(), i.padding = t.getPadding() || $i, i.scale = m === void 0 ? [1, 1] : m;
      const y = t.getOffsetX(), p = t.getOffsetY(), _ = t.getRotateWithView(), E = t.getRotation();
      this.text_ = t.getText() || "", this.textOffsetX_ = y === void 0 ? 0 : y, this.textOffsetY_ = p === void 0 ? 0 : p, this.textRotateWithView_ = _ === void 0 ? !1 : _, this.textRotation_ = E === void 0 ? 0 : E, this.strokeKey_ = u ? (typeof u.strokeStyle == "string" ? u.strokeStyle : de(u.strokeStyle)) + u.lineCap + u.lineDashOffset + "|" + u.lineWidth + u.lineJoin + u.miterLimit + "[" + u.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i.textBaseline || "?"), this.fillKey_ = s && s.fillStyle ? typeof s.fillStyle == "string" ? s.fillStyle : "|" + de(s.fillStyle) : "";
    }
    this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
  }
}
const EE = {
  Circle: Cf,
  Default: So,
  Image: mE,
  LineString: yE,
  Polygon: Cf,
  Text: _E
};
class xE {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, i, s) {
    this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = s, this.resolution_ = i, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const t = {};
    for (const e in this.buildersByZIndex_) {
      t[e] = t[e] || {};
      const i = this.buildersByZIndex_[e];
      for (const s in i) {
        const u = i[s].finish();
        t[e][s] = u;
      }
    }
    return t;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(t, e) {
    const i = t !== void 0 ? t.toString() : "0";
    let s = this.buildersByZIndex_[i];
    s === void 0 && (s = {}, this.buildersByZIndex_[i] = s);
    let u = s[e];
    if (u === void 0) {
      const h = EE[e];
      u = new h(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), s[e] = u;
    }
    return u;
  }
}
class SE extends vo {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.declutterExecutorGroup = null;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return zt();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    return zt();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(t, e) {
    return zt();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(t, e, i) {
    t[e] || (t[e] = {}), t[e][i.tileCoord.toString()] = i;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(t, e, i) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (s, u) => {
        const h = this.loadedTileCallback.bind(this, i, s);
        return t.forEachLoadedTile(e, s, u, h);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, e, i, s, u) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(t) {
    const e = (
      /** @type {import("../Image.js").default} */
      t.target
    );
    (e.getState() === wt.LOADED || e.getState() === wt.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(t) {
    let e = t.getState();
    return e != wt.LOADED && e != wt.ERROR && t.addEventListener(pn.CHANGE, this.boundHandleImageChange_), e == wt.IDLE && (t.load(), e = t.getState()), e == wt.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const t = this.getLayer();
    t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(t) {
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
class Pm {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    Ye(this, "pushMethodArgs_", (...t) => (this.instructions_[this.zIndex + this.offset_].push(t), this));
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(CanvasRenderingContext2D.prototype, {
      get: (t, e) => {
        if (typeof /** @type {*} */
        nl()[e] == "function")
          return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e), this.pushMethodArgs_;
      },
      set: (t, e, i) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e, i), !0)
    });
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(t) {
    this.instructions_.forEach((e) => {
      for (let i = 0, s = e.length; i < s; i += 2) {
        const u = e[i], h = e[i + 1];
        if (typeof /** @type {*} */
        t[u] == "function")
          t[u](...h);
        else {
          if (typeof h == "function") {
            t[u] = h(t);
            continue;
          }
          t[u] = h;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const Rf = [];
let Ur = null;
function wE() {
  Ur = Ue(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class IE extends SE {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(t), this.container = null, this.renderedResolution, this.tempTransform = $n(), this.pixelTransform = $n(), this.inversePixelTransform = $n(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(t, e, i) {
    Ur || wE(), Ur.clearRect(0, 0, 1, 1);
    let s;
    try {
      Ur.drawImage(t, e, i, 1, 1, 0, 0, 1, 1), s = Ur.getImageData(0, 0, 1, 1).data;
    } catch {
      return Ur = null, null;
    }
    return s;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(t) {
    let i = this.getLayer().getBackground();
    return typeof i == "function" && (i = i(t.viewState.resolution)), i || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(t, e, i) {
    const s = this.getLayer().getClassName();
    let u, h;
    if (t && t.className === s && (!i || t && t.style.backgroundColor && cs(
      eo(t.style.backgroundColor),
      eo(i)
    ))) {
      const c = t.firstElementChild;
      c instanceof HTMLCanvasElement && (h = c.getContext("2d"));
    }
    if (h && h.canvas.style.transform === e ? (this.container = t, this.context = h, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      u = document.createElement("div"), u.className = s;
      let c = u.style;
      c.position = "absolute", c.width = "100%", c.height = "100%", h = Ue();
      const g = h.canvas;
      u.appendChild(g), c = g.style, c.position = "absolute", c.left = "0", c.transformOrigin = "top left", this.container = u, this.context = h;
    }
    !this.containerReused && i && !this.container.style.backgroundColor && (this.container.style.backgroundColor = i);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(t, e, i) {
    const s = Hd(i), u = Kd(i), h = Zd(i), c = Vd(i);
    Ne(e.coordinateToPixelTransform, s), Ne(e.coordinateToPixelTransform, u), Ne(e.coordinateToPixelTransform, h), Ne(e.coordinateToPixelTransform, c);
    const g = this.inversePixelTransform;
    Ne(g, s), Ne(g, u), Ne(g, h), Ne(g, c), t.save(), t.beginPath(), t.moveTo(Math.round(s[0]), Math.round(s[1])), t.lineTo(Math.round(u[0]), Math.round(u[1])), t.lineTo(Math.round(h[0]), Math.round(h[1])), t.lineTo(Math.round(c[0]), Math.round(c[1])), t.clip();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(t, e, i) {
    const s = this.getLayer();
    if (s.hasListener(t)) {
      const u = new u1(
        t,
        this.inversePixelTransform,
        i,
        e
      );
      s.dispatchEvent(u);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(t, e) {
    this.frameState = e, !e.declutter && this.dispatchRenderEvent_(Hi.PRERENDER, t, e);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(t, e) {
    e.declutter || this.dispatchRenderEvent_(Hi.POSTRENDER, t, e);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(t) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(t) {
    return t.declutter && !this.deferredContext_ && (this.deferredContext_ = new Pm()), t.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(t) {
    t.declutter && (this.dispatchRenderEvent_(
      Hi.PRERENDER,
      this.context,
      t
    ), t.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(t), this.dispatchRenderEvent_(
      Hi.POSTRENDER,
      this.context,
      t
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(t, e, i, s, u, h, c) {
    const g = u / 2, m = h / 2, y = s / e, p = -y, _ = -t[0] + c, E = -t[1];
    return dr(
      this.tempTransform,
      g,
      m,
      y,
      p,
      -i,
      _,
      E
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
function kE(n, t, e, i, s, u, h, c, g, m, y, p) {
  let _ = n[t], E = n[t + 1], S = 0, I = 0, b = 0, C = 0;
  function R() {
    S = _, I = E, t += i, _ = n[t], E = n[t + 1], C += b, b = Math.sqrt((_ - S) * (_ - S) + (E - I) * (E - I));
  }
  do
    R();
  while (t < e - i && C + b < u);
  let T = b === 0 ? 0 : (u - C) / b;
  const O = Xe(S, _, T), M = Xe(I, E, T), G = t - i, D = C, F = u + c * g(m, s, y);
  for (; t < e - i && C + b < F; )
    R();
  T = b === 0 ? 0 : (F - C) / b;
  const A = Xe(S, _, T), j = Xe(I, E, T);
  let et;
  if (p) {
    const Z = [O, M, A, j];
    nm(Z, 0, 4, 2, p, Z, Z), et = Z[0] > Z[2];
  } else
    et = O > A;
  const U = Math.PI, nt = [], z = G + i === t;
  t = G, b = 0, C = D, _ = n[t], E = n[t + 1];
  let K;
  if (z) {
    R(), K = Math.atan2(E - I, _ - S), et && (K += K > 0 ? -U : U);
    const Z = (A + O) / 2, at = (j + M) / 2;
    return nt[0] = [Z, at, (F - u) / 2, K, s], nt;
  }
  s = s.replace(/\n/g, " ");
  for (let Z = 0, at = s.length; Z < at; ) {
    R();
    let gt = Math.atan2(E - I, _ - S);
    if (et && (gt += gt > 0 ? -U : U), K !== void 0) {
      let X = gt - K;
      if (X += X > U ? -2 * U : X < -U ? 2 * U : 0, Math.abs(X) > h)
        return null;
    }
    K = gt;
    const xt = Z;
    let Q = 0;
    for (; Z < at; ++Z) {
      const X = et ? at - Z - 1 : Z, pe = c * g(m, s[X], y);
      if (t + i < e && C + b < u + Q + pe / 2)
        break;
      Q += pe;
    }
    if (Z === xt)
      continue;
    const _t = et ? s.substring(at - xt, at - Z) : s.substring(xt, Z);
    T = b === 0 ? 0 : (u + Q / 2 - C) / b;
    const Et = Xe(S, _, T), Wt = Xe(I, E, T);
    nt.push([Et, Wt, Q / 2, gt, _t]), u += Q;
  }
  return nt;
}
const Gr = sr(), mi = [], Un = [], jn = [], yi = [];
function Lf(n) {
  return n[3].declutterBox;
}
const Tf = new RegExp(
  /* eslint-disable prettier/prettier */
  "[-----]"
  /* eslint-enable prettier/prettier */
);
function Nu(n, t) {
  return t === "start" ? t = Tf.test(n) ? "right" : "left" : t === "end" && (t = Tf.test(n) ? "left" : "right"), va[t];
}
function bE(n, t, e) {
  return e > 0 && n.push(`
`, ""), n.push(t, ""), n;
}
class CE {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(t, e, i, s, u) {
    this.overlaps = i, this.pixelRatio = e, this.resolution = t, this.alignAndScaleFill_, this.instructions = s.instructions, this.coordinates = s.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = $n(), this.hitDetectionInstructions = s.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = s.fillStates || {}, this.strokeStates = s.strokeStates || {}, this.textStates = s.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = u ? new Pm() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(t, e, i, s) {
    const u = t + e + i + s;
    if (this.labels_[u])
      return this.labels_[u];
    const h = s ? this.strokeStates[s] : null, c = i ? this.fillStates[i] : null, g = this.textStates[e], m = this.pixelRatio, y = [
      g.scale[0] * m,
      g.scale[1] * m
    ], p = Array.isArray(t), _ = g.justify ? va[g.justify] : Nu(
      Array.isArray(t) ? t[0] : t,
      g.textAlign || ro
    ), E = s && h.lineWidth ? h.lineWidth : 0, S = p ? t : t.split(`
`).reduce(bE, []), { width: I, height: b, widths: C, heights: R, lineWidths: T } = d0(
      g,
      S
    ), O = I + E, M = [], G = (O + 2) * y[0], D = (b + E) * y[1], F = {
      width: G < 0 ? Math.floor(G) : Math.ceil(G),
      height: D < 0 ? Math.floor(D) : Math.ceil(D),
      contextInstructions: M
    };
    (y[0] != 1 || y[1] != 1) && M.push("scale", y), s && (M.push("strokeStyle", h.strokeStyle), M.push("lineWidth", E), M.push("lineCap", h.lineCap), M.push("lineJoin", h.lineJoin), M.push("miterLimit", h.miterLimit), M.push("setLineDash", [h.lineDash]), M.push("lineDashOffset", h.lineDashOffset)), i && M.push("fillStyle", c.fillStyle), M.push("textBaseline", "middle"), M.push("textAlign", "center");
    const A = 0.5 - _;
    let j = _ * O + A * E;
    const et = [], U = [];
    let nt = 0, z = 0, K = 0, Z = 0, at;
    for (let gt = 0, xt = S.length; gt < xt; gt += 2) {
      const Q = S[gt];
      if (Q === `
`) {
        z += nt, nt = 0, j = _ * O + A * E, ++Z;
        continue;
      }
      const _t = S[gt + 1] || g.font;
      _t !== at && (s && et.push("font", _t), i && U.push("font", _t), at = _t), nt = Math.max(nt, R[K]);
      const Et = [
        Q,
        j + A * C[K] + _ * (C[K] - T[Z]),
        0.5 * (E + nt) + z
      ];
      j += C[K], s && et.push("strokeText", Et), i && U.push("fillText", Et), ++K;
    }
    return Array.prototype.push.apply(M, et), Array.prototype.push.apply(M, U), this.labels_[u] = F, F;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(t, e, i, s, u, h, c) {
    t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, i), t.lineTo.apply(t, s), t.lineTo.apply(t, u), t.lineTo.apply(t, e), h && (this.alignAndScaleFill_ = /** @type {number} */
    h[2], this.fill_(t)), c && (this.setStrokeStyle_(
      t,
      /** @type {Array<*>} */
      c
    ), t.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(t, e, i, s, u, h, c, g, m, y, p, _, E, S, I, b) {
    c *= _[0], g *= _[1];
    let C = i - c, R = s - g;
    const T = u + m > t ? t - m : u, O = h + y > e ? e - y : h, M = S[3] + T * _[0] + S[1], G = S[0] + O * _[1] + S[2], D = C - S[3], F = R - S[0];
    (I || p !== 0) && (mi[0] = D, yi[0] = D, mi[1] = F, Un[1] = F, Un[0] = D + M, jn[0] = Un[0], jn[1] = F + G, yi[1] = jn[1]);
    let A;
    return p !== 0 ? (A = dr(
      $n(),
      i,
      s,
      1,
      1,
      p,
      -i,
      -s
    ), Ne(A, mi), Ne(A, Un), Ne(A, jn), Ne(A, yi), or(
      Math.min(mi[0], Un[0], jn[0], yi[0]),
      Math.min(mi[1], Un[1], jn[1], yi[1]),
      Math.max(mi[0], Un[0], jn[0], yi[0]),
      Math.max(mi[1], Un[1], jn[1], yi[1]),
      Gr
    )) : or(
      Math.min(D, D + M),
      Math.min(F, F + G),
      Math.max(D, D + M),
      Math.max(F, F + G),
      Gr
    ), E && (C = Math.round(C), R = Math.round(R)), {
      drawImageX: C,
      drawImageY: R,
      drawImageW: T,
      drawImageH: O,
      originX: m,
      originY: y,
      declutterBox: {
        minX: Gr[0],
        minY: Gr[1],
        maxX: Gr[2],
        maxY: Gr[3],
        value: b
      },
      canvasTransform: A,
      scale: _
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(t, e, i, s, u, h, c) {
    const g = !!(h || c), m = s.declutterBox, y = c ? c[2] * s.scale[0] / 2 : 0;
    return m.minX - y <= e[0] && m.maxX + y >= 0 && m.minY - y <= e[1] && m.maxY + y >= 0 && (g && this.replayTextBackground_(
      t,
      mi,
      Un,
      jn,
      yi,
      /** @type {Array<*>} */
      h,
      /** @type {Array<*>} */
      c
    ), m0(
      t,
      s.canvasTransform,
      u,
      i,
      s.originX,
      s.originY,
      s.drawImageW,
      s.drawImageH,
      s.drawImageX,
      s.drawImageY,
      s.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(t) {
    const e = this.alignAndScaleFill_;
    if (e) {
      const i = Ne(this.renderedTransform_, [0, 0]), s = 512 * this.pixelRatio;
      t.save(), t.translate(i[0] % s, i[1] % s), e !== 1 && t.scale(e, e), t.rotate(this.viewRotation_);
    }
    t.fill(), e && t.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(t, e) {
    t.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    e[1], t.lineWidth = /** @type {number} */
    e[2], t.lineCap = /** @type {CanvasLineCap} */
    e[3], t.lineJoin = /** @type {CanvasLineJoin} */
    e[4], t.miterLimit = /** @type {number} */
    e[5], t.lineDashOffset = /** @type {number} */
    e[7], t.setLineDash(
      /** @type {Array<number>} */
      e[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(t, e, i, s) {
    const u = this.textStates[e], h = this.createLabel(t, e, s, i), c = this.strokeStates[i], g = this.pixelRatio, m = Nu(
      Array.isArray(t) ? t[0] : t,
      u.textAlign || ro
    ), y = va[u.textBaseline || fa], p = c && c.lineWidth ? c.lineWidth : 0, _ = h.width / g - 2 * u.scale[0], E = m * _ + 2 * (0.5 - m) * p, S = y * h.height / g + 2 * (0.5 - y) * p;
    return {
      label: h,
      anchorX: E,
      anchorY: S
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(t, e, i, s, u, h, c, g) {
    const m = this.zIndexContext_;
    let y;
    this.pixelCoordinates_ && cs(i, this.renderedTransform_) ? y = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), y = Ri(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      i,
      this.pixelCoordinates_
    ), v_(this.renderedTransform_, i));
    let p = 0;
    const _ = s.length;
    let E = 0, S, I, b, C, R, T, O, M, G, D, F, A, j, et = 0, U = 0, nt = null, z = null;
    const K = this.coordinateCache_, Z = this.viewRotation_, at = Math.round(Math.atan2(-i[1], i[0]) * 1e12) / 1e12, gt = (
      /** @type {import("../../render.js").State} */
      {
        context: t,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: Z
      }
    ), xt = this.instructions != s || this.overlaps ? 0 : 200;
    let Q, _t, Et, Wt;
    for (; p < _; ) {
      const X = s[p];
      switch (
        /** @type {import("./Instruction.js").default} */
        X[0]
      ) {
        case lt.BEGIN_GEOMETRY:
          Q = /** @type {import("../../Feature.js").FeatureLike} */
          X[1], Wt = X[3], Q.getGeometry() ? c !== void 0 && !mn(c, Wt.getExtent()) ? p = /** @type {number} */
          X[2] + 1 : ++p : p = /** @type {number} */
          X[2], m && (m.zIndex = X[4]);
          break;
        case lt.BEGIN_PATH:
          et > xt && (this.fill_(t), et = 0), U > xt && (t.stroke(), U = 0), !et && !U && (t.beginPath(), R = NaN, T = NaN), ++p;
          break;
        case lt.CIRCLE:
          E = /** @type {number} */
          X[1];
          const Gn = y[E], li = y[E + 1], B = y[E + 2], xr = y[E + 3], Ot = B - Gn, it = xr - li, L = Math.sqrt(Ot * Ot + it * it);
          t.moveTo(Gn + L, li), t.arc(Gn, li, L, 0, 2 * Math.PI, !0), ++p;
          break;
        case lt.CLOSE_PATH:
          t.closePath(), ++p;
          break;
        case lt.CUSTOM:
          E = /** @type {number} */
          X[1], S = X[2];
          const mt = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            X[3]
          ), Xt = X[4], dt = X[5];
          gt.geometry = mt, gt.feature = Q, p in K || (K[p] = []);
          const an = K[p];
          dt ? dt(y, E, S, 2, an) : (an[0] = y[E], an[1] = y[E + 1], an.length = 2), m && (m.zIndex = X[6]), Xt(an, gt), ++p;
          break;
        case lt.DRAW_IMAGE:
          E = /** @type {number} */
          X[1], S = /** @type {number} */
          X[2], G = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          X[3], I = /** @type {number} */
          X[4], b = /** @type {number} */
          X[5];
          let ie = (
            /** @type {number} */
            X[6]
          );
          const Gt = (
            /** @type {number} */
            X[7]
          ), H = (
            /** @type {number} */
            X[8]
          ), Bn = (
            /** @type {number} */
            X[9]
          ), Pe = (
            /** @type {boolean} */
            X[10]
          );
          let re = (
            /** @type {number} */
            X[11]
          );
          const hi = (
            /** @type {import("../../size.js").Size} */
            X[12]
          );
          let ht = (
            /** @type {number} */
            X[13]
          );
          C = X[14] || "declutter";
          const De = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            X[15]
          );
          if (!G && X.length >= 20) {
            D = /** @type {string} */
            X[19], F = /** @type {string} */
            X[20], A = /** @type {string} */
            X[21], j = /** @type {string} */
            X[22];
            const Qt = this.drawLabelWithPointPlacement_(
              D,
              F,
              A,
              j
            );
            G = Qt.label, X[3] = G;
            const J = (
              /** @type {number} */
              X[23]
            );
            I = (Qt.anchorX - J) * this.pixelRatio, X[4] = I;
            const Y = (
              /** @type {number} */
              X[24]
            );
            b = (Qt.anchorY - Y) * this.pixelRatio, X[5] = b, ie = G.height, X[6] = ie, ht = G.width, X[13] = ht;
          }
          let ce;
          X.length > 25 && (ce = /** @type {number} */
          X[25]);
          let xn, rt, Ve;
          X.length > 17 ? (xn = /** @type {Array<number>} */
          X[16], rt = /** @type {boolean} */
          X[17], Ve = /** @type {boolean} */
          X[18]) : (xn = $i, rt = !1, Ve = !1), Pe && at ? re += Z : !Pe && !at && (re -= Z);
          let It = 0;
          for (; E < S; E += 2) {
            if (ce && ce[It++] < ht / this.pixelRatio)
              continue;
            const Qt = this.calculateImageOrLabelDimensions_(
              G.width,
              G.height,
              y[E],
              y[E + 1],
              ht,
              ie,
              I,
              b,
              H,
              Bn,
              re,
              hi,
              u,
              xn,
              rt || Ve,
              Q
            ), J = [
              t,
              e,
              G,
              Qt,
              Gt,
              rt ? (
                /** @type {Array<*>} */
                nt
              ) : null,
              Ve ? (
                /** @type {Array<*>} */
                z
              ) : null
            ];
            if (g) {
              let Y, bt, Tt;
              if (De) {
                const kt = S - E;
                if (!De[kt]) {
                  De[kt] = { args: J, declutterMode: C };
                  continue;
                }
                const Bt = De[kt];
                Y = Bt.args, bt = Bt.declutterMode, delete De[kt], Tt = Lf(Y);
              }
              let Ut, yt;
              if (Y && (bt !== "declutter" || !g.collides(Tt)) && (Ut = !0), (C !== "declutter" || !g.collides(Qt.declutterBox)) && (yt = !0), bt === "declutter" && C === "declutter") {
                const kt = Ut && yt;
                Ut = kt, yt = kt;
              }
              Ut && (bt !== "none" && g.insert(Tt), this.replayImageOrLabel_.apply(this, Y)), yt && (C !== "none" && g.insert(Qt.declutterBox), this.replayImageOrLabel_.apply(this, J));
            } else
              this.replayImageOrLabel_.apply(this, J);
          }
          ++p;
          break;
        case lt.DRAW_CHARS:
          const ct = (
            /** @type {number} */
            X[1]
          ), Sr = (
            /** @type {number} */
            X[2]
          ), fe = (
            /** @type {number} */
            X[3]
          ), zi = (
            /** @type {number} */
            X[4]
          );
          j = /** @type {string} */
          X[5];
          const ut = (
            /** @type {number} */
            X[6]
          ), wr = (
            /** @type {number} */
            X[7]
          ), Ir = (
            /** @type {number} */
            X[8]
          );
          A = /** @type {string} */
          X[9];
          const zn = (
            /** @type {number} */
            X[10]
          );
          D = /** @type {string} */
          X[11], F = /** @type {string} */
          X[12];
          const ge = [
            /** @type {number} */
            X[13],
            /** @type {number} */
            X[13]
          ];
          C = X[14] || "declutter";
          const un = this.textStates[F], se = un.font, Sn = [
            un.scale[0] * wr,
            un.scale[1] * wr
          ];
          let Ze;
          se in this.widths_ ? Ze = this.widths_[se] : (Ze = {}, this.widths_[se] = Ze);
          const kr = Mm(y, ct, Sr, 2), Yi = Math.abs(Sn[0]) * $c(se, D, Ze);
          if (zi || Yi <= kr) {
            const Qt = this.textStates[F].textAlign, J = (kr - Yi) * Nu(D, Qt), Y = kE(
              y,
              ct,
              Sr,
              2,
              D,
              J,
              ut,
              Math.abs(Sn[0]),
              $c,
              se,
              Ze,
              at ? 0 : this.viewRotation_
            );
            t: if (Y) {
              const bt = [];
              let Tt, Ut, yt, kt, Bt;
              if (A)
                for (Tt = 0, Ut = Y.length; Tt < Ut; ++Tt) {
                  Bt = Y[Tt], yt = /** @type {string} */
                  Bt[4], kt = this.createLabel(yt, F, "", A), I = /** @type {number} */
                  Bt[2] + (Sn[0] < 0 ? -zn : zn), b = fe * kt.height + (0.5 - fe) * 2 * zn * Sn[1] / Sn[0] - Ir;
                  const ve = this.calculateImageOrLabelDimensions_(
                    kt.width,
                    kt.height,
                    Bt[0],
                    Bt[1],
                    kt.width,
                    kt.height,
                    I,
                    b,
                    0,
                    0,
                    Bt[3],
                    ge,
                    !1,
                    $i,
                    !1,
                    Q
                  );
                  if (g && C === "declutter" && g.collides(ve.declutterBox))
                    break t;
                  bt.push([
                    t,
                    e,
                    kt,
                    ve,
                    1,
                    null,
                    null
                  ]);
                }
              if (j)
                for (Tt = 0, Ut = Y.length; Tt < Ut; ++Tt) {
                  Bt = Y[Tt], yt = /** @type {string} */
                  Bt[4], kt = this.createLabel(yt, F, j, ""), I = /** @type {number} */
                  Bt[2], b = fe * kt.height - Ir;
                  const ve = this.calculateImageOrLabelDimensions_(
                    kt.width,
                    kt.height,
                    Bt[0],
                    Bt[1],
                    kt.width,
                    kt.height,
                    I,
                    b,
                    0,
                    0,
                    Bt[3],
                    ge,
                    !1,
                    $i,
                    !1,
                    Q
                  );
                  if (g && C === "declutter" && g.collides(ve.declutterBox))
                    break t;
                  bt.push([
                    t,
                    e,
                    kt,
                    ve,
                    1,
                    null,
                    null
                  ]);
                }
              g && C !== "none" && g.load(bt.map(Lf));
              for (let ve = 0, wn = bt.length; ve < wn; ++ve)
                this.replayImageOrLabel_.apply(this, bt[ve]);
            }
          }
          ++p;
          break;
        case lt.END_GEOMETRY:
          if (h !== void 0) {
            Q = /** @type {import("../../Feature.js").FeatureLike} */
            X[1];
            const Qt = h(Q, Wt);
            if (Qt)
              return Qt;
          }
          ++p;
          break;
        case lt.FILL:
          xt ? et++ : this.fill_(t), ++p;
          break;
        case lt.MOVE_TO_LINE_TO:
          for (E = /** @type {number} */
          X[1], S = /** @type {number} */
          X[2], _t = y[E], Et = y[E + 1], O = _t + 0.5 | 0, M = Et + 0.5 | 0, (O !== R || M !== T) && (t.moveTo(_t, Et), R = O, T = M), E += 2; E < S; E += 2)
            _t = y[E], Et = y[E + 1], O = _t + 0.5 | 0, M = Et + 0.5 | 0, (E == S - 2 || O !== R || M !== T) && (t.lineTo(_t, Et), R = O, T = M);
          ++p;
          break;
        case lt.SET_FILL_STYLE:
          nt = X, this.alignAndScaleFill_ = X[2], et && (this.fill_(t), et = 0, U && (t.stroke(), U = 0)), t.fillStyle = X[1], ++p;
          break;
        case lt.SET_STROKE_STYLE:
          z = X, U && (t.stroke(), U = 0), this.setStrokeStyle_(
            t,
            /** @type {Array<*>} */
            X
          ), ++p;
          break;
        case lt.STROKE:
          xt ? U++ : t.stroke(), ++p;
          break;
        default:
          ++p;
          break;
      }
    }
    et && this.fill_(t), U && t.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(t, e, i, s, u, h) {
    this.viewRotation_ = s, this.execute_(
      t,
      e,
      i,
      this.instructions,
      u,
      void 0,
      void 0,
      h
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(t, e, i, s, u) {
    return this.viewRotation_ = i, this.execute_(
      t,
      [t.canvas.width, t.canvas.height],
      e,
      this.hitDetectionInstructions,
      !0,
      s,
      u
    );
  }
}
const js = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], Dm = ["Image", "Text"], RE = js.filter(
  (n) => !Dm.includes(n)
);
class LE {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(t, e, i, s, u, h, c) {
    this.maxExtent_ = t, this.overlaps_ = s, this.pixelRatio_ = i, this.resolution_ = e, this.renderBuffer_ = h, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = $n(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(u, c);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(t, e) {
    const i = this.getClipCoords(e);
    t.beginPath(), t.moveTo(i[0], i[1]), t.lineTo(i[2], i[3]), t.lineTo(i[4], i[5]), t.lineTo(i[6], i[7]), t.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(t, e) {
    for (const i in t) {
      let s = this.executorsByZIndex_[i];
      s === void 0 && (s = {}, this.executorsByZIndex_[i] = s);
      const u = t[i];
      for (const h in u) {
        const c = u[h];
        s[h] = new CE(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          c,
          e
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(t) {
    for (const e in this.executorsByZIndex_) {
      const i = this.executorsByZIndex_[e];
      for (let s = 0, u = t.length; s < u; ++s)
        if (t[s] in i)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, e, i, s, u, h) {
    s = Math.round(s);
    const c = s * 2 + 1, g = dr(
      this.hitDetectionTransform_,
      s + 0.5,
      s + 0.5,
      1 / e,
      -1 / e,
      -i,
      -t[0],
      -t[1]
    ), m = !this.hitDetectionContext_;
    m && (this.hitDetectionContext_ = Ue(
      c,
      c,
      void 0,
      { willReadFrequently: !0 }
    ));
    const y = this.hitDetectionContext_;
    y.canvas.width !== c || y.canvas.height !== c ? (y.canvas.width = c, y.canvas.height = c) : m || y.clearRect(0, 0, c, c);
    let p;
    this.renderBuffer_ !== void 0 && (p = sr(), Dv(p, t), Kl(
      p,
      e * (this.renderBuffer_ + s),
      p
    ));
    const _ = TE(s);
    let E;
    function S(M, G) {
      const D = y.getImageData(
        0,
        0,
        c,
        c
      ).data;
      for (let F = 0, A = _.length; F < A; F++)
        if (D[_[F]] > 0) {
          if (!h || E !== "Image" && E !== "Text" || h.includes(M)) {
            const j = (_[F] - 3) / 4, et = s - j % c, U = s - (j / c | 0), nt = u(M, G, et * et + U * U);
            if (nt)
              return nt;
          }
          y.clearRect(0, 0, c, c);
          break;
        }
    }
    const I = Object.keys(this.executorsByZIndex_).map(Number);
    I.sort(er);
    let b, C, R, T, O;
    for (b = I.length - 1; b >= 0; --b) {
      const M = I[b].toString();
      for (R = this.executorsByZIndex_[M], C = js.length - 1; C >= 0; --C)
        if (E = js[C], T = R[E], T !== void 0 && (O = T.executeHitDetection(
          y,
          g,
          i,
          S,
          p
        ), O))
          return O;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(t) {
    const e = this.maxExtent_;
    if (!e)
      return null;
    const i = e[0], s = e[1], u = e[2], h = e[3], c = [i, s, i, h, u, h, u, s];
    return Ri(c, 0, 8, 2, t, c), c;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return es(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(t, e, i, s, u, h, c) {
    const g = Object.keys(this.executorsByZIndex_).map(Number);
    g.sort(er), h = h || js;
    let m, y, p, _, E, S;
    for (c && g.reverse(), m = 0, y = g.length; m < y; ++m) {
      const I = g[m].toString();
      for (E = this.executorsByZIndex_[I], p = 0, _ = h.length; p < _; ++p) {
        const b = h[p];
        if (S = E[b], S !== void 0) {
          const C = c === null ? void 0 : S.getZIndexContext(), R = C ? C.getContext() : t, T = this.maxExtent_ && b !== "Image" && b !== "Text";
          if (T && (R.save(), this.clip(R, i)), S.execute(
            R,
            e,
            i,
            s,
            u,
            c
          ), T && R.restore(), C) {
            C.offset();
            const O = g[m];
            this.deferredZIndexContexts_[O] || (this.deferredZIndexContexts_[O] = []), this.deferredZIndexContexts_[O].push(C);
          }
        }
      }
    }
    this.renderedContext_ = t;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const t = this.deferredZIndexContexts_, e = Object.keys(t).map(Number).sort(er);
    for (let i = 0, s = e.length; i < s; ++i)
      t[e[i]].forEach((u) => {
        u.draw(this.renderedContext_), u.clear();
      });
  }
}
const Mu = {};
function TE(n) {
  if (Mu[n] !== void 0)
    return Mu[n];
  const t = n * 2 + 1, e = n * n, i = new Array(e + 1);
  for (let u = 0; u <= n; ++u)
    for (let h = 0; h <= n; ++h) {
      const c = u * u + h * h;
      if (c > e)
        break;
      let g = i[c];
      g || (g = [], i[c] = g), g.push(((n + u) * t + (n + h)) * 4 + 3), u > 0 && g.push(((n - u) * t + (n + h)) * 4 + 3), h > 0 && (g.push(((n + u) * t + (n - h)) * 4 + 3), u > 0 && g.push(((n - u) * t + (n - h)) * 4 + 3));
    }
  const s = [];
  for (let u = 0, h = i.length; u < h; ++u)
    i[u] && s.push(...i[u]);
  return Mu[n] = s, s;
}
class NE extends Am {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(t, e, i, s, u, h, c) {
    super(), this.context_ = t, this.pixelRatio_ = e, this.extent_ = i, this.transform_ = s, this.transformRotation_ = s ? Vv(Math.atan2(s[1], s[0]), 10) : 0, this.viewRotation_ = u, this.squaredTolerance_ = h, this.userTransform_ = c, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = $n();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(t, e, i, s) {
    if (!this.image_)
      return;
    const u = Ri(
      t,
      e,
      i,
      s,
      this.transform_,
      this.pixelCoordinates_
    ), h = this.context_, c = this.tmpLocalTransform_, g = h.globalAlpha;
    this.imageOpacity_ != 1 && (h.globalAlpha = g * this.imageOpacity_);
    let m = this.imageRotation_;
    this.transformRotation_ === 0 && (m -= this.viewRotation_), this.imageRotateWithView_ && (m += this.viewRotation_);
    for (let y = 0, p = u.length; y < p; y += 2) {
      const _ = u[y] - this.imageAnchorX_, E = u[y + 1] - this.imageAnchorY_;
      if (m !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const S = _ + this.imageAnchorX_, I = E + this.imageAnchorY_;
        dr(
          c,
          S,
          I,
          1,
          1,
          m,
          -S,
          -I
        ), h.save(), h.transform.apply(h, c), h.translate(S, I), h.scale(this.imageScale_[0], this.imageScale_[1]), h.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), h.restore();
      } else
        h.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          _,
          E,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (h.globalAlpha = g);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(t, e, i, s) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const u = Ri(
      t,
      e,
      i,
      s,
      this.transform_,
      this.pixelCoordinates_
    ), h = this.context_;
    let c = this.textRotation_;
    for (this.transformRotation_ === 0 && (c -= this.viewRotation_), this.textRotateWithView_ && (c += this.viewRotation_); e < i; e += s) {
      const g = u[e] + this.textOffsetX_, m = u[e + 1] + this.textOffsetY_;
      c !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (h.save(), h.translate(g - this.textOffsetX_, m - this.textOffsetY_), h.rotate(c), h.translate(this.textOffsetX_, this.textOffsetY_), h.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && h.strokeText(this.text_, 0, 0), this.textFillState_ && h.fillText(this.text_, 0, 0), h.restore()) : (this.textStrokeState_ && h.strokeText(this.text_, g, m), this.textFillState_ && h.fillText(this.text_, g, m));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(t, e, i, s, u) {
    const h = this.context_, c = Ri(
      t,
      e,
      i,
      s,
      this.transform_,
      this.pixelCoordinates_
    );
    h.moveTo(c[0], c[1]);
    let g = c.length;
    u && (g -= 2);
    for (let m = 2; m < g; m += 2)
      h.lineTo(c[m], c[m + 1]);
    return u && h.closePath(), i;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(t, e, i, s) {
    for (let u = 0, h = i.length; u < h; ++u)
      e = this.moveToLineTo_(
        t,
        e,
        i[u],
        s,
        !0
      );
    return e;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Circle.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!mn(this.extent_, t.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = k_(
          t,
          this.transform_,
          this.pixelCoordinates_
        ), i = e[2] - e[0], s = e[3] - e[1], u = Math.sqrt(i * i + s * s), h = this.context_;
        h.beginPath(), h.arc(
          e[0],
          e[1],
          u,
          0,
          2 * Math.PI
        ), this.fillState_ && h.fill(), this.strokeState_ && h.stroke();
      }
      this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(t) {
    this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(t) {
    this.transform_ = t;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(t) {
    switch (t.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          t
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          t
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          t
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          t
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          t
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          t
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          t
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(t, e) {
    const i = e.getGeometryFunction()(t);
    i && (this.setStyle(e), this.drawGeometry(i));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(t) {
    const e = t.getGeometriesArray();
    for (let i = 0, s = e.length; i < s; ++i)
      this.drawGeometry(e[i]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/Point.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getFlatCoordinates(), i = t.getStride();
    this.image_ && this.drawImages_(e, 0, e.length, i), this.text_ !== "" && this.drawText_(e, 0, e.length, i);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPoint.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getFlatCoordinates(), i = t.getStride();
    this.image_ && this.drawImages_(e, 0, e.length, i), this.text_ !== "" && this.drawText_(e, 0, e.length, i);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/LineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!mn(this.extent_, t.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const e = this.context_, i = t.getFlatCoordinates();
        e.beginPath(), this.moveToLineTo_(
          i,
          0,
          i.length,
          t.getStride(),
          !1
        ), e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatMidpoint();
        this.drawText_(e, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiLineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getExtent();
    if (mn(this.extent_, e)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const i = this.context_, s = t.getFlatCoordinates();
        let u = 0;
        const h = (
          /** @type {Array<number>} */
          t.getEnds()
        ), c = t.getStride();
        i.beginPath();
        for (let g = 0, m = h.length; g < m; ++g)
          u = this.moveToLineTo_(
            s,
            u,
            h[g],
            c,
            !1
          );
        i.stroke();
      }
      if (this.text_ !== "") {
        const i = t.getFlatMidpoints();
        this.drawText_(i, 0, i.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Polygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!mn(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = this.context_;
        e.beginPath(), this.drawRings_(
          t.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          t.getEnds(),
          t.getStride()
        ), this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatInteriorPoint();
        this.drawText_(e, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPolygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!mn(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = this.context_, i = t.getOrientedFlatCoordinates();
        let s = 0;
        const u = t.getEndss(), h = t.getStride();
        e.beginPath();
        for (let c = 0, g = u.length; c < g; ++c) {
          const m = u[c];
          s = this.drawRings_(i, s, m, h);
        }
        this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatInteriorPoints();
        this.drawText_(e, 0, e.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(t) {
    const e = this.context_, i = this.contextFillState_;
    i ? i.fillStyle != t.fillStyle && (i.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = {
      fillStyle: t.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(t) {
    const e = this.context_, i = this.contextStrokeState_;
    i ? (i.lineCap != t.lineCap && (i.lineCap = t.lineCap, e.lineCap = t.lineCap), cs(i.lineDash, t.lineDash) || e.setLineDash(
      i.lineDash = t.lineDash
    ), i.lineDashOffset != t.lineDashOffset && (i.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset), i.lineJoin != t.lineJoin && (i.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), i.lineWidth != t.lineWidth && (i.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), i.miterLimit != t.miterLimit && (i.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), i.strokeStyle != t.strokeStyle && (i.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
      lineCap: t.lineCap,
      lineDash: t.lineDash,
      lineDashOffset: t.lineDashOffset,
      lineJoin: t.lineJoin,
      lineWidth: t.lineWidth,
      miterLimit: t.miterLimit,
      strokeStyle: t.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(t) {
    const e = this.context_, i = this.contextTextState_, s = t.textAlign ? t.textAlign : ro;
    i ? (i.font != t.font && (i.font = t.font, e.font = t.font), i.textAlign != s && (i.textAlign = s, e.textAlign = s), i.textBaseline != t.textBaseline && (i.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = s, e.textBaseline = t.textBaseline, this.contextTextState_ = {
      font: t.font,
      textAlign: s,
      textBaseline: t.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, e) {
    if (!t)
      this.fillState_ = null;
    else {
      const i = t.getColor();
      this.fillState_ = {
        fillStyle: Tn(
          i || Oe
        )
      };
    }
    if (!e)
      this.strokeState_ = null;
    else {
      const i = e.getColor(), s = e.getLineCap(), u = e.getLineDash(), h = e.getLineDashOffset(), c = e.getLineJoin(), g = e.getWidth(), m = e.getMiterLimit(), y = u || Jn;
      this.strokeState_ = {
        lineCap: s !== void 0 ? s : ns,
        lineDash: this.pixelRatio_ === 1 ? y : y.map((p) => p * this.pixelRatio_),
        lineDashOffset: (h || Qn) * this.pixelRatio_,
        lineJoin: c !== void 0 ? c : is,
        lineWidth: (g !== void 0 ? g : so) * this.pixelRatio_,
        miterLimit: m !== void 0 ? m : no,
        strokeStyle: Tn(
          i || io
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(t) {
    let e;
    if (!t || !(e = t.getSize())) {
      this.image_ = null;
      return;
    }
    const i = t.getPixelRatio(this.pixelRatio_), s = t.getAnchor(), u = t.getOrigin();
    this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = s[0] * i, this.imageAnchorY_ = s[1] * i, this.imageHeight_ = e[1] * i, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = u[0], this.imageOriginY_ = u[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
    const h = t.getScaleArray();
    this.imageScale_ = [
      h[0] * this.pixelRatio_ / i,
      h[1] * this.pixelRatio_ / i
    ], this.imageWidth_ = e[0] * i;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(t) {
    if (!t)
      this.text_ = "";
    else {
      const e = t.getFill();
      if (!e)
        this.textFillState_ = null;
      else {
        const E = e.getColor();
        this.textFillState_ = {
          fillStyle: Tn(
            E || Oe
          )
        };
      }
      const i = t.getStroke();
      if (!i)
        this.textStrokeState_ = null;
      else {
        const E = i.getColor(), S = i.getLineCap(), I = i.getLineDash(), b = i.getLineDashOffset(), C = i.getLineJoin(), R = i.getWidth(), T = i.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: S !== void 0 ? S : ns,
          lineDash: I || Jn,
          lineDashOffset: b || Qn,
          lineJoin: C !== void 0 ? C : is,
          lineWidth: R !== void 0 ? R : so,
          miterLimit: T !== void 0 ? T : no,
          strokeStyle: Tn(
            E || io
          )
        };
      }
      const s = t.getFont(), u = t.getOffsetX(), h = t.getOffsetY(), c = t.getRotateWithView(), g = t.getRotation(), m = t.getScaleArray(), y = t.getText(), p = t.getTextAlign(), _ = t.getTextBaseline();
      this.textState_ = {
        font: s !== void 0 ? s : mm,
        textAlign: p !== void 0 ? p : ro,
        textBaseline: _ !== void 0 ? _ : fa
      }, this.text_ = y !== void 0 ? Array.isArray(y) ? y.reduce((E, S, I) => E += I % 2 ? " " : S, "") : y : "", this.textOffsetX_ = u !== void 0 ? this.pixelRatio_ * u : 0, this.textOffsetY_ = h !== void 0 ? this.pixelRatio_ * h : 0, this.textRotateWithView_ = c !== void 0 ? c : !1, this.textRotation_ = g !== void 0 ? g : 0, this.textScale_ = [
        this.pixelRatio_ * m[0],
        this.pixelRatio_ * m[1]
      ];
    }
  }
}
const Ln = 0.5;
function ME(n, t, e, i, s, u, h, c, g) {
  const m = s, y = n[0] * Ln, p = n[1] * Ln, _ = Ue(y, p);
  _.imageSmoothingEnabled = !1;
  const E = _.canvas, S = new NE(
    _,
    Ln,
    s,
    null,
    h,
    c,
    null
  ), I = e.length, b = Math.floor((256 * 256 * 256 - 1) / I), C = {};
  for (let T = 1; T <= I; ++T) {
    const O = e[T - 1], M = O.getStyleFunction() || i;
    if (!M)
      continue;
    let G = M(O, u);
    if (!G)
      continue;
    Array.isArray(G) || (G = [G]);
    const F = (T * b).toString(16).padStart(7, "#00000");
    for (let A = 0, j = G.length; A < j; ++A) {
      const et = G[A], U = et.getGeometryFunction()(O);
      if (!U || !mn(m, U.getExtent()))
        continue;
      const nt = et.clone(), z = nt.getFill();
      z && z.setColor(F);
      const K = nt.getStroke();
      K && (K.setColor(F), K.setLineDash(null)), nt.setText(void 0);
      const Z = et.getImage();
      if (Z) {
        const Q = Z.getImageSize();
        if (!Q)
          continue;
        const _t = Ue(
          Q[0],
          Q[1],
          void 0,
          { alpha: !1 }
        ), Et = _t.canvas;
        _t.fillStyle = F, _t.fillRect(0, 0, Et.width, Et.height), nt.setImage(
          new Eo({
            img: Et,
            anchor: Z.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: Z.getOrigin(),
            opacity: 1,
            size: Z.getSize(),
            scale: Z.getScale(),
            rotation: Z.getRotation(),
            rotateWithView: Z.getRotateWithView()
          })
        );
      }
      const at = nt.getZIndex() || 0;
      let gt = C[at];
      gt || (gt = {}, C[at] = gt, gt.Polygon = [], gt.Circle = [], gt.LineString = [], gt.Point = []);
      const xt = U.getType();
      if (xt === "GeometryCollection") {
        const Q = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          U.getGeometriesArrayRecursive()
        );
        for (let _t = 0, Et = Q.length; _t < Et; ++_t) {
          const Wt = Q[_t];
          gt[Wt.getType().replace("Multi", "")].push(
            Wt,
            nt
          );
        }
      } else
        gt[xt.replace("Multi", "")].push(U, nt);
    }
  }
  const R = Object.keys(C).map(Number).sort(er);
  for (let T = 0, O = R.length; T < O; ++T) {
    const M = C[R[T]];
    for (const G in M) {
      const D = M[G];
      for (let F = 0, A = D.length; F < A; F += 2) {
        S.setStyle(D[F + 1]);
        for (let j = 0, et = t.length; j < et; ++j)
          S.setTransform(t[j]), S.drawGeometry(D[F]);
      }
    }
  }
  return _.getImageData(0, 0, E.width, E.height);
}
function OE(n, t, e) {
  const i = [];
  if (e) {
    const s = Math.floor(Math.round(n[0]) * Ln), u = Math.floor(Math.round(n[1]) * Ln), h = (we(s, 0, e.width - 1) + we(u, 0, e.height - 1) * e.width) * 4, c = e.data[h], g = e.data[h + 1], y = e.data[h + 2] + 256 * (g + 256 * c), p = Math.floor((256 * 256 * 256 - 1) / t.length);
    y && y % p === 0 && i.push(t[y / p - 1]);
  }
  return i;
}
const AE = 0.5, Fm = {
  Point: WE,
  LineString: BE,
  Polygon: qE,
  MultiPoint: XE,
  MultiLineString: zE,
  MultiPolygon: YE,
  GeometryCollection: GE,
  Circle: DE
};
function PE(n, t) {
  return parseInt(de(n), 10) - parseInt(de(t), 10);
}
function Nf(n, t) {
  const e = Gm(n, t);
  return e * e;
}
function Gm(n, t) {
  return AE * n / t;
}
function DE(n, t, e, i, s) {
  const u = e.getFill(), h = e.getStroke();
  if (u || h) {
    const g = n.getBuilder(e.getZIndex(), "Circle");
    g.setFillStrokeStyle(u, h), g.drawCircle(t, i, s);
  }
  const c = e.getText();
  if (c && c.getText()) {
    const g = n.getBuilder(e.getZIndex(), "Text");
    g.setTextStyle(c), g.drawText(t, i);
  }
}
function Mf(n, t, e, i, s, u, h, c) {
  const g = [], m = e.getImage();
  if (m) {
    let _ = !0;
    const E = m.getImageState();
    E == wt.LOADED || E == wt.ERROR ? _ = !1 : E == wt.IDLE && m.load(), _ && g.push(m.ready());
  }
  const y = e.getFill();
  y && y.loading() && g.push(y.ready());
  const p = g.length > 0;
  return p && Promise.all(g).then(() => s(null)), FE(
    n,
    t,
    e,
    i,
    u,
    h,
    c
  ), p;
}
function FE(n, t, e, i, s, u, h) {
  const c = e.getGeometryFunction()(t);
  if (!c)
    return;
  const g = c.simplifyTransformed(
    i,
    s
  );
  if (e.getRenderer())
    Bm(n, g, e, t, h);
  else {
    const y = Fm[g.getType()];
    y(
      n,
      g,
      e,
      t,
      h,
      u
    );
  }
}
function Bm(n, t, e, i, s) {
  if (t.getType() == "GeometryCollection") {
    const h = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      t.getGeometries()
    );
    for (let c = 0, g = h.length; c < g; ++c)
      Bm(n, h[c], e, i, s);
    return;
  }
  n.getBuilder(e.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    t,
    i,
    e.getRenderer(),
    e.getHitDetectionRenderer(),
    s
  );
}
function GE(n, t, e, i, s, u) {
  const h = t.getGeometriesArray();
  let c, g;
  for (c = 0, g = h.length; c < g; ++c) {
    const m = Fm[h[c].getType()];
    m(
      n,
      h[c],
      e,
      i,
      s,
      u
    );
  }
}
function BE(n, t, e, i, s) {
  const u = e.getStroke();
  if (u) {
    const c = n.getBuilder(
      e.getZIndex(),
      "LineString"
    );
    c.setFillStrokeStyle(null, u), c.drawLineString(t, i, s);
  }
  const h = e.getText();
  if (h && h.getText()) {
    const c = n.getBuilder(e.getZIndex(), "Text");
    c.setTextStyle(h), c.drawText(t, i, s);
  }
}
function zE(n, t, e, i, s) {
  const u = e.getStroke();
  if (u) {
    const c = n.getBuilder(
      e.getZIndex(),
      "LineString"
    );
    c.setFillStrokeStyle(null, u), c.drawMultiLineString(t, i, s);
  }
  const h = e.getText();
  if (h && h.getText()) {
    const c = n.getBuilder(e.getZIndex(), "Text");
    c.setTextStyle(h), c.drawText(t, i, s);
  }
}
function YE(n, t, e, i, s) {
  const u = e.getFill(), h = e.getStroke();
  if (h || u) {
    const g = n.getBuilder(e.getZIndex(), "Polygon");
    g.setFillStrokeStyle(u, h), g.drawMultiPolygon(t, i, s);
  }
  const c = e.getText();
  if (c && c.getText()) {
    const g = n.getBuilder(e.getZIndex(), "Text");
    g.setTextStyle(c), g.drawText(t, i, s);
  }
}
function WE(n, t, e, i, s, u) {
  const h = e.getImage(), c = e.getText(), g = c && c.getText(), m = u && h && g ? {} : void 0;
  if (h) {
    if (h.getImageState() != wt.LOADED)
      return;
    const y = n.getBuilder(e.getZIndex(), "Image");
    y.setImageStyle(h, m), y.drawPoint(t, i, s);
  }
  if (g) {
    const y = n.getBuilder(e.getZIndex(), "Text");
    y.setTextStyle(c, m), y.drawText(t, i, s);
  }
}
function XE(n, t, e, i, s, u) {
  const h = e.getImage(), c = h && h.getOpacity() !== 0, g = e.getText(), m = g && g.getText(), y = u && c && m ? {} : void 0;
  if (c) {
    if (h.getImageState() != wt.LOADED)
      return;
    const p = n.getBuilder(e.getZIndex(), "Image");
    p.setImageStyle(h, y), p.drawMultiPoint(t, i, s);
  }
  if (m) {
    const p = n.getBuilder(e.getZIndex(), "Text");
    p.setTextStyle(g, y), p.drawText(t, i, s);
  }
}
function qE(n, t, e, i, s) {
  const u = e.getFill(), h = e.getStroke();
  if (u || h) {
    const g = n.getBuilder(e.getZIndex(), "Polygon");
    g.setFillStrokeStyle(u, h), g.drawPolygon(t, i, s);
  }
  const c = e.getText();
  if (c && c.getText()) {
    const g = n.getBuilder(e.getZIndex(), "Text");
    g.setTextStyle(c), g.drawText(t, i, s);
  }
}
class UE extends IE {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(t) {
    super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = sr(), this.wrappedRenderedExtent_ = sr(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(t, e, i) {
    const s = e.extent, u = e.viewState, h = u.center, c = u.resolution, g = u.projection, m = u.rotation, y = g.getExtent(), p = this.getLayer().getSource(), _ = this.getLayer().getDeclutter(), E = e.pixelRatio, S = e.viewHints, I = !(S[nn.ANIMATING] || S[nn.INTERACTING]), b = this.context, C = Math.round(Me(s) / c * E), R = Math.round(ni(s) / c * E), T = p.getWrapX() && g.canWrapX(), O = T ? Me(y) : null, M = T ? Math.ceil((s[2] - y[2]) / O) + 1 : 1;
    let G = T ? Math.floor((s[0] - y[0]) / O) : 0;
    do {
      const D = this.getRenderTransform(
        h,
        c,
        m,
        E,
        C,
        R,
        G * O
      );
      t.execute(
        b,
        [b.canvas.width, b.canvas.height],
        D,
        m,
        I,
        i === void 0 ? js : i ? Dm : RE,
        i ? _ && e.declutter[_] : void 0
      );
    } while (++G < M);
  }
  /**
   * @private
   */
  setDrawContext_() {
    this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = Ue(
      this.context.canvas.width,
      this.context.canvas.height,
      Rf
    ));
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1) {
      const t = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = t, xv(this.context), Rf.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, t, !0);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(t) {
    this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.resetDrawContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(t, e) {
    const i = t.pixelRatio, s = t.layerStatesArray[t.layerIndex];
    this.opacity_ = s.opacity;
    const u = t.extent, h = t.viewState.resolution, c = Math.round(Me(u) / h * i), g = Math.round(ni(u) / h * i);
    dr(
      this.pixelTransform,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / i,
      1 / i,
      0,
      -c / 2,
      -g / 2
    ), __(this.inversePixelTransform, this.pixelTransform);
    const m = x_(this.pixelTransform);
    this.useContainer(e, m, this.getBackground(t));
    const y = this.context, p = y.canvas, _ = this.replayGroup_;
    let E = _ && !_.isEmpty();
    if (!E && !(this.getLayer().hasListener(Hi.PRERENDER) || this.getLayer().hasListener(Hi.POSTRENDER)))
      return null;
    p.width != c || p.height != g ? (p.width = c, p.height = g, p.style.transform !== m && (p.style.transform = m)) : this.containerReused || y.clearRect(0, 0, c, g), this.setDrawContext_(), this.preRender(y, t);
    const S = t.viewState;
    S.projection;
    let I = !1;
    if (E && s.extent && this.clipping) {
      const b = Gs(s.extent);
      E = mn(b, t.extent), I = E && !Zr(b, t.extent), I && this.clipUnrotated(y, t, b);
    }
    return E && this.renderWorlds(
      _,
      t,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), I && y.restore(), this.postRender(y, t), this.renderedRotation_ !== S.rotation && (this.renderedRotation_ = S.rotation, this.hitDetectionImageData_ = null), t.declutter || this.resetDrawContext_(), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(t) {
    return new Promise((e) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const i = [this.context.canvas.width, this.context.canvas.height];
        Ne(this.pixelTransform, i);
        const s = this.renderedCenter_, u = this.renderedResolution_, h = this.renderedRotation_, c = this.renderedProjection_, g = this.wrappedRenderedExtent_, m = this.getLayer(), y = [], p = i[0] * Ln, _ = i[1] * Ln;
        y.push(
          this.getRenderTransform(
            s,
            u,
            h,
            Ln,
            p,
            _,
            0
          ).slice()
        );
        const E = m.getSource(), S = c.getExtent();
        if (E.getWrapX() && c.canWrapX() && !Zr(S, g)) {
          let I = g[0];
          const b = Me(S);
          let C = 0, R;
          for (; I < S[0]; )
            --C, R = b * C, y.push(
              this.getRenderTransform(
                s,
                u,
                h,
                Ln,
                p,
                _,
                R
              ).slice()
            ), I += b;
          for (C = 0, I = g[2]; I > S[2]; )
            ++C, R = b * C, y.push(
              this.getRenderTransform(
                s,
                u,
                h,
                Ln,
                p,
                _,
                R
              ).slice()
            ), I -= b;
        }
        this.hitDetectionImageData_ = ME(
          i,
          y,
          this.renderedFeatures_,
          m.getStyleFunction(),
          g,
          u,
          h,
          Nf(u, this.renderedPixelRatio_)
        );
      }
      e(
        OE(t, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, e, i, s, u) {
    if (!this.replayGroup_)
      return;
    const h = e.viewState.resolution, c = e.viewState.rotation, g = this.getLayer(), m = {}, y = function(S, I, b) {
      const C = de(S), R = m[C];
      if (R) {
        if (R !== !0 && b < R.distanceSq) {
          if (b === 0)
            return m[C] = !0, u.splice(u.lastIndexOf(R), 1), s(S, g, I);
          R.geometry = I, R.distanceSq = b;
        }
      } else {
        if (b === 0)
          return m[C] = !0, s(S, g, I);
        u.push(
          m[C] = {
            feature: S,
            layer: g,
            geometry: I,
            distanceSq: b,
            callback: s
          }
        );
      }
    };
    let p;
    const _ = [this.replayGroup_], E = this.getLayer().getDeclutter();
    return _.some((S) => p = S.forEachFeatureAtCoordinate(
      t,
      h,
      c,
      i,
      y,
      E && e.declutter[E] ? e.declutter[E].all().map((I) => I.value) : null
    )), p;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const t = this.getLayer();
    t.getVisible() && this.replayGroup_ && t.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(t) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    const e = this.getLayer(), i = e.getSource();
    if (!i)
      return !1;
    const s = t.viewHints[nn.ANIMATING], u = t.viewHints[nn.INTERACTING], h = e.getUpdateWhileAnimating(), c = e.getUpdateWhileInteracting();
    if (this.ready && !h && s || !c && u)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const g = t.extent, m = t.viewState, y = m.projection, p = m.resolution, _ = t.pixelRatio, E = e.getRevision(), S = e.getRenderBuffer();
    let I = e.getRenderOrder();
    I === void 0 && (I = PE);
    const b = m.center.slice(), C = Kl(
      g,
      S * p
    ), R = C.slice(), T = [C.slice()], O = y.getExtent();
    if (i.getWrapX() && y.canWrapX() && !Zr(O, t.extent)) {
      const z = Me(O), K = Math.max(Me(C) / 2, z);
      C[0] = O[0] - K, C[2] = O[2] + K, Kv(b, y);
      const Z = $d(T[0], y);
      Z[0] < O[0] && Z[2] < O[2] ? T.push([
        Z[0] + z,
        Z[1],
        Z[2] + z,
        Z[3]
      ]) : Z[0] > O[0] && Z[2] > O[2] && T.push([
        Z[0] - z,
        Z[1],
        Z[2] - z,
        Z[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == p && this.renderedRevision_ == E && this.renderedRenderOrder_ == I && Zr(this.wrappedRenderedExtent_, C))
      return cs(this.renderedExtent_, R) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = R), this.renderedCenter_ = b, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const M = new xE(
      Gm(p, _),
      C,
      p,
      _
    );
    let G;
    for (let z = 0, K = T.length; z < K; ++z)
      i.loadFeatures(T[z], p, y);
    const D = Nf(p, _);
    let F = !0;
    const A = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (z, K) => {
        let Z;
        const at = z.getStyleFunction() || e.getStyleFunction();
        if (at && (Z = at(z, p)), Z) {
          const gt = this.renderFeature(
            z,
            D,
            Z,
            M,
            G,
            this.getLayer().getDeclutter(),
            K
          );
          F = F && !gt;
        }
      }
    ), j = em(C), et = i.getFeaturesInExtent(j);
    I && et.sort(I);
    for (let z = 0, K = et.length; z < K; ++z)
      A(et[z], z);
    this.renderedFeatures_ = et, this.ready = F;
    const U = M.finish(), nt = new LE(
      C,
      p,
      _,
      i.getOverlaps(),
      U,
      e.getRenderBuffer(),
      !!t.declutter
    );
    return this.renderedResolution_ = p, this.renderedRevision_ = E, this.renderedRenderOrder_ = I, this.renderedExtent_ = R, this.wrappedRenderedExtent_ = C, this.renderedCenter_ = b, this.renderedProjection_ = y, this.renderedPixelRatio_ = _, this.replayGroup_ = nt, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(t, e, i, s, u, h, c) {
    if (!i)
      return !1;
    let g = !1;
    if (Array.isArray(i))
      for (let m = 0, y = i.length; m < y; ++m)
        g = Mf(
          s,
          t,
          i[m],
          e,
          this.boundHandleStyleImageChange_,
          u,
          h,
          c
        ) || g;
    else
      g = Mf(
        s,
        t,
        i,
        e,
        this.boundHandleStyleImageChange_,
        u,
        h,
        c
      );
    return g;
  }
}
class jE extends o1 {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(t) {
    super(t);
  }
  createRenderer() {
    return new UE(this);
  }
}
class Of {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(t) {
    this.rbush_ = new fm(t), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(t, e) {
    const i = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3],
      value: e
    };
    this.rbush_.insert(i), this.items_[de(e)] = i;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(t, e) {
    const i = new Array(e.length);
    for (let s = 0, u = e.length; s < u; s++) {
      const h = t[s], c = e[s], g = {
        minX: h[0],
        minY: h[1],
        maxX: h[2],
        maxY: h[3],
        value: c
      };
      i[s] = g, this.items_[de(c)] = g;
    }
    this.rbush_.load(i);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(t) {
    const e = de(t), i = this.items_[e];
    return delete this.items_[e], this.rbush_.remove(i) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(t, e) {
    const i = this.items_[de(e)], s = [i.minX, i.minY, i.maxX, i.maxY];
    Ud(s, t) || (this.remove(e), this.insert(t, e));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(e) {
      return e.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(t) {
    const e = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3]
    };
    return this.rbush_.search(e).map(function(s) {
      return s.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(t) {
    return this.forEach_(this.getAll(), t);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(t, e) {
    return this.forEach_(this.getInExtent(t), e);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(t, e) {
    let i;
    for (let s = 0, u = t.length; s < u; s++)
      if (i = e(t[s]), i)
        return i;
    return i;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return es(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(t) {
    const e = this.rbush_.toJSON();
    return or(e.minX, e.minY, e.maxX, e.maxY, t);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(t) {
    this.rbush_.load(t.rbush_.all());
    for (const e in t.items_)
      this.items_[e] = t.items_[e];
  }
}
const Af = $n();
class rn {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(t, e, i, s, u, h) {
    this.styleFunction, this.extent_, this.id_ = h, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = i || null, this.properties_ = u, this.squaredTolerance_, this.stride_ = s, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(t) {
    return this.properties_[t];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? qd(this.flatCoordinates_) : Jl(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const t = ar(this.getExtent());
      this.flatInteriorPoints_ = hh(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        t,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const t = z_(this.flatCoordinates_, this.ends_), e = Om(this.flatCoordinates_, 0, t, 2);
      this.flatInteriorPoints_ = am(
        this.flatCoordinates_,
        0,
        t,
        2,
        e
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = pa(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const t = this.flatCoordinates_;
      let e = 0;
      const i = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let s = 0, u = i.length; s < u; ++s) {
        const h = i[s], c = pa(t, e, h, 2, 0.5);
        Mn(this.flatMidpoints_, c), e = h;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(t, e) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(t) {
    t = ur(t);
    const e = t.getExtent(), i = t.getWorldExtent();
    if (e && i) {
      const s = ni(i) / ni(e);
      dr(
        Af,
        i[0],
        i[3],
        s,
        -s,
        0,
        0,
        0
      ), Ri(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        Af,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(t) {
    t(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    var t;
    return new rn(
      this.type_,
      this.flatCoordinates_.slice(),
      (t = this.ends_) == null ? void 0 : t.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = Gd((t, e) => {
      if (t === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), e && this.simplifiedGeometry_.applyTransform(e);
      const i = this.simplifiedGeometry_.getFlatCoordinates();
      let s;
      switch (this.type_) {
        case "LineString":
          i.length = qa(
            i,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            t,
            i,
            0
          ), s = [i.length];
          break;
        case "MultiLineString":
          s = [], i.length = rm(
            i,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            t,
            i,
            0,
            s
          );
          break;
        case "Polygon":
          s = [], i.length = uh(
            i,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(t),
            i,
            0,
            s
          );
          break;
      }
      return s && (this.simplifiedGeometry_ = new rn(
        this.type_,
        i,
        s,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = t, this.simplifiedGeometry_;
    }), this;
  }
}
rn.prototype.getFlatCoordinates = rn.prototype.getOrientedFlatCoordinates;
class VE extends fr {
  /**
   * @param {Options} options Source options.
   */
  constructor(t) {
    super(), this.projection = ur(t.projection), this.attributions_ = Pf(t.attributions), this.attributionsCollapsible_ = t.attributionsCollapsible !== void 0 ? t.attributionsCollapsible : !0, this.loading = !1, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : !1, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
    const e = this;
    this.viewPromise_ = new Promise(function(i, s) {
      e.viewResolver = i, e.viewRejector = s;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(t) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(t) {
    this.attributions_ = Pf(t), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(t) {
    this.state_ = t, this.changed();
  }
}
function Pf(n) {
  return n ? Array.isArray(n) ? function(t) {
    return n;
  } : typeof n == "function" ? n : function(t) {
    return [n];
  } : null;
}
const Qe = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function ZE(n, t) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
let HE = !1;
function KE(n, t, e, i, s, u, h) {
  const c = new XMLHttpRequest();
  c.open(
    "GET",
    typeof n == "function" ? n(e, i, s) : n,
    !0
  ), t.getType() == "arraybuffer" && (c.responseType = "arraybuffer"), c.withCredentials = HE, c.onload = function(g) {
    if (!c.status || c.status >= 200 && c.status < 300) {
      const m = t.getType();
      let y;
      m == "json" ? y = JSON.parse(c.responseText) : m == "text" ? y = c.responseText : m == "xml" ? (y = c.responseXML, y || (y = new DOMParser().parseFromString(
        c.responseText,
        "application/xml"
      ))) : m == "arraybuffer" && (y = /** @type {ArrayBuffer} */
      c.response), y ? u(
        /** @type {Array<import("./Feature.js").default>} */
        t.readFeatures(y, {
          extent: e,
          featureProjection: s
        }),
        t.readProjection(y)
      ) : h();
    } else
      h();
  }, c.onerror = h, c.send();
}
function Df(n, t) {
  return function(e, i, s, u, h) {
    const c = (
      /** @type {import("./source/Vector").default} */
      this
    );
    KE(
      n,
      t,
      e,
      i,
      s,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(g, m) {
        c.addFeatures(g), u !== void 0 && u(g);
      },
      /* FIXME handle error */
      h || ts
    );
  };
}
class pi extends je {
  /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */
  constructor(t, e, i) {
    super(t), this.feature = e, this.features = i;
  }
}
class $E extends VE {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(t) {
    t = t || {}, super({
      attributions: t.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = ts, this.format_ = t.format, this.overlaps_ = t.overlaps === void 0 ? !0 : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (Se(this.format_, "`format` must be set when `url` is set"), this.loader_ = Df(
      this.url_,
      /** @type {import("../format/Feature.js").default} */
      this.format_
    )), this.strategy_ = t.strategy !== void 0 ? t.strategy : ZE;
    const e = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : !0;
    this.featuresRtree_ = e ? new Of() : null, this.loadedExtentsRtree_ = new Of(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let i, s;
    Array.isArray(t.features) ? s = t.features : t.features && (i = t.features, s = i.getArray()), !e && i === void 0 && (i = new o_(s)), s !== void 0 && this.addFeaturesInternal(s), i !== void 0 && this.bindFeaturesCollection_(i);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(t) {
    this.addFeatureInternal(t), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(t) {
    const e = de(t);
    if (!this.addToIndex_(e, t)) {
      this.featuresCollection_ && this.featuresCollection_.remove(t);
      return;
    }
    this.setupChangeEvents_(e, t);
    const i = t.getGeometry();
    if (i) {
      const s = i.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(s, t);
    } else
      this.nullGeometryFeatures_[e] = t;
    this.dispatchEvent(
      new pi(Qe.ADDFEATURE, t)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(t, e) {
    e instanceof rn || (this.featureChangeKeys_[t] = [
      On(e, pn.CHANGE, this.handleFeatureChange_, this),
      On(
        e,
        Dd.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(t, e) {
    let i = !0;
    if (e.getId() !== void 0) {
      const s = String(e.getId());
      if (!(s in this.idIndex_))
        this.idIndex_[s] = e;
      else if (e instanceof rn) {
        const u = this.idIndex_[s];
        u instanceof rn ? Array.isArray(u) ? u.push(e) : this.idIndex_[s] = [u, e] : i = !1;
      } else
        i = !1;
    }
    return i && (Se(
      !(t in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[t] = e), i;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(t) {
    this.addFeaturesInternal(t), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(t) {
    const e = [], i = [], s = [];
    for (let u = 0, h = t.length; u < h; u++) {
      const c = t[u], g = de(c);
      this.addToIndex_(g, c) && i.push(c);
    }
    for (let u = 0, h = i.length; u < h; u++) {
      const c = i[u], g = de(c);
      this.setupChangeEvents_(g, c);
      const m = c.getGeometry();
      if (m) {
        const y = m.getExtent();
        e.push(y), s.push(c);
      } else
        this.nullGeometryFeatures_[g] = c;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(e, s), this.hasListener(Qe.ADDFEATURE))
      for (let u = 0, h = i.length; u < h; u++)
        this.dispatchEvent(
          new pi(Qe.ADDFEATURE, i[u])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(t) {
    let e = !1;
    this.addEventListener(
      Qe.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(i) {
        e || (e = !0, t.push(i.feature), e = !1);
      }
    ), this.addEventListener(
      Qe.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(i) {
        e || (e = !0, t.remove(i.feature), e = !1);
      }
    ), t.addEventListener(
      Hr.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (i) => {
        e || (e = !0, this.addFeature(i.element), e = !1);
      }
    ), t.addEventListener(
      Hr.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (i) => {
        e || (e = !0, this.removeFeature(i.element), e = !1);
      }
    ), this.featuresCollection_ = t;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(t) {
    if (t) {
      for (const i in this.featureChangeKeys_)
        this.featureChangeKeys_[i].forEach(Kn);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const i = (s) => {
        this.removeFeatureInternal(s);
      };
      this.featuresRtree_.forEach(i);
      for (const s in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[s]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const e = new pi(Qe.CLEAR);
    this.dispatchEvent(e), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(t, e) {
    const i = [t[0], t[1], t[0], t[1]];
    return this.forEachFeatureInExtent(i, function(s) {
      const u = s.getGeometry();
      if (u instanceof rn || u.intersectsCoordinate(t))
        return e(s);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(t, e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(t, e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(t, e) {
    return this.forEachFeatureInExtent(
      t,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(i) {
        const s = i.getGeometry();
        if (s instanceof rn || s.intersectsExtent(t)) {
          const u = e(i);
          if (u)
            return u;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let t;
    return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), es(this.nullGeometryFeatures_) || Mn(t, Object.values(this.nullGeometryFeatures_))), t;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  getFeaturesAtCoordinate(t) {
    const e = [];
    return this.forEachFeatureAtCoordinateDirect(t, function(i) {
      e.push(i);
    }), e;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(t, e) {
    if (this.featuresRtree_) {
      if (!(e && e.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(t);
      const s = qv(t, e);
      return [].concat(
        ...s.map((u) => this.featuresRtree_.getInExtent(u))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(t, e) {
    const i = t[0], s = t[1];
    let u = null;
    const h = [NaN, NaN];
    let c = 1 / 0;
    const g = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return e = e || mv, this.featuresRtree_.forEachInExtent(
      g,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(m) {
        if (e(m)) {
          const y = m.getGeometry(), p = c;
          if (c = y instanceof rn ? 0 : y.closestPointXY(i, s, h, c), c < p) {
            u = m;
            const _ = Math.sqrt(c);
            g[0] = i - _, g[1] = s - _, g[2] = i + _, g[3] = s + _;
          }
        }
      }
    ), u;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(t) {
    return this.featuresRtree_.getExtent(t);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(t) {
    const e = this.idIndex_[t.toString()];
    return e !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      e
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(t) {
    const e = this.uidIndex_[t];
    return e !== void 0 ? e : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<import('../format/Feature.js').FeatureToFeatureClass<FeatureType>>|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(t) {
    const e = (
      /** @type {FeatureType} */
      t.target
    ), i = de(e), s = e.getGeometry();
    if (!s)
      i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[i] = e);
    else {
      const h = s.getExtent();
      i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(h, e)) : this.featuresRtree_ && this.featuresRtree_.update(h, e);
    }
    const u = e.getId();
    if (u !== void 0) {
      const h = u.toString();
      this.idIndex_[h] !== e && (this.removeFromIdIndex_(e), this.idIndex_[h] = e);
    } else
      this.removeFromIdIndex_(e), this.uidIndex_[i] = e;
    this.changed(), this.dispatchEvent(
      new pi(Qe.CHANGEFEATURE, e)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(t) {
    const e = t.getId();
    return e !== void 0 ? e in this.idIndex_ : de(t) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && es(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(t, e, i) {
    const s = this.loadedExtentsRtree_, u = this.strategy_(t, e, i);
    for (let h = 0, c = u.length; h < c; ++h) {
      const g = u[h];
      s.forEachInExtent(
        g,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(y) {
          return Zr(y.extent, g);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new pi(Qe.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        g,
        e,
        i,
        (y) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new pi(
              Qe.FEATURESLOADEND,
              void 0,
              y
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new pi(Qe.FEATURESLOADERROR)
          );
        }
      ), s.insert(g, { extent: g.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(t) {
    const e = this.loadedExtentsRtree_;
    let i;
    e.forEachInExtent(t, function(s) {
      if (Ud(s.extent, t))
        return i = s, !0;
    }), i && e.remove(i);
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   */
  removeFeatures(t) {
    const e = [];
    for (let i = 0, s = t.length; i < s; ++i) {
      const u = t[i], h = this.removeFeatureInternal(u);
      h && e.push(h);
    }
    e.length > 0 && this.changed();
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(t) {
    if (!t)
      return;
    this.removeFeatureInternal(t) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {FeatureType|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(t) {
    const e = de(t);
    e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t);
    const i = this.featureChangeKeys_[e];
    if (!i)
      return;
    i.forEach(Kn), delete this.featureChangeKeys_[e];
    const s = t.getId();
    return s !== void 0 && delete this.idIndex_[s.toString()], delete this.uidIndex_[e], this.hasListener(Qe.REMOVEFEATURE) && this.dispatchEvent(
      new pi(Qe.REMOVEFEATURE, t)
    ), t;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(t) {
    let e = !1;
    for (const i in this.idIndex_) {
      const s = this.idIndex_[i];
      if (t instanceof rn && Array.isArray(s) && s.includes(t))
        s.splice(s.indexOf(t), 1);
      else if (this.idIndex_[i] === t) {
        delete this.idIndex_[i], e = !0;
        break;
      }
    }
    return e;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(t) {
    this.loader_ = t;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(t) {
    Se(this.format_, "`format` must be set when `url` is set"), this.url_ = t, this.setLoader(Df(t, this.format_));
  }
}
var go = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function zm(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function JE(n) {
  if (n.__esModule) return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var s = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(e, i, s.get ? s : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), e;
}
var Ff = Object.prototype.toString, Ym = function(t) {
  var e = Ff.call(t), i = e === "[object Arguments]";
  return i || (i = e !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Ff.call(t.callee) === "[object Function]"), i;
}, Ou, Gf;
function QE() {
  if (Gf) return Ou;
  Gf = 1;
  var n;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, e = Object.prototype.toString, i = Ym, s = Object.prototype.propertyIsEnumerable, u = !s.call({ toString: null }, "toString"), h = s.call(function() {
    }, "prototype"), c = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], g = function(_) {
      var E = _.constructor;
      return E && E.prototype === _;
    }, m = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, y = function() {
      if (typeof window > "u")
        return !1;
      for (var _ in window)
        try {
          if (!m["$" + _] && t.call(window, _) && window[_] !== null && typeof window[_] == "object")
            try {
              g(window[_]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), p = function(_) {
      if (typeof window > "u" || !y)
        return g(_);
      try {
        return g(_);
      } catch {
        return !1;
      }
    };
    n = function(E) {
      var S = E !== null && typeof E == "object", I = e.call(E) === "[object Function]", b = i(E), C = S && e.call(E) === "[object String]", R = [];
      if (!S && !I && !b)
        throw new TypeError("Object.keys called on a non-object");
      var T = h && I;
      if (C && E.length > 0 && !t.call(E, 0))
        for (var O = 0; O < E.length; ++O)
          R.push(String(O));
      if (b && E.length > 0)
        for (var M = 0; M < E.length; ++M)
          R.push(String(M));
      else
        for (var G in E)
          !(T && G === "prototype") && t.call(E, G) && R.push(String(G));
      if (u)
        for (var D = p(E), F = 0; F < c.length; ++F)
          !(D && c[F] === "constructor") && t.call(E, c[F]) && R.push(c[F]);
      return R;
    };
  }
  return Ou = n, Ou;
}
var tx = Array.prototype.slice, ex = Ym, Bf = Object.keys, Jo = Bf ? function(t) {
  return Bf(t);
} : QE(), zf = Object.keys;
Jo.shim = function() {
  if (Object.keys) {
    var t = function() {
      var e = Object.keys(arguments);
      return e && e.length === arguments.length;
    }(1, 2);
    t || (Object.keys = function(i) {
      return ex(i) ? zf(tx.call(i)) : zf(i);
    });
  } else
    Object.keys = Jo;
  return Object.keys || Jo;
};
var _h = Jo, nx = Error, ix = EvalError, rx = RangeError, sx = ReferenceError, Wm = SyntaxError, Fi = TypeError, ox = URIError, Qa = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, e = Symbol("test"), i = Object(e);
  if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
    return !1;
  var s = 42;
  t[e] = s;
  for (e in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var u = Object.getOwnPropertySymbols(t);
  if (u.length !== 1 || u[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var h = Object.getOwnPropertyDescriptor(t, e);
    if (h.value !== s || h.enumerable !== !0)
      return !1;
  }
  return !0;
}, Yf = typeof Symbol < "u" && Symbol, ax = Qa, Eh = function() {
  return typeof Yf != "function" || typeof Symbol != "function" || typeof Yf("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : ax();
}, Au = {
  __proto__: null,
  foo: {}
}, ux = Object, lx = function() {
  return { __proto__: Au }.foo === Au.foo && !(Au instanceof ux);
}, hx = "Function.prototype.bind called on incompatible ", cx = Object.prototype.toString, fx = Math.max, gx = "[object Function]", Wf = function(t, e) {
  for (var i = [], s = 0; s < t.length; s += 1)
    i[s] = t[s];
  for (var u = 0; u < e.length; u += 1)
    i[u + t.length] = e[u];
  return i;
}, dx = function(t, e) {
  for (var i = [], s = e, u = 0; s < t.length; s += 1, u += 1)
    i[u] = t[s];
  return i;
}, mx = function(n, t) {
  for (var e = "", i = 0; i < n.length; i += 1)
    e += n[i], i + 1 < n.length && (e += t);
  return e;
}, yx = function(t) {
  var e = this;
  if (typeof e != "function" || cx.apply(e) !== gx)
    throw new TypeError(hx + e);
  for (var i = dx(arguments, 1), s, u = function() {
    if (this instanceof s) {
      var y = e.apply(
        this,
        Wf(i, arguments)
      );
      return Object(y) === y ? y : this;
    }
    return e.apply(
      t,
      Wf(i, arguments)
    );
  }, h = fx(0, e.length - i.length), c = [], g = 0; g < h; g++)
    c[g] = "$" + g;
  if (s = Function("binder", "return function (" + mx(c, ",") + "){ return binder.apply(this,arguments); }")(u), e.prototype) {
    var m = function() {
    };
    m.prototype = e.prototype, s.prototype = new m(), m.prototype = null;
  }
  return s;
}, px = yx, xh = Function.prototype.bind || px, vx = Function.prototype.call, _x = Object.prototype.hasOwnProperty, Ex = xh, Xm = Ex.call(vx, _x), Ct, xx = nx, Sx = ix, wx = rx, Ix = sx, ss = Wm, Qr = Fi, kx = ox, qm = Function, Pu = function(n) {
  try {
    return qm('"use strict"; return (' + n + ").constructor;")();
  } catch {
  }
}, ir = Object.getOwnPropertyDescriptor;
if (ir)
  try {
    ir({}, "");
  } catch {
    ir = null;
  }
var Du = function() {
  throw new Qr();
}, bx = ir ? function() {
  try {
    return arguments.callee, Du;
  } catch {
    try {
      return ir(arguments, "callee").get;
    } catch {
      return Du;
    }
  }
}() : Du, Br = Eh(), Cx = lx(), oe = Object.getPrototypeOf || (Cx ? function(n) {
  return n.__proto__;
} : null), jr = {}, Rx = typeof Uint8Array > "u" || !oe ? Ct : oe(Uint8Array), rr = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? Ct : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ct : ArrayBuffer,
  "%ArrayIteratorPrototype%": Br && oe ? oe([][Symbol.iterator]()) : Ct,
  "%AsyncFromSyncIteratorPrototype%": Ct,
  "%AsyncFunction%": jr,
  "%AsyncGenerator%": jr,
  "%AsyncGeneratorFunction%": jr,
  "%AsyncIteratorPrototype%": jr,
  "%Atomics%": typeof Atomics > "u" ? Ct : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Ct : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Ct : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Ct : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Ct : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": xx,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": Sx,
  "%Float32Array%": typeof Float32Array > "u" ? Ct : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Ct : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Ct : FinalizationRegistry,
  "%Function%": qm,
  "%GeneratorFunction%": jr,
  "%Int8Array%": typeof Int8Array > "u" ? Ct : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Ct : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Ct : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Br && oe ? oe(oe([][Symbol.iterator]())) : Ct,
  "%JSON%": typeof JSON == "object" ? JSON : Ct,
  "%Map%": typeof Map > "u" ? Ct : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Br || !oe ? Ct : oe((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Ct : Promise,
  "%Proxy%": typeof Proxy > "u" ? Ct : Proxy,
  "%RangeError%": wx,
  "%ReferenceError%": Ix,
  "%Reflect%": typeof Reflect > "u" ? Ct : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Ct : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Br || !oe ? Ct : oe((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Ct : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Br && oe ? oe(""[Symbol.iterator]()) : Ct,
  "%Symbol%": Br ? Symbol : Ct,
  "%SyntaxError%": ss,
  "%ThrowTypeError%": bx,
  "%TypedArray%": Rx,
  "%TypeError%": Qr,
  "%Uint8Array%": typeof Uint8Array > "u" ? Ct : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Ct : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Ct : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Ct : Uint32Array,
  "%URIError%": kx,
  "%WeakMap%": typeof WeakMap > "u" ? Ct : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Ct : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Ct : WeakSet
};
if (oe)
  try {
    null.error;
  } catch (n) {
    var Lx = oe(oe(n));
    rr["%Error.prototype%"] = Lx;
  }
var Tx = function n(t) {
  var e;
  if (t === "%AsyncFunction%")
    e = Pu("async function () {}");
  else if (t === "%GeneratorFunction%")
    e = Pu("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    e = Pu("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var i = n("%AsyncGeneratorFunction%");
    i && (e = i.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var s = n("%AsyncGenerator%");
    s && oe && (e = oe(s.prototype));
  }
  return rr[t] = e, e;
}, Xf = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, wo = xh, _a = Xm, Nx = wo.call(Function.call, Array.prototype.concat), Mx = wo.call(Function.apply, Array.prototype.splice), qf = wo.call(Function.call, String.prototype.replace), Ea = wo.call(Function.call, String.prototype.slice), Ox = wo.call(Function.call, RegExp.prototype.exec), Ax = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Px = /\\(\\)?/g, Dx = function(t) {
  var e = Ea(t, 0, 1), i = Ea(t, -1);
  if (e === "%" && i !== "%")
    throw new ss("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && e !== "%")
    throw new ss("invalid intrinsic syntax, expected opening `%`");
  var s = [];
  return qf(t, Ax, function(u, h, c, g) {
    s[s.length] = c ? qf(g, Px, "$1") : h || u;
  }), s;
}, Fx = function(t, e) {
  var i = t, s;
  if (_a(Xf, i) && (s = Xf[i], i = "%" + s[0] + "%"), _a(rr, i)) {
    var u = rr[i];
    if (u === jr && (u = Tx(i)), typeof u > "u" && !e)
      throw new Qr("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: s,
      name: i,
      value: u
    };
  }
  throw new ss("intrinsic " + t + " does not exist!");
}, Dn = function(t, e) {
  if (typeof t != "string" || t.length === 0)
    throw new Qr("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof e != "boolean")
    throw new Qr('"allowMissing" argument must be a boolean');
  if (Ox(/^%?[^%]*%?$/, t) === null)
    throw new ss("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = Dx(t), s = i.length > 0 ? i[0] : "", u = Fx("%" + s + "%", e), h = u.name, c = u.value, g = !1, m = u.alias;
  m && (s = m[0], Mx(i, Nx([0, 1], m)));
  for (var y = 1, p = !0; y < i.length; y += 1) {
    var _ = i[y], E = Ea(_, 0, 1), S = Ea(_, -1);
    if ((E === '"' || E === "'" || E === "`" || S === '"' || S === "'" || S === "`") && E !== S)
      throw new ss("property names with quotes must have matching quotes");
    if ((_ === "constructor" || !p) && (g = !0), s += "." + _, h = "%" + s + "%", _a(rr, h))
      c = rr[h];
    else if (c != null) {
      if (!(_ in c)) {
        if (!e)
          throw new Qr("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (ir && y + 1 >= i.length) {
        var I = ir(c, _);
        p = !!I, p && "get" in I && !("originalValue" in I.get) ? c = I.get : c = c[_];
      } else
        p = _a(c, _), c = c[_];
      p && !g && (rr[h] = c);
    }
  }
  return c;
}, Gx = Dn, Qo = Gx("%Object.defineProperty%", !0) || !1;
if (Qo)
  try {
    Qo({}, "a", { value: 1 });
  } catch {
    Qo = !1;
  }
var Sh = Qo, Bx = Dn, ta = Bx("%Object.getOwnPropertyDescriptor%", !0);
if (ta)
  try {
    ta([], "length");
  } catch {
    ta = null;
  }
var wh = ta, Uf = Sh, zx = Wm, zr = Fi, jf = wh, Ih = function(t, e, i) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new zr("`obj` must be an object or a function`");
  if (typeof e != "string" && typeof e != "symbol")
    throw new zr("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new zr("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new zr("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new zr("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new zr("`loose`, if provided, must be a boolean");
  var s = arguments.length > 3 ? arguments[3] : null, u = arguments.length > 4 ? arguments[4] : null, h = arguments.length > 5 ? arguments[5] : null, c = arguments.length > 6 ? arguments[6] : !1, g = !!jf && jf(t, e);
  if (Uf)
    Uf(t, e, {
      configurable: h === null && g ? g.configurable : !h,
      enumerable: s === null && g ? g.enumerable : !s,
      value: i,
      writable: u === null && g ? g.writable : !u
    });
  else if (c || !s && !u && !h)
    t[e] = i;
  else
    throw new zx("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, vl = Sh, Um = function() {
  return !!vl;
};
Um.hasArrayLengthDefineBug = function() {
  if (!vl)
    return null;
  try {
    return vl([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var kh = Um, Yx = _h, Wx = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", Xx = Object.prototype.toString, qx = Array.prototype.concat, Vf = Ih, Ux = function(n) {
  return typeof n == "function" && Xx.call(n) === "[object Function]";
}, jm = kh(), jx = function(n, t, e, i) {
  if (t in n) {
    if (i === !0) {
      if (n[t] === e)
        return;
    } else if (!Ux(i) || !i())
      return;
  }
  jm ? Vf(n, t, e, !0) : Vf(n, t, e);
}, Vm = function(n, t) {
  var e = arguments.length > 2 ? arguments[2] : {}, i = Yx(t);
  Wx && (i = qx.call(i, Object.getOwnPropertySymbols(t)));
  for (var s = 0; s < i.length; s += 1)
    jx(n, i[s], t[i[s]], e[i[s]]);
};
Vm.supportsDescriptors = !!jm;
var _r = Vm, Zm = { exports: {} }, Vx = Dn, Zf = Ih, Zx = kh(), Hf = wh, Kf = Fi, Hx = Vx("%Math.floor%"), Kx = function(t, e) {
  if (typeof t != "function")
    throw new Kf("`fn` is not a function");
  if (typeof e != "number" || e < 0 || e > 4294967295 || Hx(e) !== e)
    throw new Kf("`length` must be a positive 32-bit integer");
  var i = arguments.length > 2 && !!arguments[2], s = !0, u = !0;
  if ("length" in t && Hf) {
    var h = Hf(t, "length");
    h && !h.configurable && (s = !1), h && !h.writable && (u = !1);
  }
  return (s || u || !i) && (Zx ? Zf(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    e,
    !0,
    !0
  ) : Zf(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    e
  )), t;
};
(function(n) {
  var t = xh, e = Dn, i = Kx, s = Fi, u = e("%Function.prototype.apply%"), h = e("%Function.prototype.call%"), c = e("%Reflect.apply%", !0) || t.call(h, u), g = Sh, m = e("%Math.max%");
  n.exports = function(_) {
    if (typeof _ != "function")
      throw new s("a function is required");
    var E = c(t, h, arguments);
    return i(
      E,
      1 + m(0, _.length - (arguments.length - 1)),
      !0
    );
  };
  var y = function() {
    return c(t, u, arguments);
  };
  g ? g(n.exports, "apply", { value: y }) : n.exports.apply = y;
})(Zm);
var ds = Zm.exports, Hm = Dn, Km = ds, $x = Km(Hm("String.prototype.indexOf")), on = function(t, e) {
  var i = Hm(t, !!e);
  return typeof i == "function" && $x(t, ".prototype.") > -1 ? Km(i) : i;
}, Jx = _h, $m = Qa(), Jm = on, $f = Object, Qx = Jm("Array.prototype.push"), Jf = Jm("Object.prototype.propertyIsEnumerable"), tS = $m ? Object.getOwnPropertySymbols : null, Qm = function(t, e) {
  if (t == null)
    throw new TypeError("target must be an object");
  var i = $f(t);
  if (arguments.length === 1)
    return i;
  for (var s = 1; s < arguments.length; ++s) {
    var u = $f(arguments[s]), h = Jx(u), c = $m && (Object.getOwnPropertySymbols || tS);
    if (c)
      for (var g = c(u), m = 0; m < g.length; ++m) {
        var y = g[m];
        Jf(u, y) && Qx(h, y);
      }
    for (var p = 0; p < h.length; ++p) {
      var _ = h[p];
      if (Jf(u, _)) {
        var E = u[_];
        i[_] = E;
      }
    }
  }
  return i;
}, Fu = Qm, eS = function() {
  if (!Object.assign)
    return !1;
  for (var n = "abcdefghijklmnopqrst", t = n.split(""), e = {}, i = 0; i < t.length; ++i)
    e[t[i]] = t[i];
  var s = Object.assign({}, e), u = "";
  for (var h in s)
    u += h;
  return n !== u;
}, nS = function() {
  if (!Object.assign || !Object.preventExtensions)
    return !1;
  var n = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(n, "xy");
  } catch {
    return n[1] === "y";
  }
  return !1;
}, ty = function() {
  return !Object.assign || eS() || nS() ? Fu : Object.assign;
}, iS = _r, rS = ty, sS = function() {
  var t = rS();
  return iS(
    Object,
    { assign: t },
    { assign: function() {
      return Object.assign !== t;
    } }
  ), t;
}, oS = _r, aS = ds, uS = Qm, ey = ty, lS = sS, hS = aS.apply(ey()), ny = function(t, e) {
  return hS(Object, arguments);
};
oS(ny, {
  getPolyfill: ey,
  implementation: uS,
  shim: lS
});
var cS = ny, mo = function() {
  return typeof (function() {
  }).name == "string";
}, Vs = Object.getOwnPropertyDescriptor;
if (Vs)
  try {
    Vs([], "length");
  } catch {
    Vs = null;
  }
mo.functionsHaveConfigurableNames = function() {
  if (!mo() || !Vs)
    return !1;
  var t = Vs(function() {
  }, "name");
  return !!t && !!t.configurable;
};
var fS = Function.prototype.bind;
mo.boundFunctionsHaveNames = function() {
  return mo() && typeof fS == "function" && (function() {
  }).bind().name !== "";
};
var gS = mo, Qf = Ih, dS = kh(), mS = gS.functionsHaveConfigurableNames(), yS = Fi, pS = function(t, e) {
  if (typeof t != "function")
    throw new yS("`fn` is not a function");
  var i = arguments.length > 2 && !!arguments[2];
  return (!i || mS) && (dS ? Qf(
    /** @type {Parameters<define>[0]} */
    t,
    "name",
    e,
    !0,
    !0
  ) : Qf(
    /** @type {Parameters<define>[0]} */
    t,
    "name",
    e
  )), t;
}, vS = pS, _S = Fi, ES = Object, iy = vS(function() {
  if (this == null || this !== ES(this))
    throw new _S("RegExp.prototype.flags getter called on non-object");
  var t = "";
  return this.hasIndices && (t += "d"), this.global && (t += "g"), this.ignoreCase && (t += "i"), this.multiline && (t += "m"), this.dotAll && (t += "s"), this.unicode && (t += "u"), this.unicodeSets && (t += "v"), this.sticky && (t += "y"), t;
}, "get flags", !0), xS = iy, SS = _r.supportsDescriptors, wS = Object.getOwnPropertyDescriptor, ry = function() {
  if (SS && /a/mig.flags === "gim") {
    var t = wS(RegExp.prototype, "flags");
    if (t && typeof t.get == "function" && typeof RegExp.prototype.dotAll == "boolean" && typeof RegExp.prototype.hasIndices == "boolean") {
      var e = "", i = {};
      if (Object.defineProperty(i, "hasIndices", {
        get: function() {
          e += "d";
        }
      }), Object.defineProperty(i, "sticky", {
        get: function() {
          e += "y";
        }
      }), e === "dy")
        return t.get;
    }
  }
  return xS;
}, IS = _r.supportsDescriptors, kS = ry, bS = Object.getOwnPropertyDescriptor, CS = Object.defineProperty, RS = TypeError, tg = Object.getPrototypeOf, LS = /a/, TS = function() {
  if (!IS || !tg)
    throw new RS("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  var t = kS(), e = tg(LS), i = bS(e, "flags");
  return (!i || i.get !== t) && CS(e, "flags", {
    configurable: !0,
    enumerable: !1,
    get: t
  }), t;
}, NS = _r, MS = ds, OS = iy, sy = ry, AS = TS, oy = MS(sy());
NS(oy, {
  getPolyfill: sy,
  implementation: OS,
  shim: AS
});
var PS = oy, ea = { exports: {} }, DS = Qa, Er = function() {
  return DS() && !!Symbol.toStringTag;
}, FS = Er(), GS = on, _l = GS("Object.prototype.toString"), tu = function(t) {
  return FS && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : _l(t) === "[object Arguments]";
}, ay = function(t) {
  return tu(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && _l(t) !== "[object Array]" && _l(t.callee) === "[object Function]";
}, BS = function() {
  return tu(arguments);
}();
tu.isLegacyArguments = ay;
var uy = BS ? tu : ay;
const zS = {}, YS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: zS
}, Symbol.toStringTag, { value: "Module" })), WS = /* @__PURE__ */ JE(YS);
var bh = typeof Map == "function" && Map.prototype, Gu = Object.getOwnPropertyDescriptor && bh ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, xa = bh && Gu && typeof Gu.get == "function" ? Gu.get : null, eg = bh && Map.prototype.forEach, Ch = typeof Set == "function" && Set.prototype, Bu = Object.getOwnPropertyDescriptor && Ch ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Sa = Ch && Bu && typeof Bu.get == "function" ? Bu.get : null, ng = Ch && Set.prototype.forEach, XS = typeof WeakMap == "function" && WeakMap.prototype, Zs = XS ? WeakMap.prototype.has : null, qS = typeof WeakSet == "function" && WeakSet.prototype, Hs = qS ? WeakSet.prototype.has : null, US = typeof WeakRef == "function" && WeakRef.prototype, ig = US ? WeakRef.prototype.deref : null, jS = Boolean.prototype.valueOf, VS = Object.prototype.toString, ZS = Function.prototype.toString, HS = String.prototype.match, Rh = String.prototype.slice, bi = String.prototype.replace, KS = String.prototype.toUpperCase, rg = String.prototype.toLowerCase, ly = RegExp.prototype.test, sg = Array.prototype.concat, Cn = Array.prototype.join, $S = Array.prototype.slice, og = Math.floor, El = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, zu = Object.getOwnPropertySymbols, xl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, os = typeof Symbol == "function" && typeof Symbol.iterator == "object", be = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === os || !0) ? Symbol.toStringTag : null, hy = Object.prototype.propertyIsEnumerable, ag = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(n) {
  return n.__proto__;
} : null);
function ug(n, t) {
  if (n === 1 / 0 || n === -1 / 0 || n !== n || n && n > -1e3 && n < 1e3 || ly.call(/e/, t))
    return t;
  var e = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof n == "number") {
    var i = n < 0 ? -og(-n) : og(n);
    if (i !== n) {
      var s = String(i), u = Rh.call(t, s.length + 1);
      return bi.call(s, e, "$&_") + "." + bi.call(bi.call(u, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return bi.call(t, e, "$&_");
}
var Sl = WS, lg = Sl.custom, hg = fy(lg) ? lg : null, JS = function n(t, e, i, s) {
  var u = e || {};
  if (_i(u, "quoteStyle") && u.quoteStyle !== "single" && u.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (_i(u, "maxStringLength") && (typeof u.maxStringLength == "number" ? u.maxStringLength < 0 && u.maxStringLength !== 1 / 0 : u.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var h = _i(u, "customInspect") ? u.customInspect : !0;
  if (typeof h != "boolean" && h !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (_i(u, "indent") && u.indent !== null && u.indent !== "	" && !(parseInt(u.indent, 10) === u.indent && u.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (_i(u, "numericSeparator") && typeof u.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var c = u.numericSeparator;
  if (typeof t > "u")
    return "undefined";
  if (t === null)
    return "null";
  if (typeof t == "boolean")
    return t ? "true" : "false";
  if (typeof t == "string")
    return dy(t, u);
  if (typeof t == "number") {
    if (t === 0)
      return 1 / 0 / t > 0 ? "0" : "-0";
    var g = String(t);
    return c ? ug(t, g) : g;
  }
  if (typeof t == "bigint") {
    var m = String(t) + "n";
    return c ? ug(t, m) : m;
  }
  var y = typeof u.depth > "u" ? 5 : u.depth;
  if (typeof i > "u" && (i = 0), i >= y && y > 0 && typeof t == "object")
    return wl(t) ? "[Array]" : "[Object]";
  var p = yw(u, i);
  if (typeof s > "u")
    s = [];
  else if (gy(s, t) >= 0)
    return "[Circular]";
  function _(nt, z, K) {
    if (z && (s = $S.call(s), s.push(z)), K) {
      var Z = {
        depth: u.depth
      };
      return _i(u, "quoteStyle") && (Z.quoteStyle = u.quoteStyle), n(nt, Z, i + 1, s);
    }
    return n(nt, u, i + 1, s);
  }
  if (typeof t == "function" && !cg(t)) {
    var E = aw(t), S = Yo(t, _);
    return "[Function" + (E ? ": " + E : " (anonymous)") + "]" + (S.length > 0 ? " { " + Cn.call(S, ", ") + " }" : "");
  }
  if (fy(t)) {
    var I = os ? bi.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : xl.call(t);
    return typeof t == "object" && !os ? As(I) : I;
  }
  if (gw(t)) {
    for (var b = "<" + rg.call(String(t.nodeName)), C = t.attributes || [], R = 0; R < C.length; R++)
      b += " " + C[R].name + "=" + cy(QS(C[R].value), "double", u);
    return b += ">", t.childNodes && t.childNodes.length && (b += "..."), b += "</" + rg.call(String(t.nodeName)) + ">", b;
  }
  if (wl(t)) {
    if (t.length === 0)
      return "[]";
    var T = Yo(t, _);
    return p && !mw(T) ? "[" + Il(T, p) + "]" : "[ " + Cn.call(T, ", ") + " ]";
  }
  if (ew(t)) {
    var O = Yo(t, _);
    return !("cause" in Error.prototype) && "cause" in t && !hy.call(t, "cause") ? "{ [" + String(t) + "] " + Cn.call(sg.call("[cause]: " + _(t.cause), O), ", ") + " }" : O.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + Cn.call(O, ", ") + " }";
  }
  if (typeof t == "object" && h) {
    if (hg && typeof t[hg] == "function" && Sl)
      return Sl(t, { depth: y - i });
    if (h !== "symbol" && typeof t.inspect == "function")
      return t.inspect();
  }
  if (uw(t)) {
    var M = [];
    return eg && eg.call(t, function(nt, z) {
      M.push(_(z, t, !0) + " => " + _(nt, t));
    }), fg("Map", xa.call(t), M, p);
  }
  if (cw(t)) {
    var G = [];
    return ng && ng.call(t, function(nt) {
      G.push(_(nt, t));
    }), fg("Set", Sa.call(t), G, p);
  }
  if (lw(t))
    return Yu("WeakMap");
  if (fw(t))
    return Yu("WeakSet");
  if (hw(t))
    return Yu("WeakRef");
  if (iw(t))
    return As(_(Number(t)));
  if (sw(t))
    return As(_(El.call(t)));
  if (rw(t))
    return As(jS.call(t));
  if (nw(t))
    return As(_(String(t)));
  if (typeof window < "u" && t === window)
    return "{ [object Window] }";
  if (typeof globalThis < "u" && t === globalThis || typeof go < "u" && t === go)
    return "{ [object globalThis] }";
  if (!tw(t) && !cg(t)) {
    var D = Yo(t, _), F = ag ? ag(t) === Object.prototype : t instanceof Object || t.constructor === Object, A = t instanceof Object ? "" : "null prototype", j = !F && be && Object(t) === t && be in t ? Rh.call(Gi(t), 8, -1) : A ? "Object" : "", et = F || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", U = et + (j || A ? "[" + Cn.call(sg.call([], j || [], A || []), ": ") + "] " : "");
    return D.length === 0 ? U + "{}" : p ? U + "{" + Il(D, p) + "}" : U + "{ " + Cn.call(D, ", ") + " }";
  }
  return String(t);
};
function cy(n, t, e) {
  var i = (e.quoteStyle || t) === "double" ? '"' : "'";
  return i + n + i;
}
function QS(n) {
  return bi.call(String(n), /"/g, "&quot;");
}
function wl(n) {
  return Gi(n) === "[object Array]" && (!be || !(typeof n == "object" && be in n));
}
function tw(n) {
  return Gi(n) === "[object Date]" && (!be || !(typeof n == "object" && be in n));
}
function cg(n) {
  return Gi(n) === "[object RegExp]" && (!be || !(typeof n == "object" && be in n));
}
function ew(n) {
  return Gi(n) === "[object Error]" && (!be || !(typeof n == "object" && be in n));
}
function nw(n) {
  return Gi(n) === "[object String]" && (!be || !(typeof n == "object" && be in n));
}
function iw(n) {
  return Gi(n) === "[object Number]" && (!be || !(typeof n == "object" && be in n));
}
function rw(n) {
  return Gi(n) === "[object Boolean]" && (!be || !(typeof n == "object" && be in n));
}
function fy(n) {
  if (os)
    return n && typeof n == "object" && n instanceof Symbol;
  if (typeof n == "symbol")
    return !0;
  if (!n || typeof n != "object" || !xl)
    return !1;
  try {
    return xl.call(n), !0;
  } catch {
  }
  return !1;
}
function sw(n) {
  if (!n || typeof n != "object" || !El)
    return !1;
  try {
    return El.call(n), !0;
  } catch {
  }
  return !1;
}
var ow = Object.prototype.hasOwnProperty || function(n) {
  return n in this;
};
function _i(n, t) {
  return ow.call(n, t);
}
function Gi(n) {
  return VS.call(n);
}
function aw(n) {
  if (n.name)
    return n.name;
  var t = HS.call(ZS.call(n), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function gy(n, t) {
  if (n.indexOf)
    return n.indexOf(t);
  for (var e = 0, i = n.length; e < i; e++)
    if (n[e] === t)
      return e;
  return -1;
}
function uw(n) {
  if (!xa || !n || typeof n != "object")
    return !1;
  try {
    xa.call(n);
    try {
      Sa.call(n);
    } catch {
      return !0;
    }
    return n instanceof Map;
  } catch {
  }
  return !1;
}
function lw(n) {
  if (!Zs || !n || typeof n != "object")
    return !1;
  try {
    Zs.call(n, Zs);
    try {
      Hs.call(n, Hs);
    } catch {
      return !0;
    }
    return n instanceof WeakMap;
  } catch {
  }
  return !1;
}
function hw(n) {
  if (!ig || !n || typeof n != "object")
    return !1;
  try {
    return ig.call(n), !0;
  } catch {
  }
  return !1;
}
function cw(n) {
  if (!Sa || !n || typeof n != "object")
    return !1;
  try {
    Sa.call(n);
    try {
      xa.call(n);
    } catch {
      return !0;
    }
    return n instanceof Set;
  } catch {
  }
  return !1;
}
function fw(n) {
  if (!Hs || !n || typeof n != "object")
    return !1;
  try {
    Hs.call(n, Hs);
    try {
      Zs.call(n, Zs);
    } catch {
      return !0;
    }
    return n instanceof WeakSet;
  } catch {
  }
  return !1;
}
function gw(n) {
  return !n || typeof n != "object" ? !1 : typeof HTMLElement < "u" && n instanceof HTMLElement ? !0 : typeof n.nodeName == "string" && typeof n.getAttribute == "function";
}
function dy(n, t) {
  if (n.length > t.maxStringLength) {
    var e = n.length - t.maxStringLength, i = "... " + e + " more character" + (e > 1 ? "s" : "");
    return dy(Rh.call(n, 0, t.maxStringLength), t) + i;
  }
  var s = bi.call(bi.call(n, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, dw);
  return cy(s, "single", t);
}
function dw(n) {
  var t = n.charCodeAt(0), e = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[t];
  return e ? "\\" + e : "\\x" + (t < 16 ? "0" : "") + KS.call(t.toString(16));
}
function As(n) {
  return "Object(" + n + ")";
}
function Yu(n) {
  return n + " { ? }";
}
function fg(n, t, e, i) {
  var s = i ? Il(e, i) : Cn.call(e, ", ");
  return n + " (" + t + ") {" + s + "}";
}
function mw(n) {
  for (var t = 0; t < n.length; t++)
    if (gy(n[t], `
`) >= 0)
      return !1;
  return !0;
}
function yw(n, t) {
  var e;
  if (n.indent === "	")
    e = "	";
  else if (typeof n.indent == "number" && n.indent > 0)
    e = Cn.call(Array(n.indent + 1), " ");
  else
    return null;
  return {
    base: e,
    prev: Cn.call(Array(t + 1), e)
  };
}
function Il(n, t) {
  if (n.length === 0)
    return "";
  var e = `
` + t.prev + t.base;
  return e + Cn.call(n, "," + e) + `
` + t.prev;
}
function Yo(n, t) {
  var e = wl(n), i = [];
  if (e) {
    i.length = n.length;
    for (var s = 0; s < n.length; s++)
      i[s] = _i(n, s) ? t(n[s], n) : "";
  }
  var u = typeof zu == "function" ? zu(n) : [], h;
  if (os) {
    h = {};
    for (var c = 0; c < u.length; c++)
      h["$" + u[c]] = u[c];
  }
  for (var g in n)
    _i(n, g) && (e && String(Number(g)) === g && g < n.length || os && h["$" + g] instanceof Symbol || (ly.call(/[^\w$]/, g) ? i.push(t(g, n) + ": " + t(n[g], n)) : i.push(g + ": " + t(n[g], n))));
  if (typeof zu == "function")
    for (var m = 0; m < u.length; m++)
      hy.call(n, u[m]) && i.push("[" + t(u[m]) + "]: " + t(n[u[m]], n));
  return i;
}
var my = Dn, ms = on, pw = JS, vw = Fi, Wo = my("%WeakMap%", !0), Xo = my("%Map%", !0), _w = ms("WeakMap.prototype.get", !0), Ew = ms("WeakMap.prototype.set", !0), xw = ms("WeakMap.prototype.has", !0), Sw = ms("Map.prototype.get", !0), ww = ms("Map.prototype.set", !0), Iw = ms("Map.prototype.has", !0), Lh = function(n, t) {
  for (var e = n, i; (i = e.next) !== null; e = i)
    if (i.key === t)
      return e.next = i.next, i.next = /** @type {NonNullable<typeof list.next>} */
      n.next, n.next = i, i;
}, kw = function(n, t) {
  var e = Lh(n, t);
  return e && e.value;
}, bw = function(n, t, e) {
  var i = Lh(n, t);
  i ? i.value = e : n.next = /** @type {import('.').ListNode<typeof value>} */
  {
    // eslint-disable-line no-param-reassign, no-extra-parens
    key: t,
    next: n.next,
    value: e
  };
}, Cw = function(n, t) {
  return !!Lh(n, t);
}, yy = function() {
  var t, e, i, s = {
    assert: function(u) {
      if (!s.has(u))
        throw new vw("Side channel does not contain " + pw(u));
    },
    get: function(u) {
      if (Wo && u && (typeof u == "object" || typeof u == "function")) {
        if (t)
          return _w(t, u);
      } else if (Xo) {
        if (e)
          return Sw(e, u);
      } else if (i)
        return kw(i, u);
    },
    has: function(u) {
      if (Wo && u && (typeof u == "object" || typeof u == "function")) {
        if (t)
          return xw(t, u);
      } else if (Xo) {
        if (e)
          return Iw(e, u);
      } else if (i)
        return Cw(i, u);
      return !1;
    },
    set: function(u, h) {
      Wo && u && (typeof u == "object" || typeof u == "function") ? (t || (t = new Wo()), Ew(t, u, h)) : Xo ? (e || (e = new Xo()), ww(e, u, h)) : (i || (i = { key: {}, next: null }), bw(i, u, h));
    }
  };
  return s;
}, Rw = Xm, Ps = yy(), Vn = Fi, Th = {
  assert: function(n, t) {
    if (!n || typeof n != "object" && typeof n != "function")
      throw new Vn("`O` is not an object");
    if (typeof t != "string")
      throw new Vn("`slot` must be a string");
    if (Ps.assert(n), !Th.has(n, t))
      throw new Vn("`" + t + "` is not present on `O`");
  },
  get: function(n, t) {
    if (!n || typeof n != "object" && typeof n != "function")
      throw new Vn("`O` is not an object");
    if (typeof t != "string")
      throw new Vn("`slot` must be a string");
    var e = Ps.get(n);
    return e && e["$" + t];
  },
  has: function(n, t) {
    if (!n || typeof n != "object" && typeof n != "function")
      throw new Vn("`O` is not an object");
    if (typeof t != "string")
      throw new Vn("`slot` must be a string");
    var e = Ps.get(n);
    return !!e && Rw(e, "$" + t);
  },
  set: function(n, t, e) {
    if (!n || typeof n != "object" && typeof n != "function")
      throw new Vn("`O` is not an object");
    if (typeof t != "string")
      throw new Vn("`slot` must be a string");
    var i = Ps.get(n);
    i || (i = {}, Ps.set(n, i)), i["$" + t] = e;
  }
};
Object.freeze && Object.freeze(Th);
var Lw = Th, Ds = Lw, Tw = SyntaxError, gg = typeof StopIteration == "object" ? StopIteration : null, Nw = function(t) {
  if (!gg)
    throw new Tw("this environment lacks StopIteration");
  Ds.set(t, "[[Done]]", !1);
  var e = {
    next: function() {
      var s = Ds.get(this, "[[Iterator]]"), u = Ds.get(s, "[[Done]]");
      try {
        return {
          done: u,
          value: u ? void 0 : s.next()
        };
      } catch (h) {
        if (Ds.set(s, "[[Done]]", !0), h !== gg)
          throw h;
        return {
          done: !0,
          value: void 0
        };
      }
    }
  };
  return Ds.set(e, "[[Iterator]]", t), e;
}, Mw = {}.toString, py = Array.isArray || function(n) {
  return Mw.call(n) == "[object Array]";
}, Ow = String.prototype.valueOf, Aw = function(t) {
  try {
    return Ow.call(t), !0;
  } catch {
    return !1;
  }
}, Pw = Object.prototype.toString, Dw = "[object String]", Fw = Er(), vy = function(t) {
  return typeof t == "string" ? !0 : typeof t != "object" ? !1 : Fw ? Aw(t) : Pw.call(t) === Dw;
}, Nh = typeof Map == "function" && Map.prototype ? Map : null, Gw = typeof Set == "function" && Set.prototype ? Set : null, wa;
Nh || (wa = function(t) {
  return !1;
});
var _y = Nh ? Map.prototype.has : null, dg = Gw ? Set.prototype.has : null;
!wa && !_y && (wa = function(t) {
  return !1;
});
var Ey = wa || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (_y.call(t), dg)
      try {
        dg.call(t);
      } catch {
        return !0;
      }
    return t instanceof Nh;
  } catch {
  }
  return !1;
}, Bw = typeof Map == "function" && Map.prototype ? Map : null, Mh = typeof Set == "function" && Set.prototype ? Set : null, Ia;
Mh || (Ia = function(t) {
  return !1;
});
var mg = Bw ? Map.prototype.has : null, xy = Mh ? Set.prototype.has : null;
!Ia && !xy && (Ia = function(t) {
  return !1;
});
var Sy = Ia || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (xy.call(t), mg)
      try {
        mg.call(t);
      } catch {
        return !0;
      }
    return t instanceof Mh;
  } catch {
  }
  return !1;
}, yg = uy, pg = Nw;
if (Eh() || Qa()) {
  var Wu = Symbol.iterator;
  ea.exports = function(t) {
    if (t != null && typeof t[Wu] < "u")
      return t[Wu]();
    if (yg(t))
      return Array.prototype[Wu].call(t);
  };
} else {
  var zw = py, Yw = vy, vg = Dn, Ww = vg("%Map%", !0), Xw = vg("%Set%", !0), dn = on, _g = dn("Array.prototype.push"), Eg = dn("String.prototype.charCodeAt"), qw = dn("String.prototype.slice"), Uw = function(t, e) {
    var i = t.length;
    if (e + 1 >= i)
      return e + 1;
    var s = Eg(t, e);
    if (s < 55296 || s > 56319)
      return e + 1;
    var u = Eg(t, e + 1);
    return u < 56320 || u > 57343 ? e + 1 : e + 2;
  }, Xu = function(t) {
    var e = 0;
    return {
      next: function() {
        var s = e >= t.length, u;
        return s || (u = t[e], e += 1), {
          done: s,
          value: u
        };
      }
    };
  }, xg = function(t, e) {
    if (zw(t) || yg(t))
      return Xu(t);
    if (Yw(t)) {
      var i = 0;
      return {
        next: function() {
          var u = Uw(t, i), h = qw(t, i, u);
          return i = u, {
            done: u > t.length,
            value: h
          };
        }
      };
    }
    if (e && typeof t["_es6-shim iterator_"] < "u")
      return t["_es6-shim iterator_"]();
  };
  if (!Ww && !Xw)
    ea.exports = function(t) {
      if (t != null)
        return xg(t, !0);
    };
  else {
    var jw = Ey, Vw = Sy, Sg = dn("Map.prototype.forEach", !0), wg = dn("Set.prototype.forEach", !0);
    if (typeof process > "u" || !process.versions || !process.versions.node)
      var Ig = dn("Map.prototype.iterator", !0), kg = dn("Set.prototype.iterator", !0);
    var bg = dn("Map.prototype.@@iterator", !0) || dn("Map.prototype._es6-shim iterator_", !0), Cg = dn("Set.prototype.@@iterator", !0) || dn("Set.prototype._es6-shim iterator_", !0), Zw = function(t) {
      if (jw(t)) {
        if (Ig)
          return pg(Ig(t));
        if (bg)
          return bg(t);
        if (Sg) {
          var e = [];
          return Sg(t, function(s, u) {
            _g(e, [u, s]);
          }), Xu(e);
        }
      }
      if (Vw(t)) {
        if (kg)
          return pg(kg(t));
        if (Cg)
          return Cg(t);
        if (wg) {
          var i = [];
          return wg(t, function(s) {
            _g(i, s);
          }), Xu(i);
        }
      }
    };
    ea.exports = function(t) {
      return Zw(t) || xg(t);
    };
  }
}
var Hw = ea.exports, Rg = function(n) {
  return n !== n;
}, wy = function(t, e) {
  return t === 0 && e === 0 ? 1 / t === 1 / e : !!(t === e || Rg(t) && Rg(e));
}, Kw = wy, Iy = function() {
  return typeof Object.is == "function" ? Object.is : Kw;
}, $w = Iy, Jw = _r, Qw = function() {
  var t = $w();
  return Jw(Object, { is: t }, {
    is: function() {
      return Object.is !== t;
    }
  }), t;
}, tI = _r, eI = ds, nI = wy, ky = Iy, iI = Qw, by = eI(ky(), Object);
tI(by, {
  getPolyfill: ky,
  implementation: nI,
  shim: iI
});
var rI = by, sI = ds, Cy = on, oI = Dn, kl = oI("%ArrayBuffer%", !0), na = Cy("ArrayBuffer.prototype.byteLength", !0), aI = Cy("Object.prototype.toString"), Lg = !!kl && !na && new kl(0).slice, Tg = !!Lg && sI(Lg), Ry = na || Tg ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    return na ? na(t) : Tg(t, 0), !0;
  } catch {
    return !1;
  }
} : kl ? function(t) {
  return aI(t) === "[object ArrayBuffer]";
} : function(t) {
  return !1;
}, uI = Date.prototype.getDay, lI = function(t) {
  try {
    return uI.call(t), !0;
  } catch {
    return !1;
  }
}, hI = Object.prototype.toString, cI = "[object Date]", fI = Er(), gI = function(t) {
  return typeof t != "object" || t === null ? !1 : fI ? lI(t) : hI.call(t) === cI;
}, bl = on, Ly = Er(), Ty, Ny, Cl, Rl;
if (Ly) {
  Ty = bl("Object.prototype.hasOwnProperty"), Ny = bl("RegExp.prototype.exec"), Cl = {};
  var qu = function() {
    throw Cl;
  };
  Rl = {
    toString: qu,
    valueOf: qu
  }, typeof Symbol.toPrimitive == "symbol" && (Rl[Symbol.toPrimitive] = qu);
}
var dI = bl("Object.prototype.toString"), mI = Object.getOwnPropertyDescriptor, yI = "[object RegExp]", pI = Ly ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  var e = mI(t, "lastIndex"), i = e && Ty(e, "value");
  if (!i)
    return !1;
  try {
    Ny(t, Rl);
  } catch (s) {
    return s === Cl;
  }
} : function(t) {
  return !t || typeof t != "object" && typeof t != "function" ? !1 : dI(t) === yI;
}, vI = on, Ng = vI("SharedArrayBuffer.prototype.byteLength", !0), _I = Ng ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    return Ng(t), !0;
  } catch {
    return !1;
  }
} : function(t) {
  return !1;
}, EI = Number.prototype.toString, xI = function(t) {
  try {
    return EI.call(t), !0;
  } catch {
    return !1;
  }
}, SI = Object.prototype.toString, wI = "[object Number]", II = Er(), kI = function(t) {
  return typeof t == "number" ? !0 : typeof t != "object" ? !1 : II ? xI(t) : SI.call(t) === wI;
}, My = on, bI = My("Boolean.prototype.toString"), CI = My("Object.prototype.toString"), RI = function(t) {
  try {
    return bI(t), !0;
  } catch {
    return !1;
  }
}, LI = "[object Boolean]", TI = Er(), NI = function(t) {
  return typeof t == "boolean" ? !0 : t === null || typeof t != "object" ? !1 : TI && Symbol.toStringTag in t ? RI(t) : CI(t) === LI;
}, Ll = { exports: {} }, MI = Object.prototype.toString, OI = Eh();
if (OI) {
  var AI = Symbol.prototype.toString, PI = /^Symbol\(.*\)$/, DI = function(t) {
    return typeof t.valueOf() != "symbol" ? !1 : PI.test(AI.call(t));
  };
  Ll.exports = function(t) {
    if (typeof t == "symbol")
      return !0;
    if (MI.call(t) !== "[object Symbol]")
      return !1;
    try {
      return DI(t);
    } catch {
      return !1;
    }
  };
} else
  Ll.exports = function(t) {
    return !1;
  };
var FI = Ll.exports, Tl = { exports: {} }, Mg = typeof BigInt < "u" && BigInt, GI = function() {
  return typeof Mg == "function" && typeof BigInt == "function" && typeof Mg(42) == "bigint" && typeof BigInt(42) == "bigint";
}, BI = GI();
if (BI) {
  var zI = BigInt.prototype.valueOf, YI = function(t) {
    try {
      return zI.call(t), !0;
    } catch {
    }
    return !1;
  };
  Tl.exports = function(t) {
    return t === null || typeof t > "u" || typeof t == "boolean" || typeof t == "string" || typeof t == "number" || typeof t == "symbol" || typeof t == "function" ? !1 : typeof t == "bigint" ? !0 : YI(t);
  };
} else
  Tl.exports = function(t) {
    return !1;
  };
var WI = Tl.exports, XI = vy, qI = kI, UI = NI, jI = FI, VI = WI, ZI = function(t) {
  if (t == null || typeof t != "object" && typeof t != "function")
    return null;
  if (XI(t))
    return "String";
  if (qI(t))
    return "Number";
  if (UI(t))
    return "Boolean";
  if (jI(t))
    return "Symbol";
  if (VI(t))
    return "BigInt";
}, ka = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap : null, Og = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet : null, ba;
ka || (ba = function(t) {
  return !1;
});
var Nl = ka ? ka.prototype.has : null, Uu = Og ? Og.prototype.has : null;
!ba && !Nl && (ba = function(t) {
  return !1;
});
var HI = ba || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (Nl.call(t, Nl), Uu)
      try {
        Uu.call(t, Uu);
      } catch {
        return !0;
      }
    return t instanceof ka;
  } catch {
  }
  return !1;
}, Ml = { exports: {} }, KI = Dn, Oy = on, $I = KI("%WeakSet%", !0), ju = Oy("WeakSet.prototype.has", !0);
if (ju) {
  var Vu = Oy("WeakMap.prototype.has", !0);
  Ml.exports = function(t) {
    if (!t || typeof t != "object")
      return !1;
    try {
      if (ju(t, ju), Vu)
        try {
          Vu(t, Vu);
        } catch {
          return !0;
        }
      return t instanceof $I;
    } catch {
    }
    return !1;
  };
} else
  Ml.exports = function(t) {
    return !1;
  };
var JI = Ml.exports, QI = Ey, tk = Sy, ek = HI, nk = JI, ik = function(t) {
  if (t && typeof t == "object") {
    if (QI(t))
      return "Map";
    if (tk(t))
      return "Set";
    if (ek(t))
      return "WeakMap";
    if (nk(t))
      return "WeakSet";
  }
  return !1;
}, Ay = Function.prototype.toString, Kr = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Ol, ia;
if (typeof Kr == "function" && typeof Object.defineProperty == "function")
  try {
    Ol = Object.defineProperty({}, "length", {
      get: function() {
        throw ia;
      }
    }), ia = {}, Kr(function() {
      throw 42;
    }, null, Ol);
  } catch (n) {
    n !== ia && (Kr = null);
  }
else
  Kr = null;
var rk = /^\s*class\b/, Al = function(t) {
  try {
    var e = Ay.call(t);
    return rk.test(e);
  } catch {
    return !1;
  }
}, Zu = function(t) {
  try {
    return Al(t) ? !1 : (Ay.call(t), !0);
  } catch {
    return !1;
  }
}, ra = Object.prototype.toString, sk = "[object Object]", ok = "[object Function]", ak = "[object GeneratorFunction]", uk = "[object HTMLAllCollection]", lk = "[object HTML document.all class]", hk = "[object HTMLCollection]", ck = typeof Symbol == "function" && !!Symbol.toStringTag, fk = !(0 in [,]), Pl = function() {
  return !1;
};
if (typeof document == "object") {
  var gk = document.all;
  ra.call(gk) === ra.call(document.all) && (Pl = function(t) {
    if ((fk || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var e = ra.call(t);
        return (e === uk || e === lk || e === hk || e === sk) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var dk = Kr ? function(t) {
  if (Pl(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    Kr(t, null, Ol);
  } catch (e) {
    if (e !== ia)
      return !1;
  }
  return !Al(t) && Zu(t);
} : function(t) {
  if (Pl(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (ck)
    return Zu(t);
  if (Al(t))
    return !1;
  var e = ra.call(t);
  return e !== ok && e !== ak && !/^\[object HTML/.test(e) ? !1 : Zu(t);
}, mk = dk, yk = Object.prototype.toString, Py = Object.prototype.hasOwnProperty, pk = function(t, e, i) {
  for (var s = 0, u = t.length; s < u; s++)
    Py.call(t, s) && (i == null ? e(t[s], s, t) : e.call(i, t[s], s, t));
}, vk = function(t, e, i) {
  for (var s = 0, u = t.length; s < u; s++)
    i == null ? e(t.charAt(s), s, t) : e.call(i, t.charAt(s), s, t);
}, _k = function(t, e, i) {
  for (var s in t)
    Py.call(t, s) && (i == null ? e(t[s], s, t) : e.call(i, t[s], s, t));
}, Ek = function(t, e, i) {
  if (!mk(e))
    throw new TypeError("iterator must be a function");
  var s;
  arguments.length >= 3 && (s = i), yk.call(t) === "[object Array]" ? pk(t, e, s) : typeof t == "string" ? vk(t, e, s) : _k(t, e, s);
}, xk = Ek, Sk = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], Hu = Sk, wk = typeof globalThis > "u" ? go : globalThis, Ik = function() {
  for (var t = [], e = 0; e < Hu.length; e++)
    typeof wk[Hu[e]] == "function" && (t[t.length] = Hu[e]);
  return t;
}, Ca = xk, kk = Ik, Ag = ds, Oh = on, sa = wh, bk = Oh("Object.prototype.toString"), Dy = Er(), Pg = typeof globalThis > "u" ? go : globalThis, Dl = kk(), Ah = Oh("String.prototype.slice"), Ku = Object.getPrototypeOf, Ck = Oh("Array.prototype.indexOf", !0) || function(t, e) {
  for (var i = 0; i < t.length; i += 1)
    if (t[i] === e)
      return i;
  return -1;
}, Ra = { __proto__: null };
Dy && sa && Ku ? Ca(Dl, function(n) {
  var t = new Pg[n]();
  if (Symbol.toStringTag in t) {
    var e = Ku(t), i = sa(e, Symbol.toStringTag);
    if (!i) {
      var s = Ku(e);
      i = sa(s, Symbol.toStringTag);
    }
    Ra["$" + n] = Ag(i.get);
  }
}) : Ca(Dl, function(n) {
  var t = new Pg[n](), e = t.slice || t.set;
  e && (Ra["$" + n] = Ag(e));
});
var Rk = function(t) {
  var e = !1;
  return Ca(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    Ra,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(i, s) {
      if (!e)
        try {
          "$" + i(t) === s && (e = Ah(s, 1));
        } catch {
        }
    }
  ), e;
}, Lk = function(t) {
  var e = !1;
  return Ca(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    Ra,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(i, s) {
      if (!e)
        try {
          i(t), e = Ah(s, 1);
        } catch {
        }
    }
  ), e;
}, Tk = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!Dy) {
    var e = Ah(bk(t), 8, -1);
    return Ck(Dl, e) > -1 ? e : e !== "Object" ? !1 : Lk(t);
  }
  return sa ? Rk(t) : null;
}, Nk = on, Dg = Nk("ArrayBuffer.prototype.byteLength", !0), Mk = Ry, Ok = function(t) {
  return Mk(t) ? Dg ? Dg(t) : t.byteLength : NaN;
}, Fy = cS, Fn = on, Fg = PS, Ak = Dn, as = Hw, Pk = yy, Gg = rI, Bg = uy, zg = py, Yg = Ry, Wg = gI, Xg = pI, qg = _I, Ug = _h, jg = ZI, Vg = ik, Zg = Tk, Hg = Ok, Kg = Fn("SharedArrayBuffer.prototype.byteLength", !0), $g = Fn("Date.prototype.getTime"), $u = Object.getPrototypeOf, Jg = Fn("Object.prototype.toString"), La = Ak("%Set%", !0), Fl = Fn("Map.prototype.has", !0), Ta = Fn("Map.prototype.get", !0), Qg = Fn("Map.prototype.size", !0), Na = Fn("Set.prototype.add", !0), Gy = Fn("Set.prototype.delete", !0), Ma = Fn("Set.prototype.has", !0), oa = Fn("Set.prototype.size", !0);
function td(n, t, e, i) {
  for (var s = as(n), u; (u = s.next()) && !u.done; )
    if (vn(t, u.value, e, i))
      return Gy(n, u.value), !0;
  return !1;
}
function By(n) {
  if (typeof n > "u")
    return null;
  if (typeof n != "object")
    return typeof n == "symbol" ? !1 : typeof n == "string" || typeof n == "number" ? +n == +n : !0;
}
function Dk(n, t, e, i, s, u) {
  var h = By(e);
  if (h != null)
    return h;
  var c = Ta(t, h), g = Fy({}, s, { strict: !1 });
  return typeof c > "u" && !Fl(t, h) || !vn(i, c, g, u) ? !1 : !Fl(n, h) && vn(i, c, g, u);
}
function Fk(n, t, e) {
  var i = By(e);
  return i ?? (Ma(t, i) && !Ma(n, i));
}
function ed(n, t, e, i, s, u) {
  for (var h = as(n), c, g; (c = h.next()) && !c.done; )
    if (g = c.value, // eslint-disable-next-line no-use-before-define
    vn(e, g, s, u) && vn(i, Ta(t, g), s, u))
      return Gy(n, g), !0;
  return !1;
}
function vn(n, t, e, i) {
  var s = e || {};
  if (s.strict ? Gg(n, t) : n === t)
    return !0;
  var u = jg(n), h = jg(t);
  if (u !== h)
    return !1;
  if (!n || !t || typeof n != "object" && typeof t != "object")
    return s.strict ? Gg(n, t) : n == t;
  var c = i.has(n), g = i.has(t), m;
  if (c && g) {
    if (i.get(n) === i.get(t))
      return !0;
  } else
    m = {};
  return c || i.set(n, m), g || i.set(t, m), zk(n, t, s, i);
}
function nd(n) {
  return !n || typeof n != "object" || typeof n.length != "number" || typeof n.copy != "function" || typeof n.slice != "function" || n.length > 0 && typeof n[0] != "number" ? !1 : !!(n.constructor && n.constructor.isBuffer && n.constructor.isBuffer(n));
}
function Gk(n, t, e, i) {
  if (oa(n) !== oa(t))
    return !1;
  for (var s = as(n), u = as(t), h, c, g; (h = s.next()) && !h.done; )
    if (h.value && typeof h.value == "object")
      g || (g = new La()), Na(g, h.value);
    else if (!Ma(t, h.value)) {
      if (e.strict || !Fk(n, t, h.value))
        return !1;
      g || (g = new La()), Na(g, h.value);
    }
  if (g) {
    for (; (c = u.next()) && !c.done; )
      if (c.value && typeof c.value == "object") {
        if (!td(g, c.value, e.strict, i))
          return !1;
      } else if (!e.strict && !Ma(n, c.value) && !td(g, c.value, e.strict, i))
        return !1;
    return oa(g) === 0;
  }
  return !0;
}
function Bk(n, t, e, i) {
  if (Qg(n) !== Qg(t))
    return !1;
  for (var s = as(n), u = as(t), h, c, g, m, y, p; (h = s.next()) && !h.done; )
    if (m = h.value[0], y = h.value[1], m && typeof m == "object")
      g || (g = new La()), Na(g, m);
    else if (p = Ta(t, m), typeof p > "u" && !Fl(t, m) || !vn(y, p, e, i)) {
      if (e.strict || !Dk(n, t, m, y, e, i))
        return !1;
      g || (g = new La()), Na(g, m);
    }
  if (g) {
    for (; (c = u.next()) && !c.done; )
      if (m = c.value[0], p = c.value[1], m && typeof m == "object") {
        if (!ed(g, n, m, p, e, i))
          return !1;
      } else if (!e.strict && (!n.has(m) || !vn(Ta(n, m), p, e, i)) && !ed(g, n, m, p, Fy({}, e, { strict: !1 }), i))
        return !1;
    return oa(g) === 0;
  }
  return !0;
}
function zk(n, t, e, i) {
  var s, u;
  if (typeof n != typeof t || n == null || t == null || Jg(n) !== Jg(t) || Bg(n) !== Bg(t))
    return !1;
  var h = zg(n), c = zg(t);
  if (h !== c)
    return !1;
  var g = n instanceof Error, m = t instanceof Error;
  if (g !== m || (g || m) && (n.name !== t.name || n.message !== t.message))
    return !1;
  var y = Xg(n), p = Xg(t);
  if (y !== p || (y || p) && (n.source !== t.source || Fg(n) !== Fg(t)))
    return !1;
  var _ = Wg(n), E = Wg(t);
  if (_ !== E || (_ || E) && $g(n) !== $g(t) || e.strict && $u && $u(n) !== $u(t))
    return !1;
  var S = Zg(n), I = Zg(t);
  if (S !== I)
    return !1;
  if (S || I) {
    if (n.length !== t.length)
      return !1;
    for (s = 0; s < n.length; s++)
      if (n[s] !== t[s])
        return !1;
    return !0;
  }
  var b = nd(n), C = nd(t);
  if (b !== C)
    return !1;
  if (b || C) {
    if (n.length !== t.length)
      return !1;
    for (s = 0; s < n.length; s++)
      if (n[s] !== t[s])
        return !1;
    return !0;
  }
  var R = Yg(n), T = Yg(t);
  if (R !== T)
    return !1;
  if (R || T)
    return Hg(n) !== Hg(t) ? !1 : typeof Uint8Array == "function" && vn(new Uint8Array(n), new Uint8Array(t), e, i);
  var O = qg(n), M = qg(t);
  if (O !== M)
    return !1;
  if (O || M)
    return Kg(n) !== Kg(t) ? !1 : typeof Uint8Array == "function" && vn(new Uint8Array(n), new Uint8Array(t), e, i);
  if (typeof n != typeof t)
    return !1;
  var G = Ug(n), D = Ug(t);
  if (G.length !== D.length)
    return !1;
  for (G.sort(), D.sort(), s = G.length - 1; s >= 0; s--)
    if (G[s] != D[s])
      return !1;
  for (s = G.length - 1; s >= 0; s--)
    if (u = G[s], !vn(n[u], t[u], e, i))
      return !1;
  var F = Vg(n), A = Vg(t);
  return F !== A ? !1 : F === "Set" || A === "Set" ? Gk(n, t, e, i) : F === "Map" ? Bk(n, t, e, i) : !0;
}
var Yk = function(t, e, i) {
  return vn(t, e, i, Pk());
};
const Wk = /* @__PURE__ */ zm(Yk);
var Xk = Object.defineProperty, Ft = (n, t) => Xk(n, "name", { value: t, configurable: !0 }), qk = class {
  constructor(t) {
    this.direction = !1, this.compareProperties = !0;
    var e, i, s;
    this.precision = 10 ** -((e = t == null ? void 0 : t.precision) != null ? e : 17), this.direction = (i = t == null ? void 0 : t.direction) != null ? i : !1, this.compareProperties = (s = t == null ? void 0 : t.compareProperties) != null ? s : !0;
  }
  compare(t, e) {
    if (t.type !== e.type || !Ws(t, e))
      return !1;
    switch (t.type) {
      case "Point":
        return this.compareCoord(t.coordinates, e.coordinates);
      case "LineString":
        return this.compareLine(t.coordinates, e.coordinates);
      case "Polygon":
        return this.comparePolygon(t, e);
      case "GeometryCollection":
        return this.compareGeometryCollection(t, e);
      case "Feature":
        return this.compareFeature(t, e);
      case "FeatureCollection":
        return this.compareFeatureCollection(t, e);
      default:
        if (t.type.startsWith("Multi")) {
          const i = Gl(t), s = Gl(
            e
          );
          return i.every(
            (u) => s.some((h) => this.compare(u, h))
          );
        }
    }
    return !1;
  }
  compareCoord(t, e) {
    return t.length === e.length && t.every((i, s) => Math.abs(i - e[s]) < this.precision);
  }
  compareLine(t, e, i = 0, s = !1) {
    if (!Ws(t, e))
      return !1;
    const u = t;
    let h = e;
    if (s && !this.compareCoord(u[0], h[0])) {
      const g = this.fixStartIndex(h, u);
      if (g)
        h = g;
      else
        return !1;
    }
    const c = this.compareCoord(u[i], h[i]);
    return this.direction || c ? this.comparePath(u, h) : this.compareCoord(u[i], h[h.length - (1 + i)]) ? this.comparePath(u.slice().reverse(), h) : !1;
  }
  fixStartIndex(t, e) {
    let i, s = -1;
    for (let u = 0; u < t.length; u++)
      if (this.compareCoord(t[u], e[0])) {
        s = u;
        break;
      }
    return s >= 0 && (i = [].concat(
      t.slice(s, t.length),
      t.slice(1, s + 1)
    )), i;
  }
  comparePath(t, e) {
    return t.every((i, s) => this.compareCoord(i, e[s]));
  }
  comparePolygon(t, e) {
    if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) {
      const i = t.coordinates.slice(1, t.coordinates.length), s = e.coordinates.slice(1, e.coordinates.length);
      return i.every(
        (u) => s.some((h) => this.compareLine(u, h, 1, !0))
      );
    }
    return !1;
  }
  compareGeometryCollection(t, e) {
    return Ws(t.geometries, e.geometries) && this.compareBBox(t, e) && t.geometries.every((i, s) => this.compare(i, e.geometries[s]));
  }
  compareFeature(t, e) {
    return t.id === e.id && (this.compareProperties ? Wk(t.properties, e.properties) : !0) && this.compareBBox(t, e) && this.compare(t.geometry, e.geometry);
  }
  compareFeatureCollection(t, e) {
    return Ws(t.features, e.features) && this.compareBBox(t, e) && t.features.every((i, s) => this.compare(i, e.features[s]));
  }
  compareBBox(t, e) {
    return !t.bbox && !e.bbox || (t.bbox && e.bbox ? this.compareCoord(t.bbox, e.bbox) : !1);
  }
};
Ft(qk, "GeojsonEquality");
function Ws(n, t) {
  return n.coordinates ? n.coordinates.length === t.coordinates.length : n.length === t.length;
}
Ft(Ws, "sameLength");
function Gl(n) {
  return n.coordinates.map((t) => ({
    type: n.type.replace("Multi", ""),
    coordinates: t
  }));
}
Ft(Gl, "explode");
var Te = 63710088e-1, zy = {
  centimeters: Te * 100,
  centimetres: Te * 100,
  degrees: 360 / (2 * Math.PI),
  feet: Te * 3.28084,
  inches: Te * 39.37,
  kilometers: Te / 1e3,
  kilometres: Te / 1e3,
  meters: Te,
  metres: Te,
  miles: Te / 1609.344,
  millimeters: Te * 1e3,
  millimetres: Te * 1e3,
  nauticalmiles: Te / 1852,
  radians: 1,
  yards: Te * 1.0936
}, id = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  nauticalmiles: 29155334959812285e-23,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function En(n, t, e = {}) {
  const i = { type: "Feature" };
  return (e.id === 0 || e.id) && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.properties = t || {}, i.geometry = n, i;
}
Ft(En, "feature");
function Uk(n, t, e = {}) {
  switch (n) {
    case "Point":
      return Rn(t).geometry;
    case "LineString":
      return Hn(t).geometry;
    case "Polygon":
      return Io(t).geometry;
    case "MultiPoint":
      return Wy(t).geometry;
    case "MultiLineString":
      return Yy(t).geometry;
    case "MultiPolygon":
      return Ph(t).geometry;
    default:
      throw new Error(n + " is invalid");
  }
}
Ft(Uk, "geometry");
function Rn(n, t, e = {}) {
  if (!n)
    throw new Error("coordinates is required");
  if (!Array.isArray(n))
    throw new Error("coordinates must be an Array");
  if (n.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Oa(n[0]) || !Oa(n[1]))
    throw new Error("coordinates must contain numbers");
  return En({
    type: "Point",
    coordinates: n
  }, t, e);
}
Ft(Rn, "point");
function jk(n, t, e = {}) {
  return oi(
    n.map((i) => Rn(i, t)),
    e
  );
}
Ft(jk, "points");
function Io(n, t, e = {}) {
  for (const s of n) {
    if (s.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (s[s.length - 1].length !== s[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let u = 0; u < s[s.length - 1].length; u++)
      if (s[s.length - 1][u] !== s[0][u])
        throw new Error("First and last Position are not equivalent.");
  }
  return En({
    type: "Polygon",
    coordinates: n
  }, t, e);
}
Ft(Io, "polygon");
function Vk(n, t, e = {}) {
  return oi(
    n.map((i) => Io(i, t)),
    e
  );
}
Ft(Vk, "polygons");
function Hn(n, t, e = {}) {
  if (n.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return En({
    type: "LineString",
    coordinates: n
  }, t, e);
}
Ft(Hn, "lineString");
function Zk(n, t, e = {}) {
  return oi(
    n.map((i) => Hn(i, t)),
    e
  );
}
Ft(Zk, "lineStrings");
function oi(n, t = {}) {
  const e = { type: "FeatureCollection" };
  return t.id && (e.id = t.id), t.bbox && (e.bbox = t.bbox), e.features = n, e;
}
Ft(oi, "featureCollection");
function Yy(n, t, e = {}) {
  return En({
    type: "MultiLineString",
    coordinates: n
  }, t, e);
}
Ft(Yy, "multiLineString");
function Wy(n, t, e = {}) {
  return En({
    type: "MultiPoint",
    coordinates: n
  }, t, e);
}
Ft(Wy, "multiPoint");
function Ph(n, t, e = {}) {
  return En({
    type: "MultiPolygon",
    coordinates: n
  }, t, e);
}
Ft(Ph, "multiPolygon");
function Hk(n, t, e = {}) {
  return En({
    type: "GeometryCollection",
    geometries: n
  }, t, e);
}
Ft(Hk, "geometryCollection");
function Kk(n, t = 0) {
  if (t && !(t >= 0))
    throw new Error("precision must be a positive number");
  const e = Math.pow(10, t || 0);
  return Math.round(n * e) / e;
}
Ft(Kk, "round");
function Dh(n, t = "kilometers") {
  const e = zy[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return n * e;
}
Ft(Dh, "radiansToLength");
function eu(n, t = "kilometers") {
  const e = zy[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return n / e;
}
Ft(eu, "lengthToRadians");
function $k(n, t) {
  return Xy(eu(n, t));
}
Ft($k, "lengthToDegrees");
function Jk(n) {
  let t = n % 360;
  return t < 0 && (t += 360), t;
}
Ft(Jk, "bearingToAzimuth");
function Xy(n) {
  return n % (2 * Math.PI) * 180 / Math.PI;
}
Ft(Xy, "radiansToDegrees");
function Qk(n) {
  return n % 360 * Math.PI / 180;
}
Ft(Qk, "degreesToRadians");
function tb(n, t = "kilometers", e = "kilometers") {
  if (!(n >= 0))
    throw new Error("length must be a positive number");
  return Dh(eu(n, t), e);
}
Ft(tb, "convertLength");
function eb(n, t = "meters", e = "kilometers") {
  if (!(n >= 0))
    throw new Error("area must be a positive number");
  const i = id[t];
  if (!i)
    throw new Error("invalid original units");
  const s = id[e];
  if (!s)
    throw new Error("invalid final units");
  return n / i * s;
}
Ft(eb, "convertArea");
function Oa(n) {
  return !isNaN(n) && n !== null && !Array.isArray(n);
}
Ft(Oa, "isNumber");
function Fh(n) {
  return n !== null && typeof n == "object" && !Array.isArray(n);
}
Ft(Fh, "isObject");
function nb(n) {
  if (!n)
    throw new Error("bbox is required");
  if (!Array.isArray(n))
    throw new Error("bbox must be an Array");
  if (n.length !== 4 && n.length !== 6)
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  n.forEach((t) => {
    if (!Oa(t))
      throw new Error("bbox must only contain numbers");
  });
}
Ft(nb, "validateBBox");
function ib(n) {
  if (!n)
    throw new Error("id is required");
  if (["string", "number"].indexOf(typeof n) === -1)
    throw new Error("id must be a number or a string");
}
Ft(ib, "validateId");
var rb = Object.defineProperty, ye = (n, t) => rb(n, "name", { value: t, configurable: !0 });
function ys(n, t, e) {
  if (n !== null)
    for (var i, s, u, h, c, g, m, y = 0, p = 0, _, E = n.type, S = E === "FeatureCollection", I = E === "Feature", b = S ? n.features.length : 1, C = 0; C < b; C++) {
      m = S ? n.features[C].geometry : I ? n.geometry : n, _ = m ? m.type === "GeometryCollection" : !1, c = _ ? m.geometries.length : 1;
      for (var R = 0; R < c; R++) {
        var T = 0, O = 0;
        if (h = _ ? m.geometries[R] : m, h !== null) {
          g = h.coordinates;
          var M = h.type;
          switch (y = e && (M === "Polygon" || M === "MultiPolygon") ? 1 : 0, M) {
            case null:
              break;
            case "Point":
              if (t(
                g,
                p,
                C,
                T,
                O
              ) === !1)
                return !1;
              p++, T++;
              break;
            case "LineString":
            case "MultiPoint":
              for (i = 0; i < g.length; i++) {
                if (t(
                  g[i],
                  p,
                  C,
                  T,
                  O
                ) === !1)
                  return !1;
                p++, M === "MultiPoint" && T++;
              }
              M === "LineString" && T++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (i = 0; i < g.length; i++) {
                for (s = 0; s < g[i].length - y; s++) {
                  if (t(
                    g[i][s],
                    p,
                    C,
                    T,
                    O
                  ) === !1)
                    return !1;
                  p++;
                }
                M === "MultiLineString" && T++, M === "Polygon" && O++;
              }
              M === "Polygon" && T++;
              break;
            case "MultiPolygon":
              for (i = 0; i < g.length; i++) {
                for (O = 0, s = 0; s < g[i].length; s++) {
                  for (u = 0; u < g[i][s].length - y; u++) {
                    if (t(
                      g[i][s][u],
                      p,
                      C,
                      T,
                      O
                    ) === !1)
                      return !1;
                    p++;
                  }
                  O++;
                }
                T++;
              }
              break;
            case "GeometryCollection":
              for (i = 0; i < h.geometries.length; i++)
                if (ys(h.geometries[i], t, e) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
ye(ys, "coordEach");
function sb(n, t, e, i) {
  var s = e;
  return ys(
    n,
    function(u, h, c, g, m) {
      h === 0 && e === void 0 ? s = u : s = t(
        s,
        u,
        h,
        c,
        g,
        m
      );
    },
    i
  ), s;
}
ye(sb, "coordReduce");
function qy(n, t) {
  var e;
  switch (n.type) {
    case "FeatureCollection":
      for (e = 0; e < n.features.length && t(n.features[e].properties, e) !== !1; e++)
        ;
      break;
    case "Feature":
      t(n.properties, 0);
      break;
  }
}
ye(qy, "propEach");
function ob(n, t, e) {
  var i = e;
  return qy(n, function(s, u) {
    u === 0 && e === void 0 ? i = s : i = t(i, s, u);
  }), i;
}
ye(ob, "propReduce");
function Aa(n, t) {
  if (n.type === "Feature")
    t(n, 0);
  else if (n.type === "FeatureCollection")
    for (var e = 0; e < n.features.length && t(n.features[e], e) !== !1; e++)
      ;
}
ye(Aa, "featureEach");
function ab(n, t, e) {
  var i = e;
  return Aa(n, function(s, u) {
    u === 0 && e === void 0 ? i = s : i = t(i, s, u);
  }), i;
}
ye(ab, "featureReduce");
function ub(n) {
  var t = [];
  return ys(n, function(e) {
    t.push(e);
  }), t;
}
ye(ub, "coordAll");
function ps(n, t) {
  var e, i, s, u, h, c, g, m, y, p, _ = 0, E = n.type === "FeatureCollection", S = n.type === "Feature", I = E ? n.features.length : 1;
  for (e = 0; e < I; e++) {
    for (c = E ? n.features[e].geometry : S ? n.geometry : n, m = E ? n.features[e].properties : S ? n.properties : {}, y = E ? n.features[e].bbox : S ? n.bbox : void 0, p = E ? n.features[e].id : S ? n.id : void 0, g = c ? c.type === "GeometryCollection" : !1, h = g ? c.geometries.length : 1, s = 0; s < h; s++) {
      if (u = g ? c.geometries[s] : c, u === null) {
        if (t(
          null,
          _,
          m,
          y,
          p
        ) === !1)
          return !1;
        continue;
      }
      switch (u.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            u,
            _,
            m,
            y,
            p
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (i = 0; i < u.geometries.length; i++)
            if (t(
              u.geometries[i],
              _,
              m,
              y,
              p
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    _++;
  }
}
ye(ps, "geomEach");
function lb(n, t, e) {
  var i = e;
  return ps(
    n,
    function(s, u, h, c, g) {
      u === 0 && e === void 0 ? i = s : i = t(
        i,
        s,
        u,
        h,
        c,
        g
      );
    }
  ), i;
}
ye(lb, "geomReduce");
function nu(n, t) {
  ps(n, function(e, i, s, u, h) {
    var c = e === null ? null : e.type;
    switch (c) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return t(
          En(e, s, { bbox: u, id: h }),
          i,
          0
        ) === !1 ? !1 : void 0;
    }
    var g;
    switch (c) {
      case "MultiPoint":
        g = "Point";
        break;
      case "MultiLineString":
        g = "LineString";
        break;
      case "MultiPolygon":
        g = "Polygon";
        break;
    }
    for (var m = 0; m < e.coordinates.length; m++) {
      var y = e.coordinates[m], p = {
        type: g,
        coordinates: y
      };
      if (t(En(p, s), i, m) === !1)
        return !1;
    }
  });
}
ye(nu, "flattenEach");
function hb(n, t, e) {
  var i = e;
  return nu(
    n,
    function(s, u, h) {
      u === 0 && h === 0 && e === void 0 ? i = s : i = t(
        i,
        s,
        u,
        h
      );
    }
  ), i;
}
ye(hb, "flattenReduce");
function Uy(n, t) {
  nu(n, function(e, i, s) {
    var u = 0;
    if (e.geometry) {
      var h = e.geometry.type;
      if (!(h === "Point" || h === "MultiPoint")) {
        var c, g = 0, m = 0, y = 0;
        if (ys(
          e,
          function(p, _, E, S, I) {
            if (c === void 0 || i > g || S > m || I > y) {
              c = p, g = i, m = S, y = I, u = 0;
              return;
            }
            var b = Hn(
              [c, p],
              e.properties
            );
            if (t(
              b,
              i,
              s,
              I,
              u
            ) === !1)
              return !1;
            u++, c = p;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
ye(Uy, "segmentEach");
function cb(n, t, e) {
  var i = e, s = !1;
  return Uy(
    n,
    function(u, h, c, g, m) {
      s === !1 && e === void 0 ? i = u : i = t(
        i,
        u,
        h,
        c,
        g,
        m
      ), s = !0;
    }
  ), i;
}
ye(cb, "segmentReduce");
function jy(n, t) {
  if (!n)
    throw new Error("geojson is required");
  nu(n, function(e, i, s) {
    if (e.geometry !== null) {
      var u = e.geometry.type, h = e.geometry.coordinates;
      switch (u) {
        case "LineString":
          if (t(e, i, s, 0, 0) === !1)
            return !1;
          break;
        case "Polygon":
          for (var c = 0; c < h.length; c++)
            if (t(
              Hn(h[c], e.properties),
              i,
              s,
              c
            ) === !1)
              return !1;
          break;
      }
    }
  });
}
ye(jy, "lineEach");
function fb(n, t, e) {
  var i = e;
  return jy(
    n,
    function(s, u, h, c) {
      u === 0 && e === void 0 ? i = s : i = t(
        i,
        s,
        u,
        h,
        c
      );
    }
  ), i;
}
ye(fb, "lineReduce");
function gb(n, t) {
  if (t = t || {}, !Fh(t))
    throw new Error("options is invalid");
  var e = t.featureIndex || 0, i = t.multiFeatureIndex || 0, s = t.geometryIndex || 0, u = t.segmentIndex || 0, h = t.properties, c;
  switch (n.type) {
    case "FeatureCollection":
      e < 0 && (e = n.features.length + e), h = h || n.features[e].properties, c = n.features[e].geometry;
      break;
    case "Feature":
      h = h || n.properties, c = n.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      c = n;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (c === null)
    return null;
  var g = c.coordinates;
  switch (c.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      return u < 0 && (u = g.length + u - 1), Hn(
        [g[u], g[u + 1]],
        h,
        t
      );
    case "Polygon":
      return s < 0 && (s = g.length + s), u < 0 && (u = g[s].length + u - 1), Hn(
        [
          g[s][u],
          g[s][u + 1]
        ],
        h,
        t
      );
    case "MultiLineString":
      return i < 0 && (i = g.length + i), u < 0 && (u = g[i].length + u - 1), Hn(
        [
          g[i][u],
          g[i][u + 1]
        ],
        h,
        t
      );
    case "MultiPolygon":
      return i < 0 && (i = g.length + i), s < 0 && (s = g[i].length + s), u < 0 && (u = g[i][s].length - u - 1), Hn(
        [
          g[i][s][u],
          g[i][s][u + 1]
        ],
        h,
        t
      );
  }
  throw new Error("geojson is invalid");
}
ye(gb, "findSegment");
function db(n, t) {
  if (t = t || {}, !Fh(t))
    throw new Error("options is invalid");
  var e = t.featureIndex || 0, i = t.multiFeatureIndex || 0, s = t.geometryIndex || 0, u = t.coordIndex || 0, h = t.properties, c;
  switch (n.type) {
    case "FeatureCollection":
      e < 0 && (e = n.features.length + e), h = h || n.features[e].properties, c = n.features[e].geometry;
      break;
    case "Feature":
      h = h || n.properties, c = n.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      c = n;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (c === null)
    return null;
  var g = c.coordinates;
  switch (c.type) {
    case "Point":
      return Rn(g, h, t);
    case "MultiPoint":
      return i < 0 && (i = g.length + i), Rn(g[i], h, t);
    case "LineString":
      return u < 0 && (u = g.length + u), Rn(g[u], h, t);
    case "Polygon":
      return s < 0 && (s = g.length + s), u < 0 && (u = g[s].length + u), Rn(g[s][u], h, t);
    case "MultiLineString":
      return i < 0 && (i = g.length + i), u < 0 && (u = g[i].length + u), Rn(g[i][u], h, t);
    case "MultiPolygon":
      return i < 0 && (i = g.length + i), s < 0 && (s = g[i].length + s), u < 0 && (u = g[i][s].length - u), Rn(
        g[i][s][u],
        h,
        t
      );
  }
  throw new Error("geojson is invalid");
}
ye(db, "findPoint");
var mb = Object.defineProperty, yb = (n, t) => mb(n, "name", { value: t, configurable: !0 });
function Vy(n, t = {}) {
  if (n.bbox != null && t.recompute !== !0)
    return n.bbox;
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return ys(n, (i) => {
    e[0] > i[0] && (e[0] = i[0]), e[1] > i[1] && (e[1] = i[1]), e[2] < i[0] && (e[2] = i[0]), e[3] < i[1] && (e[3] = i[1]);
  }), e;
}
yb(Vy, "bbox");
var pb = Object.defineProperty, vb = (n, t) => pb(n, "name", { value: t, configurable: !0 });
function Zy(n, t = {}) {
  const e = Vy(n), i = (e[0] + e[2]) / 2, s = (e[1] + e[3]) / 2;
  return Rn([i, s], t.properties, t);
}
vb(Zy, "center");
var Hy = { exports: {} };
(function(n, t) {
  (function(e, i) {
    n.exports = i();
  })(go, function() {
    function e(f, r) {
      if (!(f instanceof r)) throw new TypeError("Cannot call a class as a function");
    }
    function i(f, r) {
      for (var o = 0; o < r.length; o++) {
        var a = r[o];
        a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(f, a.key, a);
      }
    }
    function s(f, r, o) {
      return r && i(f.prototype, r), o && i(f, o), f;
    }
    function u(f, r) {
      if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function");
      f.prototype = Object.create(r && r.prototype, { constructor: { value: f, writable: !0, configurable: !0 } }), r && c(f, r);
    }
    function h(f) {
      return h = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
        return r.__proto__ || Object.getPrototypeOf(r);
      }, h(f);
    }
    function c(f, r) {
      return c = Object.setPrototypeOf || function(o, a) {
        return o.__proto__ = a, o;
      }, c(f, r);
    }
    function g() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
      if (typeof Proxy == "function") return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function m(f, r, o) {
      return m = g() ? Reflect.construct : function(a, l, d) {
        var v = [null];
        v.push.apply(v, l);
        var x = new (Function.bind.apply(a, v))();
        return d && c(x, d.prototype), x;
      }, m.apply(null, arguments);
    }
    function y(f) {
      var r = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return y = function(o) {
        if (o === null || (a = o, Function.toString.call(a).indexOf("[native code]") === -1)) return o;
        var a;
        if (typeof o != "function") throw new TypeError("Super expression must either be null or a function");
        if (r !== void 0) {
          if (r.has(o)) return r.get(o);
          r.set(o, l);
        }
        function l() {
          return m(o, arguments, h(this).constructor);
        }
        return l.prototype = Object.create(o.prototype, { constructor: { value: l, enumerable: !1, writable: !0, configurable: !0 } }), c(l, o);
      }, y(f);
    }
    function p(f) {
      if (f === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return f;
    }
    function _(f, r) {
      if (r && (typeof r == "object" || typeof r == "function")) return r;
      if (r !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
      return p(f);
    }
    function E(f) {
      var r = g();
      return function() {
        var o, a = h(f);
        if (r) {
          var l = h(this).constructor;
          o = Reflect.construct(a, arguments, l);
        } else o = a.apply(this, arguments);
        return _(this, o);
      };
    }
    function S(f, r, o) {
      return S = typeof Reflect < "u" && Reflect.get ? Reflect.get : function(a, l, d) {
        var v = function(w, k) {
          for (; !Object.prototype.hasOwnProperty.call(w, k) && (w = h(w)) !== null; ) ;
          return w;
        }(a, l);
        if (v) {
          var x = Object.getOwnPropertyDescriptor(v, l);
          return x.get ? x.get.call(d) : x.value;
        }
      }, S(f, r, o || f);
    }
    function I(f) {
      return function(r) {
        if (Array.isArray(r)) return C(r);
      }(f) || function(r) {
        if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
      }(f) || b(f) || function() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }();
    }
    function b(f, r) {
      if (f) {
        if (typeof f == "string") return C(f, r);
        var o = Object.prototype.toString.call(f).slice(8, -1);
        return o === "Object" && f.constructor && (o = f.constructor.name), o === "Map" || o === "Set" ? Array.from(f) : o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? C(f, r) : void 0;
      }
    }
    function C(f, r) {
      (r == null || r > f.length) && (r = f.length);
      for (var o = 0, a = new Array(r); o < r; o++) a[o] = f[o];
      return a;
    }
    function R(f, r) {
      var o = typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
      if (!o) {
        if (Array.isArray(f) || (o = b(f)) || r) {
          o && (f = o);
          var a = 0, l = function() {
          };
          return { s: l, n: function() {
            return a >= f.length ? { done: !0 } : { done: !1, value: f[a++] };
          }, e: function(w) {
            throw w;
          }, f: l };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var d, v = !0, x = !1;
      return { s: function() {
        o = o.call(f);
      }, n: function() {
        var w = o.next();
        return v = w.done, w;
      }, e: function(w) {
        x = !0, d = w;
      }, f: function() {
        try {
          v || o.return == null || o.return();
        } finally {
          if (x) throw d;
        }
      } };
    }
    var T = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getEndCapStyle", value: function() {
        return this._endCapStyle;
      } }, { key: "isSingleSided", value: function() {
        return this._isSingleSided;
      } }, { key: "setQuadrantSegments", value: function(r) {
        this._quadrantSegments = r, this._quadrantSegments === 0 && (this._joinStyle = f.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = f.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), r <= 0 && (this._quadrantSegments = 1), this._joinStyle !== f.JOIN_ROUND && (this._quadrantSegments = f.DEFAULT_QUADRANT_SEGMENTS);
      } }, { key: "getJoinStyle", value: function() {
        return this._joinStyle;
      } }, { key: "setJoinStyle", value: function(r) {
        this._joinStyle = r;
      } }, { key: "setSimplifyFactor", value: function(r) {
        this._simplifyFactor = r < 0 ? 0 : r;
      } }, { key: "getSimplifyFactor", value: function() {
        return this._simplifyFactor;
      } }, { key: "getQuadrantSegments", value: function() {
        return this._quadrantSegments;
      } }, { key: "setEndCapStyle", value: function(r) {
        this._endCapStyle = r;
      } }, { key: "getMitreLimit", value: function() {
        return this._mitreLimit;
      } }, { key: "setMitreLimit", value: function(r) {
        this._mitreLimit = r;
      } }, { key: "setSingleSided", value: function(r) {
        this._isSingleSided = r;
      } }], [{ key: "constructor_", value: function() {
        if (this._quadrantSegments = f.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = f.CAP_ROUND, this._joinStyle = f.JOIN_ROUND, this._mitreLimit = f.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = f.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
          if (arguments.length === 1) {
            var r = arguments[0];
            this.setQuadrantSegments(r);
          } else if (arguments.length === 2) {
            var o = arguments[0], a = arguments[1];
            this.setQuadrantSegments(o), this.setEndCapStyle(a);
          } else if (arguments.length === 4) {
            var l = arguments[0], d = arguments[1], v = arguments[2], x = arguments[3];
            this.setQuadrantSegments(l), this.setEndCapStyle(d), this.setJoinStyle(v), this.setMitreLimit(x);
          }
        }
      } }, { key: "bufferDistanceError", value: function(r) {
        var o = Math.PI / 2 / r;
        return 1 - Math.cos(o / 2);
      } }]), f;
    }();
    T.CAP_ROUND = 1, T.CAP_FLAT = 2, T.CAP_SQUARE = 3, T.JOIN_ROUND = 1, T.JOIN_MITRE = 2, T.JOIN_BEVEL = 3, T.DEFAULT_QUADRANT_SEGMENTS = 8, T.DEFAULT_MITRE_LIMIT = 5, T.DEFAULT_SIMPLIFY_FACTOR = 0.01;
    var O = function(f) {
      u(o, f);
      var r = E(o);
      function o(a) {
        var l;
        return e(this, o), (l = r.call(this, a)).name = Object.keys({ Exception: o })[0], l;
      }
      return s(o, [{ key: "toString", value: function() {
        return this.message;
      } }]), o;
    }(y(Error)), M = function(f) {
      u(o, f);
      var r = E(o);
      function o(a) {
        var l;
        return e(this, o), (l = r.call(this, a)).name = Object.keys({ IllegalArgumentException: o })[0], l;
      }
      return o;
    }(O), G = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "filter", value: function(r) {
      } }]), f;
    }();
    function D() {
    }
    function F() {
    }
    function A() {
    }
    var j, et, U, nt, z, K, Z, at, gt = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "equalsWithTolerance", value: function(r, o, a) {
        return Math.abs(r - o) <= a;
      } }]), f;
    }(), xt = function() {
      function f(r, o) {
        e(this, f), this.low = o || 0, this.high = r || 0;
      }
      return s(f, null, [{ key: "toBinaryString", value: function(r) {
        var o, a = "";
        for (o = 2147483648; o > 0; o >>>= 1) a += (r.high & o) === o ? "1" : "0";
        for (o = 2147483648; o > 0; o >>>= 1) a += (r.low & o) === o ? "1" : "0";
        return a;
      } }]), f;
    }();
    function Q() {
    }
    function _t() {
    }
    Q.NaN = NaN, Q.isNaN = function(f) {
      return Number.isNaN(f);
    }, Q.isInfinite = function(f) {
      return !Number.isFinite(f);
    }, Q.MAX_VALUE = Number.MAX_VALUE, Q.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, Q.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, typeof Float64Array == "function" && typeof Int32Array == "function" ? (K = 2146435072, Z = new Float64Array(1), at = new Int32Array(Z.buffer), Q.doubleToLongBits = function(f) {
      Z[0] = f;
      var r = 0 | at[0], o = 0 | at[1];
      return (o & K) === K && 1048575 & o && r !== 0 && (r = 0, o = 2146959360), new xt(o, r);
    }, Q.longBitsToDouble = function(f) {
      return at[0] = f.low, at[1] = f.high, Z[0];
    }) : (j = 1023, et = Math.log2, U = Math.floor, nt = Math.pow, z = function() {
      for (var f = 53; f > 0; f--) {
        var r = nt(2, f) - 1;
        if (U(et(r)) + 1 === f) return r;
      }
      return 0;
    }(), Q.doubleToLongBits = function(f) {
      var r, o, a, l, d, v, x, w, k;
      if (f < 0 || 1 / f === Number.NEGATIVE_INFINITY ? (v = 1 << 31, f = -f) : v = 0, f === 0) return new xt(w = v, k = 0);
      if (f === 1 / 0) return new xt(w = 2146435072 | v, k = 0);
      if (f != f) return new xt(w = 2146959360, k = 0);
      if (l = 0, k = 0, (r = U(f)) > 1) if (r <= z) (l = U(et(r))) <= 20 ? (k = 0, w = r << 20 - l & 1048575) : (k = r % (o = nt(2, a = l - 20)) << 32 - a, w = r / o & 1048575);
      else for (a = r, k = 0; (a = U(o = a / 2)) !== 0; ) l++, k >>>= 1, k |= (1 & w) << 31, w >>>= 1, o !== a && (w |= 524288);
      if (x = l + j, d = r === 0, r = f - r, l < 52 && r !== 0) for (a = 0; ; ) {
        if ((o = 2 * r) >= 1 ? (r = o - 1, d ? (x--, d = !1) : (a <<= 1, a |= 1, l++)) : (r = o, d ? --x == 0 && (l++, d = !1) : (a <<= 1, l++)), l === 20) w |= a, a = 0;
        else if (l === 52) {
          k |= a;
          break;
        }
        if (o === 1) {
          l < 20 ? w |= a << 20 - l : l < 52 && (k |= a << 52 - l);
          break;
        }
      }
      return w |= x << 20, new xt(w |= v, k);
    }, Q.longBitsToDouble = function(f) {
      var r, o, a, l, d = f.high, v = f.low, x = d & 1 << 31 ? -1 : 1;
      for (a = ((2146435072 & d) >> 20) - j, l = 0, o = 1 << 19, r = 1; r <= 20; r++) d & o && (l += nt(2, -r)), o >>>= 1;
      for (o = 1 << 31, r = 21; r <= 52; r++) v & o && (l += nt(2, -r)), o >>>= 1;
      if (a === -1023) {
        if (l === 0) return 0 * x;
        a = -1022;
      } else {
        if (a === 1024) return l === 0 ? x / 0 : NaN;
        l += 1;
      }
      return x * l * nt(2, a);
    });
    var Et = function(f) {
      u(o, f);
      var r = E(o);
      function o(a) {
        var l;
        return e(this, o), (l = r.call(this, a)).name = Object.keys({ RuntimeException: o })[0], l;
      }
      return o;
    }(O), Wt = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, null, [{ key: "constructor_", value: function() {
        if (arguments.length === 0) Et.constructor_.call(this);
        else if (arguments.length === 1) {
          var a = arguments[0];
          Et.constructor_.call(this, a);
        }
      } }]), o;
    }(Et), X = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "shouldNeverReachHere", value: function() {
        if (arguments.length === 0) f.shouldNeverReachHere(null);
        else if (arguments.length === 1) {
          var r = arguments[0];
          throw new Wt("Should never reach here" + (r !== null ? ": " + r : ""));
        }
      } }, { key: "isTrue", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          f.isTrue(r, null);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          if (!o) throw a === null ? new Wt() : new Wt(a);
        }
      } }, { key: "equals", value: function() {
        if (arguments.length === 2) {
          var r = arguments[0], o = arguments[1];
          f.equals(r, o, null);
        } else if (arguments.length === 3) {
          var a = arguments[0], l = arguments[1], d = arguments[2];
          if (!l.equals(a)) throw new Wt("Expected " + a + " but encountered " + l + (d !== null ? ": " + d : ""));
        }
      } }]), f;
    }(), pe = new ArrayBuffer(8), Gn = new Float64Array(pe), li = new Int32Array(pe), B = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getM", value: function() {
        return Q.NaN;
      } }, { key: "setOrdinate", value: function(r, o) {
        switch (r) {
          case f.X:
            this.x = o;
            break;
          case f.Y:
            this.y = o;
            break;
          case f.Z:
            this.setZ(o);
            break;
          default:
            throw new M("Invalid ordinate index: " + r);
        }
      } }, { key: "equals2D", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          return this.x === r.x && this.y === r.y;
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          return !!gt.equalsWithTolerance(this.x, o.x, a) && !!gt.equalsWithTolerance(this.y, o.y, a);
        }
      } }, { key: "setM", value: function(r) {
        throw new M("Invalid ordinate index: " + f.M);
      } }, { key: "getZ", value: function() {
        return this.z;
      } }, { key: "getOrdinate", value: function(r) {
        switch (r) {
          case f.X:
            return this.x;
          case f.Y:
            return this.y;
          case f.Z:
            return this.getZ();
        }
        throw new M("Invalid ordinate index: " + r);
      } }, { key: "equals3D", value: function(r) {
        return this.x === r.x && this.y === r.y && (this.getZ() === r.getZ() || Q.isNaN(this.getZ()) && Q.isNaN(r.getZ()));
      } }, { key: "equals", value: function(r) {
        return r instanceof f && this.equals2D(r);
      } }, { key: "equalInZ", value: function(r, o) {
        return gt.equalsWithTolerance(this.getZ(), r.getZ(), o);
      } }, { key: "setX", value: function(r) {
        this.x = r;
      } }, { key: "compareTo", value: function(r) {
        var o = r;
        return this.x < o.x ? -1 : this.x > o.x ? 1 : this.y < o.y ? -1 : this.y > o.y ? 1 : 0;
      } }, { key: "getX", value: function() {
        return this.x;
      } }, { key: "setZ", value: function(r) {
        this.z = r;
      } }, { key: "clone", value: function() {
        try {
          return null;
        } catch (r) {
          if (r instanceof CloneNotSupportedException) return X.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
          throw r;
        }
      } }, { key: "copy", value: function() {
        return new f(this);
      } }, { key: "toString", value: function() {
        return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
      } }, { key: "distance3D", value: function(r) {
        var o = this.x - r.x, a = this.y - r.y, l = this.getZ() - r.getZ();
        return Math.sqrt(o * o + a * a + l * l);
      } }, { key: "getY", value: function() {
        return this.y;
      } }, { key: "setY", value: function(r) {
        this.y = r;
      } }, { key: "distance", value: function(r) {
        var o = this.x - r.x, a = this.y - r.y;
        return Math.sqrt(o * o + a * a);
      } }, { key: "hashCode", value: function() {
        var r = 17;
        return r = 37 * (r = 37 * r + f.hashCode(this.x)) + f.hashCode(this.y);
      } }, { key: "setCoordinate", value: function(r) {
        this.x = r.x, this.y = r.y, this.z = r.getZ();
      } }, { key: "interfaces_", get: function() {
        return [D, F, A];
      } }], [{ key: "constructor_", value: function() {
        if (this.x = null, this.y = null, this.z = null, arguments.length === 0) f.constructor_.call(this, 0, 0);
        else if (arguments.length === 1) {
          var r = arguments[0];
          f.constructor_.call(this, r.x, r.y, r.getZ());
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          f.constructor_.call(this, o, a, f.NULL_ORDINATE);
        } else if (arguments.length === 3) {
          var l = arguments[0], d = arguments[1], v = arguments[2];
          this.x = l, this.y = d, this.z = v;
        }
      } }, { key: "hashCode", value: function(r) {
        return Gn[0] = r, li[0] ^ li[1];
      } }]), f;
    }(), xr = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "compare", value: function(r, o) {
        var a = f.compare(r.x, o.x);
        if (a !== 0) return a;
        var l = f.compare(r.y, o.y);
        return l !== 0 ? l : this._dimensionsToTest <= 2 ? 0 : f.compare(r.getZ(), o.getZ());
      } }, { key: "interfaces_", get: function() {
        return [_t];
      } }], [{ key: "constructor_", value: function() {
        if (this._dimensionsToTest = 2, arguments.length === 0) f.constructor_.call(this, 2);
        else if (arguments.length === 1) {
          var r = arguments[0];
          if (r !== 2 && r !== 3) throw new M("only 2 or 3 dimensions may be specified");
          this._dimensionsToTest = r;
        }
      } }, { key: "compare", value: function(r, o) {
        return r < o ? -1 : r > o ? 1 : Q.isNaN(r) ? Q.isNaN(o) ? 0 : -1 : Q.isNaN(o) ? 1 : 0;
      } }]), f;
    }();
    B.DimensionalComparator = xr, B.NULL_ORDINATE = Q.NaN, B.X = 0, B.Y = 1, B.Z = 2, B.M = 3;
    var Ot = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getArea", value: function() {
        return this.getWidth() * this.getHeight();
      } }, { key: "equals", value: function(r) {
        if (!(r instanceof f)) return !1;
        var o = r;
        return this.isNull() ? o.isNull() : this._maxx === o.getMaxX() && this._maxy === o.getMaxY() && this._minx === o.getMinX() && this._miny === o.getMinY();
      } }, { key: "intersection", value: function(r) {
        if (this.isNull() || r.isNull() || !this.intersects(r)) return new f();
        var o = this._minx > r._minx ? this._minx : r._minx, a = this._miny > r._miny ? this._miny : r._miny;
        return new f(o, this._maxx < r._maxx ? this._maxx : r._maxx, a, this._maxy < r._maxy ? this._maxy : r._maxy);
      } }, { key: "isNull", value: function() {
        return this._maxx < this._minx;
      } }, { key: "getMaxX", value: function() {
        return this._maxx;
      } }, { key: "covers", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof B) {
            var r = arguments[0];
            return this.covers(r.x, r.y);
          }
          if (arguments[0] instanceof f) {
            var o = arguments[0];
            return !this.isNull() && !o.isNull() && o.getMinX() >= this._minx && o.getMaxX() <= this._maxx && o.getMinY() >= this._miny && o.getMaxY() <= this._maxy;
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          return !this.isNull() && a >= this._minx && a <= this._maxx && l >= this._miny && l <= this._maxy;
        }
      } }, { key: "intersects", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof f) {
            var r = arguments[0];
            return !this.isNull() && !r.isNull() && !(r._minx > this._maxx || r._maxx < this._minx || r._miny > this._maxy || r._maxy < this._miny);
          }
          if (arguments[0] instanceof B) {
            var o = arguments[0];
            return this.intersects(o.x, o.y);
          }
        } else if (arguments.length === 2) {
          if (arguments[0] instanceof B && arguments[1] instanceof B) {
            var a = arguments[0], l = arguments[1];
            if (this.isNull()) return !1;
            var d = a.x < l.x ? a.x : l.x;
            if (d > this._maxx) return !1;
            var v = a.x > l.x ? a.x : l.x;
            if (v < this._minx) return !1;
            var x = a.y < l.y ? a.y : l.y;
            if (x > this._maxy) return !1;
            var w = a.y > l.y ? a.y : l.y;
            return !(w < this._miny);
          }
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var k = arguments[0], N = arguments[1];
            return !this.isNull() && !(k > this._maxx || k < this._minx || N > this._maxy || N < this._miny);
          }
        }
      } }, { key: "getMinY", value: function() {
        return this._miny;
      } }, { key: "getDiameter", value: function() {
        if (this.isNull()) return 0;
        var r = this.getWidth(), o = this.getHeight();
        return Math.sqrt(r * r + o * o);
      } }, { key: "getMinX", value: function() {
        return this._minx;
      } }, { key: "expandToInclude", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof B) {
            var r = arguments[0];
            this.expandToInclude(r.x, r.y);
          } else if (arguments[0] instanceof f) {
            var o = arguments[0];
            if (o.isNull()) return null;
            this.isNull() ? (this._minx = o.getMinX(), this._maxx = o.getMaxX(), this._miny = o.getMinY(), this._maxy = o.getMaxY()) : (o._minx < this._minx && (this._minx = o._minx), o._maxx > this._maxx && (this._maxx = o._maxx), o._miny < this._miny && (this._miny = o._miny), o._maxy > this._maxy && (this._maxy = o._maxy));
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this.isNull() ? (this._minx = a, this._maxx = a, this._miny = l, this._maxy = l) : (a < this._minx && (this._minx = a), a > this._maxx && (this._maxx = a), l < this._miny && (this._miny = l), l > this._maxy && (this._maxy = l));
        }
      } }, { key: "minExtent", value: function() {
        if (this.isNull()) return 0;
        var r = this.getWidth(), o = this.getHeight();
        return r < o ? r : o;
      } }, { key: "getWidth", value: function() {
        return this.isNull() ? 0 : this._maxx - this._minx;
      } }, { key: "compareTo", value: function(r) {
        var o = r;
        return this.isNull() ? o.isNull() ? 0 : -1 : o.isNull() ? 1 : this._minx < o._minx ? -1 : this._minx > o._minx ? 1 : this._miny < o._miny ? -1 : this._miny > o._miny ? 1 : this._maxx < o._maxx ? -1 : this._maxx > o._maxx ? 1 : this._maxy < o._maxy ? -1 : this._maxy > o._maxy ? 1 : 0;
      } }, { key: "translate", value: function(r, o) {
        if (this.isNull()) return null;
        this.init(this.getMinX() + r, this.getMaxX() + r, this.getMinY() + o, this.getMaxY() + o);
      } }, { key: "copy", value: function() {
        return new f(this);
      } }, { key: "toString", value: function() {
        return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
      } }, { key: "setToNull", value: function() {
        this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
      } }, { key: "disjoint", value: function(r) {
        return !(!this.isNull() && !r.isNull()) || r._minx > this._maxx || r._maxx < this._minx || r._miny > this._maxy || r._maxy < this._miny;
      } }, { key: "getHeight", value: function() {
        return this.isNull() ? 0 : this._maxy - this._miny;
      } }, { key: "maxExtent", value: function() {
        if (this.isNull()) return 0;
        var r = this.getWidth(), o = this.getHeight();
        return r > o ? r : o;
      } }, { key: "expandBy", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          this.expandBy(r, r);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          if (this.isNull()) return null;
          this._minx -= o, this._maxx += o, this._miny -= a, this._maxy += a, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
        }
      } }, { key: "contains", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof f) {
            var r = arguments[0];
            return this.covers(r);
          }
          if (arguments[0] instanceof B) {
            var o = arguments[0];
            return this.covers(o);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          return this.covers(a, l);
        }
      } }, { key: "centre", value: function() {
        return this.isNull() ? null : new B((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
      } }, { key: "init", value: function() {
        if (arguments.length === 0) this.setToNull();
        else if (arguments.length === 1) {
          if (arguments[0] instanceof B) {
            var r = arguments[0];
            this.init(r.x, r.x, r.y, r.y);
          } else if (arguments[0] instanceof f) {
            var o = arguments[0];
            this._minx = o._minx, this._maxx = o._maxx, this._miny = o._miny, this._maxy = o._maxy;
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this.init(a.x, l.x, a.y, l.y);
        } else if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], x = arguments[2], w = arguments[3];
          d < v ? (this._minx = d, this._maxx = v) : (this._minx = v, this._maxx = d), x < w ? (this._miny = x, this._maxy = w) : (this._miny = w, this._maxy = x);
        }
      } }, { key: "getMaxY", value: function() {
        return this._maxy;
      } }, { key: "distance", value: function(r) {
        if (this.intersects(r)) return 0;
        var o = 0;
        this._maxx < r._minx ? o = r._minx - this._maxx : this._minx > r._maxx && (o = this._minx - r._maxx);
        var a = 0;
        return this._maxy < r._miny ? a = r._miny - this._maxy : this._miny > r._maxy && (a = this._miny - r._maxy), o === 0 ? a : a === 0 ? o : Math.sqrt(o * o + a * a);
      } }, { key: "hashCode", value: function() {
        var r = 17;
        return r = 37 * (r = 37 * (r = 37 * (r = 37 * r + B.hashCode(this._minx)) + B.hashCode(this._maxx)) + B.hashCode(this._miny)) + B.hashCode(this._maxy);
      } }, { key: "interfaces_", get: function() {
        return [D, A];
      } }], [{ key: "constructor_", value: function() {
        if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init();
        else if (arguments.length === 1) {
          if (arguments[0] instanceof B) {
            var r = arguments[0];
            this.init(r.x, r.x, r.y, r.y);
          } else if (arguments[0] instanceof f) {
            var o = arguments[0];
            this.init(o);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this.init(a.x, l.x, a.y, l.y);
        } else if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], x = arguments[2], w = arguments[3];
          this.init(d, v, x, w);
        }
      } }, { key: "intersects", value: function() {
        if (arguments.length === 3) {
          var r = arguments[0], o = arguments[1], a = arguments[2];
          return a.x >= (r.x < o.x ? r.x : o.x) && a.x <= (r.x > o.x ? r.x : o.x) && a.y >= (r.y < o.y ? r.y : o.y) && a.y <= (r.y > o.y ? r.y : o.y);
        }
        if (arguments.length === 4) {
          var l = arguments[0], d = arguments[1], v = arguments[2], x = arguments[3], w = Math.min(v.x, x.x), k = Math.max(v.x, x.x), N = Math.min(l.x, d.x), P = Math.max(l.x, d.x);
          return !(N > k) && !(P < w) && (w = Math.min(v.y, x.y), k = Math.max(v.y, x.y), N = Math.min(l.y, d.y), P = Math.max(l.y, d.y), !(N > k) && !(P < w));
        }
      } }]), f;
    }(), it = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "isGeometryCollection", value: function() {
        return this.getTypeCode() === f.TYPECODE_GEOMETRYCOLLECTION;
      } }, { key: "getFactory", value: function() {
        return this._factory;
      } }, { key: "getGeometryN", value: function(r) {
        return this;
      } }, { key: "getArea", value: function() {
        return 0;
      } }, { key: "isRectangle", value: function() {
        return !1;
      } }, { key: "equalsExact", value: function(r) {
        return this === r || this.equalsExact(r, 0);
      } }, { key: "geometryChanged", value: function() {
        this.apply(f.geometryChangedFilter);
      } }, { key: "geometryChangedAction", value: function() {
        this._envelope = null;
      } }, { key: "equalsNorm", value: function(r) {
        return r !== null && this.norm().equalsExact(r.norm());
      } }, { key: "getLength", value: function() {
        return 0;
      } }, { key: "getNumGeometries", value: function() {
        return 1;
      } }, { key: "compareTo", value: function() {
        var r;
        if (arguments.length === 1) {
          var o = arguments[0];
          return r = o, this.getTypeCode() !== r.getTypeCode() ? this.getTypeCode() - r.getTypeCode() : this.isEmpty() && r.isEmpty() ? 0 : this.isEmpty() ? -1 : r.isEmpty() ? 1 : this.compareToSameClass(o);
        }
        if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          return r = a, this.getTypeCode() !== r.getTypeCode() ? this.getTypeCode() - r.getTypeCode() : this.isEmpty() && r.isEmpty() ? 0 : this.isEmpty() ? -1 : r.isEmpty() ? 1 : this.compareToSameClass(a, l);
        }
      } }, { key: "getUserData", value: function() {
        return this._userData;
      } }, { key: "getSRID", value: function() {
        return this._SRID;
      } }, { key: "getEnvelope", value: function() {
        return this.getFactory().toGeometry(this.getEnvelopeInternal());
      } }, { key: "checkNotGeometryCollection", value: function(r) {
        if (r.getTypeCode() === f.TYPECODE_GEOMETRYCOLLECTION) throw new M("This method does not support GeometryCollection arguments");
      } }, { key: "equal", value: function(r, o, a) {
        return a === 0 ? r.equals(o) : r.distance(o) <= a;
      } }, { key: "norm", value: function() {
        var r = this.copy();
        return r.normalize(), r;
      } }, { key: "reverse", value: function() {
        var r = this.reverseInternal();
        return this.envelope != null && (r.envelope = this.envelope.copy()), r.setSRID(this.getSRID()), r;
      } }, { key: "copy", value: function() {
        var r = this.copyInternal();
        return r.envelope = this._envelope == null ? null : this._envelope.copy(), r._SRID = this._SRID, r._userData = this._userData, r;
      } }, { key: "getPrecisionModel", value: function() {
        return this._factory.getPrecisionModel();
      } }, { key: "getEnvelopeInternal", value: function() {
        return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new Ot(this._envelope);
      } }, { key: "setSRID", value: function(r) {
        this._SRID = r;
      } }, { key: "setUserData", value: function(r) {
        this._userData = r;
      } }, { key: "compare", value: function(r, o) {
        for (var a = r.iterator(), l = o.iterator(); a.hasNext() && l.hasNext(); ) {
          var d = a.next(), v = l.next(), x = d.compareTo(v);
          if (x !== 0) return x;
        }
        return a.hasNext() ? 1 : l.hasNext() ? -1 : 0;
      } }, { key: "hashCode", value: function() {
        return this.getEnvelopeInternal().hashCode();
      } }, { key: "isEquivalentClass", value: function(r) {
        return this.getClass() === r.getClass();
      } }, { key: "isGeometryCollectionOrDerived", value: function() {
        return this.getTypeCode() === f.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === f.TYPECODE_MULTIPOINT || this.getTypeCode() === f.TYPECODE_MULTILINESTRING || this.getTypeCode() === f.TYPECODE_MULTIPOLYGON;
      } }, { key: "interfaces_", get: function() {
        return [F, D, A];
      } }, { key: "getClass", value: function() {
        return f;
      } }], [{ key: "hasNonEmptyElements", value: function(r) {
        for (var o = 0; o < r.length; o++) if (!r[o].isEmpty()) return !0;
        return !1;
      } }, { key: "hasNullElements", value: function(r) {
        for (var o = 0; o < r.length; o++) if (r[o] === null) return !0;
        return !1;
      } }]), f;
    }();
    it.constructor_ = function(f) {
      f && (this._envelope = null, this._userData = null, this._factory = f, this._SRID = f.getSRID());
    }, it.TYPECODE_POINT = 0, it.TYPECODE_MULTIPOINT = 1, it.TYPECODE_LINESTRING = 2, it.TYPECODE_LINEARRING = 3, it.TYPECODE_MULTILINESTRING = 4, it.TYPECODE_POLYGON = 5, it.TYPECODE_MULTIPOLYGON = 6, it.TYPECODE_GEOMETRYCOLLECTION = 7, it.TYPENAME_POINT = "Point", it.TYPENAME_MULTIPOINT = "MultiPoint", it.TYPENAME_LINESTRING = "LineString", it.TYPENAME_LINEARRING = "LinearRing", it.TYPENAME_MULTILINESTRING = "MultiLineString", it.TYPENAME_POLYGON = "Polygon", it.TYPENAME_MULTIPOLYGON = "MultiPolygon", it.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", it.geometryChangedFilter = { get interfaces_() {
      return [G];
    }, filter: function(f) {
      f.geometryChangedAction();
    } };
    var L = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "toLocationSymbol", value: function(r) {
        switch (r) {
          case f.EXTERIOR:
            return "e";
          case f.BOUNDARY:
            return "b";
          case f.INTERIOR:
            return "i";
          case f.NONE:
            return "-";
        }
        throw new M("Unknown location value: " + r);
      } }]), f;
    }();
    L.INTERIOR = 0, L.BOUNDARY = 1, L.EXTERIOR = 2, L.NONE = -1;
    var mt = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "add", value: function() {
      } }, { key: "addAll", value: function() {
      } }, { key: "isEmpty", value: function() {
      } }, { key: "iterator", value: function() {
      } }, { key: "size", value: function() {
      } }, { key: "toArray", value: function() {
      } }, { key: "remove", value: function() {
      } }]), f;
    }(), Xt = function(f) {
      u(o, f);
      var r = E(o);
      function o(a) {
        var l;
        return e(this, o), (l = r.call(this, a)).name = Object.keys({ NoSuchElementException: o })[0], l;
      }
      return o;
    }(O), dt = function(f) {
      u(o, f);
      var r = E(o);
      function o(a) {
        var l;
        return e(this, o), (l = r.call(this, a)).name = Object.keys({ UnsupportedOperationException: o })[0], l;
      }
      return o;
    }(O), an = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        return e(this, o), r.apply(this, arguments);
      }
      return s(o, [{ key: "contains", value: function() {
      } }]), o;
    }(mt), ie = function(f, r) {
      u(a, f);
      var o = E(a);
      function a(l) {
        var d;
        return e(this, a), (d = o.call(this)).map = /* @__PURE__ */ new Map(), l instanceof mt && d.addAll(l), d;
      }
      return s(a, [{ key: "contains", value: function(l) {
        var d = l.hashCode ? l.hashCode() : l;
        return !!this.map.has(d);
      } }, { key: "add", value: function(l) {
        var d = l.hashCode ? l.hashCode() : l;
        return !this.map.has(d) && !!this.map.set(d, l);
      } }, { key: "addAll", value: function(l) {
        var d, v = R(l);
        try {
          for (v.s(); !(d = v.n()).done; ) {
            var x = d.value;
            this.add(x);
          }
        } catch (w) {
          v.e(w);
        } finally {
          v.f();
        }
        return !0;
      } }, { key: "remove", value: function() {
        throw new dt();
      } }, { key: "size", value: function() {
        return this.map.size;
      } }, { key: "isEmpty", value: function() {
        return this.map.size === 0;
      } }, { key: "toArray", value: function() {
        return Array.from(this.map.values());
      } }, { key: "iterator", value: function() {
        return new Gt(this.map);
      } }, { key: r, value: function() {
        return this.map;
      } }]), a;
    }(an, Symbol.iterator), Gt = function() {
      function f(r) {
        e(this, f), this.iterator = r.values();
        var o = this.iterator.next(), a = o.done, l = o.value;
        this.done = a, this.value = l;
      }
      return s(f, [{ key: "next", value: function() {
        if (this.done) throw new Xt();
        var r = this.value, o = this.iterator.next(), a = o.done, l = o.value;
        return this.done = a, this.value = l, r;
      } }, { key: "hasNext", value: function() {
        return !this.done;
      } }, { key: "remove", value: function() {
        throw new dt();
      } }]), f;
    }(), H = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "opposite", value: function(r) {
        return r === f.LEFT ? f.RIGHT : r === f.RIGHT ? f.LEFT : r;
      } }]), f;
    }();
    H.ON = 0, H.LEFT = 1, H.RIGHT = 2;
    var Bn = function(f) {
      u(o, f);
      var r = E(o);
      function o(a) {
        var l;
        return e(this, o), (l = r.call(this, a)).name = Object.keys({ EmptyStackException: o })[0], l;
      }
      return o;
    }(O), Pe = function(f) {
      u(o, f);
      var r = E(o);
      function o(a) {
        var l;
        return e(this, o), (l = r.call(this, a)).name = Object.keys({ IndexOutOfBoundsException: o })[0], l;
      }
      return o;
    }(O), re = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        return e(this, o), r.apply(this, arguments);
      }
      return s(o, [{ key: "get", value: function() {
      } }, { key: "set", value: function() {
      } }, { key: "isEmpty", value: function() {
      } }]), o;
    }(mt), hi = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), (a = r.call(this)).array = [], a;
      }
      return s(o, [{ key: "add", value: function(a) {
        return this.array.push(a), !0;
      } }, { key: "get", value: function(a) {
        if (a < 0 || a >= this.size()) throw new Pe();
        return this.array[a];
      } }, { key: "push", value: function(a) {
        return this.array.push(a), a;
      } }, { key: "pop", value: function() {
        if (this.array.length === 0) throw new Bn();
        return this.array.pop();
      } }, { key: "peek", value: function() {
        if (this.array.length === 0) throw new Bn();
        return this.array[this.array.length - 1];
      } }, { key: "empty", value: function() {
        return this.array.length === 0;
      } }, { key: "isEmpty", value: function() {
        return this.empty();
      } }, { key: "search", value: function(a) {
        return this.array.indexOf(a);
      } }, { key: "size", value: function() {
        return this.array.length;
      } }, { key: "toArray", value: function() {
        return this.array.slice();
      } }]), o;
    }(re);
    function ht(f, r) {
      return f.interfaces_ && f.interfaces_.indexOf(r) > -1;
    }
    var De = function() {
      function f(r) {
        e(this, f), this.str = r;
      }
      return s(f, [{ key: "append", value: function(r) {
        this.str += r;
      } }, { key: "setCharAt", value: function(r, o) {
        this.str = this.str.substr(0, r) + o + this.str.substr(r + 1);
      } }, { key: "toString", value: function() {
        return this.str;
      } }]), f;
    }(), ce = function() {
      function f(r) {
        e(this, f), this.value = r;
      }
      return s(f, [{ key: "intValue", value: function() {
        return this.value;
      } }, { key: "compareTo", value: function(r) {
        return this.value < r ? -1 : this.value > r ? 1 : 0;
      } }], [{ key: "compare", value: function(r, o) {
        return r < o ? -1 : r > o ? 1 : 0;
      } }, { key: "isNan", value: function(r) {
        return Number.isNaN(r);
      } }, { key: "valueOf", value: function(r) {
        return new f(r);
      } }]), f;
    }(), xn = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "isWhitespace", value: function(r) {
        return r <= 32 && r >= 0 || r === 127;
      } }, { key: "toUpperCase", value: function(r) {
        return r.toUpperCase();
      } }]), f;
    }(), rt = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "le", value: function(r) {
        return this._hi < r._hi || this._hi === r._hi && this._lo <= r._lo;
      } }, { key: "extractSignificantDigits", value: function(r, o) {
        var a = this.abs(), l = f.magnitude(a._hi), d = f.TEN.pow(l);
        (a = a.divide(d)).gt(f.TEN) ? (a = a.divide(f.TEN), l += 1) : a.lt(f.ONE) && (a = a.multiply(f.TEN), l -= 1);
        for (var v = l + 1, x = new De(), w = f.MAX_PRINT_DIGITS - 1, k = 0; k <= w; k++) {
          r && k === v && x.append(".");
          var N = Math.trunc(a._hi);
          if (N < 0) break;
          var P = !1, W = 0;
          N > 9 ? (P = !0, W = "9") : W = "0" + N, x.append(W), a = a.subtract(f.valueOf(N)).multiply(f.TEN), P && a.selfAdd(f.TEN);
          var tt = !0, $ = f.magnitude(a._hi);
          if ($ < 0 && Math.abs($) >= w - k && (tt = !1), !tt) break;
        }
        return o[0] = l, x.toString();
      } }, { key: "sqr", value: function() {
        return this.multiply(this);
      } }, { key: "doubleValue", value: function() {
        return this._hi + this._lo;
      } }, { key: "subtract", value: function() {
        if (arguments[0] instanceof f) {
          var r = arguments[0];
          return this.add(r.negate());
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return this.add(-o);
        }
      } }, { key: "equals", value: function() {
        if (arguments.length === 1 && arguments[0] instanceof f) {
          var r = arguments[0];
          return this._hi === r._hi && this._lo === r._lo;
        }
      } }, { key: "isZero", value: function() {
        return this._hi === 0 && this._lo === 0;
      } }, { key: "selfSubtract", value: function() {
        if (arguments[0] instanceof f) {
          var r = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-r._hi, -r._lo);
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-o, 0);
        }
      } }, { key: "getSpecialNumberString", value: function() {
        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
      } }, { key: "min", value: function(r) {
        return this.le(r) ? this : r;
      } }, { key: "selfDivide", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof f) {
            var r = arguments[0];
            return this.selfDivide(r._hi, r._lo);
          }
          if (typeof arguments[0] == "number") {
            var o = arguments[0];
            return this.selfDivide(o, 0);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1], d = null, v = null, x = null, w = null, k = null, N = null, P = null, W = null;
          return k = this._hi / a, W = (d = (N = f.SPLIT * k) - (d = N - k)) * (x = (W = f.SPLIT * a) - (x = W - a)) - (P = k * a) + d * (w = a - x) + (v = k - d) * x + v * w, W = k + (N = (this._hi - P - W + this._lo - k * l) / a), this._hi = W, this._lo = k - W + N, this;
        }
      } }, { key: "dump", value: function() {
        return "DD<" + this._hi + ", " + this._lo + ">";
      } }, { key: "divide", value: function() {
        if (arguments[0] instanceof f) {
          var r = arguments[0], o = null, a = null, l = null, d = null, v = null, x = null, w = null, k = null;
          a = (v = this._hi / r._hi) - (o = (x = f.SPLIT * v) - (o = x - v)), k = o * (l = (k = f.SPLIT * r._hi) - (l = k - r._hi)) - (w = v * r._hi) + o * (d = r._hi - l) + a * l + a * d;
          var N = k = v + (x = (this._hi - w - k + this._lo - v * r._lo) / r._hi), P = v - k + x;
          return new f(N, P);
        }
        if (typeof arguments[0] == "number") {
          var W = arguments[0];
          return Q.isNaN(W) ? f.createNaN() : f.copy(this).selfDivide(W, 0);
        }
      } }, { key: "ge", value: function(r) {
        return this._hi > r._hi || this._hi === r._hi && this._lo >= r._lo;
      } }, { key: "pow", value: function(r) {
        if (r === 0) return f.valueOf(1);
        var o = new f(this), a = f.valueOf(1), l = Math.abs(r);
        if (l > 1) for (; l > 0; ) l % 2 == 1 && a.selfMultiply(o), (l /= 2) > 0 && (o = o.sqr());
        else a = o;
        return r < 0 ? a.reciprocal() : a;
      } }, { key: "ceil", value: function() {
        if (this.isNaN()) return f.NaN;
        var r = Math.ceil(this._hi), o = 0;
        return r === this._hi && (o = Math.ceil(this._lo)), new f(r, o);
      } }, { key: "compareTo", value: function(r) {
        var o = r;
        return this._hi < o._hi ? -1 : this._hi > o._hi ? 1 : this._lo < o._lo ? -1 : this._lo > o._lo ? 1 : 0;
      } }, { key: "rint", value: function() {
        return this.isNaN() ? this : this.add(0.5).floor();
      } }, { key: "setValue", value: function() {
        if (arguments[0] instanceof f) {
          var r = arguments[0];
          return this.init(r), this;
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return this.init(o), this;
        }
      } }, { key: "max", value: function(r) {
        return this.ge(r) ? this : r;
      } }, { key: "sqrt", value: function() {
        if (this.isZero()) return f.valueOf(0);
        if (this.isNegative()) return f.NaN;
        var r = 1 / Math.sqrt(this._hi), o = this._hi * r, a = f.valueOf(o), l = this.subtract(a.sqr())._hi * (0.5 * r);
        return a.add(l);
      } }, { key: "selfAdd", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof f) {
            var r = arguments[0];
            return this.selfAdd(r._hi, r._lo);
          }
          if (typeof arguments[0] == "number") {
            var o = arguments[0], a = null, l = null, d = null, v = null, x = null, w = null;
            return v = (d = this._hi + o) - (x = d - this._hi), l = (w = (v = o - x + (this._hi - v)) + this._lo) + (d - (a = d + w)), this._hi = a + l, this._lo = l + (a - this._hi), this;
          }
        } else if (arguments.length === 2) {
          var k = arguments[0], N = arguments[1], P = null, W = null, tt = null, $ = null, ot = null, ft = null, pt = null;
          $ = this._hi + k, W = this._lo + N, ot = $ - (ft = $ - this._hi), tt = W - (pt = W - this._lo);
          var Pt = (P = $ + (ft = (ot = k - ft + (this._hi - ot)) + W)) + (ft = (tt = N - pt + (this._lo - tt)) + (ft + ($ - P))), Zt = ft + (P - Pt);
          return this._hi = Pt, this._lo = Zt, this;
        }
      } }, { key: "selfMultiply", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof f) {
            var r = arguments[0];
            return this.selfMultiply(r._hi, r._lo);
          }
          if (typeof arguments[0] == "number") {
            var o = arguments[0];
            return this.selfMultiply(o, 0);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1], d = null, v = null, x = null, w = null, k = null, N = null;
          d = (k = f.SPLIT * this._hi) - this._hi, N = f.SPLIT * a, d = k - d, v = this._hi - d, x = N - a;
          var P = (k = this._hi * a) + (N = d * (x = N - x) - k + d * (w = a - x) + v * x + v * w + (this._hi * l + this._lo * a)), W = N + (d = k - P);
          return this._hi = P, this._lo = W, this;
        }
      } }, { key: "selfSqr", value: function() {
        return this.selfMultiply(this);
      } }, { key: "floor", value: function() {
        if (this.isNaN()) return f.NaN;
        var r = Math.floor(this._hi), o = 0;
        return r === this._hi && (o = Math.floor(this._lo)), new f(r, o);
      } }, { key: "negate", value: function() {
        return this.isNaN() ? this : new f(-this._hi, -this._lo);
      } }, { key: "clone", value: function() {
        try {
          return null;
        } catch (r) {
          if (r instanceof CloneNotSupportedException) return null;
          throw r;
        }
      } }, { key: "multiply", value: function() {
        if (arguments[0] instanceof f) {
          var r = arguments[0];
          return r.isNaN() ? f.createNaN() : f.copy(this).selfMultiply(r);
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return Q.isNaN(o) ? f.createNaN() : f.copy(this).selfMultiply(o, 0);
        }
      } }, { key: "isNaN", value: function() {
        return Q.isNaN(this._hi);
      } }, { key: "intValue", value: function() {
        return Math.trunc(this._hi);
      } }, { key: "toString", value: function() {
        var r = f.magnitude(this._hi);
        return r >= -3 && r <= 20 ? this.toStandardNotation() : this.toSciNotation();
      } }, { key: "toStandardNotation", value: function() {
        var r = this.getSpecialNumberString();
        if (r !== null) return r;
        var o = new Array(1).fill(null), a = this.extractSignificantDigits(!0, o), l = o[0] + 1, d = a;
        if (a.charAt(0) === ".") d = "0" + a;
        else if (l < 0) d = "0." + f.stringOfChar("0", -l) + a;
        else if (a.indexOf(".") === -1) {
          var v = l - a.length;
          d = a + f.stringOfChar("0", v) + ".0";
        }
        return this.isNegative() ? "-" + d : d;
      } }, { key: "reciprocal", value: function() {
        var r, o, a, l, d = null, v = null, x = null, w = null;
        r = (a = 1 / this._hi) - (d = (x = f.SPLIT * a) - (d = x - a)), v = (w = f.SPLIT * this._hi) - this._hi;
        var k = a + (x = (1 - (l = a * this._hi) - (w = d * (v = w - v) - l + d * (o = this._hi - v) + r * v + r * o) - a * this._lo) / this._hi);
        return new f(k, a - k + x);
      } }, { key: "toSciNotation", value: function() {
        if (this.isZero()) return f.SCI_NOT_ZERO;
        var r = this.getSpecialNumberString();
        if (r !== null) return r;
        var o = new Array(1).fill(null), a = this.extractSignificantDigits(!1, o), l = f.SCI_NOT_EXPONENT_CHAR + o[0];
        if (a.charAt(0) === "0") throw new IllegalStateException("Found leading zero: " + a);
        var d = "";
        a.length > 1 && (d = a.substring(1));
        var v = a.charAt(0) + "." + d;
        return this.isNegative() ? "-" + v + l : v + l;
      } }, { key: "abs", value: function() {
        return this.isNaN() ? f.NaN : this.isNegative() ? this.negate() : new f(this);
      } }, { key: "isPositive", value: function() {
        return this._hi > 0 || this._hi === 0 && this._lo > 0;
      } }, { key: "lt", value: function(r) {
        return this._hi < r._hi || this._hi === r._hi && this._lo < r._lo;
      } }, { key: "add", value: function() {
        if (arguments[0] instanceof f) {
          var r = arguments[0];
          return f.copy(this).selfAdd(r);
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return f.copy(this).selfAdd(o);
        }
      } }, { key: "init", value: function() {
        if (arguments.length === 1) {
          if (typeof arguments[0] == "number") {
            var r = arguments[0];
            this._hi = r, this._lo = 0;
          } else if (arguments[0] instanceof f) {
            var o = arguments[0];
            this._hi = o._hi, this._lo = o._lo;
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this._hi = a, this._lo = l;
        }
      } }, { key: "gt", value: function(r) {
        return this._hi > r._hi || this._hi === r._hi && this._lo > r._lo;
      } }, { key: "isNegative", value: function() {
        return this._hi < 0 || this._hi === 0 && this._lo < 0;
      } }, { key: "trunc", value: function() {
        return this.isNaN() ? f.NaN : this.isPositive() ? this.floor() : this.ceil();
      } }, { key: "signum", value: function() {
        return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
      } }, { key: "interfaces_", get: function() {
        return [A, D, F];
      } }], [{ key: "constructor_", value: function() {
        if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0);
        else if (arguments.length === 1) {
          if (typeof arguments[0] == "number") {
            var r = arguments[0];
            this.init(r);
          } else if (arguments[0] instanceof f) {
            var o = arguments[0];
            this.init(o);
          } else if (typeof arguments[0] == "string") {
            var a = arguments[0];
            f.constructor_.call(this, f.parse(a));
          }
        } else if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          this.init(l, d);
        }
      } }, { key: "determinant", value: function() {
        if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var r = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
          return f.determinant(f.valueOf(r), f.valueOf(o), f.valueOf(a), f.valueOf(l));
        }
        if (arguments[3] instanceof f && arguments[2] instanceof f && arguments[0] instanceof f && arguments[1] instanceof f) {
          var d = arguments[0], v = arguments[1], x = arguments[2], w = arguments[3], k = d.multiply(w).selfSubtract(v.multiply(x));
          return k;
        }
      } }, { key: "sqr", value: function(r) {
        return f.valueOf(r).selfMultiply(r);
      } }, { key: "valueOf", value: function() {
        if (typeof arguments[0] == "string") {
          var r = arguments[0];
          return f.parse(r);
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return new f(o);
        }
      } }, { key: "sqrt", value: function(r) {
        return f.valueOf(r).sqrt();
      } }, { key: "parse", value: function(r) {
        for (var o = 0, a = r.length; xn.isWhitespace(r.charAt(o)); ) o++;
        var l = !1;
        if (o < a) {
          var d = r.charAt(o);
          d !== "-" && d !== "+" || (o++, d === "-" && (l = !0));
        }
        for (var v = new f(), x = 0, w = 0, k = 0, N = !1; !(o >= a); ) {
          var P = r.charAt(o);
          if (o++, xn.isDigit(P)) {
            var W = P - "0";
            v.selfMultiply(f.TEN), v.selfAdd(W), x++;
          } else {
            if (P !== ".") {
              if (P === "e" || P === "E") {
                var tt = r.substring(o);
                try {
                  k = ce.parseInt(tt);
                } catch (Pt) {
                  throw Pt instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + tt + " in string " + r) : Pt;
                }
                break;
              }
              throw new NumberFormatException("Unexpected character '" + P + "' at position " + o + " in string " + r);
            }
            w = x, N = !0;
          }
        }
        var $ = v;
        N || (w = x);
        var ot = x - w - k;
        if (ot === 0) $ = v;
        else if (ot > 0) {
          var ft = f.TEN.pow(ot);
          $ = v.divide(ft);
        } else if (ot < 0) {
          var pt = f.TEN.pow(-ot);
          $ = v.multiply(pt);
        }
        return l ? $.negate() : $;
      } }, { key: "createNaN", value: function() {
        return new f(Q.NaN, Q.NaN);
      } }, { key: "copy", value: function(r) {
        return new f(r);
      } }, { key: "magnitude", value: function(r) {
        var o = Math.abs(r), a = Math.log(o) / Math.log(10), l = Math.trunc(Math.floor(a));
        return 10 * Math.pow(10, l) <= o && (l += 1), l;
      } }, { key: "stringOfChar", value: function(r, o) {
        for (var a = new De(), l = 0; l < o; l++) a.append(r);
        return a.toString();
      } }]), f;
    }();
    rt.PI = new rt(3.141592653589793, 12246467991473532e-32), rt.TWO_PI = new rt(6.283185307179586, 24492935982947064e-32), rt.PI_2 = new rt(1.5707963267948966, 6123233995736766e-32), rt.E = new rt(2.718281828459045, 14456468917292502e-32), rt.NaN = new rt(Q.NaN, Q.NaN), rt.EPS = 123259516440783e-46, rt.SPLIT = 134217729, rt.MAX_PRINT_DIGITS = 32, rt.TEN = rt.valueOf(10), rt.ONE = rt.valueOf(1), rt.SCI_NOT_EXPONENT_CHAR = "E", rt.SCI_NOT_ZERO = "0.0E0";
    var Ve = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "orientationIndex", value: function(r, o, a) {
        var l = f.orientationIndexFilter(r, o, a);
        if (l <= 1) return l;
        var d = rt.valueOf(o.x).selfAdd(-r.x), v = rt.valueOf(o.y).selfAdd(-r.y), x = rt.valueOf(a.x).selfAdd(-o.x), w = rt.valueOf(a.y).selfAdd(-o.y);
        return d.selfMultiply(w).selfSubtract(v.selfMultiply(x)).signum();
      } }, { key: "signOfDet2x2", value: function() {
        if (arguments[3] instanceof rt && arguments[2] instanceof rt && arguments[0] instanceof rt && arguments[1] instanceof rt) {
          var r = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3], d = r.multiply(l).selfSubtract(o.multiply(a));
          return d.signum();
        }
        if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var v = arguments[0], x = arguments[1], w = arguments[2], k = arguments[3], N = rt.valueOf(v), P = rt.valueOf(x), W = rt.valueOf(w), tt = rt.valueOf(k), $ = N.multiply(tt).selfSubtract(P.multiply(W));
          return $.signum();
        }
      } }, { key: "intersection", value: function(r, o, a, l) {
        var d = new rt(r.y).selfSubtract(o.y), v = new rt(o.x).selfSubtract(r.x), x = new rt(r.x).selfMultiply(o.y).selfSubtract(new rt(o.x).selfMultiply(r.y)), w = new rt(a.y).selfSubtract(l.y), k = new rt(l.x).selfSubtract(a.x), N = new rt(a.x).selfMultiply(l.y).selfSubtract(new rt(l.x).selfMultiply(a.y)), P = v.multiply(N).selfSubtract(k.multiply(x)), W = w.multiply(x).selfSubtract(d.multiply(N)), tt = d.multiply(k).selfSubtract(w.multiply(v)), $ = P.selfDivide(tt).doubleValue(), ot = W.selfDivide(tt).doubleValue();
        return Q.isNaN($) || Q.isInfinite($) || Q.isNaN(ot) || Q.isInfinite(ot) ? null : new B($, ot);
      } }, { key: "orientationIndexFilter", value: function(r, o, a) {
        var l = null, d = (r.x - a.x) * (o.y - a.y), v = (r.y - a.y) * (o.x - a.x), x = d - v;
        if (d > 0) {
          if (v <= 0) return f.signum(x);
          l = d + v;
        } else {
          if (!(d < 0) || v >= 0) return f.signum(x);
          l = -d - v;
        }
        var w = f.DP_SAFE_EPSILON * l;
        return x >= w || -x >= w ? f.signum(x) : 2;
      } }, { key: "signum", value: function(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
      } }]), f;
    }();
    Ve.DP_SAFE_EPSILON = 1e-15;
    var It = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "getM", value: function(r) {
        if (this.hasM()) {
          var o = this.getDimension() - this.getMeasures();
          return this.getOrdinate(r, o);
        }
        return Q.NaN;
      } }, { key: "setOrdinate", value: function(r, o, a) {
      } }, { key: "getZ", value: function(r) {
        return this.hasZ() ? this.getOrdinate(r, 2) : Q.NaN;
      } }, { key: "size", value: function() {
      } }, { key: "getOrdinate", value: function(r, o) {
      } }, { key: "getCoordinate", value: function() {
      } }, { key: "getCoordinateCopy", value: function(r) {
      } }, { key: "createCoordinate", value: function() {
      } }, { key: "getDimension", value: function() {
      } }, { key: "hasM", value: function() {
        return this.getMeasures() > 0;
      } }, { key: "getX", value: function(r) {
      } }, { key: "hasZ", value: function() {
        return this.getDimension() - this.getMeasures() > 2;
      } }, { key: "getMeasures", value: function() {
        return 0;
      } }, { key: "expandEnvelope", value: function(r) {
      } }, { key: "copy", value: function() {
      } }, { key: "getY", value: function(r) {
      } }, { key: "toCoordinateArray", value: function() {
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }]), f;
    }();
    It.X = 0, It.Y = 1, It.Z = 2, It.M = 3;
    var ct = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "index", value: function(r, o, a) {
        return Ve.orientationIndex(r, o, a);
      } }, { key: "isCCW", value: function() {
        if (arguments[0] instanceof Array) {
          var r = arguments[0], o = r.length - 1;
          if (o < 3) throw new M("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var a = r[0], l = 0, d = 1; d <= o; d++) {
            var v = r[d];
            v.y > a.y && (a = v, l = d);
          }
          var x = l;
          do
            (x -= 1) < 0 && (x = o);
          while (r[x].equals2D(a) && x !== l);
          var w = l;
          do
            w = (w + 1) % o;
          while (r[w].equals2D(a) && w !== l);
          var k = r[x], N = r[w];
          if (k.equals2D(a) || N.equals2D(a) || k.equals2D(N)) return !1;
          var P = f.index(k, a, N), W = null;
          return W = P === 0 ? k.x > N.x : P > 0, W;
        }
        if (ht(arguments[0], It)) {
          var tt = arguments[0], $ = tt.size() - 1;
          if ($ < 3) throw new M("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var ot = tt.getCoordinate(0), ft = 0, pt = 1; pt <= $; pt++) {
            var Pt = tt.getCoordinate(pt);
            Pt.y > ot.y && (ot = Pt, ft = pt);
          }
          var Zt = null, _e = ft;
          do
            (_e -= 1) < 0 && (_e = $), Zt = tt.getCoordinate(_e);
          while (Zt.equals2D(ot) && _e !== ft);
          var ze = null, cn = ft;
          do
            cn = (cn + 1) % $, ze = tt.getCoordinate(cn);
          while (ze.equals2D(ot) && cn !== ft);
          if (Zt.equals2D(ot) || ze.equals2D(ot) || Zt.equals2D(ze)) return !1;
          var Xn = f.index(Zt, ot, ze);
          return Xn === 0 ? Zt.x > ze.x : Xn > 0;
        }
      } }]), f;
    }();
    ct.CLOCKWISE = -1, ct.RIGHT = ct.CLOCKWISE, ct.COUNTERCLOCKWISE = 1, ct.LEFT = ct.COUNTERCLOCKWISE, ct.COLLINEAR = 0, ct.STRAIGHT = ct.COLLINEAR;
    var Sr = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getCoordinate", value: function() {
        return this._minCoord;
      } }, { key: "getRightmostSide", value: function(r, o) {
        var a = this.getRightmostSideOfSegment(r, o);
        return a < 0 && (a = this.getRightmostSideOfSegment(r, o - 1)), a < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(r)), a;
      } }, { key: "findRightmostEdgeAtVertex", value: function() {
        var r = this._minDe.getEdge().getCoordinates();
        X.isTrue(this._minIndex > 0 && this._minIndex < r.length, "rightmost point expected to be interior vertex of edge");
        var o = r[this._minIndex - 1], a = r[this._minIndex + 1], l = ct.index(this._minCoord, a, o), d = !1;
        (o.y < this._minCoord.y && a.y < this._minCoord.y && l === ct.COUNTERCLOCKWISE || o.y > this._minCoord.y && a.y > this._minCoord.y && l === ct.CLOCKWISE) && (d = !0), d && (this._minIndex = this._minIndex - 1);
      } }, { key: "getRightmostSideOfSegment", value: function(r, o) {
        var a = r.getEdge().getCoordinates();
        if (o < 0 || o + 1 >= a.length || a[o].y === a[o + 1].y) return -1;
        var l = H.LEFT;
        return a[o].y < a[o + 1].y && (l = H.RIGHT), l;
      } }, { key: "getEdge", value: function() {
        return this._orientedDe;
      } }, { key: "checkForRightmostCoordinate", value: function(r) {
        for (var o = r.getEdge().getCoordinates(), a = 0; a < o.length - 1; a++) (this._minCoord === null || o[a].x > this._minCoord.x) && (this._minDe = r, this._minIndex = a, this._minCoord = o[a]);
      } }, { key: "findRightmostEdgeAtNode", value: function() {
        var r = this._minDe.getNode().getEdges();
        this._minDe = r.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
      } }, { key: "findEdge", value: function(r) {
        for (var o = r.iterator(); o.hasNext(); ) {
          var a = o.next();
          a.isForward() && this.checkForRightmostCoordinate(a);
        }
        X.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === H.LEFT && (this._orientedDe = this._minDe.getSym());
      } }], [{ key: "constructor_", value: function() {
        this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
      } }]), f;
    }(), fe = function(f) {
      u(o, f);
      var r = E(o);
      function o(a, l) {
        var d;
        return e(this, o), (d = r.call(this, l ? a + " [ " + l + " ]" : a)).pt = l ? new B(l) : void 0, d.name = Object.keys({ TopologyException: o })[0], d;
      }
      return s(o, [{ key: "getCoordinate", value: function() {
        return this.pt;
      } }]), o;
    }(Et), zi = function() {
      function f() {
        e(this, f), this.array = [];
      }
      return s(f, [{ key: "addLast", value: function(r) {
        this.array.push(r);
      } }, { key: "removeFirst", value: function() {
        return this.array.shift();
      } }, { key: "isEmpty", value: function() {
        return this.array.length === 0;
      } }]), f;
    }(), ut = function(f, r) {
      u(a, f);
      var o = E(a);
      function a(l) {
        var d;
        return e(this, a), (d = o.call(this)).array = [], l instanceof mt && d.addAll(l), d;
      }
      return s(a, [{ key: "interfaces_", get: function() {
        return [re, mt];
      } }, { key: "ensureCapacity", value: function() {
      } }, { key: "add", value: function(l) {
        return arguments.length === 1 ? this.array.push(l) : this.array.splice(arguments[0], 0, arguments[1]), !0;
      } }, { key: "clear", value: function() {
        this.array = [];
      } }, { key: "addAll", value: function(l) {
        var d, v = R(l);
        try {
          for (v.s(); !(d = v.n()).done; ) {
            var x = d.value;
            this.array.push(x);
          }
        } catch (w) {
          v.e(w);
        } finally {
          v.f();
        }
      } }, { key: "set", value: function(l, d) {
        var v = this.array[l];
        return this.array[l] = d, v;
      } }, { key: "iterator", value: function() {
        return new wr(this);
      } }, { key: "get", value: function(l) {
        if (l < 0 || l >= this.size()) throw new Pe();
        return this.array[l];
      } }, { key: "isEmpty", value: function() {
        return this.array.length === 0;
      } }, { key: "sort", value: function(l) {
        l ? this.array.sort(function(d, v) {
          return l.compare(d, v);
        }) : this.array.sort();
      } }, { key: "size", value: function() {
        return this.array.length;
      } }, { key: "toArray", value: function() {
        return this.array.slice();
      } }, { key: "remove", value: function(l) {
        for (var d = 0, v = this.array.length; d < v; d++) if (this.array[d] === l) return !!this.array.splice(d, 1);
        return !1;
      } }, { key: r, value: function() {
        return this.array.values();
      } }]), a;
    }(re, Symbol.iterator), wr = function() {
      function f(r) {
        e(this, f), this.arrayList = r, this.position = 0;
      }
      return s(f, [{ key: "next", value: function() {
        if (this.position === this.arrayList.size()) throw new Xt();
        return this.arrayList.get(this.position++);
      } }, { key: "hasNext", value: function() {
        return this.position < this.arrayList.size();
      } }, { key: "set", value: function(r) {
        return this.arrayList.set(this.position - 1, r);
      } }, { key: "remove", value: function() {
        this.arrayList.remove(this.arrayList.get(this.position));
      } }]), f;
    }(), Ir = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "clearVisitedEdges", value: function() {
        for (var r = this._dirEdgeList.iterator(); r.hasNext(); )
          r.next().setVisited(!1);
      } }, { key: "getRightmostCoordinate", value: function() {
        return this._rightMostCoord;
      } }, { key: "computeNodeDepth", value: function(r) {
        for (var o = null, a = r.getEdges().iterator(); a.hasNext(); ) {
          var l = a.next();
          if (l.isVisited() || l.getSym().isVisited()) {
            o = l;
            break;
          }
        }
        if (o === null) throw new fe("unable to find edge to compute depths at " + r.getCoordinate());
        r.getEdges().computeDepths(o);
        for (var d = r.getEdges().iterator(); d.hasNext(); ) {
          var v = d.next();
          v.setVisited(!0), this.copySymDepths(v);
        }
      } }, { key: "computeDepth", value: function(r) {
        this.clearVisitedEdges();
        var o = this._finder.getEdge();
        o.getNode(), o.getLabel(), o.setEdgeDepths(H.RIGHT, r), this.copySymDepths(o), this.computeDepths(o);
      } }, { key: "create", value: function(r) {
        this.addReachable(r), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
      } }, { key: "findResultEdges", value: function() {
        for (var r = this._dirEdgeList.iterator(); r.hasNext(); ) {
          var o = r.next();
          o.getDepth(H.RIGHT) >= 1 && o.getDepth(H.LEFT) <= 0 && !o.isInteriorAreaEdge() && o.setInResult(!0);
        }
      } }, { key: "computeDepths", value: function(r) {
        var o = new ie(), a = new zi(), l = r.getNode();
        for (a.addLast(l), o.add(l), r.setVisited(!0); !a.isEmpty(); ) {
          var d = a.removeFirst();
          o.add(d), this.computeNodeDepth(d);
          for (var v = d.getEdges().iterator(); v.hasNext(); ) {
            var x = v.next().getSym();
            if (!x.isVisited()) {
              var w = x.getNode();
              o.contains(w) || (a.addLast(w), o.add(w));
            }
          }
        }
      } }, { key: "compareTo", value: function(r) {
        var o = r;
        return this._rightMostCoord.x < o._rightMostCoord.x ? -1 : this._rightMostCoord.x > o._rightMostCoord.x ? 1 : 0;
      } }, { key: "getEnvelope", value: function() {
        if (this._env === null) {
          for (var r = new Ot(), o = this._dirEdgeList.iterator(); o.hasNext(); ) for (var a = o.next().getEdge().getCoordinates(), l = 0; l < a.length - 1; l++) r.expandToInclude(a[l]);
          this._env = r;
        }
        return this._env;
      } }, { key: "addReachable", value: function(r) {
        var o = new hi();
        for (o.add(r); !o.empty(); ) {
          var a = o.pop();
          this.add(a, o);
        }
      } }, { key: "copySymDepths", value: function(r) {
        var o = r.getSym();
        o.setDepth(H.LEFT, r.getDepth(H.RIGHT)), o.setDepth(H.RIGHT, r.getDepth(H.LEFT));
      } }, { key: "add", value: function(r, o) {
        r.setVisited(!0), this._nodes.add(r);
        for (var a = r.getEdges().iterator(); a.hasNext(); ) {
          var l = a.next();
          this._dirEdgeList.add(l);
          var d = l.getSym().getNode();
          d.isVisited() || o.push(d);
        }
      } }, { key: "getNodes", value: function() {
        return this._nodes;
      } }, { key: "getDirectedEdges", value: function() {
        return this._dirEdgeList;
      } }, { key: "interfaces_", get: function() {
        return [D];
      } }], [{ key: "constructor_", value: function() {
        this._finder = null, this._dirEdgeList = new ut(), this._nodes = new ut(), this._rightMostCoord = null, this._env = null, this._finder = new Sr();
      } }]), f;
    }(), zn = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "intersection", value: function(r, o, a, l) {
        var d = r.x < o.x ? r.x : o.x, v = r.y < o.y ? r.y : o.y, x = r.x > o.x ? r.x : o.x, w = r.y > o.y ? r.y : o.y, k = a.x < l.x ? a.x : l.x, N = a.y < l.y ? a.y : l.y, P = a.x > l.x ? a.x : l.x, W = a.y > l.y ? a.y : l.y, tt = ((d > k ? d : k) + (x < P ? x : P)) / 2, $ = ((v > N ? v : N) + (w < W ? w : W)) / 2, ot = r.x - tt, ft = r.y - $, pt = o.x - tt, Pt = o.y - $, Zt = a.x - tt, _e = a.y - $, ze = l.x - tt, cn = l.y - $, Xn = ft - Pt, ji = pt - ot, bs = ot * Pt - pt * ft, Cs = _e - cn, Ar = ze - Zt, Sc = Zt * cn - ze * _e, wc = Xn * Ar - Cs * ji, pu = (ji * Sc - Ar * bs) / wc, vu = (Cs * bs - Xn * Sc) / wc;
        return Q.isNaN(pu) || Q.isInfinite(pu) || Q.isNaN(vu) || Q.isInfinite(vu) ? null : new B(pu + tt, vu + $);
      } }]), f;
    }(), ge = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "arraycopy", value: function(r, o, a, l, d) {
        for (var v = 0, x = o; x < o + d; x++) a[l + v] = r[x], v++;
      } }, { key: "getProperty", value: function(r) {
        return { "line.separator": `
` }[r];
      } }]), f;
    }(), un = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "log10", value: function(r) {
        var o = Math.log(r);
        return Q.isInfinite(o) || Q.isNaN(o) ? o : o / f.LOG_10;
      } }, { key: "min", value: function(r, o, a, l) {
        var d = r;
        return o < d && (d = o), a < d && (d = a), l < d && (d = l), d;
      } }, { key: "clamp", value: function() {
        if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var r = arguments[0], o = arguments[1], a = arguments[2];
          return r < o ? o : r > a ? a : r;
        }
        if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
          var l = arguments[0], d = arguments[1], v = arguments[2];
          return l < d ? d : l > v ? v : l;
        }
      } }, { key: "wrap", value: function(r, o) {
        return r < 0 ? o - -r % o : r % o;
      } }, { key: "max", value: function() {
        if (arguments.length === 3) {
          var r = arguments[0], o = arguments[1], a = arguments[2], l = r;
          return o > l && (l = o), a > l && (l = a), l;
        }
        if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], x = arguments[2], w = arguments[3], k = d;
          return v > k && (k = v), x > k && (k = x), w > k && (k = w), k;
        }
      } }, { key: "average", value: function(r, o) {
        return (r + o) / 2;
      } }]), f;
    }();
    un.LOG_10 = Math.log(10);
    var se = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "segmentToSegment", value: function(r, o, a, l) {
        if (r.equals(o)) return f.pointToSegment(r, a, l);
        if (a.equals(l)) return f.pointToSegment(l, r, o);
        var d = !1;
        if (Ot.intersects(r, o, a, l)) {
          var v = (o.x - r.x) * (l.y - a.y) - (o.y - r.y) * (l.x - a.x);
          if (v === 0) d = !0;
          else {
            var x = (r.y - a.y) * (l.x - a.x) - (r.x - a.x) * (l.y - a.y), w = ((r.y - a.y) * (o.x - r.x) - (r.x - a.x) * (o.y - r.y)) / v, k = x / v;
            (k < 0 || k > 1 || w < 0 || w > 1) && (d = !0);
          }
        } else d = !0;
        return d ? un.min(f.pointToSegment(r, a, l), f.pointToSegment(o, a, l), f.pointToSegment(a, r, o), f.pointToSegment(l, r, o)) : 0;
      } }, { key: "pointToSegment", value: function(r, o, a) {
        if (o.x === a.x && o.y === a.y) return r.distance(o);
        var l = (a.x - o.x) * (a.x - o.x) + (a.y - o.y) * (a.y - o.y), d = ((r.x - o.x) * (a.x - o.x) + (r.y - o.y) * (a.y - o.y)) / l;
        if (d <= 0) return r.distance(o);
        if (d >= 1) return r.distance(a);
        var v = ((o.y - r.y) * (a.x - o.x) - (o.x - r.x) * (a.y - o.y)) / l;
        return Math.abs(v) * Math.sqrt(l);
      } }, { key: "pointToLinePerpendicular", value: function(r, o, a) {
        var l = (a.x - o.x) * (a.x - o.x) + (a.y - o.y) * (a.y - o.y), d = ((o.y - r.y) * (a.x - o.x) - (o.x - r.x) * (a.y - o.y)) / l;
        return Math.abs(d) * Math.sqrt(l);
      } }, { key: "pointToSegmentString", value: function(r, o) {
        if (o.length === 0) throw new M("Line array must contain at least one vertex");
        for (var a = r.distance(o[0]), l = 0; l < o.length - 1; l++) {
          var d = f.pointToSegment(r, o[l], o[l + 1]);
          d < a && (a = d);
        }
        return a;
      } }]), f;
    }(), Sn = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "create", value: function() {
        if (arguments.length === 1) arguments[0] instanceof Array || ht(arguments[0], It);
        else if (arguments.length !== 2) {
          if (arguments.length === 3) {
            var r = arguments[0], o = arguments[1];
            return this.create(r, o);
          }
        }
      } }]), f;
    }(), Ze = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "filter", value: function(r) {
      } }]), f;
    }(), kr = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "ofLine", value: function(r) {
        var o = r.size();
        if (o <= 1) return 0;
        var a = 0, l = new B();
        r.getCoordinate(0, l);
        for (var d = l.x, v = l.y, x = 1; x < o; x++) {
          r.getCoordinate(x, l);
          var w = l.x, k = l.y, N = w - d, P = k - v;
          a += Math.sqrt(N * N + P * P), d = w, v = k;
        }
        return a;
      } }]), f;
    }(), Yi = function f() {
      e(this, f);
    }, Qt = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "copyCoord", value: function(r, o, a, l) {
        for (var d = Math.min(r.getDimension(), a.getDimension()), v = 0; v < d; v++) a.setOrdinate(l, v, r.getOrdinate(o, v));
      } }, { key: "isRing", value: function(r) {
        var o = r.size();
        return o === 0 || !(o <= 3) && r.getOrdinate(0, It.X) === r.getOrdinate(o - 1, It.X) && r.getOrdinate(0, It.Y) === r.getOrdinate(o - 1, It.Y);
      } }, { key: "scroll", value: function() {
        if (arguments.length === 2) {
          if (ht(arguments[0], It) && Number.isInteger(arguments[1])) {
            var r = arguments[0], o = arguments[1];
            f.scroll(r, o, f.isRing(r));
          } else if (ht(arguments[0], It) && arguments[1] instanceof B) {
            var a = arguments[0], l = arguments[1], d = f.indexOf(l, a);
            if (d <= 0) return null;
            f.scroll(a, d);
          }
        } else if (arguments.length === 3) {
          var v = arguments[0], x = arguments[1], w = arguments[2], k = x;
          if (k <= 0) return null;
          for (var N = v.copy(), P = w ? v.size() - 1 : v.size(), W = 0; W < P; W++) for (var tt = 0; tt < v.getDimension(); tt++) v.setOrdinate(W, tt, N.getOrdinate((x + W) % P, tt));
          if (w) for (var $ = 0; $ < v.getDimension(); $++) v.setOrdinate(P, $, v.getOrdinate(0, $));
        }
      } }, { key: "isEqual", value: function(r, o) {
        var a = r.size();
        if (a !== o.size()) return !1;
        for (var l = Math.min(r.getDimension(), o.getDimension()), d = 0; d < a; d++) for (var v = 0; v < l; v++) {
          var x = r.getOrdinate(d, v), w = o.getOrdinate(d, v);
          if (r.getOrdinate(d, v) !== o.getOrdinate(d, v) && (!Q.isNaN(x) || !Q.isNaN(w))) return !1;
        }
        return !0;
      } }, { key: "minCoordinateIndex", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          return f.minCoordinateIndex(r, 0, r.size() - 1);
        }
        if (arguments.length === 3) {
          for (var o = arguments[0], a = arguments[1], l = arguments[2], d = -1, v = null, x = a; x <= l; x++) {
            var w = o.getCoordinate(x);
            (v === null || v.compareTo(w) > 0) && (v = w, d = x);
          }
          return d;
        }
      } }, { key: "extend", value: function(r, o, a) {
        var l = r.create(a, o.getDimension()), d = o.size();
        if (f.copy(o, 0, l, 0, d), d > 0) for (var v = d; v < a; v++) f.copy(o, d - 1, l, v, 1);
        return l;
      } }, { key: "reverse", value: function(r) {
        for (var o = r.size() - 1, a = Math.trunc(o / 2), l = 0; l <= a; l++) f.swap(r, l, o - l);
      } }, { key: "swap", value: function(r, o, a) {
        if (o === a) return null;
        for (var l = 0; l < r.getDimension(); l++) {
          var d = r.getOrdinate(o, l);
          r.setOrdinate(o, l, r.getOrdinate(a, l)), r.setOrdinate(a, l, d);
        }
      } }, { key: "copy", value: function(r, o, a, l, d) {
        for (var v = 0; v < d; v++) f.copyCoord(r, o + v, a, l + v);
      } }, { key: "ensureValidRing", value: function(r, o) {
        var a = o.size();
        return a === 0 ? o : a <= 3 ? f.createClosedRing(r, o, 4) : o.getOrdinate(0, It.X) === o.getOrdinate(a - 1, It.X) && o.getOrdinate(0, It.Y) === o.getOrdinate(a - 1, It.Y) ? o : f.createClosedRing(r, o, a + 1);
      } }, { key: "indexOf", value: function(r, o) {
        for (var a = 0; a < o.size(); a++) if (r.x === o.getOrdinate(a, It.X) && r.y === o.getOrdinate(a, It.Y)) return a;
        return -1;
      } }, { key: "createClosedRing", value: function(r, o, a) {
        var l = r.create(a, o.getDimension()), d = o.size();
        f.copy(o, 0, l, 0, d);
        for (var v = d; v < a; v++) f.copy(o, 0, l, v, 1);
        return l;
      } }, { key: "minCoordinate", value: function(r) {
        for (var o = null, a = 0; a < r.size(); a++) {
          var l = r.getCoordinate(a);
          (o === null || o.compareTo(l) > 0) && (o = l);
        }
        return o;
      } }]), f;
    }(), J = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "toDimensionSymbol", value: function(r) {
        switch (r) {
          case f.FALSE:
            return f.SYM_FALSE;
          case f.TRUE:
            return f.SYM_TRUE;
          case f.DONTCARE:
            return f.SYM_DONTCARE;
          case f.P:
            return f.SYM_P;
          case f.L:
            return f.SYM_L;
          case f.A:
            return f.SYM_A;
        }
        throw new M("Unknown dimension value: " + r);
      } }, { key: "toDimensionValue", value: function(r) {
        switch (xn.toUpperCase(r)) {
          case f.SYM_FALSE:
            return f.FALSE;
          case f.SYM_TRUE:
            return f.TRUE;
          case f.SYM_DONTCARE:
            return f.DONTCARE;
          case f.SYM_P:
            return f.P;
          case f.SYM_L:
            return f.L;
          case f.SYM_A:
            return f.A;
        }
        throw new M("Unknown dimension symbol: " + r);
      } }]), f;
    }();
    J.P = 0, J.L = 1, J.A = 2, J.FALSE = -1, J.TRUE = -2, J.DONTCARE = -3, J.SYM_FALSE = "F", J.SYM_TRUE = "T", J.SYM_DONTCARE = "*", J.SYM_P = "0", J.SYM_L = "1", J.SYM_A = "2";
    var Y = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "filter", value: function(r) {
      } }]), f;
    }(), bt = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "filter", value: function(r, o) {
      } }, { key: "isDone", value: function() {
      } }, { key: "isGeometryChanged", value: function() {
      } }]), f;
    }(), Tt = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "computeEnvelopeInternal", value: function() {
        return this.isEmpty() ? new Ot() : this._points.expandEnvelope(new Ot());
      } }, { key: "isRing", value: function() {
        return this.isClosed() && this.isSimple();
      } }, { key: "getCoordinates", value: function() {
        return this._points.toCoordinateArray();
      } }, { key: "copyInternal", value: function() {
        return new o(this._points.copy(), this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
          var a = arguments[0], l = arguments[1];
          if (!this.isEquivalentClass(a)) return !1;
          var d = a;
          if (this._points.size() !== d._points.size()) return !1;
          for (var v = 0; v < this._points.size(); v++) if (!this.equal(this._points.getCoordinate(v), d._points.getCoordinate(v), l)) return !1;
          return !0;
        }
        return S(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "normalize", value: function() {
        for (var a = 0; a < Math.trunc(this._points.size() / 2); a++) {
          var l = this._points.size() - 1 - a;
          if (!this._points.getCoordinate(a).equals(this._points.getCoordinate(l))) {
            if (this._points.getCoordinate(a).compareTo(this._points.getCoordinate(l)) > 0) {
              var d = this._points.copy();
              Qt.reverse(d), this._points = d;
            }
            return null;
          }
        }
      } }, { key: "getCoordinate", value: function() {
        return this.isEmpty() ? null : this._points.getCoordinate(0);
      } }, { key: "getBoundaryDimension", value: function() {
        return this.isClosed() ? J.FALSE : 0;
      } }, { key: "isClosed", value: function() {
        return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
      } }, { key: "reverseInternal", value: function() {
        var a = this._points.copy();
        return Qt.reverse(a), this.getFactory().createLineString(a);
      } }, { key: "getEndPoint", value: function() {
        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
      } }, { key: "getTypeCode", value: function() {
        return it.TYPECODE_LINESTRING;
      } }, { key: "getDimension", value: function() {
        return 1;
      } }, { key: "getLength", value: function() {
        return kr.ofLine(this._points);
      } }, { key: "getNumPoints", value: function() {
        return this._points.size();
      } }, { key: "compareToSameClass", value: function() {
        if (arguments.length === 1) {
          for (var a = arguments[0], l = a, d = 0, v = 0; d < this._points.size() && v < l._points.size(); ) {
            var x = this._points.getCoordinate(d).compareTo(l._points.getCoordinate(v));
            if (x !== 0) return x;
            d++, v++;
          }
          return d < this._points.size() ? 1 : v < l._points.size() ? -1 : 0;
        }
        if (arguments.length === 2) {
          var w = arguments[0], k = arguments[1], N = w;
          return k.compare(this._points, N._points);
        }
      } }, { key: "apply", value: function() {
        if (ht(arguments[0], Ze)) for (var a = arguments[0], l = 0; l < this._points.size(); l++) a.filter(this._points.getCoordinate(l));
        else if (ht(arguments[0], bt)) {
          var d = arguments[0];
          if (this._points.size() === 0) return null;
          for (var v = 0; v < this._points.size() && (d.filter(this._points, v), !d.isDone()); v++) ;
          d.isGeometryChanged() && this.geometryChanged();
        } else if (ht(arguments[0], Y)) {
          var x = arguments[0];
          x.filter(this);
        } else if (ht(arguments[0], G)) {
          var w = arguments[0];
          w.filter(this);
        }
      } }, { key: "getBoundary", value: function() {
        throw new dt();
      } }, { key: "isEquivalentClass", value: function(a) {
        return a instanceof o;
      } }, { key: "getCoordinateN", value: function(a) {
        return this._points.getCoordinate(a);
      } }, { key: "getGeometryType", value: function() {
        return it.TYPENAME_LINESTRING;
      } }, { key: "getCoordinateSequence", value: function() {
        return this._points;
      } }, { key: "isEmpty", value: function() {
        return this._points.size() === 0;
      } }, { key: "init", value: function(a) {
        if (a === null && (a = this.getFactory().getCoordinateSequenceFactory().create([])), a.size() === 1) throw new M("Invalid number of points in LineString (found " + a.size() + " - must be 0 or >= 2)");
        this._points = a;
      } }, { key: "isCoordinate", value: function(a) {
        for (var l = 0; l < this._points.size(); l++) if (this._points.getCoordinate(l).equals(a)) return !0;
        return !1;
      } }, { key: "getStartPoint", value: function() {
        return this.isEmpty() ? null : this.getPointN(0);
      } }, { key: "getPointN", value: function(a) {
        return this.getFactory().createPoint(this._points.getCoordinate(a));
      } }, { key: "interfaces_", get: function() {
        return [Yi];
      } }], [{ key: "constructor_", value: function() {
        if (this._points = null, arguments.length !== 0) {
          if (arguments.length === 2) {
            var a = arguments[0], l = arguments[1];
            it.constructor_.call(this, l), this.init(a);
          }
        }
      } }]), o;
    }(it), Ut = function f() {
      e(this, f);
    }, yt = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "computeEnvelopeInternal", value: function() {
        if (this.isEmpty()) return new Ot();
        var a = new Ot();
        return a.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), a;
      } }, { key: "getCoordinates", value: function() {
        return this.isEmpty() ? [] : [this.getCoordinate()];
      } }, { key: "copyInternal", value: function() {
        return new o(this._coordinates.copy(), this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
          var a = arguments[0], l = arguments[1];
          return !!this.isEquivalentClass(a) && (!(!this.isEmpty() || !a.isEmpty()) || this.isEmpty() === a.isEmpty() && this.equal(a.getCoordinate(), this.getCoordinate(), l));
        }
        return S(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "normalize", value: function() {
      } }, { key: "getCoordinate", value: function() {
        return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
      } }, { key: "getBoundaryDimension", value: function() {
        return J.FALSE;
      } }, { key: "reverseInternal", value: function() {
        return this.getFactory().createPoint(this._coordinates.copy());
      } }, { key: "getTypeCode", value: function() {
        return it.TYPECODE_POINT;
      } }, { key: "getDimension", value: function() {
        return 0;
      } }, { key: "getNumPoints", value: function() {
        return this.isEmpty() ? 0 : 1;
      } }, { key: "getX", value: function() {
        if (this.getCoordinate() === null) throw new IllegalStateException("getX called on empty Point");
        return this.getCoordinate().x;
      } }, { key: "compareToSameClass", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0], l = a;
          return this.getCoordinate().compareTo(l.getCoordinate());
        }
        if (arguments.length === 2) {
          var d = arguments[0], v = arguments[1], x = d;
          return v.compare(this._coordinates, x._coordinates);
        }
      } }, { key: "apply", value: function() {
        if (ht(arguments[0], Ze)) {
          var a = arguments[0];
          if (this.isEmpty()) return null;
          a.filter(this.getCoordinate());
        } else if (ht(arguments[0], bt)) {
          var l = arguments[0];
          if (this.isEmpty()) return null;
          l.filter(this._coordinates, 0), l.isGeometryChanged() && this.geometryChanged();
        } else if (ht(arguments[0], Y)) {
          var d = arguments[0];
          d.filter(this);
        } else if (ht(arguments[0], G)) {
          var v = arguments[0];
          v.filter(this);
        }
      } }, { key: "getBoundary", value: function() {
        return this.getFactory().createGeometryCollection();
      } }, { key: "getGeometryType", value: function() {
        return it.TYPENAME_POINT;
      } }, { key: "getCoordinateSequence", value: function() {
        return this._coordinates;
      } }, { key: "getY", value: function() {
        if (this.getCoordinate() === null) throw new IllegalStateException("getY called on empty Point");
        return this.getCoordinate().y;
      } }, { key: "isEmpty", value: function() {
        return this._coordinates.size() === 0;
      } }, { key: "init", value: function(a) {
        a === null && (a = this.getFactory().getCoordinateSequenceFactory().create([])), X.isTrue(a.size() <= 1), this._coordinates = a;
      } }, { key: "isSimple", value: function() {
        return !0;
      } }, { key: "interfaces_", get: function() {
        return [Ut];
      } }], [{ key: "constructor_", value: function() {
        this._coordinates = null;
        var a = arguments[0], l = arguments[1];
        it.constructor_.call(this, l), this.init(a);
      } }]), o;
    }(it), kt = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "ofRing", value: function() {
        if (arguments[0] instanceof Array) {
          var r = arguments[0];
          return Math.abs(f.ofRingSigned(r));
        }
        if (ht(arguments[0], It)) {
          var o = arguments[0];
          return Math.abs(f.ofRingSigned(o));
        }
      } }, { key: "ofRingSigned", value: function() {
        if (arguments[0] instanceof Array) {
          var r = arguments[0];
          if (r.length < 3) return 0;
          for (var o = 0, a = r[0].x, l = 1; l < r.length - 1; l++) {
            var d = r[l].x - a, v = r[l + 1].y, x = r[l - 1].y;
            o += d * (x - v);
          }
          return o / 2;
        }
        if (ht(arguments[0], It)) {
          var w = arguments[0], k = w.size();
          if (k < 3) return 0;
          var N = new B(), P = new B(), W = new B();
          w.getCoordinate(0, P), w.getCoordinate(1, W);
          var tt = P.x;
          W.x -= tt;
          for (var $ = 0, ot = 1; ot < k - 1; ot++) N.y = P.y, P.x = W.x, P.y = W.y, w.getCoordinate(ot + 1, W), W.x -= tt, $ += P.x * (N.y - W.y);
          return $ / 2;
        }
      } }]), f;
    }(), Bt = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "sort", value: function() {
        var r = arguments, o = arguments[0];
        if (arguments.length === 1) o.sort(function(tt, $) {
          return tt.compareTo($);
        });
        else if (arguments.length === 2) o.sort(function(tt, $) {
          return r[1].compare(tt, $);
        });
        else if (arguments.length === 3) {
          var a = o.slice(arguments[1], arguments[2]);
          a.sort();
          var l = o.slice(0, arguments[1]).concat(a, o.slice(arguments[2], o.length));
          o.splice(0, o.length);
          var d, v = R(l);
          try {
            for (v.s(); !(d = v.n()).done; ) {
              var x = d.value;
              o.push(x);
            }
          } catch (tt) {
            v.e(tt);
          } finally {
            v.f();
          }
        } else if (arguments.length === 4) {
          var w = o.slice(arguments[1], arguments[2]);
          w.sort(function(tt, $) {
            return r[3].compare(tt, $);
          });
          var k = o.slice(0, arguments[1]).concat(w, o.slice(arguments[2], o.length));
          o.splice(0, o.length);
          var N, P = R(k);
          try {
            for (P.s(); !(N = P.n()).done; ) {
              var W = N.value;
              o.push(W);
            }
          } catch (tt) {
            P.e(tt);
          } finally {
            P.f();
          }
        }
      } }, { key: "asList", value: function(r) {
        var o, a = new ut(), l = R(r);
        try {
          for (l.s(); !(o = l.n()).done; ) {
            var d = o.value;
            a.add(d);
          }
        } catch (v) {
          l.e(v);
        } finally {
          l.f();
        }
        return a;
      } }, { key: "copyOf", value: function(r, o) {
        return r.slice(0, o);
      } }]), f;
    }(), ve = function f() {
      e(this, f);
    }, wn = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "computeEnvelopeInternal", value: function() {
        return this._shell.getEnvelopeInternal();
      } }, { key: "getCoordinates", value: function() {
        if (this.isEmpty()) return [];
        for (var a = new Array(this.getNumPoints()).fill(null), l = -1, d = this._shell.getCoordinates(), v = 0; v < d.length; v++) a[++l] = d[v];
        for (var x = 0; x < this._holes.length; x++) for (var w = this._holes[x].getCoordinates(), k = 0; k < w.length; k++) a[++l] = w[k];
        return a;
      } }, { key: "getArea", value: function() {
        var a = 0;
        a += kt.ofRing(this._shell.getCoordinateSequence());
        for (var l = 0; l < this._holes.length; l++) a -= kt.ofRing(this._holes[l].getCoordinateSequence());
        return a;
      } }, { key: "copyInternal", value: function() {
        for (var a = this._shell.copy(), l = new Array(this._holes.length).fill(null), d = 0; d < this._holes.length; d++) l[d] = this._holes[d].copy();
        return new o(a, l, this._factory);
      } }, { key: "isRectangle", value: function() {
        if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5) return !1;
        for (var a = this._shell.getCoordinateSequence(), l = this.getEnvelopeInternal(), d = 0; d < 5; d++) {
          var v = a.getX(d);
          if (v !== l.getMinX() && v !== l.getMaxX()) return !1;
          var x = a.getY(d);
          if (x !== l.getMinY() && x !== l.getMaxY()) return !1;
        }
        for (var w = a.getX(0), k = a.getY(0), N = 1; N <= 4; N++) {
          var P = a.getX(N), W = a.getY(N);
          if (P !== w == (W !== k)) return !1;
          w = P, k = W;
        }
        return !0;
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
          var a = arguments[0], l = arguments[1];
          if (!this.isEquivalentClass(a)) return !1;
          var d = a, v = this._shell, x = d._shell;
          if (!v.equalsExact(x, l) || this._holes.length !== d._holes.length) return !1;
          for (var w = 0; w < this._holes.length; w++) if (!this._holes[w].equalsExact(d._holes[w], l)) return !1;
          return !0;
        }
        return S(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "normalize", value: function() {
        if (arguments.length === 0) {
          this._shell = this.normalized(this._shell, !0);
          for (var a = 0; a < this._holes.length; a++) this._holes[a] = this.normalized(this._holes[a], !1);
          Bt.sort(this._holes);
        } else if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          if (l.isEmpty()) return null;
          var v = l.getCoordinateSequence(), x = Qt.minCoordinateIndex(v, 0, v.size() - 2);
          Qt.scroll(v, x, !0), ct.isCCW(v) === d && Qt.reverse(v);
        }
      } }, { key: "getCoordinate", value: function() {
        return this._shell.getCoordinate();
      } }, { key: "getNumInteriorRing", value: function() {
        return this._holes.length;
      } }, { key: "getBoundaryDimension", value: function() {
        return 1;
      } }, { key: "reverseInternal", value: function() {
        for (var a = this.getExteriorRing().reverse(), l = new Array(this.getNumInteriorRing()).fill(null), d = 0; d < l.length; d++) l[d] = this.getInteriorRingN(d).reverse();
        return this.getFactory().createPolygon(a, l);
      } }, { key: "getTypeCode", value: function() {
        return it.TYPECODE_POLYGON;
      } }, { key: "getDimension", value: function() {
        return 2;
      } }, { key: "getLength", value: function() {
        var a = 0;
        a += this._shell.getLength();
        for (var l = 0; l < this._holes.length; l++) a += this._holes[l].getLength();
        return a;
      } }, { key: "getNumPoints", value: function() {
        for (var a = this._shell.getNumPoints(), l = 0; l < this._holes.length; l++) a += this._holes[l].getNumPoints();
        return a;
      } }, { key: "convexHull", value: function() {
        return this.getExteriorRing().convexHull();
      } }, { key: "normalized", value: function(a, l) {
        var d = a.copy();
        return this.normalize(d, l), d;
      } }, { key: "compareToSameClass", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0], l = this._shell, d = a._shell;
          return l.compareToSameClass(d);
        }
        if (arguments.length === 2) {
          var v = arguments[0], x = arguments[1], w = v, k = this._shell, N = w._shell, P = k.compareToSameClass(N, x);
          if (P !== 0) return P;
          for (var W = this.getNumInteriorRing(), tt = w.getNumInteriorRing(), $ = 0; $ < W && $ < tt; ) {
            var ot = this.getInteriorRingN($), ft = w.getInteriorRingN($), pt = ot.compareToSameClass(ft, x);
            if (pt !== 0) return pt;
            $++;
          }
          return $ < W ? 1 : $ < tt ? -1 : 0;
        }
      } }, { key: "apply", value: function() {
        if (ht(arguments[0], Ze)) {
          var a = arguments[0];
          this._shell.apply(a);
          for (var l = 0; l < this._holes.length; l++) this._holes[l].apply(a);
        } else if (ht(arguments[0], bt)) {
          var d = arguments[0];
          if (this._shell.apply(d), !d.isDone()) for (var v = 0; v < this._holes.length && (this._holes[v].apply(d), !d.isDone()); v++) ;
          d.isGeometryChanged() && this.geometryChanged();
        } else if (ht(arguments[0], Y)) {
          var x = arguments[0];
          x.filter(this);
        } else if (ht(arguments[0], G)) {
          var w = arguments[0];
          w.filter(this), this._shell.apply(w);
          for (var k = 0; k < this._holes.length; k++) this._holes[k].apply(w);
        }
      } }, { key: "getBoundary", value: function() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        var a = new Array(this._holes.length + 1).fill(null);
        a[0] = this._shell;
        for (var l = 0; l < this._holes.length; l++) a[l + 1] = this._holes[l];
        return a.length <= 1 ? this.getFactory().createLinearRing(a[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(a);
      } }, { key: "getGeometryType", value: function() {
        return it.TYPENAME_POLYGON;
      } }, { key: "getExteriorRing", value: function() {
        return this._shell;
      } }, { key: "isEmpty", value: function() {
        return this._shell.isEmpty();
      } }, { key: "getInteriorRingN", value: function(a) {
        return this._holes[a];
      } }, { key: "interfaces_", get: function() {
        return [ve];
      } }], [{ key: "constructor_", value: function() {
        this._shell = null, this._holes = null;
        var a = arguments[0], l = arguments[1], d = arguments[2];
        if (it.constructor_.call(this, d), a === null && (a = this.getFactory().createLinearRing()), l === null && (l = []), it.hasNullElements(l)) throw new M("holes must not contain null elements");
        if (a.isEmpty() && it.hasNonEmptyElements(l)) throw new M("shell is empty but holes are not");
        this._shell = a, this._holes = l;
      } }]), o;
    }(it), br = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        return e(this, o), r.apply(this, arguments);
      }
      return o;
    }(an), Wh = function(f) {
      u(o, f);
      var r = E(o);
      function o(a) {
        var l;
        return e(this, o), (l = r.call(this)).array = [], a instanceof mt && l.addAll(a), l;
      }
      return s(o, [{ key: "contains", value: function(a) {
        var l, d = R(this.array);
        try {
          for (d.s(); !(l = d.n()).done; )
            if (l.value.compareTo(a) === 0) return !0;
        } catch (v) {
          d.e(v);
        } finally {
          d.f();
        }
        return !1;
      } }, { key: "add", value: function(a) {
        if (this.contains(a)) return !1;
        for (var l = 0, d = this.array.length; l < d; l++)
          if (this.array[l].compareTo(a) === 1) return !!this.array.splice(l, 0, a);
        return this.array.push(a), !0;
      } }, { key: "addAll", value: function(a) {
        var l, d = R(a);
        try {
          for (d.s(); !(l = d.n()).done; ) {
            var v = l.value;
            this.add(v);
          }
        } catch (x) {
          d.e(x);
        } finally {
          d.f();
        }
        return !0;
      } }, { key: "remove", value: function() {
        throw new dt();
      } }, { key: "size", value: function() {
        return this.array.length;
      } }, { key: "isEmpty", value: function() {
        return this.array.length === 0;
      } }, { key: "toArray", value: function() {
        return this.array.slice();
      } }, { key: "iterator", value: function() {
        return new fp(this.array);
      } }]), o;
    }(br), fp = function() {
      function f(r) {
        e(this, f), this.array = r, this.position = 0;
      }
      return s(f, [{ key: "next", value: function() {
        if (this.position === this.array.length) throw new Xt();
        return this.array[this.position++];
      } }, { key: "hasNext", value: function() {
        return this.position < this.array.length;
      } }, { key: "remove", value: function() {
        throw new dt();
      } }]), f;
    }(), Fe = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "computeEnvelopeInternal", value: function() {
        for (var a = new Ot(), l = 0; l < this._geometries.length; l++) a.expandToInclude(this._geometries[l].getEnvelopeInternal());
        return a;
      } }, { key: "getGeometryN", value: function(a) {
        return this._geometries[a];
      } }, { key: "getCoordinates", value: function() {
        for (var a = new Array(this.getNumPoints()).fill(null), l = -1, d = 0; d < this._geometries.length; d++) for (var v = this._geometries[d].getCoordinates(), x = 0; x < v.length; x++) a[++l] = v[x];
        return a;
      } }, { key: "getArea", value: function() {
        for (var a = 0, l = 0; l < this._geometries.length; l++) a += this._geometries[l].getArea();
        return a;
      } }, { key: "copyInternal", value: function() {
        for (var a = new Array(this._geometries.length).fill(null), l = 0; l < a.length; l++) a[l] = this._geometries[l].copy();
        return new o(a, this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
          var a = arguments[0], l = arguments[1];
          if (!this.isEquivalentClass(a)) return !1;
          var d = a;
          if (this._geometries.length !== d._geometries.length) return !1;
          for (var v = 0; v < this._geometries.length; v++) if (!this._geometries[v].equalsExact(d._geometries[v], l)) return !1;
          return !0;
        }
        return S(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "normalize", value: function() {
        for (var a = 0; a < this._geometries.length; a++) this._geometries[a].normalize();
        Bt.sort(this._geometries);
      } }, { key: "getCoordinate", value: function() {
        return this.isEmpty() ? null : this._geometries[0].getCoordinate();
      } }, { key: "getBoundaryDimension", value: function() {
        for (var a = J.FALSE, l = 0; l < this._geometries.length; l++) a = Math.max(a, this._geometries[l].getBoundaryDimension());
        return a;
      } }, { key: "reverseInternal", value: function() {
        for (var a = this._geometries.length, l = new ut(a), d = 0; d < a; d++) l.add(this._geometries[d].reverse());
        return this.getFactory().buildGeometry(l);
      } }, { key: "getTypeCode", value: function() {
        return it.TYPECODE_GEOMETRYCOLLECTION;
      } }, { key: "getDimension", value: function() {
        for (var a = J.FALSE, l = 0; l < this._geometries.length; l++) a = Math.max(a, this._geometries[l].getDimension());
        return a;
      } }, { key: "getLength", value: function() {
        for (var a = 0, l = 0; l < this._geometries.length; l++) a += this._geometries[l].getLength();
        return a;
      } }, { key: "getNumPoints", value: function() {
        for (var a = 0, l = 0; l < this._geometries.length; l++) a += this._geometries[l].getNumPoints();
        return a;
      } }, { key: "getNumGeometries", value: function() {
        return this._geometries.length;
      } }, { key: "compareToSameClass", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0], l = new Wh(Bt.asList(this._geometries)), d = new Wh(Bt.asList(a._geometries));
          return this.compare(l, d);
        }
        if (arguments.length === 2) {
          for (var v = arguments[0], x = arguments[1], w = v, k = this.getNumGeometries(), N = w.getNumGeometries(), P = 0; P < k && P < N; ) {
            var W = this.getGeometryN(P), tt = w.getGeometryN(P), $ = W.compareToSameClass(tt, x);
            if ($ !== 0) return $;
            P++;
          }
          return P < k ? 1 : P < N ? -1 : 0;
        }
      } }, { key: "apply", value: function() {
        if (ht(arguments[0], Ze)) for (var a = arguments[0], l = 0; l < this._geometries.length; l++) this._geometries[l].apply(a);
        else if (ht(arguments[0], bt)) {
          var d = arguments[0];
          if (this._geometries.length === 0) return null;
          for (var v = 0; v < this._geometries.length && (this._geometries[v].apply(d), !d.isDone()); v++) ;
          d.isGeometryChanged() && this.geometryChanged();
        } else if (ht(arguments[0], Y)) {
          var x = arguments[0];
          x.filter(this);
          for (var w = 0; w < this._geometries.length; w++) this._geometries[w].apply(x);
        } else if (ht(arguments[0], G)) {
          var k = arguments[0];
          k.filter(this);
          for (var N = 0; N < this._geometries.length; N++) this._geometries[N].apply(k);
        }
      } }, { key: "getBoundary", value: function() {
        return it.checkNotGeometryCollection(this), X.shouldNeverReachHere(), null;
      } }, { key: "getGeometryType", value: function() {
        return it.TYPENAME_GEOMETRYCOLLECTION;
      } }, { key: "isEmpty", value: function() {
        for (var a = 0; a < this._geometries.length; a++) if (!this._geometries[a].isEmpty()) return !1;
        return !0;
      } }], [{ key: "constructor_", value: function() {
        if (this._geometries = null, arguments.length !== 0) {
          if (arguments.length === 2) {
            var a = arguments[0], l = arguments[1];
            if (it.constructor_.call(this, l), a === null && (a = []), it.hasNullElements(a)) throw new M("geometries must not contain null elements");
            this._geometries = a;
          }
        }
      } }]), o;
    }(it), iu = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "copyInternal", value: function() {
        for (var a = new Array(this._geometries.length).fill(null), l = 0; l < a.length; l++) a[l] = this._geometries[l].copy();
        return new o(a, this._factory);
      } }, { key: "isValid", value: function() {
        return !0;
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
          var a = arguments[0], l = arguments[1];
          return !!this.isEquivalentClass(a) && S(h(o.prototype), "equalsExact", this).call(this, a, l);
        }
        return S(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "getCoordinate", value: function() {
        if (arguments.length === 1 && Number.isInteger(arguments[0])) {
          var a = arguments[0];
          return this._geometries[a].getCoordinate();
        }
        return S(h(o.prototype), "getCoordinate", this).apply(this, arguments);
      } }, { key: "getBoundaryDimension", value: function() {
        return J.FALSE;
      } }, { key: "getTypeCode", value: function() {
        return it.TYPECODE_MULTIPOINT;
      } }, { key: "getDimension", value: function() {
        return 0;
      } }, { key: "getBoundary", value: function() {
        return this.getFactory().createGeometryCollection();
      } }, { key: "getGeometryType", value: function() {
        return it.TYPENAME_MULTIPOINT;
      } }, { key: "interfaces_", get: function() {
        return [Ut];
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        Fe.constructor_.call(this, a, l);
      } }]), o;
    }(Fe), Es = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "copyInternal", value: function() {
        return new o(this._points.copy(), this._factory);
      } }, { key: "getBoundaryDimension", value: function() {
        return J.FALSE;
      } }, { key: "isClosed", value: function() {
        return !!this.isEmpty() || S(h(o.prototype), "isClosed", this).call(this);
      } }, { key: "reverseInternal", value: function() {
        var a = this._points.copy();
        return Qt.reverse(a), this.getFactory().createLinearRing(a);
      } }, { key: "getTypeCode", value: function() {
        return it.TYPECODE_LINEARRING;
      } }, { key: "validateConstruction", value: function() {
        if (!this.isEmpty() && !S(h(o.prototype), "isClosed", this).call(this)) throw new M("Points of LinearRing do not form a closed linestring");
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < o.MINIMUM_VALID_SIZE) throw new M("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
      } }, { key: "getGeometryType", value: function() {
        return it.TYPENAME_LINEARRING;
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        Tt.constructor_.call(this, a, l), this.validateConstruction();
      } }]), o;
    }(Tt);
    Es.MINIMUM_VALID_SIZE = 4;
    var Wi = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "setOrdinate", value: function(a, l) {
        switch (a) {
          case o.X:
            this.x = l;
            break;
          case o.Y:
            this.y = l;
            break;
          default:
            throw new M("Invalid ordinate index: " + a);
        }
      } }, { key: "getZ", value: function() {
        return B.NULL_ORDINATE;
      } }, { key: "getOrdinate", value: function(a) {
        switch (a) {
          case o.X:
            return this.x;
          case o.Y:
            return this.y;
        }
        throw new M("Invalid ordinate index: " + a);
      } }, { key: "setZ", value: function(a) {
        throw new M("CoordinateXY dimension 2 does not support z-ordinate");
      } }, { key: "copy", value: function() {
        return new o(this);
      } }, { key: "toString", value: function() {
        return "(" + this.x + ", " + this.y + ")";
      } }, { key: "setCoordinate", value: function(a) {
        this.x = a.x, this.y = a.y, this.z = a.getZ();
      } }], [{ key: "constructor_", value: function() {
        if (arguments.length === 0) B.constructor_.call(this);
        else if (arguments.length === 1) {
          if (arguments[0] instanceof o) {
            var a = arguments[0];
            B.constructor_.call(this, a.x, a.y);
          } else if (arguments[0] instanceof B) {
            var l = arguments[0];
            B.constructor_.call(this, l.x, l.y);
          }
        } else if (arguments.length === 2) {
          var d = arguments[0], v = arguments[1];
          B.constructor_.call(this, d, v, B.NULL_ORDINATE);
        }
      } }]), o;
    }(B);
    Wi.X = 0, Wi.Y = 1, Wi.Z = -1, Wi.M = -1;
    var Xi = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "getM", value: function() {
        return this._m;
      } }, { key: "setOrdinate", value: function(a, l) {
        switch (a) {
          case o.X:
            this.x = l;
            break;
          case o.Y:
            this.y = l;
            break;
          case o.M:
            this._m = l;
            break;
          default:
            throw new M("Invalid ordinate index: " + a);
        }
      } }, { key: "setM", value: function(a) {
        this._m = a;
      } }, { key: "getZ", value: function() {
        return B.NULL_ORDINATE;
      } }, { key: "getOrdinate", value: function(a) {
        switch (a) {
          case o.X:
            return this.x;
          case o.Y:
            return this.y;
          case o.M:
            return this._m;
        }
        throw new M("Invalid ordinate index: " + a);
      } }, { key: "setZ", value: function(a) {
        throw new M("CoordinateXY dimension 2 does not support z-ordinate");
      } }, { key: "copy", value: function() {
        return new o(this);
      } }, { key: "toString", value: function() {
        return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
      } }, { key: "setCoordinate", value: function(a) {
        this.x = a.x, this.y = a.y, this.z = a.getZ(), this._m = a.getM();
      } }], [{ key: "constructor_", value: function() {
        if (this._m = null, arguments.length === 0) B.constructor_.call(this), this._m = 0;
        else if (arguments.length === 1) {
          if (arguments[0] instanceof o) {
            var a = arguments[0];
            B.constructor_.call(this, a.x, a.y), this._m = a._m;
          } else if (arguments[0] instanceof B) {
            var l = arguments[0];
            B.constructor_.call(this, l.x, l.y), this._m = this.getM();
          }
        } else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], x = arguments[2];
          B.constructor_.call(this, d, v, B.NULL_ORDINATE), this._m = x;
        }
      } }]), o;
    }(B);
    Xi.X = 0, Xi.Y = 1, Xi.Z = -1, Xi.M = 2;
    var ru = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "getM", value: function() {
        return this._m;
      } }, { key: "setOrdinate", value: function(a, l) {
        switch (a) {
          case B.X:
            this.x = l;
            break;
          case B.Y:
            this.y = l;
            break;
          case B.Z:
            this.z = l;
            break;
          case B.M:
            this._m = l;
            break;
          default:
            throw new M("Invalid ordinate index: " + a);
        }
      } }, { key: "setM", value: function(a) {
        this._m = a;
      } }, { key: "getOrdinate", value: function(a) {
        switch (a) {
          case B.X:
            return this.x;
          case B.Y:
            return this.y;
          case B.Z:
            return this.getZ();
          case B.M:
            return this.getM();
        }
        throw new M("Invalid ordinate index: " + a);
      } }, { key: "copy", value: function() {
        return new o(this);
      } }, { key: "toString", value: function() {
        return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
      } }, { key: "setCoordinate", value: function(a) {
        this.x = a.x, this.y = a.y, this.z = a.getZ(), this._m = a.getM();
      } }], [{ key: "constructor_", value: function() {
        if (this._m = null, arguments.length === 0) B.constructor_.call(this), this._m = 0;
        else if (arguments.length === 1) {
          if (arguments[0] instanceof o) {
            var a = arguments[0];
            B.constructor_.call(this, a), this._m = a._m;
          } else if (arguments[0] instanceof B) {
            var l = arguments[0];
            B.constructor_.call(this, l), this._m = this.getM();
          }
        } else if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], x = arguments[2], w = arguments[3];
          B.constructor_.call(this, d, v, x), this._m = w;
        }
      } }]), o;
    }(B), bo = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "measures", value: function(r) {
        return r instanceof Wi ? 0 : r instanceof Xi || r instanceof ru ? 1 : 0;
      } }, { key: "dimension", value: function(r) {
        return r instanceof Wi ? 2 : r instanceof Xi ? 3 : r instanceof ru ? 4 : 3;
      } }, { key: "create", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          return f.create(r, 0);
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          return o === 2 ? new Wi() : o === 3 && a === 0 ? new B() : o === 3 && a === 1 ? new Xi() : o === 4 && a === 1 ? new ru() : new B();
        }
      } }]), f;
    }(), xs = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "getCoordinate", value: function(a) {
        return this.get(a);
      } }, { key: "addAll", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "boolean" && ht(arguments[0], mt)) {
          for (var a = arguments[0], l = arguments[1], d = !1, v = a.iterator(); v.hasNext(); ) this.add(v.next(), l), d = !0;
          return d;
        }
        return S(h(o.prototype), "addAll", this).apply(this, arguments);
      } }, { key: "clone", value: function() {
        for (var a = S(h(o.prototype), "clone", this).call(this), l = 0; l < this.size(); l++) a.add(l, this.get(l).clone());
        return a;
      } }, { key: "toCoordinateArray", value: function() {
        if (arguments.length === 0) return this.toArray(o.coordArrayType);
        if (arguments.length === 1) {
          var a = arguments[0];
          if (a) return this.toArray(o.coordArrayType);
          for (var l = this.size(), d = new Array(l).fill(null), v = 0; v < l; v++) d[v] = this.get(l - v - 1);
          return d;
        }
      } }, { key: "add", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0];
          return S(h(o.prototype), "add", this).call(this, a);
        }
        if (arguments.length === 2) {
          if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
            var l = arguments[0], d = arguments[1];
            return this.add(l, d, !0), !0;
          }
          if (arguments[0] instanceof B && typeof arguments[1] == "boolean") {
            var v = arguments[0], x = arguments[1];
            if (!x && this.size() >= 1) {
              var w = this.get(this.size() - 1);
              if (w.equals2D(v)) return null;
            }
            S(h(o.prototype), "add", this).call(this, v);
          } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
            var k = arguments[0], N = arguments[1];
            return this.add(k, N), !0;
          }
        } else if (arguments.length === 3) {
          if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
            var P = arguments[0], W = arguments[1], tt = arguments[2];
            if (tt) for (var $ = 0; $ < P.length; $++) this.add(P[$], W);
            else for (var ot = P.length - 1; ot >= 0; ot--) this.add(P[ot], W);
            return !0;
          }
          if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof B) {
            var ft = arguments[0], pt = arguments[1], Pt = arguments[2];
            if (!Pt) {
              var Zt = this.size();
              if (Zt > 0) {
                if (ft > 0) {
                  var _e = this.get(ft - 1);
                  if (_e.equals2D(pt)) return null;
                }
                if (ft < Zt) {
                  var ze = this.get(ft);
                  if (ze.equals2D(pt)) return null;
                }
              }
            }
            S(h(o.prototype), "add", this).call(this, ft, pt);
          }
        } else if (arguments.length === 4) {
          var cn = arguments[0], Xn = arguments[1], ji = arguments[2], bs = arguments[3], Cs = 1;
          ji > bs && (Cs = -1);
          for (var Ar = ji; Ar !== bs; Ar += Cs) this.add(cn[Ar], Xn);
          return !0;
        }
      } }, { key: "closeRing", value: function() {
        if (this.size() > 0) {
          var a = this.get(0).copy();
          this.add(a, !1);
        }
      } }], [{ key: "constructor_", value: function() {
        if (arguments.length !== 0) {
          if (arguments.length === 1) {
            var a = arguments[0];
            this.ensureCapacity(a.length), this.add(a, !0);
          } else if (arguments.length === 2) {
            var l = arguments[0], d = arguments[1];
            this.ensureCapacity(l.length), this.add(l, d);
          }
        }
      } }]), o;
    }(ut);
    xs.coordArrayType = new Array(0).fill(null);
    var ne = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "isRing", value: function(r) {
        return !(r.length < 4) && !!r[0].equals2D(r[r.length - 1]);
      } }, { key: "ptNotInList", value: function(r, o) {
        for (var a = 0; a < r.length; a++) {
          var l = r[a];
          if (f.indexOf(l, o) < 0) return l;
        }
        return null;
      } }, { key: "scroll", value: function(r, o) {
        var a = f.indexOf(o, r);
        if (a < 0) return null;
        var l = new Array(r.length).fill(null);
        ge.arraycopy(r, a, l, 0, r.length - a), ge.arraycopy(r, 0, l, r.length - a, a), ge.arraycopy(l, 0, r, 0, r.length);
      } }, { key: "equals", value: function() {
        if (arguments.length === 2) {
          var r = arguments[0], o = arguments[1];
          if (r === o) return !0;
          if (r === null || o === null || r.length !== o.length) return !1;
          for (var a = 0; a < r.length; a++) if (!r[a].equals(o[a])) return !1;
          return !0;
        }
        if (arguments.length === 3) {
          var l = arguments[0], d = arguments[1], v = arguments[2];
          if (l === d) return !0;
          if (l === null || d === null || l.length !== d.length) return !1;
          for (var x = 0; x < l.length; x++) if (v.compare(l[x], d[x]) !== 0) return !1;
          return !0;
        }
      } }, { key: "intersection", value: function(r, o) {
        for (var a = new xs(), l = 0; l < r.length; l++) o.intersects(r[l]) && a.add(r[l], !0);
        return a.toCoordinateArray();
      } }, { key: "measures", value: function(r) {
        if (r === null || r.length === 0) return 0;
        var o, a = 0, l = R(r);
        try {
          for (l.s(); !(o = l.n()).done; ) {
            var d = o.value;
            a = Math.max(a, bo.measures(d));
          }
        } catch (v) {
          l.e(v);
        } finally {
          l.f();
        }
        return a;
      } }, { key: "hasRepeatedPoints", value: function(r) {
        for (var o = 1; o < r.length; o++) if (r[o - 1].equals(r[o])) return !0;
        return !1;
      } }, { key: "removeRepeatedPoints", value: function(r) {
        return f.hasRepeatedPoints(r) ? new xs(r, !1).toCoordinateArray() : r;
      } }, { key: "reverse", value: function(r) {
        for (var o = r.length - 1, a = Math.trunc(o / 2), l = 0; l <= a; l++) {
          var d = r[l];
          r[l] = r[o - l], r[o - l] = d;
        }
      } }, { key: "removeNull", value: function(r) {
        for (var o = 0, a = 0; a < r.length; a++) r[a] !== null && o++;
        var l = new Array(o).fill(null);
        if (o === 0) return l;
        for (var d = 0, v = 0; v < r.length; v++) r[v] !== null && (l[d++] = r[v]);
        return l;
      } }, { key: "copyDeep", value: function() {
        if (arguments.length === 1) {
          for (var r = arguments[0], o = new Array(r.length).fill(null), a = 0; a < r.length; a++) o[a] = r[a].copy();
          return o;
        }
        if (arguments.length === 5) for (var l = arguments[0], d = arguments[1], v = arguments[2], x = arguments[3], w = arguments[4], k = 0; k < w; k++) v[x + k] = l[d + k].copy();
      } }, { key: "isEqualReversed", value: function(r, o) {
        for (var a = 0; a < r.length; a++) {
          var l = r[a], d = o[r.length - a - 1];
          if (l.compareTo(d) !== 0) return !1;
        }
        return !0;
      } }, { key: "envelope", value: function(r) {
        for (var o = new Ot(), a = 0; a < r.length; a++) o.expandToInclude(r[a]);
        return o;
      } }, { key: "toCoordinateArray", value: function(r) {
        return r.toArray(f.coordArrayType);
      } }, { key: "dimension", value: function(r) {
        if (r === null || r.length === 0) return 3;
        var o, a = 0, l = R(r);
        try {
          for (l.s(); !(o = l.n()).done; ) {
            var d = o.value;
            a = Math.max(a, bo.dimension(d));
          }
        } catch (v) {
          l.e(v);
        } finally {
          l.f();
        }
        return a;
      } }, { key: "atLeastNCoordinatesOrNothing", value: function(r, o) {
        return o.length >= r ? o : [];
      } }, { key: "indexOf", value: function(r, o) {
        for (var a = 0; a < o.length; a++) if (r.equals(o[a])) return a;
        return -1;
      } }, { key: "increasingDirection", value: function(r) {
        for (var o = 0; o < Math.trunc(r.length / 2); o++) {
          var a = r.length - 1 - o, l = r[o].compareTo(r[a]);
          if (l !== 0) return l;
        }
        return 1;
      } }, { key: "compare", value: function(r, o) {
        for (var a = 0; a < r.length && a < o.length; ) {
          var l = r[a].compareTo(o[a]);
          if (l !== 0) return l;
          a++;
        }
        return a < o.length ? -1 : a < r.length ? 1 : 0;
      } }, { key: "minCoordinate", value: function(r) {
        for (var o = null, a = 0; a < r.length; a++) (o === null || o.compareTo(r[a]) > 0) && (o = r[a]);
        return o;
      } }, { key: "extract", value: function(r, o, a) {
        o = un.clamp(o, 0, r.length);
        var l = (a = un.clamp(a, -1, r.length)) - o + 1;
        a < 0 && (l = 0), o >= r.length && (l = 0), a < o && (l = 0);
        var d = new Array(l).fill(null);
        if (l === 0) return d;
        for (var v = 0, x = o; x <= a; x++) d[v++] = r[x];
        return d;
      } }]), f;
    }(), gp = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "compare", value: function(r, o) {
        var a = r, l = o;
        return ne.compare(a, l);
      } }, { key: "interfaces_", get: function() {
        return [_t];
      } }]), f;
    }(), dp = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "compare", value: function(r, o) {
        var a = r, l = o;
        if (a.length < l.length) return -1;
        if (a.length > l.length) return 1;
        if (a.length === 0) return 0;
        var d = ne.compare(a, l);
        return ne.isEqualReversed(a, l) ? 0 : d;
      } }, { key: "OLDcompare", value: function(r, o) {
        var a = r, l = o;
        if (a.length < l.length) return -1;
        if (a.length > l.length) return 1;
        if (a.length === 0) return 0;
        for (var d = ne.increasingDirection(a), v = ne.increasingDirection(l), x = d > 0 ? 0 : a.length - 1, w = v > 0 ? 0 : a.length - 1, k = 0; k < a.length; k++) {
          var N = a[x].compareTo(l[w]);
          if (N !== 0) return N;
          x += d, w += v;
        }
        return 0;
      } }, { key: "interfaces_", get: function() {
        return [_t];
      } }]), f;
    }();
    ne.ForwardComparator = gp, ne.BidirectionalComparator = dp, ne.coordArrayType = new Array(0).fill(null);
    var Co = function() {
      function f(r) {
        e(this, f), this.str = r;
      }
      return s(f, [{ key: "append", value: function(r) {
        this.str += r;
      } }, { key: "setCharAt", value: function(r, o) {
        this.str = this.str.substr(0, r) + o + this.str.substr(r + 1);
      } }, { key: "toString", value: function() {
        return this.str;
      } }]), f;
    }(), Ss = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getM", value: function(r) {
        return this.hasM() ? this._coordinates[r].getM() : Q.NaN;
      } }, { key: "setOrdinate", value: function(r, o, a) {
        switch (o) {
          case It.X:
            this._coordinates[r].x = a;
            break;
          case It.Y:
            this._coordinates[r].y = a;
            break;
          default:
            this._coordinates[r].setOrdinate(o, a);
        }
      } }, { key: "getZ", value: function(r) {
        return this.hasZ() ? this._coordinates[r].getZ() : Q.NaN;
      } }, { key: "size", value: function() {
        return this._coordinates.length;
      } }, { key: "getOrdinate", value: function(r, o) {
        switch (o) {
          case It.X:
            return this._coordinates[r].x;
          case It.Y:
            return this._coordinates[r].y;
          default:
            return this._coordinates[r].getOrdinate(o);
        }
      } }, { key: "getCoordinate", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          return this._coordinates[r];
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          a.setCoordinate(this._coordinates[o]);
        }
      } }, { key: "getCoordinateCopy", value: function(r) {
        var o = this.createCoordinate();
        return o.setCoordinate(this._coordinates[r]), o;
      } }, { key: "createCoordinate", value: function() {
        return bo.create(this.getDimension(), this.getMeasures());
      } }, { key: "getDimension", value: function() {
        return this._dimension;
      } }, { key: "getX", value: function(r) {
        return this._coordinates[r].x;
      } }, { key: "getMeasures", value: function() {
        return this._measures;
      } }, { key: "expandEnvelope", value: function(r) {
        for (var o = 0; o < this._coordinates.length; o++) r.expandToInclude(this._coordinates[o]);
        return r;
      } }, { key: "copy", value: function() {
        for (var r = new Array(this.size()).fill(null), o = 0; o < this._coordinates.length; o++) {
          var a = this.createCoordinate();
          a.setCoordinate(this._coordinates[o]), r[o] = a;
        }
        return new f(r, this._dimension, this._measures);
      } }, { key: "toString", value: function() {
        if (this._coordinates.length > 0) {
          var r = new Co(17 * this._coordinates.length);
          r.append("("), r.append(this._coordinates[0]);
          for (var o = 1; o < this._coordinates.length; o++) r.append(", "), r.append(this._coordinates[o]);
          return r.append(")"), r.toString();
        }
        return "()";
      } }, { key: "getY", value: function(r) {
        return this._coordinates[r].y;
      } }, { key: "toCoordinateArray", value: function() {
        return this._coordinates;
      } }, { key: "interfaces_", get: function() {
        return [It, A];
      } }], [{ key: "constructor_", value: function() {
        if (this._dimension = 3, this._measures = 0, this._coordinates = null, arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var r = arguments[0];
            f.constructor_.call(this, r, ne.dimension(r), ne.measures(r));
          } else if (Number.isInteger(arguments[0])) {
            var o = arguments[0];
            this._coordinates = new Array(o).fill(null);
            for (var a = 0; a < o; a++) this._coordinates[a] = new B();
          } else if (ht(arguments[0], It)) {
            var l = arguments[0];
            if (l === null) return this._coordinates = new Array(0).fill(null), null;
            this._dimension = l.getDimension(), this._measures = l.getMeasures(), this._coordinates = new Array(l.size()).fill(null);
            for (var d = 0; d < this._coordinates.length; d++) this._coordinates[d] = l.getCoordinateCopy(d);
          }
        } else if (arguments.length === 2) {
          if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
            var v = arguments[0], x = arguments[1];
            f.constructor_.call(this, v, x, ne.measures(v));
          } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var w = arguments[0], k = arguments[1];
            this._coordinates = new Array(w).fill(null), this._dimension = k;
            for (var N = 0; N < w; N++) this._coordinates[N] = bo.create(k);
          }
        } else if (arguments.length === 3) {
          if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
            var P = arguments[0], W = arguments[1], tt = arguments[2];
            this._dimension = W, this._measures = tt, this._coordinates = P === null ? new Array(0).fill(null) : P;
          } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var $ = arguments[0], ot = arguments[1], ft = arguments[2];
            this._coordinates = new Array($).fill(null), this._dimension = ot, this._measures = ft;
            for (var pt = 0; pt < $; pt++) this._coordinates[pt] = this.createCoordinate();
          }
        }
      } }]), f;
    }(), su = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "readResolve", value: function() {
        return f.instance();
      } }, { key: "create", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var r = arguments[0];
            return new Ss(r);
          }
          if (ht(arguments[0], It)) {
            var o = arguments[0];
            return new Ss(o);
          }
        } else {
          if (arguments.length === 2) {
            var a = arguments[0], l = arguments[1];
            return l > 3 && (l = 3), l < 2 && (l = 2), new Ss(a, l);
          }
          if (arguments.length === 3) {
            var d = arguments[0], v = arguments[1], x = arguments[2], w = v - x;
            return x > 1 && (x = 1), w > 3 && (w = 3), w < 2 && (w = 2), new Ss(d, w + x, x);
          }
        }
      } }, { key: "interfaces_", get: function() {
        return [Sn, A];
      } }], [{ key: "instance", value: function() {
        return f.instanceObject;
      } }]), f;
    }();
    su.instanceObject = new su();
    var ou = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "copyInternal", value: function() {
        for (var a = new Array(this._geometries.length).fill(null), l = 0; l < a.length; l++) a[l] = this._geometries[l].copy();
        return new o(a, this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
          var a = arguments[0], l = arguments[1];
          return !!this.isEquivalentClass(a) && S(h(o.prototype), "equalsExact", this).call(this, a, l);
        }
        return S(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "getBoundaryDimension", value: function() {
        return 1;
      } }, { key: "getTypeCode", value: function() {
        return it.TYPECODE_MULTIPOLYGON;
      } }, { key: "getDimension", value: function() {
        return 2;
      } }, { key: "getBoundary", value: function() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        for (var a = new ut(), l = 0; l < this._geometries.length; l++) for (var d = this._geometries[l].getBoundary(), v = 0; v < d.getNumGeometries(); v++) a.add(d.getGeometryN(v));
        var x = new Array(a.size()).fill(null);
        return this.getFactory().createMultiLineString(a.toArray(x));
      } }, { key: "getGeometryType", value: function() {
        return it.TYPENAME_MULTIPOLYGON;
      } }, { key: "interfaces_", get: function() {
        return [ve];
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        Fe.constructor_.call(this, a, l);
      } }]), o;
    }(Fe), Xh = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "get", value: function() {
      } }, { key: "put", value: function() {
      } }, { key: "size", value: function() {
      } }, { key: "values", value: function() {
      } }, { key: "entrySet", value: function() {
      } }]), f;
    }(), mp = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), (a = r.call(this)).map = /* @__PURE__ */ new Map(), a;
      }
      return s(o, [{ key: "get", value: function(a) {
        return this.map.get(a) || null;
      } }, { key: "put", value: function(a, l) {
        return this.map.set(a, l), l;
      } }, { key: "values", value: function() {
        for (var a = new ut(), l = this.map.values(), d = l.next(); !d.done; ) a.add(d.value), d = l.next();
        return a;
      } }, { key: "entrySet", value: function() {
        var a = new ie();
        return this.map.entries().forEach(function(l) {
          return a.add(l);
        }), a;
      } }, { key: "size", value: function() {
        return this.map.size();
      } }]), o;
    }(Xh), ln = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "equals", value: function(r) {
        if (!(r instanceof f)) return !1;
        var o = r;
        return this._modelType === o._modelType && this._scale === o._scale;
      } }, { key: "compareTo", value: function(r) {
        var o = r, a = this.getMaximumSignificantDigits(), l = o.getMaximumSignificantDigits();
        return ce.compare(a, l);
      } }, { key: "getScale", value: function() {
        return this._scale;
      } }, { key: "isFloating", value: function() {
        return this._modelType === f.FLOATING || this._modelType === f.FLOATING_SINGLE;
      } }, { key: "getType", value: function() {
        return this._modelType;
      } }, { key: "toString", value: function() {
        var r = "UNKNOWN";
        return this._modelType === f.FLOATING ? r = "Floating" : this._modelType === f.FLOATING_SINGLE ? r = "Floating-Single" : this._modelType === f.FIXED && (r = "Fixed (Scale=" + this.getScale() + ")"), r;
      } }, { key: "makePrecise", value: function() {
        if (typeof arguments[0] == "number") {
          var r = arguments[0];
          return Q.isNaN(r) || this._modelType === f.FLOATING_SINGLE ? r : this._modelType === f.FIXED ? Math.round(r * this._scale) / this._scale : r;
        }
        if (arguments[0] instanceof B) {
          var o = arguments[0];
          if (this._modelType === f.FLOATING) return null;
          o.x = this.makePrecise(o.x), o.y = this.makePrecise(o.y);
        }
      } }, { key: "getMaximumSignificantDigits", value: function() {
        var r = 16;
        return this._modelType === f.FLOATING ? r = 16 : this._modelType === f.FLOATING_SINGLE ? r = 6 : this._modelType === f.FIXED && (r = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), r;
      } }, { key: "setScale", value: function(r) {
        this._scale = Math.abs(r);
      } }, { key: "interfaces_", get: function() {
        return [A, D];
      } }], [{ key: "constructor_", value: function() {
        if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = f.FLOATING;
        else if (arguments.length === 1) {
          if (arguments[0] instanceof Cr) {
            var r = arguments[0];
            this._modelType = r, r === f.FIXED && this.setScale(1);
          } else if (typeof arguments[0] == "number") {
            var o = arguments[0];
            this._modelType = f.FIXED, this.setScale(o);
          } else if (arguments[0] instanceof f) {
            var a = arguments[0];
            this._modelType = a._modelType, this._scale = a._scale;
          }
        }
      } }, { key: "mostPrecise", value: function(r, o) {
        return r.compareTo(o) >= 0 ? r : o;
      } }]), f;
    }(), Cr = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "readResolve", value: function() {
        return f.nameToTypeMap.get(this._name);
      } }, { key: "toString", value: function() {
        return this._name;
      } }, { key: "interfaces_", get: function() {
        return [A];
      } }], [{ key: "constructor_", value: function() {
        this._name = null;
        var r = arguments[0];
        this._name = r, f.nameToTypeMap.put(r, this);
      } }]), f;
    }();
    Cr.nameToTypeMap = new mp(), ln.Type = Cr, ln.FIXED = new Cr("FIXED"), ln.FLOATING = new Cr("FLOATING"), ln.FLOATING_SINGLE = new Cr("FLOATING SINGLE"), ln.maximumPreciseValue = 9007199254740992;
    var au = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "copyInternal", value: function() {
        for (var a = new Array(this._geometries.length).fill(null), l = 0; l < a.length; l++) a[l] = this._geometries[l].copy();
        return new o(a, this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof it) {
          var a = arguments[0], l = arguments[1];
          return !!this.isEquivalentClass(a) && S(h(o.prototype), "equalsExact", this).call(this, a, l);
        }
        return S(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "getBoundaryDimension", value: function() {
        return this.isClosed() ? J.FALSE : 0;
      } }, { key: "isClosed", value: function() {
        if (this.isEmpty()) return !1;
        for (var a = 0; a < this._geometries.length; a++) if (!this._geometries[a].isClosed()) return !1;
        return !0;
      } }, { key: "getTypeCode", value: function() {
        return it.TYPECODE_MULTILINESTRING;
      } }, { key: "getDimension", value: function() {
        return 1;
      } }, { key: "getBoundary", value: function() {
        throw new dt();
      } }, { key: "getGeometryType", value: function() {
        return it.TYPENAME_MULTILINESTRING;
      } }, { key: "interfaces_", get: function() {
        return [Yi];
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        Fe.constructor_.call(this, a, l);
      } }]), o;
    }(Fe), Rr = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "createEmpty", value: function(r) {
        switch (r) {
          case -1:
            return this.createGeometryCollection();
          case 0:
            return this.createPoint();
          case 1:
            return this.createLineString();
          case 2:
            return this.createPolygon();
          default:
            throw new M("Invalid dimension: " + r);
        }
      } }, { key: "toGeometry", value: function(r) {
        return r.isNull() ? this.createPoint() : r.getMinX() === r.getMaxX() && r.getMinY() === r.getMaxY() ? this.createPoint(new B(r.getMinX(), r.getMinY())) : r.getMinX() === r.getMaxX() || r.getMinY() === r.getMaxY() ? this.createLineString([new B(r.getMinX(), r.getMinY()), new B(r.getMaxX(), r.getMaxY())]) : this.createPolygon(this.createLinearRing([new B(r.getMinX(), r.getMinY()), new B(r.getMinX(), r.getMaxY()), new B(r.getMaxX(), r.getMaxY()), new B(r.getMaxX(), r.getMinY()), new B(r.getMinX(), r.getMinY())]), null);
      } }, { key: "createLineString", value: function() {
        if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var r = arguments[0];
            return this.createLineString(r !== null ? this.getCoordinateSequenceFactory().create(r) : null);
          }
          if (ht(arguments[0], It)) {
            var o = arguments[0];
            return new Tt(o, this);
          }
        }
      } }, { key: "createMultiLineString", value: function() {
        if (arguments.length === 0) return new au(null, this);
        if (arguments.length === 1) {
          var r = arguments[0];
          return new au(r, this);
        }
      } }, { key: "buildGeometry", value: function(r) {
        for (var o = null, a = !1, l = !1, d = r.iterator(); d.hasNext(); ) {
          var v = d.next(), x = v.getTypeCode();
          o === null && (o = x), x !== o && (a = !0), v instanceof Fe && (l = !0);
        }
        if (o === null) return this.createGeometryCollection();
        if (a || l) return this.createGeometryCollection(f.toGeometryArray(r));
        var w = r.iterator().next();
        if (r.size() > 1) {
          if (w instanceof wn) return this.createMultiPolygon(f.toPolygonArray(r));
          if (w instanceof Tt) return this.createMultiLineString(f.toLineStringArray(r));
          if (w instanceof yt) return this.createMultiPoint(f.toPointArray(r));
          X.shouldNeverReachHere("Unhandled geometry type: " + w.getGeometryType());
        }
        return w;
      } }, { key: "createMultiPointFromCoords", value: function(r) {
        return this.createMultiPoint(r !== null ? this.getCoordinateSequenceFactory().create(r) : null);
      } }, { key: "createPoint", value: function() {
        if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
          if (arguments[0] instanceof B) {
            var r = arguments[0];
            return this.createPoint(r !== null ? this.getCoordinateSequenceFactory().create([r]) : null);
          }
          if (ht(arguments[0], It)) {
            var o = arguments[0];
            return new yt(o, this);
          }
        }
      } }, { key: "getCoordinateSequenceFactory", value: function() {
        return this._coordinateSequenceFactory;
      } }, { key: "createPolygon", value: function() {
        if (arguments.length === 0) return this.createPolygon(null, null);
        if (arguments.length === 1) {
          if (ht(arguments[0], It)) {
            var r = arguments[0];
            return this.createPolygon(this.createLinearRing(r));
          }
          if (arguments[0] instanceof Array) {
            var o = arguments[0];
            return this.createPolygon(this.createLinearRing(o));
          }
          if (arguments[0] instanceof Es) {
            var a = arguments[0];
            return this.createPolygon(a, null);
          }
        } else if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          return new wn(l, d, this);
        }
      } }, { key: "getSRID", value: function() {
        return this._SRID;
      } }, { key: "createGeometryCollection", value: function() {
        if (arguments.length === 0) return new Fe(null, this);
        if (arguments.length === 1) {
          var r = arguments[0];
          return new Fe(r, this);
        }
      } }, { key: "getPrecisionModel", value: function() {
        return this._precisionModel;
      } }, { key: "createLinearRing", value: function() {
        if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var r = arguments[0];
            return this.createLinearRing(r !== null ? this.getCoordinateSequenceFactory().create(r) : null);
          }
          if (ht(arguments[0], It)) {
            var o = arguments[0];
            return new Es(o, this);
          }
        }
      } }, { key: "createMultiPolygon", value: function() {
        if (arguments.length === 0) return new ou(null, this);
        if (arguments.length === 1) {
          var r = arguments[0];
          return new ou(r, this);
        }
      } }, { key: "createMultiPoint", value: function() {
        if (arguments.length === 0) return new iu(null, this);
        if (arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var r = arguments[0];
            return new iu(r, this);
          }
          if (ht(arguments[0], It)) {
            var o = arguments[0];
            if (o === null) return this.createMultiPoint(new Array(0).fill(null));
            for (var a = new Array(o.size()).fill(null), l = 0; l < o.size(); l++) {
              var d = this.getCoordinateSequenceFactory().create(1, o.getDimension(), o.getMeasures());
              Qt.copy(o, l, d, 0, 1), a[l] = this.createPoint(d);
            }
            return this.createMultiPoint(a);
          }
        }
      } }, { key: "interfaces_", get: function() {
        return [A];
      } }], [{ key: "constructor_", value: function() {
        if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, arguments.length === 0) f.constructor_.call(this, new ln(), 0);
        else if (arguments.length === 1) {
          if (ht(arguments[0], Sn)) {
            var r = arguments[0];
            f.constructor_.call(this, new ln(), 0, r);
          } else if (arguments[0] instanceof ln) {
            var o = arguments[0];
            f.constructor_.call(this, o, 0, f.getDefaultCoordinateSequenceFactory());
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          f.constructor_.call(this, a, l, f.getDefaultCoordinateSequenceFactory());
        } else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], x = arguments[2];
          this._precisionModel = d, this._coordinateSequenceFactory = x, this._SRID = v;
        }
      } }, { key: "toMultiPolygonArray", value: function(r) {
        var o = new Array(r.size()).fill(null);
        return r.toArray(o);
      } }, { key: "toGeometryArray", value: function(r) {
        if (r === null) return null;
        var o = new Array(r.size()).fill(null);
        return r.toArray(o);
      } }, { key: "getDefaultCoordinateSequenceFactory", value: function() {
        return su.instance();
      } }, { key: "toMultiLineStringArray", value: function(r) {
        var o = new Array(r.size()).fill(null);
        return r.toArray(o);
      } }, { key: "toLineStringArray", value: function(r) {
        var o = new Array(r.size()).fill(null);
        return r.toArray(o);
      } }, { key: "toMultiPointArray", value: function(r) {
        var o = new Array(r.size()).fill(null);
        return r.toArray(o);
      } }, { key: "toLinearRingArray", value: function(r) {
        var o = new Array(r.size()).fill(null);
        return r.toArray(o);
      } }, { key: "toPointArray", value: function(r) {
        var o = new Array(r.size()).fill(null);
        return r.toArray(o);
      } }, { key: "toPolygonArray", value: function(r) {
        var o = new Array(r.size()).fill(null);
        return r.toArray(o);
      } }, { key: "createPointFromInternalCoord", value: function(r, o) {
        return o.getPrecisionModel().makePrecise(r), o.getFactory().createPoint(r);
      } }]), f;
    }(), uu = "XY", yp = "XYZ", pp = "XYM", vp = "XYZM", qh = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, Uh = "EMPTY", Ro = 1, Yn = 2, ci = 3, jh = 4, Lr = 5, _p = 6;
    for (var Ep in qh) qh[Ep].toUpperCase();
    var xp = function() {
      function f(r) {
        e(this, f), this.wkt = r, this.index_ = -1;
      }
      return s(f, [{ key: "isAlpha_", value: function(r) {
        return r >= "a" && r <= "z" || r >= "A" && r <= "Z";
      } }, { key: "isNumeric_", value: function(r, o) {
        return r >= "0" && r <= "9" || r == "." && !(o !== void 0 && o);
      } }, { key: "isWhiteSpace_", value: function(r) {
        return r == " " || r == "	" || r == "\r" || r == `
`;
      } }, { key: "nextChar_", value: function() {
        return this.wkt.charAt(++this.index_);
      } }, { key: "nextToken", value: function() {
        var r, o = this.nextChar_(), a = this.index_, l = o;
        if (o == "(") r = Yn;
        else if (o == ",") r = Lr;
        else if (o == ")") r = ci;
        else if (this.isNumeric_(o) || o == "-") r = jh, l = this.readNumber_();
        else if (this.isAlpha_(o)) r = Ro, l = this.readText_();
        else {
          if (this.isWhiteSpace_(o)) return this.nextToken();
          if (o !== "") throw new Error("Unexpected character: " + o);
          r = _p;
        }
        return { position: a, value: l, type: r };
      } }, { key: "readNumber_", value: function() {
        var r, o = this.index_, a = !1, l = !1;
        do
          r == "." ? a = !0 : r != "e" && r != "E" || (l = !0), r = this.nextChar_();
        while (this.isNumeric_(r, a) || !l && (r == "e" || r == "E") || l && (r == "-" || r == "+"));
        return parseFloat(this.wkt.substring(o, this.index_--));
      } }, { key: "readText_", value: function() {
        var r, o = this.index_;
        do
          r = this.nextChar_();
        while (this.isAlpha_(r));
        return this.wkt.substring(o, this.index_--).toUpperCase();
      } }]), f;
    }(), Sp = function() {
      function f(r, o) {
        e(this, f), this.lexer_ = r, this.token_, this.layout_ = uu, this.factory = o;
      }
      return s(f, [{ key: "consume_", value: function() {
        this.token_ = this.lexer_.nextToken();
      } }, { key: "isTokenType", value: function(r) {
        return this.token_.type == r;
      } }, { key: "match", value: function(r) {
        var o = this.isTokenType(r);
        return o && this.consume_(), o;
      } }, { key: "parse", value: function() {
        return this.consume_(), this.parseGeometry_();
      } }, { key: "parseGeometryLayout_", value: function() {
        var r = uu, o = this.token_;
        if (this.isTokenType(Ro)) {
          var a = o.value;
          a === "Z" ? r = yp : a === "M" ? r = pp : a === "ZM" && (r = vp), r !== uu && this.consume_();
        }
        return r;
      } }, { key: "parseGeometryCollectionText_", value: function() {
        if (this.match(Yn)) {
          var r = [];
          do
            r.push(this.parseGeometry_());
          while (this.match(Lr));
          if (this.match(ci)) return r;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parsePointText_", value: function() {
        if (this.match(Yn)) {
          var r = this.parsePoint_();
          if (this.match(ci)) return r;
        } else if (this.isEmptyGeometry_()) return null;
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parseLineStringText_", value: function() {
        if (this.match(Yn)) {
          var r = this.parsePointList_();
          if (this.match(ci)) return r;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parsePolygonText_", value: function() {
        if (this.match(Yn)) {
          var r = this.parseLineStringTextList_();
          if (this.match(ci)) return r;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parseMultiPointText_", value: function() {
        var r;
        if (this.match(Yn)) {
          if (r = this.token_.type == Yn ? this.parsePointTextList_() : this.parsePointList_(), this.match(ci)) return r;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parseMultiLineStringText_", value: function() {
        if (this.match(Yn)) {
          var r = this.parseLineStringTextList_();
          if (this.match(ci)) return r;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parseMultiPolygonText_", value: function() {
        if (this.match(Yn)) {
          var r = this.parsePolygonTextList_();
          if (this.match(ci)) return r;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parsePoint_", value: function() {
        for (var r = [], o = this.layout_.length, a = 0; a < o; ++a) {
          var l = this.token_;
          if (!this.match(jh)) break;
          r.push(l.value);
        }
        if (r.length == o) return r;
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parsePointList_", value: function() {
        for (var r = [this.parsePoint_()]; this.match(Lr); ) r.push(this.parsePoint_());
        return r;
      } }, { key: "parsePointTextList_", value: function() {
        for (var r = [this.parsePointText_()]; this.match(Lr); ) r.push(this.parsePointText_());
        return r;
      } }, { key: "parseLineStringTextList_", value: function() {
        for (var r = [this.parseLineStringText_()]; this.match(Lr); ) r.push(this.parseLineStringText_());
        return r;
      } }, { key: "parsePolygonTextList_", value: function() {
        for (var r = [this.parsePolygonText_()]; this.match(Lr); ) r.push(this.parsePolygonText_());
        return r;
      } }, { key: "isEmptyGeometry_", value: function() {
        var r = this.isTokenType(Ro) && this.token_.value == Uh;
        return r && this.consume_(), r;
      } }, { key: "formatErrorMessage_", value: function() {
        return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
      } }, { key: "parseGeometry_", value: function() {
        var r = this.factory, o = function(ft) {
          return m(B, I(ft));
        }, a = function(ft) {
          var pt = ft.map(function(Pt) {
            return r.createLinearRing(Pt.map(o));
          });
          return pt.length > 1 ? r.createPolygon(pt[0], pt.slice(1)) : r.createPolygon(pt[0]);
        }, l = this.token_;
        if (this.match(Ro)) {
          var d = l.value;
          if (this.layout_ = this.parseGeometryLayout_(), d == "GEOMETRYCOLLECTION") {
            var v = this.parseGeometryCollectionText_();
            return r.createGeometryCollection(v);
          }
          switch (d) {
            case "POINT":
              var x = this.parsePointText_();
              return x ? r.createPoint(m(B, I(x))) : r.createPoint();
            case "LINESTRING":
              var w = this.parseLineStringText_().map(o);
              return r.createLineString(w);
            case "LINEARRING":
              var k = this.parseLineStringText_().map(o);
              return r.createLinearRing(k);
            case "POLYGON":
              var N = this.parsePolygonText_();
              return N && N.length !== 0 ? a(N) : r.createPolygon();
            case "MULTIPOINT":
              var P = this.parseMultiPointText_();
              if (!P || P.length === 0) return r.createMultiPoint();
              var W = P.map(o).map(function(ft) {
                return r.createPoint(ft);
              });
              return r.createMultiPoint(W);
            case "MULTILINESTRING":
              var tt = this.parseMultiLineStringText_().map(function(ft) {
                return r.createLineString(ft.map(o));
              });
              return r.createMultiLineString(tt);
            case "MULTIPOLYGON":
              var $ = this.parseMultiPolygonText_();
              if (!$ || $.length === 0) return r.createMultiPolygon();
              var ot = $.map(a);
              return r.createMultiPolygon(ot);
            default:
              throw new Error("Invalid geometry type: " + d);
          }
        }
        throw new Error(this.formatErrorMessage_());
      } }]), f;
    }();
    function Vh(f) {
      if (f.isEmpty()) return "";
      var r = f.getCoordinate(), o = [r.x, r.y];
      return r.z === void 0 || Number.isNaN(r.z) || o.push(r.z), r.m === void 0 || Number.isNaN(r.m) || o.push(r.m), o.join(" ");
    }
    function ws(f) {
      for (var r = f.getCoordinates().map(function(d) {
        var v = [d.x, d.y];
        return d.z === void 0 || Number.isNaN(d.z) || v.push(d.z), d.m === void 0 || Number.isNaN(d.m) || v.push(d.m), v;
      }), o = [], a = 0, l = r.length; a < l; ++a) o.push(r[a].join(" "));
      return o.join(", ");
    }
    function Zh(f) {
      var r = [];
      r.push("(" + ws(f.getExteriorRing()) + ")");
      for (var o = 0, a = f.getNumInteriorRing(); o < a; ++o) r.push("(" + ws(f.getInteriorRingN(o)) + ")");
      return r.join(", ");
    }
    var wp = { Point: Vh, LineString: ws, LinearRing: ws, Polygon: Zh, MultiPoint: function(f) {
      for (var r = [], o = 0, a = f.getNumGeometries(); o < a; ++o) r.push("(" + Vh(f.getGeometryN(o)) + ")");
      return r.join(", ");
    }, MultiLineString: function(f) {
      for (var r = [], o = 0, a = f.getNumGeometries(); o < a; ++o) r.push("(" + ws(f.getGeometryN(o)) + ")");
      return r.join(", ");
    }, MultiPolygon: function(f) {
      for (var r = [], o = 0, a = f.getNumGeometries(); o < a; ++o) r.push("(" + Zh(f.getGeometryN(o)) + ")");
      return r.join(", ");
    }, GeometryCollection: function(f) {
      for (var r = [], o = 0, a = f.getNumGeometries(); o < a; ++o) r.push(Hh(f.getGeometryN(o)));
      return r.join(", ");
    } };
    function Hh(f) {
      var r = f.getGeometryType(), o = wp[r];
      r = r.toUpperCase();
      var a = function(l) {
        var d = "";
        if (l.isEmpty()) return d;
        var v = l.getCoordinate();
        return v.z === void 0 || Number.isNaN(v.z) || (d += "Z"), v.m === void 0 || Number.isNaN(v.m) || (d += "M"), d;
      }(f);
      return a.length > 0 && (r += " " + a), f.isEmpty() ? r + " " + Uh : r + " (" + o(f) + ")";
    }
    var Ip = function() {
      function f(r) {
        e(this, f), this.geometryFactory = r || new Rr(), this.precisionModel = this.geometryFactory.getPrecisionModel();
      }
      return s(f, [{ key: "read", value: function(r) {
        var o = new xp(r);
        return new Sp(o, this.geometryFactory).parse();
      } }, { key: "write", value: function(r) {
        return Hh(r);
      } }]), f;
    }(), lu = function() {
      function f(r) {
        e(this, f), this.parser = new Ip(r);
      }
      return s(f, [{ key: "write", value: function(r) {
        return this.parser.write(r);
      } }], [{ key: "toLineString", value: function(r, o) {
        if (arguments.length !== 2) throw new Error("Not implemented");
        return "LINESTRING ( " + r.x + " " + r.y + ", " + o.x + " " + o.y + " )";
      } }]), f;
    }(), jt = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getIndexAlongSegment", value: function(r, o) {
        return this.computeIntLineIndex(), this._intLineIndex[r][o];
      } }, { key: "getTopologySummary", value: function() {
        var r = new Co();
        return this.isEndPoint() && r.append(" endpoint"), this._isProper && r.append(" proper"), this.isCollinear() && r.append(" collinear"), r.toString();
      } }, { key: "computeIntersection", value: function(r, o, a, l) {
        this._inputLines[0][0] = r, this._inputLines[0][1] = o, this._inputLines[1][0] = a, this._inputLines[1][1] = l, this._result = this.computeIntersect(r, o, a, l);
      } }, { key: "getIntersectionNum", value: function() {
        return this._result;
      } }, { key: "computeIntLineIndex", value: function() {
        if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(function() {
          return Array(2);
        }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
        else if (arguments.length === 1) {
          var r = arguments[0], o = this.getEdgeDistance(r, 0), a = this.getEdgeDistance(r, 1);
          o > a ? (this._intLineIndex[r][0] = 0, this._intLineIndex[r][1] = 1) : (this._intLineIndex[r][0] = 1, this._intLineIndex[r][1] = 0);
        }
      } }, { key: "isProper", value: function() {
        return this.hasIntersection() && this._isProper;
      } }, { key: "setPrecisionModel", value: function(r) {
        this._precisionModel = r;
      } }, { key: "isInteriorIntersection", value: function() {
        if (arguments.length === 0) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
        if (arguments.length === 1) {
          for (var r = arguments[0], o = 0; o < this._result; o++) if (!this._intPt[o].equals2D(this._inputLines[r][0]) && !this._intPt[o].equals2D(this._inputLines[r][1])) return !0;
          return !1;
        }
      } }, { key: "getIntersection", value: function(r) {
        return this._intPt[r];
      } }, { key: "isEndPoint", value: function() {
        return this.hasIntersection() && !this._isProper;
      } }, { key: "hasIntersection", value: function() {
        return this._result !== f.NO_INTERSECTION;
      } }, { key: "getEdgeDistance", value: function(r, o) {
        return f.computeEdgeDistance(this._intPt[o], this._inputLines[r][0], this._inputLines[r][1]);
      } }, { key: "isCollinear", value: function() {
        return this._result === f.COLLINEAR_INTERSECTION;
      } }, { key: "toString", value: function() {
        return lu.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + lu.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
      } }, { key: "getEndpoint", value: function(r, o) {
        return this._inputLines[r][o];
      } }, { key: "isIntersection", value: function(r) {
        for (var o = 0; o < this._result; o++) if (this._intPt[o].equals2D(r)) return !0;
        return !1;
      } }, { key: "getIntersectionAlongSegment", value: function(r, o) {
        return this.computeIntLineIndex(), this._intPt[this._intLineIndex[r][o]];
      } }], [{ key: "constructor_", value: function() {
        this._result = null, this._inputLines = Array(2).fill().map(function() {
          return Array(2);
        }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new B(), this._intPt[1] = new B(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
      } }, { key: "computeEdgeDistance", value: function(r, o, a) {
        var l = Math.abs(a.x - o.x), d = Math.abs(a.y - o.y), v = -1;
        if (r.equals(o)) v = 0;
        else if (r.equals(a)) v = l > d ? l : d;
        else {
          var x = Math.abs(r.x - o.x), w = Math.abs(r.y - o.y);
          (v = l > d ? x : w) !== 0 || r.equals(o) || (v = Math.max(x, w));
        }
        return X.isTrue(!(v === 0 && !r.equals(o)), "Bad distance calculation"), v;
      } }, { key: "nonRobustComputeEdgeDistance", value: function(r, o, a) {
        var l = r.x - o.x, d = r.y - o.y, v = Math.sqrt(l * l + d * d);
        return X.isTrue(!(v === 0 && !r.equals(o)), "Invalid distance calculation"), v;
      } }]), f;
    }();
    jt.DONT_INTERSECT = 0, jt.DO_INTERSECT = 1, jt.COLLINEAR = 2, jt.NO_INTERSECTION = 0, jt.POINT_INTERSECTION = 1, jt.COLLINEAR_INTERSECTION = 2;
    var qi = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        return e(this, o), r.call(this);
      }
      return s(o, [{ key: "isInSegmentEnvelopes", value: function(a) {
        var l = new Ot(this._inputLines[0][0], this._inputLines[0][1]), d = new Ot(this._inputLines[1][0], this._inputLines[1][1]);
        return l.contains(a) && d.contains(a);
      } }, { key: "computeIntersection", value: function() {
        if (arguments.length !== 3) return S(h(o.prototype), "computeIntersection", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1], d = arguments[2];
        if (this._isProper = !1, Ot.intersects(l, d, a) && ct.index(l, d, a) === 0 && ct.index(d, l, a) === 0) return this._isProper = !0, (a.equals(l) || a.equals(d)) && (this._isProper = !1), this._result = jt.POINT_INTERSECTION, null;
        this._result = jt.NO_INTERSECTION;
      } }, { key: "intersection", value: function(a, l, d, v) {
        var x = this.intersectionSafe(a, l, d, v);
        return this.isInSegmentEnvelopes(x) || (x = new B(o.nearestEndpoint(a, l, d, v))), this._precisionModel !== null && this._precisionModel.makePrecise(x), x;
      } }, { key: "checkDD", value: function(a, l, d, v, x) {
        var w = Ve.intersection(a, l, d, v), k = this.isInSegmentEnvelopes(w);
        ge.out.println("DD in env = " + k + "  --------------------- " + w), x.distance(w) > 1e-4 && ge.out.println("Distance = " + x.distance(w));
      } }, { key: "intersectionSafe", value: function(a, l, d, v) {
        var x = zn.intersection(a, l, d, v);
        return x === null && (x = o.nearestEndpoint(a, l, d, v)), x;
      } }, { key: "computeCollinearIntersection", value: function(a, l, d, v) {
        var x = Ot.intersects(a, l, d), w = Ot.intersects(a, l, v), k = Ot.intersects(d, v, a), N = Ot.intersects(d, v, l);
        return x && w ? (this._intPt[0] = d, this._intPt[1] = v, jt.COLLINEAR_INTERSECTION) : k && N ? (this._intPt[0] = a, this._intPt[1] = l, jt.COLLINEAR_INTERSECTION) : x && k ? (this._intPt[0] = d, this._intPt[1] = a, !d.equals(a) || w || N ? jt.COLLINEAR_INTERSECTION : jt.POINT_INTERSECTION) : x && N ? (this._intPt[0] = d, this._intPt[1] = l, !d.equals(l) || w || k ? jt.COLLINEAR_INTERSECTION : jt.POINT_INTERSECTION) : w && k ? (this._intPt[0] = v, this._intPt[1] = a, !v.equals(a) || x || N ? jt.COLLINEAR_INTERSECTION : jt.POINT_INTERSECTION) : w && N ? (this._intPt[0] = v, this._intPt[1] = l, !v.equals(l) || x || k ? jt.COLLINEAR_INTERSECTION : jt.POINT_INTERSECTION) : jt.NO_INTERSECTION;
      } }, { key: "computeIntersect", value: function(a, l, d, v) {
        if (this._isProper = !1, !Ot.intersects(a, l, d, v)) return jt.NO_INTERSECTION;
        var x = ct.index(a, l, d), w = ct.index(a, l, v);
        if (x > 0 && w > 0 || x < 0 && w < 0) return jt.NO_INTERSECTION;
        var k = ct.index(d, v, a), N = ct.index(d, v, l);
        return k > 0 && N > 0 || k < 0 && N < 0 ? jt.NO_INTERSECTION : x === 0 && w === 0 && k === 0 && N === 0 ? this.computeCollinearIntersection(a, l, d, v) : (x === 0 || w === 0 || k === 0 || N === 0 ? (this._isProper = !1, a.equals2D(d) || a.equals2D(v) ? this._intPt[0] = a : l.equals2D(d) || l.equals2D(v) ? this._intPt[0] = l : x === 0 ? this._intPt[0] = new B(d) : w === 0 ? this._intPt[0] = new B(v) : k === 0 ? this._intPt[0] = new B(a) : N === 0 && (this._intPt[0] = new B(l))) : (this._isProper = !0, this._intPt[0] = this.intersection(a, l, d, v)), jt.POINT_INTERSECTION);
      } }], [{ key: "nearestEndpoint", value: function(a, l, d, v) {
        var x = a, w = se.pointToSegment(a, d, v), k = se.pointToSegment(l, d, v);
        return k < w && (w = k, x = l), (k = se.pointToSegment(d, a, l)) < w && (w = k, x = d), (k = se.pointToSegment(v, a, l)) < w && (w = k, x = v), x;
      } }]), o;
    }(jt), kp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "countSegment", value: function(r, o) {
        if (r.x < this._p.x && o.x < this._p.x) return null;
        if (this._p.x === o.x && this._p.y === o.y) return this._isPointOnSegment = !0, null;
        if (r.y === this._p.y && o.y === this._p.y) {
          var a = r.x, l = o.x;
          return a > l && (a = o.x, l = r.x), this._p.x >= a && this._p.x <= l && (this._isPointOnSegment = !0), null;
        }
        if (r.y > this._p.y && o.y <= this._p.y || o.y > this._p.y && r.y <= this._p.y) {
          var d = ct.index(r, o, this._p);
          if (d === ct.COLLINEAR) return this._isPointOnSegment = !0, null;
          o.y < r.y && (d = -d), d === ct.LEFT && this._crossingCount++;
        }
      } }, { key: "isPointInPolygon", value: function() {
        return this.getLocation() !== L.EXTERIOR;
      } }, { key: "getLocation", value: function() {
        return this._isPointOnSegment ? L.BOUNDARY : this._crossingCount % 2 == 1 ? L.INTERIOR : L.EXTERIOR;
      } }, { key: "isOnSegment", value: function() {
        return this._isPointOnSegment;
      } }], [{ key: "constructor_", value: function() {
        this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
        var r = arguments[0];
        this._p = r;
      } }, { key: "locatePointInRing", value: function() {
        if (arguments[0] instanceof B && ht(arguments[1], It)) {
          for (var r = arguments[0], o = arguments[1], a = new f(r), l = new B(), d = new B(), v = 1; v < o.size(); v++) if (o.getCoordinate(v, l), o.getCoordinate(v - 1, d), a.countSegment(l, d), a.isOnSegment()) return a.getLocation();
          return a.getLocation();
        }
        if (arguments[0] instanceof B && arguments[1] instanceof Array) {
          for (var x = arguments[0], w = arguments[1], k = new f(x), N = 1; N < w.length; N++) {
            var P = w[N], W = w[N - 1];
            if (k.countSegment(P, W), k.isOnSegment()) return k.getLocation();
          }
          return k.getLocation();
        }
      } }]), f;
    }(), hu = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "isOnLine", value: function() {
        if (arguments[0] instanceof B && ht(arguments[1], It)) {
          for (var r = arguments[0], o = arguments[1], a = new qi(), l = new B(), d = new B(), v = o.size(), x = 1; x < v; x++) if (o.getCoordinate(x - 1, l), o.getCoordinate(x, d), a.computeIntersection(r, l, d), a.hasIntersection()) return !0;
          return !1;
        }
        if (arguments[0] instanceof B && arguments[1] instanceof Array) {
          for (var w = arguments[0], k = arguments[1], N = new qi(), P = 1; P < k.length; P++) {
            var W = k[P - 1], tt = k[P];
            if (N.computeIntersection(w, W, tt), N.hasIntersection()) return !0;
          }
          return !1;
        }
      } }, { key: "locateInRing", value: function(r, o) {
        return kp.locatePointInRing(r, o);
      } }, { key: "isInRing", value: function(r, o) {
        return f.locateInRing(r, o) !== L.EXTERIOR;
      } }]), f;
    }(), He = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "setAllLocations", value: function(r) {
        for (var o = 0; o < this.location.length; o++) this.location[o] = r;
      } }, { key: "isNull", value: function() {
        for (var r = 0; r < this.location.length; r++) if (this.location[r] !== L.NONE) return !1;
        return !0;
      } }, { key: "setAllLocationsIfNull", value: function(r) {
        for (var o = 0; o < this.location.length; o++) this.location[o] === L.NONE && (this.location[o] = r);
      } }, { key: "isLine", value: function() {
        return this.location.length === 1;
      } }, { key: "merge", value: function(r) {
        if (r.location.length > this.location.length) {
          var o = new Array(3).fill(null);
          o[H.ON] = this.location[H.ON], o[H.LEFT] = L.NONE, o[H.RIGHT] = L.NONE, this.location = o;
        }
        for (var a = 0; a < this.location.length; a++) this.location[a] === L.NONE && a < r.location.length && (this.location[a] = r.location[a]);
      } }, { key: "getLocations", value: function() {
        return this.location;
      } }, { key: "flip", value: function() {
        if (this.location.length <= 1) return null;
        var r = this.location[H.LEFT];
        this.location[H.LEFT] = this.location[H.RIGHT], this.location[H.RIGHT] = r;
      } }, { key: "toString", value: function() {
        var r = new De();
        return this.location.length > 1 && r.append(L.toLocationSymbol(this.location[H.LEFT])), r.append(L.toLocationSymbol(this.location[H.ON])), this.location.length > 1 && r.append(L.toLocationSymbol(this.location[H.RIGHT])), r.toString();
      } }, { key: "setLocations", value: function(r, o, a) {
        this.location[H.ON] = r, this.location[H.LEFT] = o, this.location[H.RIGHT] = a;
      } }, { key: "get", value: function(r) {
        return r < this.location.length ? this.location[r] : L.NONE;
      } }, { key: "isArea", value: function() {
        return this.location.length > 1;
      } }, { key: "isAnyNull", value: function() {
        for (var r = 0; r < this.location.length; r++) if (this.location[r] === L.NONE) return !0;
        return !1;
      } }, { key: "setLocation", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          this.setLocation(H.ON, r);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this.location[o] = a;
        }
      } }, { key: "init", value: function(r) {
        this.location = new Array(r).fill(null), this.setAllLocations(L.NONE);
      } }, { key: "isEqualOnSide", value: function(r, o) {
        return this.location[o] === r.location[o];
      } }, { key: "allPositionsEqual", value: function(r) {
        for (var o = 0; o < this.location.length; o++) if (this.location[o] !== r) return !1;
        return !0;
      } }], [{ key: "constructor_", value: function() {
        if (this.location = null, arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var r = arguments[0];
            this.init(r.length);
          } else if (Number.isInteger(arguments[0])) {
            var o = arguments[0];
            this.init(1), this.location[H.ON] = o;
          } else if (arguments[0] instanceof f) {
            var a = arguments[0];
            if (this.init(a.location.length), a !== null) for (var l = 0; l < this.location.length; l++) this.location[l] = a.location[l];
          }
        } else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], x = arguments[2];
          this.init(3), this.location[H.ON] = d, this.location[H.LEFT] = v, this.location[H.RIGHT] = x;
        }
      } }]), f;
    }(), Ke = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getGeometryCount", value: function() {
        var r = 0;
        return this.elt[0].isNull() || r++, this.elt[1].isNull() || r++, r;
      } }, { key: "setAllLocations", value: function(r, o) {
        this.elt[r].setAllLocations(o);
      } }, { key: "isNull", value: function(r) {
        return this.elt[r].isNull();
      } }, { key: "setAllLocationsIfNull", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          this.setAllLocationsIfNull(0, r), this.setAllLocationsIfNull(1, r);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this.elt[o].setAllLocationsIfNull(a);
        }
      } }, { key: "isLine", value: function(r) {
        return this.elt[r].isLine();
      } }, { key: "merge", value: function(r) {
        for (var o = 0; o < 2; o++) this.elt[o] === null && r.elt[o] !== null ? this.elt[o] = new He(r.elt[o]) : this.elt[o].merge(r.elt[o]);
      } }, { key: "flip", value: function() {
        this.elt[0].flip(), this.elt[1].flip();
      } }, { key: "getLocation", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          return this.elt[r].get(H.ON);
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          return this.elt[o].get(a);
        }
      } }, { key: "toString", value: function() {
        var r = new De();
        return this.elt[0] !== null && (r.append("A:"), r.append(this.elt[0].toString())), this.elt[1] !== null && (r.append(" B:"), r.append(this.elt[1].toString())), r.toString();
      } }, { key: "isArea", value: function() {
        if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
        if (arguments.length === 1) {
          var r = arguments[0];
          return this.elt[r].isArea();
        }
      } }, { key: "isAnyNull", value: function(r) {
        return this.elt[r].isAnyNull();
      } }, { key: "setLocation", value: function() {
        if (arguments.length === 2) {
          var r = arguments[0], o = arguments[1];
          this.elt[r].setLocation(H.ON, o);
        } else if (arguments.length === 3) {
          var a = arguments[0], l = arguments[1], d = arguments[2];
          this.elt[a].setLocation(l, d);
        }
      } }, { key: "isEqualOnSide", value: function(r, o) {
        return this.elt[0].isEqualOnSide(r.elt[0], o) && this.elt[1].isEqualOnSide(r.elt[1], o);
      } }, { key: "allPositionsEqual", value: function(r, o) {
        return this.elt[r].allPositionsEqual(o);
      } }, { key: "toLine", value: function(r) {
        this.elt[r].isArea() && (this.elt[r] = new He(this.elt[r].location[0]));
      } }], [{ key: "constructor_", value: function() {
        if (this.elt = new Array(2).fill(null), arguments.length === 1) {
          if (Number.isInteger(arguments[0])) {
            var r = arguments[0];
            this.elt[0] = new He(r), this.elt[1] = new He(r);
          } else if (arguments[0] instanceof f) {
            var o = arguments[0];
            this.elt[0] = new He(o.elt[0]), this.elt[1] = new He(o.elt[1]);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this.elt[0] = new He(L.NONE), this.elt[1] = new He(L.NONE), this.elt[a].setLocation(l);
        } else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], x = arguments[2];
          this.elt[0] = new He(d, v, x), this.elt[1] = new He(d, v, x);
        } else if (arguments.length === 4) {
          var w = arguments[0], k = arguments[1], N = arguments[2], P = arguments[3];
          this.elt[0] = new He(L.NONE, L.NONE, L.NONE), this.elt[1] = new He(L.NONE, L.NONE, L.NONE), this.elt[w].setLocations(k, N, P);
        }
      } }, { key: "toLineLabel", value: function(r) {
        for (var o = new f(L.NONE), a = 0; a < 2; a++) o.setLocation(a, r.getLocation(a));
        return o;
      } }]), f;
    }(), Lo = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "computeRing", value: function() {
        if (this._ring !== null) return null;
        for (var r = new Array(this._pts.size()).fill(null), o = 0; o < this._pts.size(); o++) r[o] = this._pts.get(o);
        this._ring = this._geometryFactory.createLinearRing(r), this._isHole = ct.isCCW(this._ring.getCoordinates());
      } }, { key: "isIsolated", value: function() {
        return this._label.getGeometryCount() === 1;
      } }, { key: "computePoints", value: function(r) {
        this._startDe = r;
        var o = r, a = !0;
        do {
          if (o === null) throw new fe("Found null DirectedEdge");
          if (o.getEdgeRing() === this) throw new fe("Directed Edge visited twice during ring-building at " + o.getCoordinate());
          this._edges.add(o);
          var l = o.getLabel();
          X.isTrue(l.isArea()), this.mergeLabel(l), this.addPoints(o.getEdge(), o.isForward(), a), a = !1, this.setEdgeRing(o, this), o = this.getNext(o);
        } while (o !== this._startDe);
      } }, { key: "getLinearRing", value: function() {
        return this._ring;
      } }, { key: "getCoordinate", value: function(r) {
        return this._pts.get(r);
      } }, { key: "computeMaxNodeDegree", value: function() {
        this._maxNodeDegree = 0;
        var r = this._startDe;
        do {
          var o = r.getNode().getEdges().getOutgoingDegree(this);
          o > this._maxNodeDegree && (this._maxNodeDegree = o), r = this.getNext(r);
        } while (r !== this._startDe);
        this._maxNodeDegree *= 2;
      } }, { key: "addPoints", value: function(r, o, a) {
        var l = r.getCoordinates();
        if (o) {
          var d = 1;
          a && (d = 0);
          for (var v = d; v < l.length; v++) this._pts.add(l[v]);
        } else {
          var x = l.length - 2;
          a && (x = l.length - 1);
          for (var w = x; w >= 0; w--) this._pts.add(l[w]);
        }
      } }, { key: "isHole", value: function() {
        return this._isHole;
      } }, { key: "setInResult", value: function() {
        var r = this._startDe;
        do
          r.getEdge().setInResult(!0), r = r.getNext();
        while (r !== this._startDe);
      } }, { key: "containsPoint", value: function(r) {
        var o = this.getLinearRing();
        if (!o.getEnvelopeInternal().contains(r) || !hu.isInRing(r, o.getCoordinates())) return !1;
        for (var a = this._holes.iterator(); a.hasNext(); )
          if (a.next().containsPoint(r)) return !1;
        return !0;
      } }, { key: "addHole", value: function(r) {
        this._holes.add(r);
      } }, { key: "isShell", value: function() {
        return this._shell === null;
      } }, { key: "getLabel", value: function() {
        return this._label;
      } }, { key: "getEdges", value: function() {
        return this._edges;
      } }, { key: "getMaxNodeDegree", value: function() {
        return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
      } }, { key: "getShell", value: function() {
        return this._shell;
      } }, { key: "mergeLabel", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          this.mergeLabel(r, 0), this.mergeLabel(r, 1);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1], l = o.getLocation(a, H.RIGHT);
          if (l === L.NONE) return null;
          if (this._label.getLocation(a) === L.NONE) return this._label.setLocation(a, l), null;
        }
      } }, { key: "setShell", value: function(r) {
        this._shell = r, r !== null && r.addHole(this);
      } }, { key: "toPolygon", value: function(r) {
        for (var o = new Array(this._holes.size()).fill(null), a = 0; a < this._holes.size(); a++) o[a] = this._holes.get(a).getLinearRing();
        return r.createPolygon(this.getLinearRing(), o);
      } }], [{ key: "constructor_", value: function() {
        if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new ut(), this._pts = new ut(), this._label = new Ke(L.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new ut(), this._geometryFactory = null, arguments.length !== 0) {
          if (arguments.length === 2) {
            var r = arguments[0], o = arguments[1];
            this._geometryFactory = o, this.computePoints(r), this.computeRing();
          }
        }
      } }]), f;
    }(), bp = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "setEdgeRing", value: function(a, l) {
        a.setMinEdgeRing(l);
      } }, { key: "getNext", value: function(a) {
        return a.getNextMin();
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        Lo.constructor_.call(this, a, l);
      } }]), o;
    }(Lo), Cp = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "buildMinimalRings", value: function() {
        var a = new ut(), l = this._startDe;
        do {
          if (l.getMinEdgeRing() === null) {
            var d = new bp(l, this._geometryFactory);
            a.add(d);
          }
          l = l.getNext();
        } while (l !== this._startDe);
        return a;
      } }, { key: "setEdgeRing", value: function(a, l) {
        a.setEdgeRing(l);
      } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function() {
        var a = this._startDe;
        do
          a.getNode().getEdges().linkMinimalDirectedEdges(this), a = a.getNext();
        while (a !== this._startDe);
      } }, { key: "getNext", value: function(a) {
        return a.getNext();
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        Lo.constructor_.call(this, a, l);
      } }]), o;
    }(Lo), Kh = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "setVisited", value: function(r) {
        this._isVisited = r;
      } }, { key: "setInResult", value: function(r) {
        this._isInResult = r;
      } }, { key: "isCovered", value: function() {
        return this._isCovered;
      } }, { key: "isCoveredSet", value: function() {
        return this._isCoveredSet;
      } }, { key: "setLabel", value: function(r) {
        this._label = r;
      } }, { key: "getLabel", value: function() {
        return this._label;
      } }, { key: "setCovered", value: function(r) {
        this._isCovered = r, this._isCoveredSet = !0;
      } }, { key: "updateIM", value: function(r) {
        X.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(r);
      } }, { key: "isInResult", value: function() {
        return this._isInResult;
      } }, { key: "isVisited", value: function() {
        return this._isVisited;
      } }], [{ key: "constructor_", value: function() {
        if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length !== 0) {
          if (arguments.length === 1) {
            var r = arguments[0];
            this._label = r;
          }
        }
      } }]), f;
    }(), To = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "isIncidentEdgeInResult", value: function() {
        for (var a = this.getEdges().getEdges().iterator(); a.hasNext(); )
          if (a.next().getEdge().isInResult()) return !0;
        return !1;
      } }, { key: "isIsolated", value: function() {
        return this._label.getGeometryCount() === 1;
      } }, { key: "getCoordinate", value: function() {
        return this._coord;
      } }, { key: "print", value: function(a) {
        a.println("node " + this._coord + " lbl: " + this._label);
      } }, { key: "computeIM", value: function(a) {
      } }, { key: "computeMergedLocation", value: function(a, l) {
        var d = L.NONE;
        if (d = this._label.getLocation(l), !a.isNull(l)) {
          var v = a.getLocation(l);
          d !== L.BOUNDARY && (d = v);
        }
        return d;
      } }, { key: "setLabel", value: function() {
        if (arguments.length !== 2 || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return S(h(o.prototype), "setLabel", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1];
        this._label === null ? this._label = new Ke(a, l) : this._label.setLocation(a, l);
      } }, { key: "getEdges", value: function() {
        return this._edges;
      } }, { key: "mergeLabel", value: function() {
        if (arguments[0] instanceof o) {
          var a = arguments[0];
          this.mergeLabel(a._label);
        } else if (arguments[0] instanceof Ke) for (var l = arguments[0], d = 0; d < 2; d++) {
          var v = this.computeMergedLocation(l, d), x = this._label.getLocation(d);
          x === L.NONE && this._label.setLocation(d, v);
        }
      } }, { key: "add", value: function(a) {
        this._edges.insert(a), a.setNode(this);
      } }, { key: "setLabelBoundary", value: function(a) {
        if (this._label === null) return null;
        var l = L.NONE;
        this._label !== null && (l = this._label.getLocation(a));
        var d = null;
        switch (l) {
          case L.BOUNDARY:
            d = L.INTERIOR;
            break;
          case L.INTERIOR:
          default:
            d = L.BOUNDARY;
        }
        this._label.setLocation(a, d);
      } }], [{ key: "constructor_", value: function() {
        this._coord = null, this._edges = null;
        var a = arguments[0], l = arguments[1];
        this._coord = a, this._edges = l, this._label = new Ke(0, L.NONE);
      } }]), o;
    }(Kh), Rp = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        return e(this, o), r.apply(this, arguments);
      }
      return o;
    }(Xh);
    function $h(f) {
      return f == null ? 0 : f.color;
    }
    function Mt(f) {
      return f == null ? null : f.parent;
    }
    function In(f, r) {
      f !== null && (f.color = r);
    }
    function cu(f) {
      return f == null ? null : f.left;
    }
    function Jh(f) {
      return f == null ? null : f.right;
    }
    var Is = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), (a = r.call(this)).root_ = null, a.size_ = 0, a;
      }
      return s(o, [{ key: "get", value: function(a) {
        for (var l = this.root_; l !== null; ) {
          var d = a.compareTo(l.key);
          if (d < 0) l = l.left;
          else {
            if (!(d > 0)) return l.value;
            l = l.right;
          }
        }
        return null;
      } }, { key: "put", value: function(a, l) {
        if (this.root_ === null) return this.root_ = { key: a, value: l, left: null, right: null, parent: null, color: 0, getValue: function() {
          return this.value;
        }, getKey: function() {
          return this.key;
        } }, this.size_ = 1, null;
        var d, v, x = this.root_;
        do
          if (d = x, (v = a.compareTo(x.key)) < 0) x = x.left;
          else {
            if (!(v > 0)) {
              var w = x.value;
              return x.value = l, w;
            }
            x = x.right;
          }
        while (x !== null);
        var k = { key: a, left: null, right: null, value: l, parent: d, color: 0, getValue: function() {
          return this.value;
        }, getKey: function() {
          return this.key;
        } };
        return v < 0 ? d.left = k : d.right = k, this.fixAfterInsertion(k), this.size_++, null;
      } }, { key: "fixAfterInsertion", value: function(a) {
        var l;
        for (a.color = 1; a != null && a !== this.root_ && a.parent.color === 1; ) Mt(a) === cu(Mt(Mt(a))) ? $h(l = Jh(Mt(Mt(a)))) === 1 ? (In(Mt(a), 0), In(l, 0), In(Mt(Mt(a)), 1), a = Mt(Mt(a))) : (a === Jh(Mt(a)) && (a = Mt(a), this.rotateLeft(a)), In(Mt(a), 0), In(Mt(Mt(a)), 1), this.rotateRight(Mt(Mt(a)))) : $h(l = cu(Mt(Mt(a)))) === 1 ? (In(Mt(a), 0), In(l, 0), In(Mt(Mt(a)), 1), a = Mt(Mt(a))) : (a === cu(Mt(a)) && (a = Mt(a), this.rotateRight(a)), In(Mt(a), 0), In(Mt(Mt(a)), 1), this.rotateLeft(Mt(Mt(a))));
        this.root_.color = 0;
      } }, { key: "values", value: function() {
        var a = new ut(), l = this.getFirstEntry();
        if (l !== null) for (a.add(l.value); (l = o.successor(l)) !== null; ) a.add(l.value);
        return a;
      } }, { key: "entrySet", value: function() {
        var a = new ie(), l = this.getFirstEntry();
        if (l !== null) for (a.add(l); (l = o.successor(l)) !== null; ) a.add(l);
        return a;
      } }, { key: "rotateLeft", value: function(a) {
        if (a != null) {
          var l = a.right;
          a.right = l.left, l.left != null && (l.left.parent = a), l.parent = a.parent, a.parent == null ? this.root_ = l : a.parent.left === a ? a.parent.left = l : a.parent.right = l, l.left = a, a.parent = l;
        }
      } }, { key: "rotateRight", value: function(a) {
        if (a != null) {
          var l = a.left;
          a.left = l.right, l.right != null && (l.right.parent = a), l.parent = a.parent, a.parent == null ? this.root_ = l : a.parent.right === a ? a.parent.right = l : a.parent.left = l, l.right = a, a.parent = l;
        }
      } }, { key: "getFirstEntry", value: function() {
        var a = this.root_;
        if (a != null) for (; a.left != null; ) a = a.left;
        return a;
      } }, { key: "size", value: function() {
        return this.size_;
      } }, { key: "containsKey", value: function(a) {
        for (var l = this.root_; l !== null; ) {
          var d = a.compareTo(l.key);
          if (d < 0) l = l.left;
          else {
            if (!(d > 0)) return !0;
            l = l.right;
          }
        }
        return !1;
      } }], [{ key: "successor", value: function(a) {
        var l;
        if (a === null) return null;
        if (a.right !== null) {
          for (l = a.right; l.left !== null; ) l = l.left;
          return l;
        }
        l = a.parent;
        for (var d = a; l !== null && d === l.right; ) d = l, l = l.parent;
        return l;
      } }]), o;
    }(Rp), Qh = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "find", value: function(r) {
        return this.nodeMap.get(r);
      } }, { key: "addNode", value: function() {
        if (arguments[0] instanceof B) {
          var r = arguments[0], o = this.nodeMap.get(r);
          return o === null && (o = this.nodeFact.createNode(r), this.nodeMap.put(r, o)), o;
        }
        if (arguments[0] instanceof To) {
          var a = arguments[0], l = this.nodeMap.get(a.getCoordinate());
          return l === null ? (this.nodeMap.put(a.getCoordinate(), a), a) : (l.mergeLabel(a), l);
        }
      } }, { key: "print", value: function(r) {
        for (var o = this.iterator(); o.hasNext(); )
          o.next().print(r);
      } }, { key: "iterator", value: function() {
        return this.nodeMap.values().iterator();
      } }, { key: "values", value: function() {
        return this.nodeMap.values();
      } }, { key: "getBoundaryNodes", value: function(r) {
        for (var o = new ut(), a = this.iterator(); a.hasNext(); ) {
          var l = a.next();
          l.getLabel().getLocation(r) === L.BOUNDARY && o.add(l);
        }
        return o;
      } }, { key: "add", value: function(r) {
        var o = r.getCoordinate();
        this.addNode(o).add(r);
      } }], [{ key: "constructor_", value: function() {
        this.nodeMap = new Is(), this.nodeFact = null;
        var r = arguments[0];
        this.nodeFact = r;
      } }]), f;
    }(), Ce = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "isNorthern", value: function(r) {
        return r === f.NE || r === f.NW;
      } }, { key: "isOpposite", value: function(r, o) {
        return r !== o && (r - o + 4) % 4 === 2;
      } }, { key: "commonHalfPlane", value: function(r, o) {
        if (r === o) return r;
        if ((r - o + 4) % 4 === 2) return -1;
        var a = r < o ? r : o;
        return a === 0 && (r > o ? r : o) === 3 ? 3 : a;
      } }, { key: "isInHalfPlane", value: function(r, o) {
        return o === f.SE ? r === f.SE || r === f.SW : r === o || r === o + 1;
      } }, { key: "quadrant", value: function() {
        if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var r = arguments[0], o = arguments[1];
          if (r === 0 && o === 0) throw new M("Cannot compute the quadrant for point ( " + r + ", " + o + " )");
          return r >= 0 ? o >= 0 ? f.NE : f.SE : o >= 0 ? f.NW : f.SW;
        }
        if (arguments[0] instanceof B && arguments[1] instanceof B) {
          var a = arguments[0], l = arguments[1];
          if (l.x === a.x && l.y === a.y) throw new M("Cannot compute the quadrant for two identical points " + a);
          return l.x >= a.x ? l.y >= a.y ? f.NE : f.SE : l.y >= a.y ? f.NW : f.SW;
        }
      } }]), f;
    }();
    Ce.NE = 0, Ce.NW = 1, Ce.SW = 2, Ce.SE = 3;
    var tc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "compareDirection", value: function(r) {
        return this._dx === r._dx && this._dy === r._dy ? 0 : this._quadrant > r._quadrant ? 1 : this._quadrant < r._quadrant ? -1 : ct.index(r._p0, r._p1, this._p1);
      } }, { key: "getDy", value: function() {
        return this._dy;
      } }, { key: "getCoordinate", value: function() {
        return this._p0;
      } }, { key: "setNode", value: function(r) {
        this._node = r;
      } }, { key: "print", value: function(r) {
        var o = Math.atan2(this._dy, this._dx), a = this.getClass().getName(), l = a.lastIndexOf("."), d = a.substring(l + 1);
        r.print("  " + d + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + o + "   " + this._label);
      } }, { key: "compareTo", value: function(r) {
        var o = r;
        return this.compareDirection(o);
      } }, { key: "getDirectedCoordinate", value: function() {
        return this._p1;
      } }, { key: "getDx", value: function() {
        return this._dx;
      } }, { key: "getLabel", value: function() {
        return this._label;
      } }, { key: "getEdge", value: function() {
        return this._edge;
      } }, { key: "getQuadrant", value: function() {
        return this._quadrant;
      } }, { key: "getNode", value: function() {
        return this._node;
      } }, { key: "toString", value: function() {
        var r = Math.atan2(this._dy, this._dx), o = this.getClass().getName(), a = o.lastIndexOf(".");
        return "  " + o.substring(a + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + r + "   " + this._label;
      } }, { key: "computeLabel", value: function(r) {
      } }, { key: "init", value: function(r, o) {
        this._p0 = r, this._p1 = o, this._dx = o.x - r.x, this._dy = o.y - r.y, this._quadrant = Ce.quadrant(this._dx, this._dy), X.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
      } }, { key: "interfaces_", get: function() {
        return [D];
      } }], [{ key: "constructor_", value: function() {
        if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
          var r = arguments[0];
          this._edge = r;
        } else if (arguments.length === 3) {
          var o = arguments[0], a = arguments[1], l = arguments[2];
          f.constructor_.call(this, o, a, l, null);
        } else if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], x = arguments[2], w = arguments[3];
          f.constructor_.call(this, d), this.init(v, x), this._label = w;
        }
      } }]), f;
    }(), fu = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "getNextMin", value: function() {
        return this._nextMin;
      } }, { key: "getDepth", value: function(a) {
        return this._depth[a];
      } }, { key: "setVisited", value: function(a) {
        this._isVisited = a;
      } }, { key: "computeDirectedLabel", value: function() {
        this._label = new Ke(this._edge.getLabel()), this._isForward || this._label.flip();
      } }, { key: "getNext", value: function() {
        return this._next;
      } }, { key: "setDepth", value: function(a, l) {
        if (this._depth[a] !== -999 && this._depth[a] !== l) throw new fe("assigned depths do not match", this.getCoordinate());
        this._depth[a] = l;
      } }, { key: "isInteriorAreaEdge", value: function() {
        for (var a = !0, l = 0; l < 2; l++) this._label.isArea(l) && this._label.getLocation(l, H.LEFT) === L.INTERIOR && this._label.getLocation(l, H.RIGHT) === L.INTERIOR || (a = !1);
        return a;
      } }, { key: "setNextMin", value: function(a) {
        this._nextMin = a;
      } }, { key: "print", value: function(a) {
        S(h(o.prototype), "print", this).call(this, a), a.print(" " + this._depth[H.LEFT] + "/" + this._depth[H.RIGHT]), a.print(" (" + this.getDepthDelta() + ")"), this._isInResult && a.print(" inResult");
      } }, { key: "setMinEdgeRing", value: function(a) {
        this._minEdgeRing = a;
      } }, { key: "isLineEdge", value: function() {
        var a = this._label.isLine(0) || this._label.isLine(1), l = !this._label.isArea(0) || this._label.allPositionsEqual(0, L.EXTERIOR), d = !this._label.isArea(1) || this._label.allPositionsEqual(1, L.EXTERIOR);
        return a && l && d;
      } }, { key: "setEdgeRing", value: function(a) {
        this._edgeRing = a;
      } }, { key: "getMinEdgeRing", value: function() {
        return this._minEdgeRing;
      } }, { key: "getDepthDelta", value: function() {
        var a = this._edge.getDepthDelta();
        return this._isForward || (a = -a), a;
      } }, { key: "setInResult", value: function(a) {
        this._isInResult = a;
      } }, { key: "getSym", value: function() {
        return this._sym;
      } }, { key: "isForward", value: function() {
        return this._isForward;
      } }, { key: "getEdge", value: function() {
        return this._edge;
      } }, { key: "printEdge", value: function(a) {
        this.print(a), a.print(" "), this._isForward ? this._edge.print(a) : this._edge.printReverse(a);
      } }, { key: "setSym", value: function(a) {
        this._sym = a;
      } }, { key: "setVisitedEdge", value: function(a) {
        this.setVisited(a), this._sym.setVisited(a);
      } }, { key: "setEdgeDepths", value: function(a, l) {
        var d = this.getEdge().getDepthDelta();
        this._isForward || (d = -d);
        var v = 1;
        a === H.LEFT && (v = -1);
        var x = H.opposite(a), w = l + d * v;
        this.setDepth(a, l), this.setDepth(x, w);
      } }, { key: "getEdgeRing", value: function() {
        return this._edgeRing;
      } }, { key: "isInResult", value: function() {
        return this._isInResult;
      } }, { key: "setNext", value: function(a) {
        this._next = a;
      } }, { key: "isVisited", value: function() {
        return this._isVisited;
      } }], [{ key: "constructor_", value: function() {
        this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
        var a = arguments[0], l = arguments[1];
        if (tc.constructor_.call(this, a), this._isForward = l, l) this.init(a.getCoordinate(0), a.getCoordinate(1));
        else {
          var d = a.getNumPoints() - 1;
          this.init(a.getCoordinate(d), a.getCoordinate(d - 1));
        }
        this.computeDirectedLabel();
      } }, { key: "depthFactor", value: function(a, l) {
        return a === L.EXTERIOR && l === L.INTERIOR ? 1 : a === L.INTERIOR && l === L.EXTERIOR ? -1 : 0;
      } }]), o;
    }(tc), ec = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "createNode", value: function(r) {
        return new To(r, null);
      } }]), f;
    }(), nc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "printEdges", value: function(r) {
        r.println("Edges:");
        for (var o = 0; o < this._edges.size(); o++) {
          r.println("edge " + o + ":");
          var a = this._edges.get(o);
          a.print(r), a.eiList.print(r);
        }
      } }, { key: "find", value: function(r) {
        return this._nodes.find(r);
      } }, { key: "addNode", value: function() {
        if (arguments[0] instanceof To) {
          var r = arguments[0];
          return this._nodes.addNode(r);
        }
        if (arguments[0] instanceof B) {
          var o = arguments[0];
          return this._nodes.addNode(o);
        }
      } }, { key: "getNodeIterator", value: function() {
        return this._nodes.iterator();
      } }, { key: "linkResultDirectedEdges", value: function() {
        for (var r = this._nodes.iterator(); r.hasNext(); )
          r.next().getEdges().linkResultDirectedEdges();
      } }, { key: "debugPrintln", value: function(r) {
        ge.out.println(r);
      } }, { key: "isBoundaryNode", value: function(r, o) {
        var a = this._nodes.find(o);
        if (a === null) return !1;
        var l = a.getLabel();
        return l !== null && l.getLocation(r) === L.BOUNDARY;
      } }, { key: "linkAllDirectedEdges", value: function() {
        for (var r = this._nodes.iterator(); r.hasNext(); )
          r.next().getEdges().linkAllDirectedEdges();
      } }, { key: "matchInSameDirection", value: function(r, o, a, l) {
        return !!r.equals(a) && ct.index(r, o, l) === ct.COLLINEAR && Ce.quadrant(r, o) === Ce.quadrant(a, l);
      } }, { key: "getEdgeEnds", value: function() {
        return this._edgeEndList;
      } }, { key: "debugPrint", value: function(r) {
        ge.out.print(r);
      } }, { key: "getEdgeIterator", value: function() {
        return this._edges.iterator();
      } }, { key: "findEdgeInSameDirection", value: function(r, o) {
        for (var a = 0; a < this._edges.size(); a++) {
          var l = this._edges.get(a), d = l.getCoordinates();
          if (this.matchInSameDirection(r, o, d[0], d[1]) || this.matchInSameDirection(r, o, d[d.length - 1], d[d.length - 2])) return l;
        }
        return null;
      } }, { key: "insertEdge", value: function(r) {
        this._edges.add(r);
      } }, { key: "findEdgeEnd", value: function(r) {
        for (var o = this.getEdgeEnds().iterator(); o.hasNext(); ) {
          var a = o.next();
          if (a.getEdge() === r) return a;
        }
        return null;
      } }, { key: "addEdges", value: function(r) {
        for (var o = r.iterator(); o.hasNext(); ) {
          var a = o.next();
          this._edges.add(a);
          var l = new fu(a, !0), d = new fu(a, !1);
          l.setSym(d), d.setSym(l), this.add(l), this.add(d);
        }
      } }, { key: "add", value: function(r) {
        this._nodes.add(r), this._edgeEndList.add(r);
      } }, { key: "getNodes", value: function() {
        return this._nodes.values();
      } }, { key: "findEdge", value: function(r, o) {
        for (var a = 0; a < this._edges.size(); a++) {
          var l = this._edges.get(a), d = l.getCoordinates();
          if (r.equals(d[0]) && o.equals(d[1])) return l;
        }
        return null;
      } }], [{ key: "constructor_", value: function() {
        if (this._edges = new ut(), this._nodes = null, this._edgeEndList = new ut(), arguments.length === 0) this._nodes = new Qh(new ec());
        else if (arguments.length === 1) {
          var r = arguments[0];
          this._nodes = new Qh(r);
        }
      } }, { key: "linkResultDirectedEdges", value: function(r) {
        for (var o = r.iterator(); o.hasNext(); )
          o.next().getEdges().linkResultDirectedEdges();
      } }]), f;
    }(), Lp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "sortShellsAndHoles", value: function(r, o, a) {
        for (var l = r.iterator(); l.hasNext(); ) {
          var d = l.next();
          d.isHole() ? a.add(d) : o.add(d);
        }
      } }, { key: "computePolygons", value: function(r) {
        for (var o = new ut(), a = r.iterator(); a.hasNext(); ) {
          var l = a.next().toPolygon(this._geometryFactory);
          o.add(l);
        }
        return o;
      } }, { key: "placeFreeHoles", value: function(r, o) {
        for (var a = o.iterator(); a.hasNext(); ) {
          var l = a.next();
          if (l.getShell() === null) {
            var d = f.findEdgeRingContaining(l, r);
            if (d === null) throw new fe("unable to assign hole to a shell", l.getCoordinate(0));
            l.setShell(d);
          }
        }
      } }, { key: "buildMinimalEdgeRings", value: function(r, o, a) {
        for (var l = new ut(), d = r.iterator(); d.hasNext(); ) {
          var v = d.next();
          if (v.getMaxNodeDegree() > 2) {
            v.linkDirectedEdgesForMinimalEdgeRings();
            var x = v.buildMinimalRings(), w = this.findShell(x);
            w !== null ? (this.placePolygonHoles(w, x), o.add(w)) : a.addAll(x);
          } else l.add(v);
        }
        return l;
      } }, { key: "buildMaximalEdgeRings", value: function(r) {
        for (var o = new ut(), a = r.iterator(); a.hasNext(); ) {
          var l = a.next();
          if (l.isInResult() && l.getLabel().isArea() && l.getEdgeRing() === null) {
            var d = new Cp(l, this._geometryFactory);
            o.add(d), d.setInResult();
          }
        }
        return o;
      } }, { key: "placePolygonHoles", value: function(r, o) {
        for (var a = o.iterator(); a.hasNext(); ) {
          var l = a.next();
          l.isHole() && l.setShell(r);
        }
      } }, { key: "getPolygons", value: function() {
        return this.computePolygons(this._shellList);
      } }, { key: "findShell", value: function(r) {
        for (var o = 0, a = null, l = r.iterator(); l.hasNext(); ) {
          var d = l.next();
          d.isHole() || (a = d, o++);
        }
        return X.isTrue(o <= 1, "found two shells in MinimalEdgeRing list"), a;
      } }, { key: "add", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          this.add(r.getEdgeEnds(), r.getNodes());
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          nc.linkResultDirectedEdges(a);
          var l = this.buildMaximalEdgeRings(o), d = new ut(), v = this.buildMinimalEdgeRings(l, this._shellList, d);
          this.sortShellsAndHoles(v, this._shellList, d), this.placeFreeHoles(this._shellList, d);
        }
      } }], [{ key: "constructor_", value: function() {
        this._geometryFactory = null, this._shellList = new ut();
        var r = arguments[0];
        this._geometryFactory = r;
      } }, { key: "findEdgeRingContaining", value: function(r, o) {
        for (var a = r.getLinearRing(), l = a.getEnvelopeInternal(), d = a.getCoordinateN(0), v = null, x = null, w = o.iterator(); w.hasNext(); ) {
          var k = w.next(), N = k.getLinearRing(), P = N.getEnvelopeInternal();
          if (!P.equals(l) && P.contains(l)) {
            d = ne.ptNotInList(a.getCoordinates(), N.getCoordinates());
            var W = !1;
            hu.isInRing(d, N.getCoordinates()) && (W = !0), W && (v === null || x.contains(P)) && (x = (v = k).getLinearRing().getEnvelopeInternal());
          }
        }
        return v;
      } }]), f;
    }(), ic = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "getBounds", value: function() {
      } }]), f;
    }(), Wn = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getItem", value: function() {
        return this._item;
      } }, { key: "getBounds", value: function() {
        return this._bounds;
      } }, { key: "interfaces_", get: function() {
        return [ic, A];
      } }], [{ key: "constructor_", value: function() {
        this._bounds = null, this._item = null;
        var r = arguments[0], o = arguments[1];
        this._bounds = r, this._item = o;
      } }]), f;
    }(), No = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "poll", value: function() {
        if (this.isEmpty()) return null;
        var r = this._items.get(1);
        return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), r;
      } }, { key: "size", value: function() {
        return this._size;
      } }, { key: "reorder", value: function(r) {
        for (var o = null, a = this._items.get(r); 2 * r <= this._size && ((o = 2 * r) !== this._size && this._items.get(o + 1).compareTo(this._items.get(o)) < 0 && o++, this._items.get(o).compareTo(a) < 0); r = o) this._items.set(r, this._items.get(o));
        this._items.set(r, a);
      } }, { key: "clear", value: function() {
        this._size = 0, this._items.clear();
      } }, { key: "peek", value: function() {
        return this.isEmpty() ? null : this._items.get(1);
      } }, { key: "isEmpty", value: function() {
        return this._size === 0;
      } }, { key: "add", value: function(r) {
        this._items.add(null), this._size += 1;
        var o = this._size;
        for (this._items.set(0, r); r.compareTo(this._items.get(Math.trunc(o / 2))) < 0; o /= 2) this._items.set(o, this._items.get(Math.trunc(o / 2)));
        this._items.set(o, r);
      } }], [{ key: "constructor_", value: function() {
        this._size = null, this._items = null, this._size = 0, this._items = new ut(), this._items.add(null);
      } }]), f;
    }(), Tp = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "insert", value: function(r, o) {
      } }, { key: "remove", value: function(r, o) {
      } }, { key: "query", value: function() {
      } }]), f;
    }(), $e = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getLevel", value: function() {
        return this._level;
      } }, { key: "size", value: function() {
        return this._childBoundables.size();
      } }, { key: "getChildBoundables", value: function() {
        return this._childBoundables;
      } }, { key: "addChildBoundable", value: function(r) {
        X.isTrue(this._bounds === null), this._childBoundables.add(r);
      } }, { key: "isEmpty", value: function() {
        return this._childBoundables.isEmpty();
      } }, { key: "getBounds", value: function() {
        return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
      } }, { key: "interfaces_", get: function() {
        return [ic, A];
      } }], [{ key: "constructor_", value: function() {
        if (this._childBoundables = new ut(), this._bounds = null, this._level = null, arguments.length !== 0) {
          if (arguments.length === 1) {
            var r = arguments[0];
            this._level = r;
          }
        }
      } }]), f;
    }(), Tr = { reverseOrder: function() {
      return { compare: function(f, r) {
        return r.compareTo(f);
      } };
    }, min: function(f) {
      return Tr.sort(f), f.get(0);
    }, sort: function(f, r) {
      var o = f.toArray();
      r ? Bt.sort(o, r) : Bt.sort(o);
      for (var a = f.iterator(), l = 0, d = o.length; l < d; l++) a.next(), a.set(o[l]);
    }, singletonList: function(f) {
      var r = new ut();
      return r.add(f), r;
    } }, Np = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "maxDistance", value: function(r, o, a, l, d, v, x, w) {
        var k = f.distance(r, o, d, v);
        return k = Math.max(k, f.distance(r, o, x, w)), k = Math.max(k, f.distance(a, l, d, v)), k = Math.max(k, f.distance(a, l, x, w));
      } }, { key: "distance", value: function(r, o, a, l) {
        var d = a - r, v = l - o;
        return Math.sqrt(d * d + v * v);
      } }, { key: "maximumDistance", value: function(r, o) {
        var a = Math.min(r.getMinX(), o.getMinX()), l = Math.min(r.getMinY(), o.getMinY()), d = Math.max(r.getMaxX(), o.getMaxX()), v = Math.max(r.getMaxY(), o.getMaxY());
        return f.distance(a, l, d, v);
      } }, { key: "minMaxDistance", value: function(r, o) {
        var a = r.getMinX(), l = r.getMinY(), d = r.getMaxX(), v = r.getMaxY(), x = o.getMinX(), w = o.getMinY(), k = o.getMaxX(), N = o.getMaxY(), P = f.maxDistance(a, l, a, v, x, w, x, N);
        return P = Math.min(P, f.maxDistance(a, l, a, v, x, w, k, w)), P = Math.min(P, f.maxDistance(a, l, a, v, k, N, x, N)), P = Math.min(P, f.maxDistance(a, l, a, v, k, N, k, w)), P = Math.min(P, f.maxDistance(a, l, d, l, x, w, x, N)), P = Math.min(P, f.maxDistance(a, l, d, l, x, w, k, w)), P = Math.min(P, f.maxDistance(a, l, d, l, k, N, x, N)), P = Math.min(P, f.maxDistance(a, l, d, l, k, N, k, w)), P = Math.min(P, f.maxDistance(d, v, a, v, x, w, x, N)), P = Math.min(P, f.maxDistance(d, v, a, v, x, w, k, w)), P = Math.min(P, f.maxDistance(d, v, a, v, k, N, x, N)), P = Math.min(P, f.maxDistance(d, v, a, v, k, N, k, w)), P = Math.min(P, f.maxDistance(d, v, d, l, x, w, x, N)), P = Math.min(P, f.maxDistance(d, v, d, l, x, w, k, w)), P = Math.min(P, f.maxDistance(d, v, d, l, k, N, x, N)), P = Math.min(P, f.maxDistance(d, v, d, l, k, N, k, w));
      } }]), f;
    }(), Nr = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "maximumDistance", value: function() {
        return Np.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
      } }, { key: "expandToQueue", value: function(r, o) {
        var a = f.isComposite(this._boundable1), l = f.isComposite(this._boundable2);
        if (a && l) return f.area(this._boundable1) > f.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, r, o), null) : (this.expand(this._boundable2, this._boundable1, !0, r, o), null);
        if (a) return this.expand(this._boundable1, this._boundable2, !1, r, o), null;
        if (l) return this.expand(this._boundable2, this._boundable1, !0, r, o), null;
        throw new M("neither boundable is composite");
      } }, { key: "isLeaves", value: function() {
        return !(f.isComposite(this._boundable1) || f.isComposite(this._boundable2));
      } }, { key: "compareTo", value: function(r) {
        var o = r;
        return this._distance < o._distance ? -1 : this._distance > o._distance ? 1 : 0;
      } }, { key: "expand", value: function(r, o, a, l, d) {
        for (var v = r.getChildBoundables().iterator(); v.hasNext(); ) {
          var x = v.next(), w = null;
          (w = a ? new f(o, x, this._itemDistance) : new f(x, o, this._itemDistance)).getDistance() < d && l.add(w);
        }
      } }, { key: "getBoundable", value: function(r) {
        return r === 0 ? this._boundable1 : this._boundable2;
      } }, { key: "getDistance", value: function() {
        return this._distance;
      } }, { key: "distance", value: function() {
        return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
      } }, { key: "interfaces_", get: function() {
        return [D];
      } }], [{ key: "constructor_", value: function() {
        this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
        var r = arguments[0], o = arguments[1], a = arguments[2];
        this._boundable1 = r, this._boundable2 = o, this._itemDistance = a, this._distance = this.distance();
      } }, { key: "area", value: function(r) {
        return r.getBounds().getArea();
      } }, { key: "isComposite", value: function(r) {
        return r instanceof $e;
      } }]), f;
    }(), rc = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "visitItem", value: function(r) {
      } }]), f;
    }(), Mr = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "queryInternal", value: function() {
        if (ht(arguments[2], rc) && arguments[0] instanceof Object && arguments[1] instanceof $e) for (var r = arguments[0], o = arguments[1], a = arguments[2], l = o.getChildBoundables(), d = 0; d < l.size(); d++) {
          var v = l.get(d);
          this.getIntersectsOp().intersects(v.getBounds(), r) && (v instanceof $e ? this.queryInternal(r, v, a) : v instanceof Wn ? a.visitItem(v.getItem()) : X.shouldNeverReachHere());
        }
        else if (ht(arguments[2], re) && arguments[0] instanceof Object && arguments[1] instanceof $e) for (var x = arguments[0], w = arguments[1], k = arguments[2], N = w.getChildBoundables(), P = 0; P < N.size(); P++) {
          var W = N.get(P);
          this.getIntersectsOp().intersects(W.getBounds(), x) && (W instanceof $e ? this.queryInternal(x, W, k) : W instanceof Wn ? k.add(W.getItem()) : X.shouldNeverReachHere());
        }
      } }, { key: "getNodeCapacity", value: function() {
        return this._nodeCapacity;
      } }, { key: "lastNode", value: function(r) {
        return r.get(r.size() - 1);
      } }, { key: "size", value: function() {
        if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
        if (arguments.length === 1) {
          for (var r = arguments[0], o = 0, a = r.getChildBoundables().iterator(); a.hasNext(); ) {
            var l = a.next();
            l instanceof $e ? o += this.size(l) : l instanceof Wn && (o += 1);
          }
          return o;
        }
      } }, { key: "removeItem", value: function(r, o) {
        for (var a = null, l = r.getChildBoundables().iterator(); l.hasNext(); ) {
          var d = l.next();
          d instanceof Wn && d.getItem() === o && (a = d);
        }
        return a !== null && (r.getChildBoundables().remove(a), !0);
      } }, { key: "itemsTree", value: function() {
        if (arguments.length === 0) {
          this.build();
          var r = this.itemsTree(this._root);
          return r === null ? new ut() : r;
        }
        if (arguments.length === 1) {
          for (var o = arguments[0], a = new ut(), l = o.getChildBoundables().iterator(); l.hasNext(); ) {
            var d = l.next();
            if (d instanceof $e) {
              var v = this.itemsTree(d);
              v !== null && a.add(v);
            } else d instanceof Wn ? a.add(d.getItem()) : X.shouldNeverReachHere();
          }
          return a.size() <= 0 ? null : a;
        }
      } }, { key: "insert", value: function(r, o) {
        X.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new Wn(r, o));
      } }, { key: "boundablesAtLevel", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0], o = new ut();
          return this.boundablesAtLevel(r, this._root, o), o;
        }
        if (arguments.length === 3) {
          var a = arguments[0], l = arguments[1], d = arguments[2];
          if (X.isTrue(a > -2), l.getLevel() === a) return d.add(l), null;
          for (var v = l.getChildBoundables().iterator(); v.hasNext(); ) {
            var x = v.next();
            x instanceof $e ? this.boundablesAtLevel(a, x, d) : (X.isTrue(x instanceof Wn), a === -1 && d.add(x));
          }
          return null;
        }
      } }, { key: "query", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          this.build();
          var o = new ut();
          return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), r) && this.queryInternal(r, this._root, o), o;
        }
        if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          if (this.build(), this.isEmpty()) return null;
          this.getIntersectsOp().intersects(this._root.getBounds(), a) && this.queryInternal(a, this._root, l);
        }
      } }, { key: "build", value: function() {
        if (this._built) return null;
        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
      } }, { key: "getRoot", value: function() {
        return this.build(), this._root;
      } }, { key: "remove", value: function() {
        if (arguments.length === 2) {
          var r = arguments[0], o = arguments[1];
          return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), r) && this.remove(r, this._root, o);
        }
        if (arguments.length === 3) {
          var a = arguments[0], l = arguments[1], d = arguments[2], v = this.removeItem(l, d);
          if (v) return !0;
          for (var x = null, w = l.getChildBoundables().iterator(); w.hasNext(); ) {
            var k = w.next();
            if (this.getIntersectsOp().intersects(k.getBounds(), a) && k instanceof $e && (v = this.remove(a, k, d))) {
              x = k;
              break;
            }
          }
          return x !== null && x.getChildBoundables().isEmpty() && l.getChildBoundables().remove(x), v;
        }
      } }, { key: "createHigherLevels", value: function(r, o) {
        X.isTrue(!r.isEmpty());
        var a = this.createParentBoundables(r, o + 1);
        return a.size() === 1 ? a.get(0) : this.createHigherLevels(a, o + 1);
      } }, { key: "depth", value: function() {
        if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
        if (arguments.length === 1) {
          for (var r = arguments[0], o = 0, a = r.getChildBoundables().iterator(); a.hasNext(); ) {
            var l = a.next();
            if (l instanceof $e) {
              var d = this.depth(l);
              d > o && (o = d);
            }
          }
          return o + 1;
        }
      } }, { key: "createParentBoundables", value: function(r, o) {
        X.isTrue(!r.isEmpty());
        var a = new ut();
        a.add(this.createNode(o));
        var l = new ut(r);
        Tr.sort(l, this.getComparator());
        for (var d = l.iterator(); d.hasNext(); ) {
          var v = d.next();
          this.lastNode(a).getChildBoundables().size() === this.getNodeCapacity() && a.add(this.createNode(o)), this.lastNode(a).addChildBoundable(v);
        }
        return a;
      } }, { key: "isEmpty", value: function() {
        return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
      } }, { key: "interfaces_", get: function() {
        return [A];
      } }], [{ key: "constructor_", value: function() {
        if (this._root = null, this._built = !1, this._itemBoundables = new ut(), this._nodeCapacity = null, arguments.length === 0) f.constructor_.call(this, f.DEFAULT_NODE_CAPACITY);
        else if (arguments.length === 1) {
          var r = arguments[0];
          X.isTrue(r > 1, "Node capacity must be greater than 1"), this._nodeCapacity = r;
        }
      } }, { key: "compareDoubles", value: function(r, o) {
        return r > o ? 1 : r < o ? -1 : 0;
      } }]), f;
    }();
    Mr.IntersectsOp = function() {
    }, Mr.DEFAULT_NODE_CAPACITY = 10;
    var Mp = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "distance", value: function(r, o) {
      } }]), f;
    }(), kn = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "createParentBoundablesFromVerticalSlices", value: function(a, l) {
        X.isTrue(a.length > 0);
        for (var d = new ut(), v = 0; v < a.length; v++) d.addAll(this.createParentBoundablesFromVerticalSlice(a[v], l));
        return d;
      } }, { key: "nearestNeighbourK", value: function() {
        if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          return this.nearestNeighbourK(a, Q.POSITIVE_INFINITY, l);
        }
        if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], x = arguments[2], w = v, k = new No();
          k.add(d);
          for (var N = new No(); !k.isEmpty() && w >= 0; ) {
            var P = k.poll(), W = P.getDistance();
            if (W >= w) break;
            if (P.isLeaves()) if (N.size() < x) N.add(P);
            else {
              var tt = N.peek();
              tt.getDistance() > W && (N.poll(), N.add(P));
              var $ = N.peek();
              w = $.getDistance();
            }
            else P.expandToQueue(k, w);
          }
          return o.getItems(N);
        }
      } }, { key: "createNode", value: function(a) {
        return new sc(a);
      } }, { key: "size", value: function() {
        return arguments.length === 0 ? S(h(o.prototype), "size", this).call(this) : S(h(o.prototype), "size", this).apply(this, arguments);
      } }, { key: "insert", value: function() {
        if (!(arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Ot)) return S(h(o.prototype), "insert", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1];
        if (a.isNull()) return null;
        S(h(o.prototype), "insert", this).call(this, a, l);
      } }, { key: "getIntersectsOp", value: function() {
        return o.intersectsOp;
      } }, { key: "verticalSlices", value: function(a, l) {
        for (var d = Math.trunc(Math.ceil(a.size() / l)), v = new Array(l).fill(null), x = a.iterator(), w = 0; w < l; w++) {
          v[w] = new ut();
          for (var k = 0; x.hasNext() && k < d; ) {
            var N = x.next();
            v[w].add(N), k++;
          }
        }
        return v;
      } }, { key: "query", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0];
          return S(h(o.prototype), "query", this).call(this, a);
        }
        if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          S(h(o.prototype), "query", this).call(this, l, d);
        }
      } }, { key: "getComparator", value: function() {
        return o.yComparator;
      } }, { key: "createParentBoundablesFromVerticalSlice", value: function(a, l) {
        return S(h(o.prototype), "createParentBoundables", this).call(this, a, l);
      } }, { key: "remove", value: function() {
        if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Ot) {
          var a = arguments[0], l = arguments[1];
          return S(h(o.prototype), "remove", this).call(this, a, l);
        }
        return S(h(o.prototype), "remove", this).apply(this, arguments);
      } }, { key: "depth", value: function() {
        return arguments.length === 0 ? S(h(o.prototype), "depth", this).call(this) : S(h(o.prototype), "depth", this).apply(this, arguments);
      } }, { key: "createParentBoundables", value: function(a, l) {
        X.isTrue(!a.isEmpty());
        var d = Math.trunc(Math.ceil(a.size() / this.getNodeCapacity())), v = new ut(a);
        Tr.sort(v, o.xComparator);
        var x = this.verticalSlices(v, Math.trunc(Math.ceil(Math.sqrt(d))));
        return this.createParentBoundablesFromVerticalSlices(x, l);
      } }, { key: "nearestNeighbour", value: function() {
        if (arguments.length === 1) {
          if (ht(arguments[0], Mp)) {
            var a = arguments[0];
            if (this.isEmpty()) return null;
            var l = new Nr(this.getRoot(), this.getRoot(), a);
            return this.nearestNeighbour(l);
          }
          if (arguments[0] instanceof Nr) {
            var d = arguments[0], v = Q.POSITIVE_INFINITY, x = null, w = new No();
            for (w.add(d); !w.isEmpty() && v > 0; ) {
              var k = w.poll(), N = k.getDistance();
              if (N >= v) break;
              k.isLeaves() ? (v = N, x = k) : k.expandToQueue(w, v);
            }
            return x === null ? null : [x.getBoundable(0).getItem(), x.getBoundable(1).getItem()];
          }
        } else {
          if (arguments.length === 2) {
            var P = arguments[0], W = arguments[1];
            if (this.isEmpty() || P.isEmpty()) return null;
            var tt = new Nr(this.getRoot(), P.getRoot(), W);
            return this.nearestNeighbour(tt);
          }
          if (arguments.length === 3) {
            var $ = arguments[0], ot = arguments[1], ft = arguments[2], pt = new Wn($, ot), Pt = new Nr(this.getRoot(), pt, ft);
            return this.nearestNeighbour(Pt)[0];
          }
          if (arguments.length === 4) {
            var Zt = arguments[0], _e = arguments[1], ze = arguments[2], cn = arguments[3], Xn = new Wn(Zt, _e), ji = new Nr(this.getRoot(), Xn, ze);
            return this.nearestNeighbourK(ji, cn);
          }
        }
      } }, { key: "isWithinDistance", value: function() {
        if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1], d = Q.POSITIVE_INFINITY, v = new No();
          for (v.add(a); !v.isEmpty(); ) {
            var x = v.poll(), w = x.getDistance();
            if (w > l) return !1;
            if (x.maximumDistance() <= l) return !0;
            if (x.isLeaves()) {
              if ((d = w) <= l) return !0;
            } else x.expandToQueue(v, d);
          }
          return !1;
        }
        if (arguments.length === 3) {
          var k = arguments[0], N = arguments[1], P = arguments[2], W = new Nr(this.getRoot(), k.getRoot(), N);
          return this.isWithinDistance(W, P);
        }
      } }, { key: "interfaces_", get: function() {
        return [Tp, A];
      } }], [{ key: "constructor_", value: function() {
        if (arguments.length === 0) o.constructor_.call(this, o.DEFAULT_NODE_CAPACITY);
        else if (arguments.length === 1) {
          var a = arguments[0];
          Mr.constructor_.call(this, a);
        }
      } }, { key: "centreX", value: function(a) {
        return o.avg(a.getMinX(), a.getMaxX());
      } }, { key: "avg", value: function(a, l) {
        return (a + l) / 2;
      } }, { key: "getItems", value: function(a) {
        for (var l = new Array(a.size()).fill(null), d = 0; !a.isEmpty(); ) {
          var v = a.poll();
          l[d] = v.getBoundable(0).getItem(), d++;
        }
        return l;
      } }, { key: "centreY", value: function(a) {
        return o.avg(a.getMinY(), a.getMaxY());
      } }]), o;
    }(Mr), sc = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "computeBounds", value: function() {
        for (var a = null, l = this.getChildBoundables().iterator(); l.hasNext(); ) {
          var d = l.next();
          a === null ? a = new Ot(d.getBounds()) : a.expandToInclude(d.getBounds());
        }
        return a;
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0];
        $e.constructor_.call(this, a);
      } }]), o;
    }($e);
    kn.STRtreeNode = sc, kn.xComparator = new (function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "interfaces_", get: function() {
        return [_t];
      } }, { key: "compare", value: function(r, o) {
        return Mr.compareDoubles(kn.centreX(r.getBounds()), kn.centreX(o.getBounds()));
      } }]), f;
    }())(), kn.yComparator = new (function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "interfaces_", get: function() {
        return [_t];
      } }, { key: "compare", value: function(r, o) {
        return Mr.compareDoubles(kn.centreY(r.getBounds()), kn.centreY(o.getBounds()));
      } }]), f;
    }())(), kn.intersectsOp = new (function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "interfaces_", get: function() {
        return [IntersectsOp];
      } }, { key: "intersects", value: function(r, o) {
        return r.intersects(o);
      } }]), f;
    }())(), kn.DEFAULT_NODE_CAPACITY = 10;
    var Op = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "relativeSign", value: function(r, o) {
        return r < o ? -1 : r > o ? 1 : 0;
      } }, { key: "compare", value: function(r, o, a) {
        if (o.equals2D(a)) return 0;
        var l = f.relativeSign(o.x, a.x), d = f.relativeSign(o.y, a.y);
        switch (r) {
          case 0:
            return f.compareValue(l, d);
          case 1:
            return f.compareValue(d, l);
          case 2:
            return f.compareValue(d, -l);
          case 3:
            return f.compareValue(-l, d);
          case 4:
            return f.compareValue(-l, -d);
          case 5:
            return f.compareValue(-d, -l);
          case 6:
            return f.compareValue(-d, l);
          case 7:
            return f.compareValue(l, -d);
        }
        return X.shouldNeverReachHere("invalid octant value"), 0;
      } }, { key: "compareValue", value: function(r, o) {
        return r < 0 ? -1 : r > 0 ? 1 : o < 0 ? -1 : o > 0 ? 1 : 0;
      } }]), f;
    }(), Ap = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getCoordinate", value: function() {
        return this.coord;
      } }, { key: "print", value: function(r) {
        r.print(this.coord), r.print(" seg # = " + this.segmentIndex);
      } }, { key: "compareTo", value: function(r) {
        var o = r;
        return this.segmentIndex < o.segmentIndex ? -1 : this.segmentIndex > o.segmentIndex ? 1 : this.coord.equals2D(o.coord) ? 0 : this._isInterior ? o._isInterior ? Op.compare(this._segmentOctant, this.coord, o.coord) : 1 : -1;
      } }, { key: "isEndPoint", value: function(r) {
        return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === r;
      } }, { key: "toString", value: function() {
        return this.segmentIndex + ":" + this.coord.toString();
      } }, { key: "isInterior", value: function() {
        return this._isInterior;
      } }, { key: "interfaces_", get: function() {
        return [D];
      } }], [{ key: "constructor_", value: function() {
        this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
        var r = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
        this._segString = r, this.coord = new B(o), this.segmentIndex = a, this._segmentOctant = l, this._isInterior = !o.equals2D(r.getCoordinate(a));
      } }]), f;
    }(), Pp = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "hasNext", value: function() {
      } }, { key: "next", value: function() {
      } }, { key: "remove", value: function() {
      } }]), f;
    }(), Dp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getSplitCoordinates", value: function() {
        var r = new xs();
        this.addEndpoints();
        for (var o = this.iterator(), a = o.next(); o.hasNext(); ) {
          var l = o.next();
          this.addEdgeCoordinates(a, l, r), a = l;
        }
        return r.toCoordinateArray();
      } }, { key: "addCollapsedNodes", value: function() {
        var r = new ut();
        this.findCollapsesFromInsertedNodes(r), this.findCollapsesFromExistingVertices(r);
        for (var o = r.iterator(); o.hasNext(); ) {
          var a = o.next().intValue();
          this.add(this._edge.getCoordinate(a), a);
        }
      } }, { key: "createSplitEdgePts", value: function(r, o) {
        var a = o.segmentIndex - r.segmentIndex + 2;
        if (a === 2) return [new B(r.coord), new B(o.coord)];
        var l = this._edge.getCoordinate(o.segmentIndex), d = o.isInterior() || !o.coord.equals2D(l);
        d || a--;
        var v = new Array(a).fill(null), x = 0;
        v[x++] = new B(r.coord);
        for (var w = r.segmentIndex + 1; w <= o.segmentIndex; w++) v[x++] = this._edge.getCoordinate(w);
        return d && (v[x] = new B(o.coord)), v;
      } }, { key: "print", value: function(r) {
        r.println("Intersections:");
        for (var o = this.iterator(); o.hasNext(); )
          o.next().print(r);
      } }, { key: "findCollapsesFromExistingVertices", value: function(r) {
        for (var o = 0; o < this._edge.size() - 2; o++) {
          var a = this._edge.getCoordinate(o);
          this._edge.getCoordinate(o + 1);
          var l = this._edge.getCoordinate(o + 2);
          a.equals2D(l) && r.add(ce.valueOf(o + 1));
        }
      } }, { key: "addEdgeCoordinates", value: function(r, o, a) {
        var l = this.createSplitEdgePts(r, o);
        a.add(l, !1);
      } }, { key: "iterator", value: function() {
        return this._nodeMap.values().iterator();
      } }, { key: "addSplitEdges", value: function(r) {
        this.addEndpoints(), this.addCollapsedNodes();
        for (var o = this.iterator(), a = o.next(); o.hasNext(); ) {
          var l = o.next(), d = this.createSplitEdge(a, l);
          r.add(d), a = l;
        }
      } }, { key: "findCollapseIndex", value: function(r, o, a) {
        if (!r.coord.equals2D(o.coord)) return !1;
        var l = o.segmentIndex - r.segmentIndex;
        return o.isInterior() || l--, l === 1 && (a[0] = r.segmentIndex + 1, !0);
      } }, { key: "findCollapsesFromInsertedNodes", value: function(r) {
        for (var o = new Array(1).fill(null), a = this.iterator(), l = a.next(); a.hasNext(); ) {
          var d = a.next();
          this.findCollapseIndex(l, d, o) && r.add(ce.valueOf(o[0])), l = d;
        }
      } }, { key: "getEdge", value: function() {
        return this._edge;
      } }, { key: "addEndpoints", value: function() {
        var r = this._edge.size() - 1;
        this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(r), r);
      } }, { key: "createSplitEdge", value: function(r, o) {
        var a = this.createSplitEdgePts(r, o);
        return new Ui(a, this._edge.getData());
      } }, { key: "add", value: function(r, o) {
        var a = new Ap(this._edge, r, o, this._edge.getSegmentOctant(o)), l = this._nodeMap.get(a);
        return l !== null ? (X.isTrue(l.coord.equals2D(r), "Found equal nodes with different coordinates"), l) : (this._nodeMap.put(a, a), a);
      } }, { key: "checkSplitEdgesCorrectness", value: function(r) {
        var o = this._edge.getCoordinates(), a = r.get(0).getCoordinate(0);
        if (!a.equals2D(o[0])) throw new Et("bad split edge start point at " + a);
        var l = r.get(r.size() - 1).getCoordinates(), d = l[l.length - 1];
        if (!d.equals2D(o[o.length - 1])) throw new Et("bad split edge end point at " + d);
      } }], [{ key: "constructor_", value: function() {
        this._nodeMap = new Is(), this._edge = null;
        var r = arguments[0];
        this._edge = r;
      } }]), f;
    }(), Fp = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "octant", value: function() {
        if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var r = arguments[0], o = arguments[1];
          if (r === 0 && o === 0) throw new M("Cannot compute the octant for point ( " + r + ", " + o + " )");
          var a = Math.abs(r), l = Math.abs(o);
          return r >= 0 ? o >= 0 ? a >= l ? 0 : 1 : a >= l ? 7 : 6 : o >= 0 ? a >= l ? 3 : 2 : a >= l ? 4 : 5;
        }
        if (arguments[0] instanceof B && arguments[1] instanceof B) {
          var d = arguments[0], v = arguments[1], x = v.x - d.x, w = v.y - d.y;
          if (x === 0 && w === 0) throw new M("Cannot compute the octant for two identical points " + d);
          return f.octant(x, w);
        }
      } }]), f;
    }(), Gp = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "getCoordinates", value: function() {
      } }, { key: "size", value: function() {
      } }, { key: "getCoordinate", value: function(r) {
      } }, { key: "isClosed", value: function() {
      } }, { key: "setData", value: function(r) {
      } }, { key: "getData", value: function() {
      } }]), f;
    }(), Bp = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "addIntersection", value: function(r, o) {
      } }, { key: "interfaces_", get: function() {
        return [Gp];
      } }]), f;
    }(), Ui = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getCoordinates", value: function() {
        return this._pts;
      } }, { key: "size", value: function() {
        return this._pts.length;
      } }, { key: "getCoordinate", value: function(r) {
        return this._pts[r];
      } }, { key: "isClosed", value: function() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
      } }, { key: "getSegmentOctant", value: function(r) {
        return r === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(r), this.getCoordinate(r + 1));
      } }, { key: "setData", value: function(r) {
        this._data = r;
      } }, { key: "safeOctant", value: function(r, o) {
        return r.equals2D(o) ? 0 : Fp.octant(r, o);
      } }, { key: "getData", value: function() {
        return this._data;
      } }, { key: "addIntersection", value: function() {
        if (arguments.length === 2) {
          var r = arguments[0], o = arguments[1];
          this.addIntersectionNode(r, o);
        } else if (arguments.length === 4) {
          var a = arguments[0], l = arguments[1], d = arguments[3], v = new B(a.getIntersection(d));
          this.addIntersection(v, l);
        }
      } }, { key: "toString", value: function() {
        return lu.toLineString(new Ss(this._pts));
      } }, { key: "getNodeList", value: function() {
        return this._nodeList;
      } }, { key: "addIntersectionNode", value: function(r, o) {
        var a = o, l = a + 1;
        if (l < this._pts.length) {
          var d = this._pts[l];
          r.equals2D(d) && (a = l);
        }
        return this._nodeList.add(r, a);
      } }, { key: "addIntersections", value: function(r, o, a) {
        for (var l = 0; l < r.getIntersectionNum(); l++) this.addIntersection(r, o, a, l);
      } }, { key: "interfaces_", get: function() {
        return [Bp];
      } }], [{ key: "constructor_", value: function() {
        this._nodeList = new Dp(this), this._pts = null, this._data = null;
        var r = arguments[0], o = arguments[1];
        this._pts = r, this._data = o;
      } }, { key: "getNodedSubstrings", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0], o = new ut();
          return f.getNodedSubstrings(r, o), o;
        }
        if (arguments.length === 2) for (var a = arguments[0], l = arguments[1], d = a.iterator(); d.hasNext(); ) {
          var v = d.next();
          v.getNodeList().addSplitEdges(l);
        }
      } }]), f;
    }(), Ge = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "minX", value: function() {
        return Math.min(this.p0.x, this.p1.x);
      } }, { key: "orientationIndex", value: function() {
        if (arguments[0] instanceof f) {
          var r = arguments[0], o = ct.index(this.p0, this.p1, r.p0), a = ct.index(this.p0, this.p1, r.p1);
          return o >= 0 && a >= 0 || o <= 0 && a <= 0 ? Math.max(o, a) : 0;
        }
        if (arguments[0] instanceof B) {
          var l = arguments[0];
          return ct.index(this.p0, this.p1, l);
        }
      } }, { key: "toGeometry", value: function(r) {
        return r.createLineString([this.p0, this.p1]);
      } }, { key: "isVertical", value: function() {
        return this.p0.x === this.p1.x;
      } }, { key: "equals", value: function(r) {
        if (!(r instanceof f)) return !1;
        var o = r;
        return this.p0.equals(o.p0) && this.p1.equals(o.p1);
      } }, { key: "intersection", value: function(r) {
        var o = new qi();
        return o.computeIntersection(this.p0, this.p1, r.p0, r.p1), o.hasIntersection() ? o.getIntersection(0) : null;
      } }, { key: "project", value: function() {
        if (arguments[0] instanceof B) {
          var r = arguments[0];
          if (r.equals(this.p0) || r.equals(this.p1)) return new B(r);
          var o = this.projectionFactor(r), a = new B();
          return a.x = this.p0.x + o * (this.p1.x - this.p0.x), a.y = this.p0.y + o * (this.p1.y - this.p0.y), a;
        }
        if (arguments[0] instanceof f) {
          var l = arguments[0], d = this.projectionFactor(l.p0), v = this.projectionFactor(l.p1);
          if (d >= 1 && v >= 1 || d <= 0 && v <= 0) return null;
          var x = this.project(l.p0);
          d < 0 && (x = this.p0), d > 1 && (x = this.p1);
          var w = this.project(l.p1);
          return v < 0 && (w = this.p0), v > 1 && (w = this.p1), new f(x, w);
        }
      } }, { key: "normalize", value: function() {
        this.p1.compareTo(this.p0) < 0 && this.reverse();
      } }, { key: "angle", value: function() {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
      } }, { key: "getCoordinate", value: function(r) {
        return r === 0 ? this.p0 : this.p1;
      } }, { key: "distancePerpendicular", value: function(r) {
        return se.pointToLinePerpendicular(r, this.p0, this.p1);
      } }, { key: "minY", value: function() {
        return Math.min(this.p0.y, this.p1.y);
      } }, { key: "midPoint", value: function() {
        return f.midPoint(this.p0, this.p1);
      } }, { key: "projectionFactor", value: function(r) {
        if (r.equals(this.p0)) return 0;
        if (r.equals(this.p1)) return 1;
        var o = this.p1.x - this.p0.x, a = this.p1.y - this.p0.y, l = o * o + a * a;
        return l <= 0 ? Q.NaN : ((r.x - this.p0.x) * o + (r.y - this.p0.y) * a) / l;
      } }, { key: "closestPoints", value: function(r) {
        var o = this.intersection(r);
        if (o !== null) return [o, o];
        var a = new Array(2).fill(null), l = Q.MAX_VALUE, d = null, v = this.closestPoint(r.p0);
        l = v.distance(r.p0), a[0] = v, a[1] = r.p0;
        var x = this.closestPoint(r.p1);
        (d = x.distance(r.p1)) < l && (l = d, a[0] = x, a[1] = r.p1);
        var w = r.closestPoint(this.p0);
        (d = w.distance(this.p0)) < l && (l = d, a[0] = this.p0, a[1] = w);
        var k = r.closestPoint(this.p1);
        return (d = k.distance(this.p1)) < l && (l = d, a[0] = this.p1, a[1] = k), a;
      } }, { key: "closestPoint", value: function(r) {
        var o = this.projectionFactor(r);
        return o > 0 && o < 1 ? this.project(r) : this.p0.distance(r) < this.p1.distance(r) ? this.p0 : this.p1;
      } }, { key: "maxX", value: function() {
        return Math.max(this.p0.x, this.p1.x);
      } }, { key: "getLength", value: function() {
        return this.p0.distance(this.p1);
      } }, { key: "compareTo", value: function(r) {
        var o = r, a = this.p0.compareTo(o.p0);
        return a !== 0 ? a : this.p1.compareTo(o.p1);
      } }, { key: "reverse", value: function() {
        var r = this.p0;
        this.p0 = this.p1, this.p1 = r;
      } }, { key: "equalsTopo", value: function(r) {
        return this.p0.equals(r.p0) && this.p1.equals(r.p1) || this.p0.equals(r.p1) && this.p1.equals(r.p0);
      } }, { key: "lineIntersection", value: function(r) {
        return zn.intersection(this.p0, this.p1, r.p0, r.p1);
      } }, { key: "maxY", value: function() {
        return Math.max(this.p0.y, this.p1.y);
      } }, { key: "pointAlongOffset", value: function(r, o) {
        var a = this.p0.x + r * (this.p1.x - this.p0.x), l = this.p0.y + r * (this.p1.y - this.p0.y), d = this.p1.x - this.p0.x, v = this.p1.y - this.p0.y, x = Math.sqrt(d * d + v * v), w = 0, k = 0;
        if (o !== 0) {
          if (x <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
          w = o * d / x, k = o * v / x;
        }
        return new B(a - k, l + w);
      } }, { key: "setCoordinates", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          this.setCoordinates(r.p0, r.p1);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this.p0.x = o.x, this.p0.y = o.y, this.p1.x = a.x, this.p1.y = a.y;
        }
      } }, { key: "segmentFraction", value: function(r) {
        var o = this.projectionFactor(r);
        return o < 0 ? o = 0 : (o > 1 || Q.isNaN(o)) && (o = 1), o;
      } }, { key: "toString", value: function() {
        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
      } }, { key: "isHorizontal", value: function() {
        return this.p0.y === this.p1.y;
      } }, { key: "reflect", value: function(r) {
        var o = this.p1.getY() - this.p0.getY(), a = this.p0.getX() - this.p1.getX(), l = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), d = o * o + a * a, v = o * o - a * a, x = r.getX(), w = r.getY();
        return new B((-v * x - 2 * o * a * w - 2 * o * l) / d, (v * w - 2 * o * a * x - 2 * a * l) / d);
      } }, { key: "distance", value: function() {
        if (arguments[0] instanceof f) {
          var r = arguments[0];
          return se.segmentToSegment(this.p0, this.p1, r.p0, r.p1);
        }
        if (arguments[0] instanceof B) {
          var o = arguments[0];
          return se.pointToSegment(o, this.p0, this.p1);
        }
      } }, { key: "pointAlong", value: function(r) {
        var o = new B();
        return o.x = this.p0.x + r * (this.p1.x - this.p0.x), o.y = this.p0.y + r * (this.p1.y - this.p0.y), o;
      } }, { key: "hashCode", value: function() {
        var r = Q.doubleToLongBits(this.p0.x);
        r ^= 31 * Q.doubleToLongBits(this.p0.y);
        var o = Math.trunc(r) ^ Math.trunc(r >> 32), a = Q.doubleToLongBits(this.p1.x);
        return a ^= 31 * Q.doubleToLongBits(this.p1.y), o ^ (Math.trunc(a) ^ Math.trunc(a >> 32));
      } }, { key: "interfaces_", get: function() {
        return [D, A];
      } }], [{ key: "constructor_", value: function() {
        if (this.p0 = null, this.p1 = null, arguments.length === 0) f.constructor_.call(this, new B(), new B());
        else if (arguments.length === 1) {
          var r = arguments[0];
          f.constructor_.call(this, r.p0, r.p1);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this.p0 = o, this.p1 = a;
        } else if (arguments.length === 4) {
          var l = arguments[0], d = arguments[1], v = arguments[2], x = arguments[3];
          f.constructor_.call(this, new B(l, d), new B(v, x));
        }
      } }, { key: "midPoint", value: function(r, o) {
        return new B((r.x + o.x) / 2, (r.y + o.y) / 2);
      } }]), f;
    }(), zp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "overlap", value: function() {
        if (arguments.length !== 2) {
          if (arguments.length === 4) {
            var r = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
            r.getLineSegment(o, this._overlapSeg1), a.getLineSegment(l, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        }
      } }], [{ key: "constructor_", value: function() {
        this._overlapSeg1 = new Ge(), this._overlapSeg2 = new Ge();
      } }]), f;
    }(), oc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getLineSegment", value: function(r, o) {
        o.p0 = this._pts[r], o.p1 = this._pts[r + 1];
      } }, { key: "computeSelect", value: function(r, o, a, l) {
        var d = this._pts[o], v = this._pts[a];
        if (a - o == 1) return l.select(this, o), null;
        if (!r.intersects(d, v)) return null;
        var x = Math.trunc((o + a) / 2);
        o < x && this.computeSelect(r, o, x, l), x < a && this.computeSelect(r, x, a, l);
      } }, { key: "getCoordinates", value: function() {
        for (var r = new Array(this._end - this._start + 1).fill(null), o = 0, a = this._start; a <= this._end; a++) r[o++] = this._pts[a];
        return r;
      } }, { key: "computeOverlaps", value: function() {
        if (arguments.length === 2) {
          var r = arguments[0], o = arguments[1];
          this.computeOverlaps(this._start, this._end, r, r._start, r._end, o);
        } else if (arguments.length === 6) {
          var a = arguments[0], l = arguments[1], d = arguments[2], v = arguments[3], x = arguments[4], w = arguments[5];
          if (l - a == 1 && x - v == 1) return w.overlap(this, a, d, v), null;
          if (!this.overlaps(a, l, d, v, x)) return null;
          var k = Math.trunc((a + l) / 2), N = Math.trunc((v + x) / 2);
          a < k && (v < N && this.computeOverlaps(a, k, d, v, N, w), N < x && this.computeOverlaps(a, k, d, N, x, w)), k < l && (v < N && this.computeOverlaps(k, l, d, v, N, w), N < x && this.computeOverlaps(k, l, d, N, x, w));
        }
      } }, { key: "setId", value: function(r) {
        this._id = r;
      } }, { key: "select", value: function(r, o) {
        this.computeSelect(r, this._start, this._end, o);
      } }, { key: "getEnvelope", value: function() {
        if (this._env === null) {
          var r = this._pts[this._start], o = this._pts[this._end];
          this._env = new Ot(r, o);
        }
        return this._env;
      } }, { key: "overlaps", value: function(r, o, a, l, d) {
        return Ot.intersects(this._pts[r], this._pts[o], a._pts[l], a._pts[d]);
      } }, { key: "getEndIndex", value: function() {
        return this._end;
      } }, { key: "getStartIndex", value: function() {
        return this._start;
      } }, { key: "getContext", value: function() {
        return this._context;
      } }, { key: "getId", value: function() {
        return this._id;
      } }], [{ key: "constructor_", value: function() {
        this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
        var r = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
        this._pts = r, this._start = o, this._end = a, this._context = l;
      } }]), f;
    }(), Yp = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "findChainEnd", value: function(r, o) {
        for (var a = o; a < r.length - 1 && r[a].equals2D(r[a + 1]); ) a++;
        if (a >= r.length - 1) return r.length - 1;
        for (var l = Ce.quadrant(r[a], r[a + 1]), d = o + 1; d < r.length && !(!r[d - 1].equals2D(r[d]) && Ce.quadrant(r[d - 1], r[d]) !== l); )
          d++;
        return d - 1;
      } }, { key: "getChains", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          return f.getChains(r, null);
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1], l = new ut(), d = 0;
          do {
            var v = f.findChainEnd(o, d), x = new oc(o, d, v, a);
            l.add(x), d = v;
          } while (d < o.length - 1);
          return l;
        }
      } }]), f;
    }(), gu = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "computeNodes", value: function(r) {
      } }, { key: "getNodedSubstrings", value: function() {
      } }]), f;
    }(), ac = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "setSegmentIntersector", value: function(r) {
        this._segInt = r;
      } }, { key: "interfaces_", get: function() {
        return [gu];
      } }], [{ key: "constructor_", value: function() {
        if (this._segInt = null, arguments.length !== 0) {
          if (arguments.length === 1) {
            var r = arguments[0];
            this.setSegmentIntersector(r);
          }
        }
      } }]), f;
    }(), du = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "getMonotoneChains", value: function() {
        return this._monoChains;
      } }, { key: "getNodedSubstrings", value: function() {
        return Ui.getNodedSubstrings(this._nodedSegStrings);
      } }, { key: "getIndex", value: function() {
        return this._index;
      } }, { key: "add", value: function(a) {
        for (var l = Yp.getChains(a.getCoordinates(), a).iterator(); l.hasNext(); ) {
          var d = l.next();
          d.setId(this._idCounter++), this._index.insert(d.getEnvelope(), d), this._monoChains.add(d);
        }
      } }, { key: "computeNodes", value: function(a) {
        this._nodedSegStrings = a;
        for (var l = a.iterator(); l.hasNext(); ) this.add(l.next());
        this.intersectChains();
      } }, { key: "intersectChains", value: function() {
        for (var a = new uc(this._segInt), l = this._monoChains.iterator(); l.hasNext(); ) for (var d = l.next(), v = this._index.query(d.getEnvelope()).iterator(); v.hasNext(); ) {
          var x = v.next();
          if (x.getId() > d.getId() && (d.computeOverlaps(x, a), this._nOverlaps++), this._segInt.isDone()) return null;
        }
      } }], [{ key: "constructor_", value: function() {
        if (this._monoChains = new ut(), this._index = new kn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, arguments.length !== 0) {
          if (arguments.length === 1) {
            var a = arguments[0];
            ac.constructor_.call(this, a);
          }
        }
      } }]), o;
    }(ac), uc = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "overlap", value: function() {
        if (arguments.length !== 4) return S(h(o.prototype), "overlap", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1], d = arguments[2], v = arguments[3], x = a.getContext(), w = d.getContext();
        this._si.processIntersections(x, l, w, v);
      } }], [{ key: "constructor_", value: function() {
        this._si = null;
        var a = arguments[0];
        this._si = a;
      } }]), o;
    }(zp);
    du.SegmentOverlapAction = uc;
    var hn = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "isDeletable", value: function(r, o, a, l) {
        var d = this._inputLine[r], v = this._inputLine[o], x = this._inputLine[a];
        return !!this.isConcave(d, v, x) && !!this.isShallow(d, v, x, l) && this.isShallowSampled(d, v, r, a, l);
      } }, { key: "deleteShallowConcavities", value: function() {
        for (var r = 1, o = this.findNextNonDeletedIndex(r), a = this.findNextNonDeletedIndex(o), l = !1; a < this._inputLine.length; ) {
          var d = !1;
          this.isDeletable(r, o, a, this._distanceTol) && (this._isDeleted[o] = f.DELETE, d = !0, l = !0), r = d ? a : o, o = this.findNextNonDeletedIndex(r), a = this.findNextNonDeletedIndex(o);
        }
        return l;
      } }, { key: "isShallowConcavity", value: function(r, o, a, l) {
        return ct.index(r, o, a) === this._angleOrientation && se.pointToSegment(o, r, a) < l;
      } }, { key: "isShallowSampled", value: function(r, o, a, l, d) {
        var v = Math.trunc((l - a) / f.NUM_PTS_TO_CHECK);
        v <= 0 && (v = 1);
        for (var x = a; x < l; x += v) if (!this.isShallow(r, o, this._inputLine[x], d)) return !1;
        return !0;
      } }, { key: "isConcave", value: function(r, o, a) {
        var l = ct.index(r, o, a) === this._angleOrientation;
        return l;
      } }, { key: "simplify", value: function(r) {
        this._distanceTol = Math.abs(r), r < 0 && (this._angleOrientation = ct.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
        var o = !1;
        do
          o = this.deleteShallowConcavities();
        while (o);
        return this.collapseLine();
      } }, { key: "findNextNonDeletedIndex", value: function(r) {
        for (var o = r + 1; o < this._inputLine.length && this._isDeleted[o] === f.DELETE; ) o++;
        return o;
      } }, { key: "isShallow", value: function(r, o, a, l) {
        return se.pointToSegment(o, r, a) < l;
      } }, { key: "collapseLine", value: function() {
        for (var r = new xs(), o = 0; o < this._inputLine.length; o++) this._isDeleted[o] !== f.DELETE && r.add(this._inputLine[o]);
        return r.toCoordinateArray();
      } }], [{ key: "constructor_", value: function() {
        this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ct.COUNTERCLOCKWISE;
        var r = arguments[0];
        this._inputLine = r;
      } }, { key: "simplify", value: function(r, o) {
        return new f(r).simplify(o);
      } }]), f;
    }();
    hn.INIT = 0, hn.DELETE = 1, hn.KEEP = 1, hn.NUM_PTS_TO_CHECK = 10;
    var lc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getCoordinates", value: function() {
        return this._ptList.toArray(f.COORDINATE_ARRAY_TYPE);
      } }, { key: "setPrecisionModel", value: function(r) {
        this._precisionModel = r;
      } }, { key: "addPt", value: function(r) {
        var o = new B(r);
        if (this._precisionModel.makePrecise(o), this.isRedundant(o)) return null;
        this._ptList.add(o);
      } }, { key: "reverse", value: function() {
      } }, { key: "addPts", value: function(r, o) {
        if (o) for (var a = 0; a < r.length; a++) this.addPt(r[a]);
        else for (var l = r.length - 1; l >= 0; l--) this.addPt(r[l]);
      } }, { key: "isRedundant", value: function(r) {
        if (this._ptList.size() < 1) return !1;
        var o = this._ptList.get(this._ptList.size() - 1);
        return r.distance(o) < this._minimimVertexDistance;
      } }, { key: "toString", value: function() {
        return new Rr().createLineString(this.getCoordinates()).toString();
      } }, { key: "closeRing", value: function() {
        if (this._ptList.size() < 1) return null;
        var r = new B(this._ptList.get(0)), o = this._ptList.get(this._ptList.size() - 1);
        if (r.equals(o)) return null;
        this._ptList.add(r);
      } }, { key: "setMinimumVertexDistance", value: function(r) {
        this._minimimVertexDistance = r;
      } }], [{ key: "constructor_", value: function() {
        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new ut();
      } }]), f;
    }();
    lc.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
    var Be = function() {
      function f() {
        e(this, f);
      }
      return s(f, null, [{ key: "toDegrees", value: function(r) {
        return 180 * r / Math.PI;
      } }, { key: "normalize", value: function(r) {
        for (; r > Math.PI; ) r -= f.PI_TIMES_2;
        for (; r <= -Math.PI; ) r += f.PI_TIMES_2;
        return r;
      } }, { key: "angle", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          return Math.atan2(r.y, r.x);
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1], l = a.x - o.x, d = a.y - o.y;
          return Math.atan2(d, l);
        }
      } }, { key: "isAcute", value: function(r, o, a) {
        var l = r.x - o.x, d = r.y - o.y;
        return l * (a.x - o.x) + d * (a.y - o.y) > 0;
      } }, { key: "isObtuse", value: function(r, o, a) {
        var l = r.x - o.x, d = r.y - o.y;
        return l * (a.x - o.x) + d * (a.y - o.y) < 0;
      } }, { key: "interiorAngle", value: function(r, o, a) {
        var l = f.angle(o, r), d = f.angle(o, a);
        return Math.abs(d - l);
      } }, { key: "normalizePositive", value: function(r) {
        if (r < 0) {
          for (; r < 0; ) r += f.PI_TIMES_2;
          r >= f.PI_TIMES_2 && (r = 0);
        } else {
          for (; r >= f.PI_TIMES_2; ) r -= f.PI_TIMES_2;
          r < 0 && (r = 0);
        }
        return r;
      } }, { key: "angleBetween", value: function(r, o, a) {
        var l = f.angle(o, r), d = f.angle(o, a);
        return f.diff(l, d);
      } }, { key: "diff", value: function(r, o) {
        var a = null;
        return (a = r < o ? o - r : r - o) > Math.PI && (a = 2 * Math.PI - a), a;
      } }, { key: "toRadians", value: function(r) {
        return r * Math.PI / 180;
      } }, { key: "getTurn", value: function(r, o) {
        var a = Math.sin(o - r);
        return a > 0 ? f.COUNTERCLOCKWISE : a < 0 ? f.CLOCKWISE : f.NONE;
      } }, { key: "angleBetweenOriented", value: function(r, o, a) {
        var l = f.angle(o, r), d = f.angle(o, a) - l;
        return d <= -Math.PI ? d + f.PI_TIMES_2 : d > Math.PI ? d - f.PI_TIMES_2 : d;
      } }]), f;
    }();
    Be.PI_TIMES_2 = 2 * Math.PI, Be.PI_OVER_2 = Math.PI / 2, Be.PI_OVER_4 = Math.PI / 4, Be.COUNTERCLOCKWISE = ct.COUNTERCLOCKWISE, Be.CLOCKWISE = ct.CLOCKWISE, Be.NONE = ct.COLLINEAR;
    var ks = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "addNextSegment", value: function(r, o) {
        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = r, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
        var a = ct.index(this._s0, this._s1, this._s2), l = a === ct.CLOCKWISE && this._side === H.LEFT || a === ct.COUNTERCLOCKWISE && this._side === H.RIGHT;
        a === 0 ? this.addCollinear(o) : l ? this.addOutsideTurn(a, o) : this.addInsideTurn(a, o);
      } }, { key: "addLineEndCap", value: function(r, o) {
        var a = new Ge(r, o), l = new Ge();
        this.computeOffsetSegment(a, H.LEFT, this._distance, l);
        var d = new Ge();
        this.computeOffsetSegment(a, H.RIGHT, this._distance, d);
        var v = o.x - r.x, x = o.y - r.y, w = Math.atan2(x, v);
        switch (this._bufParams.getEndCapStyle()) {
          case T.CAP_ROUND:
            this._segList.addPt(l.p1), this.addDirectedFillet(o, w + Math.PI / 2, w - Math.PI / 2, ct.CLOCKWISE, this._distance), this._segList.addPt(d.p1);
            break;
          case T.CAP_FLAT:
            this._segList.addPt(l.p1), this._segList.addPt(d.p1);
            break;
          case T.CAP_SQUARE:
            var k = new B();
            k.x = Math.abs(this._distance) * Math.cos(w), k.y = Math.abs(this._distance) * Math.sin(w);
            var N = new B(l.p1.x + k.x, l.p1.y + k.y), P = new B(d.p1.x + k.x, d.p1.y + k.y);
            this._segList.addPt(N), this._segList.addPt(P);
        }
      } }, { key: "getCoordinates", value: function() {
        return this._segList.getCoordinates();
      } }, { key: "addMitreJoin", value: function(r, o, a, l) {
        var d = zn.intersection(o.p0, o.p1, a.p0, a.p1);
        if (d !== null && (l <= 0 ? 1 : d.distance(r) / Math.abs(l)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(d), null;
        this.addLimitedMitreJoin(o, a, l, this._bufParams.getMitreLimit());
      } }, { key: "addOutsideTurn", value: function(r, o) {
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * f.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
        this._bufParams.getJoinStyle() === T.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === T.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (o && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, r, this._distance), this._segList.addPt(this._offset1.p0));
      } }, { key: "createSquare", value: function(r) {
        this._segList.addPt(new B(r.x + this._distance, r.y + this._distance)), this._segList.addPt(new B(r.x + this._distance, r.y - this._distance)), this._segList.addPt(new B(r.x - this._distance, r.y - this._distance)), this._segList.addPt(new B(r.x - this._distance, r.y + this._distance)), this._segList.closeRing();
      } }, { key: "addSegments", value: function(r, o) {
        this._segList.addPts(r, o);
      } }, { key: "addFirstSegment", value: function() {
        this._segList.addPt(this._offset1.p0);
      } }, { key: "addCornerFillet", value: function(r, o, a, l, d) {
        var v = o.x - r.x, x = o.y - r.y, w = Math.atan2(x, v), k = a.x - r.x, N = a.y - r.y, P = Math.atan2(N, k);
        l === ct.CLOCKWISE ? w <= P && (w += 2 * Math.PI) : w >= P && (w -= 2 * Math.PI), this._segList.addPt(o), this.addDirectedFillet(r, w, P, l, d), this._segList.addPt(a);
      } }, { key: "addLastSegment", value: function() {
        this._segList.addPt(this._offset1.p1);
      } }, { key: "initSideSegments", value: function(r, o, a) {
        this._s1 = r, this._s2 = o, this._side = a, this._seg1.setCoordinates(r, o), this.computeOffsetSegment(this._seg1, a, this._distance, this._offset1);
      } }, { key: "addLimitedMitreJoin", value: function(r, o, a, l) {
        var d = this._seg0.p1, v = Be.angle(d, this._seg0.p0), x = Be.angleBetweenOriented(this._seg0.p0, d, this._seg1.p1) / 2, w = Be.normalize(v + x), k = Be.normalize(w + Math.PI), N = l * a, P = a - N * Math.abs(Math.sin(x)), W = d.x + N * Math.cos(k), tt = d.y + N * Math.sin(k), $ = new B(W, tt), ot = new Ge(d, $), ft = ot.pointAlongOffset(1, P), pt = ot.pointAlongOffset(1, -P);
        this._side === H.LEFT ? (this._segList.addPt(ft), this._segList.addPt(pt)) : (this._segList.addPt(pt), this._segList.addPt(ft));
      } }, { key: "addDirectedFillet", value: function(r, o, a, l, d) {
        var v = l === ct.CLOCKWISE ? -1 : 1, x = Math.abs(o - a), w = Math.trunc(x / this._filletAngleQuantum + 0.5);
        if (w < 1) return null;
        for (var k = x / w, N = new B(), P = 0; P < w; P++) {
          var W = o + v * P * k;
          N.x = r.x + d * Math.cos(W), N.y = r.y + d * Math.sin(W), this._segList.addPt(N);
        }
      } }, { key: "computeOffsetSegment", value: function(r, o, a, l) {
        var d = o === H.LEFT ? 1 : -1, v = r.p1.x - r.p0.x, x = r.p1.y - r.p0.y, w = Math.sqrt(v * v + x * x), k = d * a * v / w, N = d * a * x / w;
        l.p0.x = r.p0.x - N, l.p0.y = r.p0.y + k, l.p1.x = r.p1.x - N, l.p1.y = r.p1.y + k;
      } }, { key: "addInsideTurn", value: function(r, o) {
        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
        else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * f.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
        else {
          if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
            var a = new B((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(a);
            var l = new B((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(l);
          } else this._segList.addPt(this._s1);
          this._segList.addPt(this._offset1.p0);
        }
      } }, { key: "createCircle", value: function(r) {
        var o = new B(r.x + this._distance, r.y);
        this._segList.addPt(o), this.addDirectedFillet(r, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
      } }, { key: "addBevelJoin", value: function(r, o) {
        this._segList.addPt(r.p1), this._segList.addPt(o.p0);
      } }, { key: "init", value: function(r) {
        this._distance = r, this._maxCurveSegmentError = r * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new lc(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(r * f.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
      } }, { key: "addCollinear", value: function(r) {
        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === T.JOIN_BEVEL || this._bufParams.getJoinStyle() === T.JOIN_MITRE ? (r && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ct.CLOCKWISE, this._distance));
      } }, { key: "closeRing", value: function() {
        this._segList.closeRing();
      } }, { key: "hasNarrowConcaveAngle", value: function() {
        return this._hasNarrowConcaveAngle;
      } }], [{ key: "constructor_", value: function() {
        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new Ge(), this._seg1 = new Ge(), this._offset0 = new Ge(), this._offset1 = new Ge(), this._side = 0, this._hasNarrowConcaveAngle = !1;
        var r = arguments[0], o = arguments[1], a = arguments[2];
        this._precisionModel = r, this._bufParams = o, this._li = new qi(), this._filletAngleQuantum = Math.PI / 2 / o.getQuadrantSegments(), o.getQuadrantSegments() >= 8 && o.getJoinStyle() === T.JOIN_ROUND && (this._closingSegLengthFactor = f.MAX_CLOSING_SEG_LEN_FACTOR), this.init(a);
      } }]), f;
    }();
    ks.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, ks.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, ks.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, ks.MAX_CLOSING_SEG_LEN_FACTOR = 80;
    var Wp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getOffsetCurve", value: function(r, o) {
        if (this._distance = o, o === 0) return null;
        var a = o < 0, l = Math.abs(o), d = this.getSegGen(l);
        r.length <= 1 ? this.computePointCurve(r[0], d) : this.computeOffsetCurve(r, a, d);
        var v = d.getCoordinates();
        return a && ne.reverse(v), v;
      } }, { key: "computeSingleSidedBufferCurve", value: function(r, o, a) {
        var l = this.simplifyTolerance(this._distance);
        if (o) {
          a.addSegments(r, !0);
          var d = hn.simplify(r, -l), v = d.length - 1;
          a.initSideSegments(d[v], d[v - 1], H.LEFT), a.addFirstSegment();
          for (var x = v - 2; x >= 0; x--) a.addNextSegment(d[x], !0);
        } else {
          a.addSegments(r, !1);
          var w = hn.simplify(r, l), k = w.length - 1;
          a.initSideSegments(w[0], w[1], H.LEFT), a.addFirstSegment();
          for (var N = 2; N <= k; N++) a.addNextSegment(w[N], !0);
        }
        a.addLastSegment(), a.closeRing();
      } }, { key: "computeRingBufferCurve", value: function(r, o, a) {
        var l = this.simplifyTolerance(this._distance);
        o === H.RIGHT && (l = -l);
        var d = hn.simplify(r, l), v = d.length - 1;
        a.initSideSegments(d[v - 1], d[0], o);
        for (var x = 1; x <= v; x++) {
          var w = x !== 1;
          a.addNextSegment(d[x], w);
        }
        a.closeRing();
      } }, { key: "computeLineBufferCurve", value: function(r, o) {
        var a = this.simplifyTolerance(this._distance), l = hn.simplify(r, a), d = l.length - 1;
        o.initSideSegments(l[0], l[1], H.LEFT);
        for (var v = 2; v <= d; v++) o.addNextSegment(l[v], !0);
        o.addLastSegment(), o.addLineEndCap(l[d - 1], l[d]);
        var x = hn.simplify(r, -a), w = x.length - 1;
        o.initSideSegments(x[w], x[w - 1], H.LEFT);
        for (var k = w - 2; k >= 0; k--) o.addNextSegment(x[k], !0);
        o.addLastSegment(), o.addLineEndCap(x[1], x[0]), o.closeRing();
      } }, { key: "computePointCurve", value: function(r, o) {
        switch (this._bufParams.getEndCapStyle()) {
          case T.CAP_ROUND:
            o.createCircle(r);
            break;
          case T.CAP_SQUARE:
            o.createSquare(r);
        }
      } }, { key: "getLineCurve", value: function(r, o) {
        if (this._distance = o, this.isLineOffsetEmpty(o)) return null;
        var a = Math.abs(o), l = this.getSegGen(a);
        if (r.length <= 1) this.computePointCurve(r[0], l);
        else if (this._bufParams.isSingleSided()) {
          var d = o < 0;
          this.computeSingleSidedBufferCurve(r, d, l);
        } else this.computeLineBufferCurve(r, l);
        return l.getCoordinates();
      } }, { key: "getBufferParameters", value: function() {
        return this._bufParams;
      } }, { key: "simplifyTolerance", value: function(r) {
        return r * this._bufParams.getSimplifyFactor();
      } }, { key: "getRingCurve", value: function(r, o, a) {
        if (this._distance = a, r.length <= 2) return this.getLineCurve(r, a);
        if (a === 0) return f.copyCoordinates(r);
        var l = this.getSegGen(a);
        return this.computeRingBufferCurve(r, o, l), l.getCoordinates();
      } }, { key: "computeOffsetCurve", value: function(r, o, a) {
        var l = this.simplifyTolerance(this._distance);
        if (o) {
          var d = hn.simplify(r, -l), v = d.length - 1;
          a.initSideSegments(d[v], d[v - 1], H.LEFT), a.addFirstSegment();
          for (var x = v - 2; x >= 0; x--) a.addNextSegment(d[x], !0);
        } else {
          var w = hn.simplify(r, l), k = w.length - 1;
          a.initSideSegments(w[0], w[1], H.LEFT), a.addFirstSegment();
          for (var N = 2; N <= k; N++) a.addNextSegment(w[N], !0);
        }
        a.addLastSegment();
      } }, { key: "isLineOffsetEmpty", value: function(r) {
        return r === 0 || r < 0 && !this._bufParams.isSingleSided();
      } }, { key: "getSegGen", value: function(r) {
        return new ks(this._precisionModel, this._bufParams, r);
      } }], [{ key: "constructor_", value: function() {
        this._distance = 0, this._precisionModel = null, this._bufParams = null;
        var r = arguments[0], o = arguments[1];
        this._precisionModel = r, this._bufParams = o;
      } }, { key: "copyCoordinates", value: function(r) {
        for (var o = new Array(r.length).fill(null), a = 0; a < o.length; a++) o[a] = new B(r[a]);
        return o;
      } }]), f;
    }(), hc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "findStabbedSegments", value: function() {
        if (arguments.length === 1) {
          for (var r = arguments[0], o = new ut(), a = this._subgraphs.iterator(); a.hasNext(); ) {
            var l = a.next(), d = l.getEnvelope();
            r.y < d.getMinY() || r.y > d.getMaxY() || this.findStabbedSegments(r, l.getDirectedEdges(), o);
          }
          return o;
        }
        if (arguments.length === 3) {
          if (ht(arguments[2], re) && arguments[0] instanceof B && arguments[1] instanceof fu) for (var v = arguments[0], x = arguments[1], w = arguments[2], k = x.getEdge().getCoordinates(), N = 0; N < k.length - 1; N++) {
            this._seg.p0 = k[N], this._seg.p1 = k[N + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
            var P = Math.max(this._seg.p0.x, this._seg.p1.x);
            if (!(P < v.x) && !(this._seg.isHorizontal() || v.y < this._seg.p0.y || v.y > this._seg.p1.y || ct.index(this._seg.p0, this._seg.p1, v) === ct.RIGHT)) {
              var W = x.getDepth(H.LEFT);
              this._seg.p0.equals(k[N]) || (W = x.getDepth(H.RIGHT));
              var tt = new cc(this._seg, W);
              w.add(tt);
            }
          }
          else if (ht(arguments[2], re) && arguments[0] instanceof B && ht(arguments[1], re)) for (var $ = arguments[0], ot = arguments[1], ft = arguments[2], pt = ot.iterator(); pt.hasNext(); ) {
            var Pt = pt.next();
            Pt.isForward() && this.findStabbedSegments($, Pt, ft);
          }
        }
      } }, { key: "getDepth", value: function(r) {
        var o = this.findStabbedSegments(r);
        return o.size() === 0 ? 0 : Tr.min(o)._leftDepth;
      } }], [{ key: "constructor_", value: function() {
        this._subgraphs = null, this._seg = new Ge();
        var r = arguments[0];
        this._subgraphs = r;
      } }]), f;
    }(), cc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "compareTo", value: function(r) {
        var o = r;
        if (this._upwardSeg.minX() >= o._upwardSeg.maxX()) return 1;
        if (this._upwardSeg.maxX() <= o._upwardSeg.minX()) return -1;
        var a = this._upwardSeg.orientationIndex(o._upwardSeg);
        return a !== 0 || (a = -1 * o._upwardSeg.orientationIndex(this._upwardSeg)) !== 0 ? a : this._upwardSeg.compareTo(o._upwardSeg);
      } }, { key: "compareX", value: function(r, o) {
        var a = r.p0.compareTo(o.p0);
        return a !== 0 ? a : r.p1.compareTo(o.p1);
      } }, { key: "toString", value: function() {
        return this._upwardSeg.toString();
      } }, { key: "interfaces_", get: function() {
        return [D];
      } }], [{ key: "constructor_", value: function() {
        this._upwardSeg = null, this._leftDepth = null;
        var r = arguments[0], o = arguments[1];
        this._upwardSeg = new Ge(r), this._leftDepth = o;
      } }]), f;
    }();
    hc.DepthSegment = cc;
    var fc = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, null, [{ key: "constructor_", value: function() {
        O.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
      } }]), o;
    }(O), mu = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getY", value: function() {
        var r = this.y / this.w;
        if (Q.isNaN(r) || Q.isInfinite(r)) throw new fc();
        return r;
      } }, { key: "getX", value: function() {
        var r = this.x / this.w;
        if (Q.isNaN(r) || Q.isInfinite(r)) throw new fc();
        return r;
      } }, { key: "getCoordinate", value: function() {
        var r = new B();
        return r.x = this.getX(), r.y = this.getY(), r;
      } }], [{ key: "constructor_", value: function() {
        if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1;
        else if (arguments.length === 1) {
          var r = arguments[0];
          this.x = r.x, this.y = r.y, this.w = 1;
        } else if (arguments.length === 2) {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], a = arguments[1];
            this.x = o, this.y = a, this.w = 1;
          } else if (arguments[0] instanceof f && arguments[1] instanceof f) {
            var l = arguments[0], d = arguments[1];
            this.x = l.y * d.w - d.y * l.w, this.y = d.x * l.w - l.x * d.w, this.w = l.x * d.y - d.x * l.y;
          } else if (arguments[0] instanceof B && arguments[1] instanceof B) {
            var v = arguments[0], x = arguments[1];
            this.x = v.y - x.y, this.y = x.x - v.x, this.w = v.x * x.y - x.x * v.y;
          }
        } else if (arguments.length === 3) {
          var w = arguments[0], k = arguments[1], N = arguments[2];
          this.x = w, this.y = k, this.w = N;
        } else if (arguments.length === 4) {
          var P = arguments[0], W = arguments[1], tt = arguments[2], $ = arguments[3], ot = P.y - W.y, ft = W.x - P.x, pt = P.x * W.y - W.x * P.y, Pt = tt.y - $.y, Zt = $.x - tt.x, _e = tt.x * $.y - $.x * tt.y;
          this.x = ft * _e - Zt * pt, this.y = Pt * pt - ot * _e, this.w = ot * Zt - Pt * ft;
        }
      } }]), f;
    }(), Xp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "area", value: function() {
        return f.area(this.p0, this.p1, this.p2);
      } }, { key: "signedArea", value: function() {
        return f.signedArea(this.p0, this.p1, this.p2);
      } }, { key: "interpolateZ", value: function(r) {
        if (r === null) throw new M("Supplied point is null.");
        return f.interpolateZ(r, this.p0, this.p1, this.p2);
      } }, { key: "longestSideLength", value: function() {
        return f.longestSideLength(this.p0, this.p1, this.p2);
      } }, { key: "isAcute", value: function() {
        return f.isAcute(this.p0, this.p1, this.p2);
      } }, { key: "circumcentre", value: function() {
        return f.circumcentre(this.p0, this.p1, this.p2);
      } }, { key: "area3D", value: function() {
        return f.area3D(this.p0, this.p1, this.p2);
      } }, { key: "centroid", value: function() {
        return f.centroid(this.p0, this.p1, this.p2);
      } }, { key: "inCentre", value: function() {
        return f.inCentre(this.p0, this.p1, this.p2);
      } }], [{ key: "constructor_", value: function() {
        this.p0 = null, this.p1 = null, this.p2 = null;
        var r = arguments[0], o = arguments[1], a = arguments[2];
        this.p0 = r, this.p1 = o, this.p2 = a;
      } }, { key: "area", value: function(r, o, a) {
        return Math.abs(((a.x - r.x) * (o.y - r.y) - (o.x - r.x) * (a.y - r.y)) / 2);
      } }, { key: "signedArea", value: function(r, o, a) {
        return ((a.x - r.x) * (o.y - r.y) - (o.x - r.x) * (a.y - r.y)) / 2;
      } }, { key: "det", value: function(r, o, a, l) {
        return r * l - o * a;
      } }, { key: "interpolateZ", value: function(r, o, a, l) {
        var d = o.x, v = o.y, x = a.x - d, w = l.x - d, k = a.y - v, N = l.y - v, P = x * N - w * k, W = r.x - d, tt = r.y - v, $ = (N * W - w * tt) / P, ot = (-k * W + x * tt) / P;
        return o.getZ() + $ * (a.getZ() - o.getZ()) + ot * (l.getZ() - o.getZ());
      } }, { key: "longestSideLength", value: function(r, o, a) {
        var l = r.distance(o), d = o.distance(a), v = a.distance(r), x = l;
        return d > x && (x = d), v > x && (x = v), x;
      } }, { key: "circumcentreDD", value: function(r, o, a) {
        var l = rt.valueOf(r.x).subtract(a.x), d = rt.valueOf(r.y).subtract(a.y), v = rt.valueOf(o.x).subtract(a.x), x = rt.valueOf(o.y).subtract(a.y), w = rt.determinant(l, d, v, x).multiply(2), k = l.sqr().add(d.sqr()), N = v.sqr().add(x.sqr()), P = rt.determinant(d, k, x, N), W = rt.determinant(l, k, v, N), tt = rt.valueOf(a.x).subtract(P.divide(w)).doubleValue(), $ = rt.valueOf(a.y).add(W.divide(w)).doubleValue();
        return new B(tt, $);
      } }, { key: "isAcute", value: function(r, o, a) {
        return !!Be.isAcute(r, o, a) && !!Be.isAcute(o, a, r) && !!Be.isAcute(a, r, o);
      } }, { key: "circumcentre", value: function(r, o, a) {
        var l = a.x, d = a.y, v = r.x - l, x = r.y - d, w = o.x - l, k = o.y - d, N = 2 * f.det(v, x, w, k), P = f.det(x, v * v + x * x, k, w * w + k * k), W = f.det(v, v * v + x * x, w, w * w + k * k);
        return new B(l - P / N, d + W / N);
      } }, { key: "perpendicularBisector", value: function(r, o) {
        var a = o.x - r.x, l = o.y - r.y, d = new mu(r.x + a / 2, r.y + l / 2, 1), v = new mu(r.x - l + a / 2, r.y + a + l / 2, 1);
        return new mu(d, v);
      } }, { key: "angleBisector", value: function(r, o, a) {
        var l = o.distance(r), d = l / (l + o.distance(a)), v = a.x - r.x, x = a.y - r.y;
        return new B(r.x + d * v, r.y + d * x);
      } }, { key: "area3D", value: function(r, o, a) {
        var l = o.x - r.x, d = o.y - r.y, v = o.getZ() - r.getZ(), x = a.x - r.x, w = a.y - r.y, k = a.getZ() - r.getZ(), N = d * k - v * w, P = v * x - l * k, W = l * w - d * x, tt = N * N + P * P + W * W, $ = Math.sqrt(tt) / 2;
        return $;
      } }, { key: "centroid", value: function(r, o, a) {
        var l = (r.x + o.x + a.x) / 3, d = (r.y + o.y + a.y) / 3;
        return new B(l, d);
      } }, { key: "inCentre", value: function(r, o, a) {
        var l = o.distance(a), d = r.distance(a), v = r.distance(o), x = l + d + v, w = (l * r.x + d * o.x + v * a.x) / x, k = (l * r.y + d * o.y + v * a.y) / x;
        return new B(w, k);
      } }]), f;
    }(), qp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "addRingSide", value: function(r, o, a, l, d) {
        if (o === 0 && r.length < Es.MINIMUM_VALID_SIZE) return null;
        var v = l, x = d;
        r.length >= Es.MINIMUM_VALID_SIZE && ct.isCCW(r) && (v = d, x = l, a = H.opposite(a));
        var w = this._curveBuilder.getRingCurve(r, a, o);
        this.addCurve(w, v, x);
      } }, { key: "addRingBothSides", value: function(r, o) {
        this.addRingSide(r, o, H.LEFT, L.EXTERIOR, L.INTERIOR), this.addRingSide(r, o, H.RIGHT, L.INTERIOR, L.EXTERIOR);
      } }, { key: "addPoint", value: function(r) {
        if (this._distance <= 0) return null;
        var o = r.getCoordinates(), a = this._curveBuilder.getLineCurve(o, this._distance);
        this.addCurve(a, L.EXTERIOR, L.INTERIOR);
      } }, { key: "addPolygon", value: function(r) {
        var o = this._distance, a = H.LEFT;
        this._distance < 0 && (o = -this._distance, a = H.RIGHT);
        var l = r.getExteriorRing(), d = ne.removeRepeatedPoints(l.getCoordinates());
        if (this._distance < 0 && this.isErodedCompletely(l, this._distance) || this._distance <= 0 && d.length < 3) return null;
        this.addRingSide(d, o, a, L.EXTERIOR, L.INTERIOR);
        for (var v = 0; v < r.getNumInteriorRing(); v++) {
          var x = r.getInteriorRingN(v), w = ne.removeRepeatedPoints(x.getCoordinates());
          this._distance > 0 && this.isErodedCompletely(x, -this._distance) || this.addRingSide(w, o, H.opposite(a), L.INTERIOR, L.EXTERIOR);
        }
      } }, { key: "isTriangleErodedCompletely", value: function(r, o) {
        var a = new Xp(r[0], r[1], r[2]), l = a.inCentre();
        return se.pointToSegment(l, a.p0, a.p1) < Math.abs(o);
      } }, { key: "addLineString", value: function(r) {
        if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
        var o = ne.removeRepeatedPoints(r.getCoordinates());
        if (ne.isRing(o) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(o, this._distance);
        else {
          var a = this._curveBuilder.getLineCurve(o, this._distance);
          this.addCurve(a, L.EXTERIOR, L.INTERIOR);
        }
      } }, { key: "addCurve", value: function(r, o, a) {
        if (r === null || r.length < 2) return null;
        var l = new Ui(r, new Ke(0, L.BOUNDARY, o, a));
        this._curveList.add(l);
      } }, { key: "getCurves", value: function() {
        return this.add(this._inputGeom), this._curveList;
      } }, { key: "add", value: function(r) {
        if (r.isEmpty()) return null;
        if (r instanceof wn) this.addPolygon(r);
        else if (r instanceof Tt) this.addLineString(r);
        else if (r instanceof yt) this.addPoint(r);
        else if (r instanceof iu) this.addCollection(r);
        else if (r instanceof au) this.addCollection(r);
        else if (r instanceof ou) this.addCollection(r);
        else {
          if (!(r instanceof Fe)) throw new dt(r.getGeometryType());
          this.addCollection(r);
        }
      } }, { key: "isErodedCompletely", value: function(r, o) {
        var a = r.getCoordinates();
        if (a.length < 4) return o < 0;
        if (a.length === 4) return this.isTriangleErodedCompletely(a, o);
        var l = r.getEnvelopeInternal(), d = Math.min(l.getHeight(), l.getWidth());
        return o < 0 && 2 * Math.abs(o) > d;
      } }, { key: "addCollection", value: function(r) {
        for (var o = 0; o < r.getNumGeometries(); o++) {
          var a = r.getGeometryN(o);
          this.add(a);
        }
      } }], [{ key: "constructor_", value: function() {
        this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new ut();
        var r = arguments[0], o = arguments[1], a = arguments[2];
        this._inputGeom = r, this._distance = o, this._curveBuilder = a;
      } }]), f;
    }(), Up = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "locate", value: function(r) {
      } }]), f;
    }(), jp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "next", value: function() {
        if (this._atStart) return this._atStart = !1, f.isAtomic(this._parent) && this._index++, this._parent;
        if (this._subcollectionIterator !== null) {
          if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
          this._subcollectionIterator = null;
        }
        if (this._index >= this._max) throw new Xt();
        var r = this._parent.getGeometryN(this._index++);
        return r instanceof Fe ? (this._subcollectionIterator = new f(r), this._subcollectionIterator.next()) : r;
      } }, { key: "remove", value: function() {
        throw new dt(this.getClass().getName());
      } }, { key: "hasNext", value: function() {
        if (this._atStart) return !0;
        if (this._subcollectionIterator !== null) {
          if (this._subcollectionIterator.hasNext()) return !0;
          this._subcollectionIterator = null;
        }
        return !(this._index >= this._max);
      } }, { key: "interfaces_", get: function() {
        return [Pp];
      } }], [{ key: "constructor_", value: function() {
        this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
        var r = arguments[0];
        this._parent = r, this._atStart = !0, this._index = 0, this._max = r.getNumGeometries();
      } }, { key: "isAtomic", value: function(r) {
        return !(r instanceof Fe);
      } }]), f;
    }(), Vp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "locate", value: function(r) {
        return f.locate(r, this._geom);
      } }, { key: "interfaces_", get: function() {
        return [Up];
      } }], [{ key: "constructor_", value: function() {
        this._geom = null;
        var r = arguments[0];
        this._geom = r;
      } }, { key: "locatePointInPolygon", value: function(r, o) {
        if (o.isEmpty()) return L.EXTERIOR;
        var a = o.getExteriorRing(), l = f.locatePointInRing(r, a);
        if (l !== L.INTERIOR) return l;
        for (var d = 0; d < o.getNumInteriorRing(); d++) {
          var v = o.getInteriorRingN(d), x = f.locatePointInRing(r, v);
          if (x === L.BOUNDARY) return L.BOUNDARY;
          if (x === L.INTERIOR) return L.EXTERIOR;
        }
        return L.INTERIOR;
      } }, { key: "locatePointInRing", value: function(r, o) {
        return o.getEnvelopeInternal().intersects(r) ? hu.locateInRing(r, o.getCoordinates()) : L.EXTERIOR;
      } }, { key: "containsPointInPolygon", value: function(r, o) {
        return L.EXTERIOR !== f.locatePointInPolygon(r, o);
      } }, { key: "locateInGeometry", value: function(r, o) {
        if (o instanceof wn) return f.locatePointInPolygon(r, o);
        if (o instanceof Fe) for (var a = new jp(o); a.hasNext(); ) {
          var l = a.next();
          if (l !== o) {
            var d = f.locateInGeometry(r, l);
            if (d !== L.EXTERIOR) return d;
          }
        }
        return L.EXTERIOR;
      } }, { key: "isContained", value: function(r, o) {
        return L.EXTERIOR !== f.locate(r, o);
      } }, { key: "locate", value: function(r, o) {
        return o.isEmpty() ? L.EXTERIOR : o.getEnvelopeInternal().intersects(r) ? f.locateInGeometry(r, o) : L.EXTERIOR;
      } }]), f;
    }(), Zp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getNextCW", value: function(r) {
        this.getEdges();
        var o = this._edgeList.indexOf(r), a = o - 1;
        return o === 0 && (a = this._edgeList.size() - 1), this._edgeList.get(a);
      } }, { key: "propagateSideLabels", value: function(r) {
        for (var o = L.NONE, a = this.iterator(); a.hasNext(); ) {
          var l = a.next().getLabel();
          l.isArea(r) && l.getLocation(r, H.LEFT) !== L.NONE && (o = l.getLocation(r, H.LEFT));
        }
        if (o === L.NONE) return null;
        for (var d = o, v = this.iterator(); v.hasNext(); ) {
          var x = v.next(), w = x.getLabel();
          if (w.getLocation(r, H.ON) === L.NONE && w.setLocation(r, H.ON, d), w.isArea(r)) {
            var k = w.getLocation(r, H.LEFT), N = w.getLocation(r, H.RIGHT);
            if (N !== L.NONE) {
              if (N !== d) throw new fe("side location conflict", x.getCoordinate());
              k === L.NONE && X.shouldNeverReachHere("found single null side (at " + x.getCoordinate() + ")"), d = k;
            } else X.isTrue(w.getLocation(r, H.LEFT) === L.NONE, "found single null side"), w.setLocation(r, H.RIGHT, d), w.setLocation(r, H.LEFT, d);
          }
        }
      } }, { key: "getCoordinate", value: function() {
        var r = this.iterator();
        return r.hasNext() ? r.next().getCoordinate() : null;
      } }, { key: "print", value: function(r) {
        ge.out.println("EdgeEndStar:   " + this.getCoordinate());
        for (var o = this.iterator(); o.hasNext(); )
          o.next().print(r);
      } }, { key: "isAreaLabelsConsistent", value: function(r) {
        return this.computeEdgeEndLabels(r.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
      } }, { key: "checkAreaLabelsConsistent", value: function(r) {
        var o = this.getEdges();
        if (o.size() <= 0) return !0;
        var a = o.size() - 1, l = o.get(a).getLabel().getLocation(r, H.LEFT);
        X.isTrue(l !== L.NONE, "Found unlabelled area edge");
        for (var d = l, v = this.iterator(); v.hasNext(); ) {
          var x = v.next().getLabel();
          X.isTrue(x.isArea(r), "Found non-area edge");
          var w = x.getLocation(r, H.LEFT), k = x.getLocation(r, H.RIGHT);
          if (w === k || k !== d) return !1;
          d = w;
        }
        return !0;
      } }, { key: "findIndex", value: function(r) {
        this.iterator();
        for (var o = 0; o < this._edgeList.size(); o++)
          if (this._edgeList.get(o) === r) return o;
        return -1;
      } }, { key: "iterator", value: function() {
        return this.getEdges().iterator();
      } }, { key: "getEdges", value: function() {
        return this._edgeList === null && (this._edgeList = new ut(this._edgeMap.values())), this._edgeList;
      } }, { key: "getLocation", value: function(r, o, a) {
        return this._ptInAreaLocation[r] === L.NONE && (this._ptInAreaLocation[r] = Vp.locate(o, a[r].getGeometry())), this._ptInAreaLocation[r];
      } }, { key: "toString", value: function() {
        var r = new De();
        r.append("EdgeEndStar:   " + this.getCoordinate()), r.append(`
`);
        for (var o = this.iterator(); o.hasNext(); ) {
          var a = o.next();
          r.append(a), r.append(`
`);
        }
        return r.toString();
      } }, { key: "computeEdgeEndLabels", value: function(r) {
        for (var o = this.iterator(); o.hasNext(); )
          o.next().computeLabel(r);
      } }, { key: "computeLabelling", value: function(r) {
        this.computeEdgeEndLabels(r[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
        for (var o = [!1, !1], a = this.iterator(); a.hasNext(); ) for (var l = a.next().getLabel(), d = 0; d < 2; d++) l.isLine(d) && l.getLocation(d) === L.BOUNDARY && (o[d] = !0);
        for (var v = this.iterator(); v.hasNext(); ) for (var x = v.next(), w = x.getLabel(), k = 0; k < 2; k++) if (w.isAnyNull(k)) {
          var N = L.NONE;
          if (o[k]) N = L.EXTERIOR;
          else {
            var P = x.getCoordinate();
            N = this.getLocation(k, P, r);
          }
          w.setAllLocationsIfNull(k, N);
        }
      } }, { key: "getDegree", value: function() {
        return this._edgeMap.size();
      } }, { key: "insertEdgeEnd", value: function(r, o) {
        this._edgeMap.put(r, o), this._edgeList = null;
      } }], [{ key: "constructor_", value: function() {
        this._edgeMap = new Is(), this._edgeList = null, this._ptInAreaLocation = [L.NONE, L.NONE];
      } }]), f;
    }(), Hp = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "linkResultDirectedEdges", value: function() {
        this.getResultAreaEdges();
        for (var a = null, l = null, d = this._SCANNING_FOR_INCOMING, v = 0; v < this._resultAreaEdgeList.size(); v++) {
          var x = this._resultAreaEdgeList.get(v), w = x.getSym();
          if (x.getLabel().isArea()) switch (a === null && x.isInResult() && (a = x), d) {
            case this._SCANNING_FOR_INCOMING:
              if (!w.isInResult()) continue;
              l = w, d = this._LINKING_TO_OUTGOING;
              break;
            case this._LINKING_TO_OUTGOING:
              if (!x.isInResult()) continue;
              l.setNext(x), d = this._SCANNING_FOR_INCOMING;
          }
        }
        if (d === this._LINKING_TO_OUTGOING) {
          if (a === null) throw new fe("no outgoing dirEdge found", this.getCoordinate());
          X.isTrue(a.isInResult(), "unable to link last incoming dirEdge"), l.setNext(a);
        }
      } }, { key: "insert", value: function(a) {
        var l = a;
        this.insertEdgeEnd(l, l);
      } }, { key: "getRightmostEdge", value: function() {
        var a = this.getEdges(), l = a.size();
        if (l < 1) return null;
        var d = a.get(0);
        if (l === 1) return d;
        var v = a.get(l - 1), x = d.getQuadrant(), w = v.getQuadrant();
        return Ce.isNorthern(x) && Ce.isNorthern(w) ? d : Ce.isNorthern(x) || Ce.isNorthern(w) ? d.getDy() !== 0 ? d : v.getDy() !== 0 ? v : (X.shouldNeverReachHere("found two horizontal edges incident on node"), null) : v;
      } }, { key: "print", value: function(a) {
        ge.out.println("DirectedEdgeStar: " + this.getCoordinate());
        for (var l = this.iterator(); l.hasNext(); ) {
          var d = l.next();
          a.print("out "), d.print(a), a.println(), a.print("in "), d.getSym().print(a), a.println();
        }
      } }, { key: "getResultAreaEdges", value: function() {
        if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
        this._resultAreaEdgeList = new ut();
        for (var a = this.iterator(); a.hasNext(); ) {
          var l = a.next();
          (l.isInResult() || l.getSym().isInResult()) && this._resultAreaEdgeList.add(l);
        }
        return this._resultAreaEdgeList;
      } }, { key: "updateLabelling", value: function(a) {
        for (var l = this.iterator(); l.hasNext(); ) {
          var d = l.next().getLabel();
          d.setAllLocationsIfNull(0, a.getLocation(0)), d.setAllLocationsIfNull(1, a.getLocation(1));
        }
      } }, { key: "linkAllDirectedEdges", value: function() {
        this.getEdges();
        for (var a = null, l = null, d = this._edgeList.size() - 1; d >= 0; d--) {
          var v = this._edgeList.get(d), x = v.getSym();
          l === null && (l = x), a !== null && x.setNext(a), a = v;
        }
        l.setNext(a);
      } }, { key: "computeDepths", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0], l = this.findIndex(a), d = a.getDepth(H.LEFT), v = a.getDepth(H.RIGHT), x = this.computeDepths(l + 1, this._edgeList.size(), d), w = this.computeDepths(0, l, x);
          if (w !== v) throw new fe("depth mismatch at " + a.getCoordinate());
        } else if (arguments.length === 3) {
          for (var k = arguments[0], N = arguments[1], P = arguments[2], W = P, tt = k; tt < N; tt++) {
            var $ = this._edgeList.get(tt);
            $.setEdgeDepths(H.RIGHT, W), W = $.getDepth(H.LEFT);
          }
          return W;
        }
      } }, { key: "mergeSymLabels", value: function() {
        for (var a = this.iterator(); a.hasNext(); ) {
          var l = a.next();
          l.getLabel().merge(l.getSym().getLabel());
        }
      } }, { key: "linkMinimalDirectedEdges", value: function(a) {
        for (var l = null, d = null, v = this._SCANNING_FOR_INCOMING, x = this._resultAreaEdgeList.size() - 1; x >= 0; x--) {
          var w = this._resultAreaEdgeList.get(x), k = w.getSym();
          switch (l === null && w.getEdgeRing() === a && (l = w), v) {
            case this._SCANNING_FOR_INCOMING:
              if (k.getEdgeRing() !== a) continue;
              d = k, v = this._LINKING_TO_OUTGOING;
              break;
            case this._LINKING_TO_OUTGOING:
              if (w.getEdgeRing() !== a) continue;
              d.setNextMin(w), v = this._SCANNING_FOR_INCOMING;
          }
        }
        v === this._LINKING_TO_OUTGOING && (X.isTrue(l !== null, "found null for first outgoing dirEdge"), X.isTrue(l.getEdgeRing() === a, "unable to link last incoming dirEdge"), d.setNextMin(l));
      } }, { key: "getOutgoingDegree", value: function() {
        if (arguments.length === 0) {
          for (var a = 0, l = this.iterator(); l.hasNext(); ) {
            var d = l.next();
            d.isInResult() && a++;
          }
          return a;
        }
        if (arguments.length === 1) {
          for (var v = arguments[0], x = 0, w = this.iterator(); w.hasNext(); ) {
            var k = w.next();
            k.getEdgeRing() === v && x++;
          }
          return x;
        }
      } }, { key: "getLabel", value: function() {
        return this._label;
      } }, { key: "findCoveredLineEdges", value: function() {
        for (var a = L.NONE, l = this.iterator(); l.hasNext(); ) {
          var d = l.next(), v = d.getSym();
          if (!d.isLineEdge()) {
            if (d.isInResult()) {
              a = L.INTERIOR;
              break;
            }
            if (v.isInResult()) {
              a = L.EXTERIOR;
              break;
            }
          }
        }
        if (a === L.NONE) return null;
        for (var x = a, w = this.iterator(); w.hasNext(); ) {
          var k = w.next(), N = k.getSym();
          k.isLineEdge() ? k.getEdge().setCovered(x === L.INTERIOR) : (k.isInResult() && (x = L.EXTERIOR), N.isInResult() && (x = L.INTERIOR));
        }
      } }, { key: "computeLabelling", value: function(a) {
        S(h(o.prototype), "computeLabelling", this).call(this, a), this._label = new Ke(L.NONE);
        for (var l = this.iterator(); l.hasNext(); ) for (var d = l.next().getEdge().getLabel(), v = 0; v < 2; v++) {
          var x = d.getLocation(v);
          x !== L.INTERIOR && x !== L.BOUNDARY || this._label.setLocation(v, L.INTERIOR);
        }
      } }], [{ key: "constructor_", value: function() {
        this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
      } }]), o;
    }(Zp), Kp = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        return e(this, o), r.call(this);
      }
      return s(o, [{ key: "createNode", value: function(a) {
        return new To(a, new Hp());
      } }]), o;
    }(ec), gc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "compareTo", value: function(r) {
        var o = r;
        return f.compareOriented(this._pts, this._orientation, o._pts, o._orientation);
      } }, { key: "interfaces_", get: function() {
        return [D];
      } }], [{ key: "constructor_", value: function() {
        this._pts = null, this._orientation = null;
        var r = arguments[0];
        this._pts = r, this._orientation = f.orientation(r);
      } }, { key: "orientation", value: function(r) {
        return ne.increasingDirection(r) === 1;
      } }, { key: "compareOriented", value: function(r, o, a, l) {
        for (var d = o ? 1 : -1, v = l ? 1 : -1, x = o ? r.length : -1, w = l ? a.length : -1, k = o ? 0 : r.length - 1, N = l ? 0 : a.length - 1; ; ) {
          var P = r[k].compareTo(a[N]);
          if (P !== 0) return P;
          var W = (k += d) === x, tt = (N += v) === w;
          if (W && !tt) return -1;
          if (!W && tt) return 1;
          if (W && tt) return 0;
        }
      } }]), f;
    }(), $p = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "print", value: function(r) {
        r.print("MULTILINESTRING ( ");
        for (var o = 0; o < this._edges.size(); o++) {
          var a = this._edges.get(o);
          o > 0 && r.print(","), r.print("(");
          for (var l = a.getCoordinates(), d = 0; d < l.length; d++) d > 0 && r.print(","), r.print(l[d].x + " " + l[d].y);
          r.println(")");
        }
        r.print(")  ");
      } }, { key: "addAll", value: function(r) {
        for (var o = r.iterator(); o.hasNext(); ) this.add(o.next());
      } }, { key: "findEdgeIndex", value: function(r) {
        for (var o = 0; o < this._edges.size(); o++) if (this._edges.get(o).equals(r)) return o;
        return -1;
      } }, { key: "iterator", value: function() {
        return this._edges.iterator();
      } }, { key: "getEdges", value: function() {
        return this._edges;
      } }, { key: "get", value: function(r) {
        return this._edges.get(r);
      } }, { key: "findEqualEdge", value: function(r) {
        var o = new gc(r.getCoordinates());
        return this._ocaMap.get(o);
      } }, { key: "add", value: function(r) {
        this._edges.add(r);
        var o = new gc(r.getCoordinates());
        this._ocaMap.put(o, r);
      } }], [{ key: "constructor_", value: function() {
        this._edges = new ut(), this._ocaMap = new Is();
      } }]), f;
    }(), dc = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "processIntersections", value: function(r, o, a, l) {
      } }, { key: "isDone", value: function() {
      } }]), f;
    }(), Jp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "isTrivialIntersection", value: function(r, o, a, l) {
        if (r === a && this._li.getIntersectionNum() === 1) {
          if (f.isAdjacentSegments(o, l)) return !0;
          if (r.isClosed()) {
            var d = r.size() - 1;
            if (o === 0 && l === d || l === 0 && o === d) return !0;
          }
        }
        return !1;
      } }, { key: "getProperIntersectionPoint", value: function() {
        return this._properIntersectionPoint;
      } }, { key: "hasProperInteriorIntersection", value: function() {
        return this._hasProperInterior;
      } }, { key: "getLineIntersector", value: function() {
        return this._li;
      } }, { key: "hasProperIntersection", value: function() {
        return this._hasProper;
      } }, { key: "processIntersections", value: function(r, o, a, l) {
        if (r === a && o === l) return null;
        this.numTests++;
        var d = r.getCoordinates()[o], v = r.getCoordinates()[o + 1], x = a.getCoordinates()[l], w = a.getCoordinates()[l + 1];
        this._li.computeIntersection(d, v, x, w), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(r, o, a, l) || (this._hasIntersection = !0, r.addIntersections(this._li, o, 0), a.addIntersections(this._li, l, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
      } }, { key: "hasIntersection", value: function() {
        return this._hasIntersection;
      } }, { key: "isDone", value: function() {
        return !1;
      } }, { key: "hasInteriorIntersection", value: function() {
        return this._hasInterior;
      } }, { key: "interfaces_", get: function() {
        return [dc];
      } }], [{ key: "constructor_", value: function() {
        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
        var r = arguments[0];
        this._li = r;
      } }, { key: "isAdjacentSegments", value: function(r, o) {
        return Math.abs(r - o) === 1;
      } }]), f;
    }(), Qp = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getSegmentIndex", value: function() {
        return this.segmentIndex;
      } }, { key: "getCoordinate", value: function() {
        return this.coord;
      } }, { key: "print", value: function(r) {
        r.print(this.coord), r.print(" seg # = " + this.segmentIndex), r.println(" dist = " + this.dist);
      } }, { key: "compareTo", value: function(r) {
        var o = r;
        return this.compare(o.segmentIndex, o.dist);
      } }, { key: "isEndPoint", value: function(r) {
        return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === r;
      } }, { key: "toString", value: function() {
        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
      } }, { key: "getDistance", value: function() {
        return this.dist;
      } }, { key: "compare", value: function(r, o) {
        return this.segmentIndex < r ? -1 : this.segmentIndex > r ? 1 : this.dist < o ? -1 : this.dist > o ? 1 : 0;
      } }, { key: "interfaces_", get: function() {
        return [D];
      } }], [{ key: "constructor_", value: function() {
        this.coord = null, this.segmentIndex = null, this.dist = null;
        var r = arguments[0], o = arguments[1], a = arguments[2];
        this.coord = new B(r), this.segmentIndex = o, this.dist = a;
      } }]), f;
    }(), tv = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "print", value: function(r) {
        r.println("Intersections:");
        for (var o = this.iterator(); o.hasNext(); )
          o.next().print(r);
      } }, { key: "iterator", value: function() {
        return this._nodeMap.values().iterator();
      } }, { key: "addSplitEdges", value: function(r) {
        this.addEndpoints();
        for (var o = this.iterator(), a = o.next(); o.hasNext(); ) {
          var l = o.next(), d = this.createSplitEdge(a, l);
          r.add(d), a = l;
        }
      } }, { key: "addEndpoints", value: function() {
        var r = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[r], r, 0);
      } }, { key: "createSplitEdge", value: function(r, o) {
        var a = o.segmentIndex - r.segmentIndex + 2, l = this.edge.pts[o.segmentIndex], d = o.dist > 0 || !o.coord.equals2D(l);
        d || a--;
        var v = new Array(a).fill(null), x = 0;
        v[x++] = new B(r.coord);
        for (var w = r.segmentIndex + 1; w <= o.segmentIndex; w++) v[x++] = this.edge.pts[w];
        return d && (v[x] = o.coord), new yc(v, new Ke(this.edge._label));
      } }, { key: "add", value: function(r, o, a) {
        var l = new Qp(r, o, a), d = this._nodeMap.get(l);
        return d !== null ? d : (this._nodeMap.put(l, l), l);
      } }, { key: "isIntersection", value: function(r) {
        for (var o = this.iterator(); o.hasNext(); )
          if (o.next().coord.equals(r)) return !0;
        return !1;
      } }], [{ key: "constructor_", value: function() {
        this._nodeMap = new Is(), this.edge = null;
        var r = arguments[0];
        this.edge = r;
      } }]), f;
    }(), ev = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "isIntersects", value: function() {
        return !this.isDisjoint();
      } }, { key: "isCovers", value: function() {
        return (f.isTrue(this._matrix[L.INTERIOR][L.INTERIOR]) || f.isTrue(this._matrix[L.INTERIOR][L.BOUNDARY]) || f.isTrue(this._matrix[L.BOUNDARY][L.INTERIOR]) || f.isTrue(this._matrix[L.BOUNDARY][L.BOUNDARY])) && this._matrix[L.EXTERIOR][L.INTERIOR] === J.FALSE && this._matrix[L.EXTERIOR][L.BOUNDARY] === J.FALSE;
      } }, { key: "isCoveredBy", value: function() {
        return (f.isTrue(this._matrix[L.INTERIOR][L.INTERIOR]) || f.isTrue(this._matrix[L.INTERIOR][L.BOUNDARY]) || f.isTrue(this._matrix[L.BOUNDARY][L.INTERIOR]) || f.isTrue(this._matrix[L.BOUNDARY][L.BOUNDARY])) && this._matrix[L.INTERIOR][L.EXTERIOR] === J.FALSE && this._matrix[L.BOUNDARY][L.EXTERIOR] === J.FALSE;
      } }, { key: "set", value: function() {
        if (arguments.length === 1) for (var r = arguments[0], o = 0; o < r.length; o++) {
          var a = Math.trunc(o / 3), l = o % 3;
          this._matrix[a][l] = J.toDimensionValue(r.charAt(o));
        }
        else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], x = arguments[2];
          this._matrix[d][v] = x;
        }
      } }, { key: "isContains", value: function() {
        return f.isTrue(this._matrix[L.INTERIOR][L.INTERIOR]) && this._matrix[L.EXTERIOR][L.INTERIOR] === J.FALSE && this._matrix[L.EXTERIOR][L.BOUNDARY] === J.FALSE;
      } }, { key: "setAtLeast", value: function() {
        if (arguments.length === 1) for (var r = arguments[0], o = 0; o < r.length; o++) {
          var a = Math.trunc(o / 3), l = o % 3;
          this.setAtLeast(a, l, J.toDimensionValue(r.charAt(o)));
        }
        else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], x = arguments[2];
          this._matrix[d][v] < x && (this._matrix[d][v] = x);
        }
      } }, { key: "setAtLeastIfValid", value: function(r, o, a) {
        r >= 0 && o >= 0 && this.setAtLeast(r, o, a);
      } }, { key: "isWithin", value: function() {
        return f.isTrue(this._matrix[L.INTERIOR][L.INTERIOR]) && this._matrix[L.INTERIOR][L.EXTERIOR] === J.FALSE && this._matrix[L.BOUNDARY][L.EXTERIOR] === J.FALSE;
      } }, { key: "isTouches", value: function(r, o) {
        return r > o ? this.isTouches(o, r) : (r === J.A && o === J.A || r === J.L && o === J.L || r === J.L && o === J.A || r === J.P && o === J.A || r === J.P && o === J.L) && this._matrix[L.INTERIOR][L.INTERIOR] === J.FALSE && (f.isTrue(this._matrix[L.INTERIOR][L.BOUNDARY]) || f.isTrue(this._matrix[L.BOUNDARY][L.INTERIOR]) || f.isTrue(this._matrix[L.BOUNDARY][L.BOUNDARY]));
      } }, { key: "isOverlaps", value: function(r, o) {
        return r === J.P && o === J.P || r === J.A && o === J.A ? f.isTrue(this._matrix[L.INTERIOR][L.INTERIOR]) && f.isTrue(this._matrix[L.INTERIOR][L.EXTERIOR]) && f.isTrue(this._matrix[L.EXTERIOR][L.INTERIOR]) : r === J.L && o === J.L && this._matrix[L.INTERIOR][L.INTERIOR] === 1 && f.isTrue(this._matrix[L.INTERIOR][L.EXTERIOR]) && f.isTrue(this._matrix[L.EXTERIOR][L.INTERIOR]);
      } }, { key: "isEquals", value: function(r, o) {
        return r === o && f.isTrue(this._matrix[L.INTERIOR][L.INTERIOR]) && this._matrix[L.INTERIOR][L.EXTERIOR] === J.FALSE && this._matrix[L.BOUNDARY][L.EXTERIOR] === J.FALSE && this._matrix[L.EXTERIOR][L.INTERIOR] === J.FALSE && this._matrix[L.EXTERIOR][L.BOUNDARY] === J.FALSE;
      } }, { key: "toString", value: function() {
        for (var r = new Co("123456789"), o = 0; o < 3; o++) for (var a = 0; a < 3; a++) r.setCharAt(3 * o + a, J.toDimensionSymbol(this._matrix[o][a]));
        return r.toString();
      } }, { key: "setAll", value: function(r) {
        for (var o = 0; o < 3; o++) for (var a = 0; a < 3; a++) this._matrix[o][a] = r;
      } }, { key: "get", value: function(r, o) {
        return this._matrix[r][o];
      } }, { key: "transpose", value: function() {
        var r = this._matrix[1][0];
        return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = r, r = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = r, r = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = r, this;
      } }, { key: "matches", value: function(r) {
        if (r.length !== 9) throw new M("Should be length 9: " + r);
        for (var o = 0; o < 3; o++) for (var a = 0; a < 3; a++) if (!f.matches(this._matrix[o][a], r.charAt(3 * o + a))) return !1;
        return !0;
      } }, { key: "add", value: function(r) {
        for (var o = 0; o < 3; o++) for (var a = 0; a < 3; a++) this.setAtLeast(o, a, r.get(o, a));
      } }, { key: "isDisjoint", value: function() {
        return this._matrix[L.INTERIOR][L.INTERIOR] === J.FALSE && this._matrix[L.INTERIOR][L.BOUNDARY] === J.FALSE && this._matrix[L.BOUNDARY][L.INTERIOR] === J.FALSE && this._matrix[L.BOUNDARY][L.BOUNDARY] === J.FALSE;
      } }, { key: "isCrosses", value: function(r, o) {
        return r === J.P && o === J.L || r === J.P && o === J.A || r === J.L && o === J.A ? f.isTrue(this._matrix[L.INTERIOR][L.INTERIOR]) && f.isTrue(this._matrix[L.INTERIOR][L.EXTERIOR]) : r === J.L && o === J.P || r === J.A && o === J.P || r === J.A && o === J.L ? f.isTrue(this._matrix[L.INTERIOR][L.INTERIOR]) && f.isTrue(this._matrix[L.EXTERIOR][L.INTERIOR]) : r === J.L && o === J.L && this._matrix[L.INTERIOR][L.INTERIOR] === 0;
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }], [{ key: "constructor_", value: function() {
        if (this._matrix = null, arguments.length === 0) this._matrix = Array(3).fill().map(function() {
          return Array(3);
        }), this.setAll(J.FALSE);
        else if (arguments.length === 1) {
          if (typeof arguments[0] == "string") {
            var r = arguments[0];
            f.constructor_.call(this), this.set(r);
          } else if (arguments[0] instanceof f) {
            var o = arguments[0];
            f.constructor_.call(this), this._matrix[L.INTERIOR][L.INTERIOR] = o._matrix[L.INTERIOR][L.INTERIOR], this._matrix[L.INTERIOR][L.BOUNDARY] = o._matrix[L.INTERIOR][L.BOUNDARY], this._matrix[L.INTERIOR][L.EXTERIOR] = o._matrix[L.INTERIOR][L.EXTERIOR], this._matrix[L.BOUNDARY][L.INTERIOR] = o._matrix[L.BOUNDARY][L.INTERIOR], this._matrix[L.BOUNDARY][L.BOUNDARY] = o._matrix[L.BOUNDARY][L.BOUNDARY], this._matrix[L.BOUNDARY][L.EXTERIOR] = o._matrix[L.BOUNDARY][L.EXTERIOR], this._matrix[L.EXTERIOR][L.INTERIOR] = o._matrix[L.EXTERIOR][L.INTERIOR], this._matrix[L.EXTERIOR][L.BOUNDARY] = o._matrix[L.EXTERIOR][L.BOUNDARY], this._matrix[L.EXTERIOR][L.EXTERIOR] = o._matrix[L.EXTERIOR][L.EXTERIOR];
          }
        }
      } }, { key: "matches", value: function() {
        if (Number.isInteger(arguments[0]) && typeof arguments[1] == "string") {
          var r = arguments[0], o = arguments[1];
          return o === J.SYM_DONTCARE || o === J.SYM_TRUE && (r >= 0 || r === J.TRUE) || o === J.SYM_FALSE && r === J.FALSE || o === J.SYM_P && r === J.P || o === J.SYM_L && r === J.L || o === J.SYM_A && r === J.A;
        }
        if (typeof arguments[0] == "string" && typeof arguments[1] == "string") {
          var a = arguments[0], l = arguments[1], d = new f(a);
          return d.matches(l);
        }
      } }, { key: "isTrue", value: function(r) {
        return r >= 0 || r === J.TRUE;
      } }]), f;
    }(), nv = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "size", value: function() {
        return this._size;
      } }, { key: "addAll", value: function(r) {
        return r === null || r.length === 0 ? null : (this.ensureCapacity(this._size + r.length), ge.arraycopy(r, 0, this._data, this._size, r.length), void (this._size += r.length));
      } }, { key: "ensureCapacity", value: function(r) {
        if (r <= this._data.length) return null;
        var o = Math.max(r, 2 * this._data.length);
        this._data = Bt.copyOf(this._data, o);
      } }, { key: "toArray", value: function() {
        var r = new Array(this._size).fill(null);
        return ge.arraycopy(this._data, 0, r, 0, this._size), r;
      } }, { key: "add", value: function(r) {
        this.ensureCapacity(this._size + 1), this._data[this._size] = r, ++this._size;
      } }], [{ key: "constructor_", value: function() {
        if (this._data = null, this._size = 0, arguments.length === 0) f.constructor_.call(this, 10);
        else if (arguments.length === 1) {
          var r = arguments[0];
          this._data = new Array(r).fill(null);
        }
      } }]), f;
    }(), iv = function() {
      function f() {
        e(this, f);
      }
      return s(f, [{ key: "getChainStartIndices", value: function(r) {
        var o = 0, a = new nv(Math.trunc(r.length / 2));
        a.add(o);
        do {
          var l = this.findChainEnd(r, o);
          a.add(l), o = l;
        } while (o < r.length - 1);
        return a.toArray();
      } }, { key: "findChainEnd", value: function(r, o) {
        for (var a = Ce.quadrant(r[o], r[o + 1]), l = o + 1; l < r.length && Ce.quadrant(r[l - 1], r[l]) === a; )
          l++;
        return l - 1;
      } }, { key: "OLDgetChainStartIndices", value: function(r) {
        var o = 0, a = new ut();
        a.add(o);
        do {
          var l = this.findChainEnd(r, o);
          a.add(l), o = l;
        } while (o < r.length - 1);
        return f.toIntArray(a);
      } }], [{ key: "toIntArray", value: function(r) {
        for (var o = new Array(r.size()).fill(null), a = 0; a < o.length; a++) o[a] = r.get(a).intValue();
        return o;
      } }]), f;
    }(), rv = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getCoordinates", value: function() {
        return this.pts;
      } }, { key: "getMaxX", value: function(r) {
        var o = this.pts[this.startIndex[r]].x, a = this.pts[this.startIndex[r + 1]].x;
        return o > a ? o : a;
      } }, { key: "getMinX", value: function(r) {
        var o = this.pts[this.startIndex[r]].x, a = this.pts[this.startIndex[r + 1]].x;
        return o < a ? o : a;
      } }, { key: "computeIntersectsForChain", value: function() {
        if (arguments.length === 4) {
          var r = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
          this.computeIntersectsForChain(this.startIndex[r], this.startIndex[r + 1], o, o.startIndex[a], o.startIndex[a + 1], l);
        } else if (arguments.length === 6) {
          var d = arguments[0], v = arguments[1], x = arguments[2], w = arguments[3], k = arguments[4], N = arguments[5];
          if (v - d == 1 && k - w == 1) return N.addIntersections(this.e, d, x.e, w), null;
          if (!this.overlaps(d, v, x, w, k)) return null;
          var P = Math.trunc((d + v) / 2), W = Math.trunc((w + k) / 2);
          d < P && (w < W && this.computeIntersectsForChain(d, P, x, w, W, N), W < k && this.computeIntersectsForChain(d, P, x, W, k, N)), P < v && (w < W && this.computeIntersectsForChain(P, v, x, w, W, N), W < k && this.computeIntersectsForChain(P, v, x, W, k, N));
        }
      } }, { key: "overlaps", value: function(r, o, a, l, d) {
        return Ot.intersects(this.pts[r], this.pts[o], a.pts[l], a.pts[d]);
      } }, { key: "getStartIndexes", value: function() {
        return this.startIndex;
      } }, { key: "computeIntersects", value: function(r, o) {
        for (var a = 0; a < this.startIndex.length - 1; a++) for (var l = 0; l < r.startIndex.length - 1; l++) this.computeIntersectsForChain(a, r, l, o);
      } }], [{ key: "constructor_", value: function() {
        this.e = null, this.pts = null, this.startIndex = null;
        var r = arguments[0];
        this.e = r, this.pts = r.getCoordinates();
        var o = new iv();
        this.startIndex = o.getChainStartIndices(this.pts);
      } }]), f;
    }(), mc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "getDepth", value: function(r, o) {
        return this._depth[r][o];
      } }, { key: "setDepth", value: function(r, o, a) {
        this._depth[r][o] = a;
      } }, { key: "isNull", value: function() {
        if (arguments.length === 0) {
          for (var r = 0; r < 2; r++) for (var o = 0; o < 3; o++) if (this._depth[r][o] !== f.NULL_VALUE) return !1;
          return !0;
        }
        if (arguments.length === 1) {
          var a = arguments[0];
          return this._depth[a][1] === f.NULL_VALUE;
        }
        if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          return this._depth[l][d] === f.NULL_VALUE;
        }
      } }, { key: "normalize", value: function() {
        for (var r = 0; r < 2; r++) if (!this.isNull(r)) {
          var o = this._depth[r][1];
          this._depth[r][2] < o && (o = this._depth[r][2]), o < 0 && (o = 0);
          for (var a = 1; a < 3; a++) {
            var l = 0;
            this._depth[r][a] > o && (l = 1), this._depth[r][a] = l;
          }
        }
      } }, { key: "getDelta", value: function(r) {
        return this._depth[r][H.RIGHT] - this._depth[r][H.LEFT];
      } }, { key: "getLocation", value: function(r, o) {
        return this._depth[r][o] <= 0 ? L.EXTERIOR : L.INTERIOR;
      } }, { key: "toString", value: function() {
        return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
      } }, { key: "add", value: function() {
        if (arguments.length === 1) for (var r = arguments[0], o = 0; o < 2; o++) for (var a = 1; a < 3; a++) {
          var l = r.getLocation(o, a);
          l !== L.EXTERIOR && l !== L.INTERIOR || (this.isNull(o, a) ? this._depth[o][a] = f.depthAtLocation(l) : this._depth[o][a] += f.depthAtLocation(l));
        }
        else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], x = arguments[2];
          x === L.INTERIOR && this._depth[d][v]++;
        }
      } }], [{ key: "constructor_", value: function() {
        this._depth = Array(2).fill().map(function() {
          return Array(3);
        });
        for (var r = 0; r < 2; r++) for (var o = 0; o < 3; o++) this._depth[r][o] = f.NULL_VALUE;
      } }, { key: "depthAtLocation", value: function(r) {
        return r === L.EXTERIOR ? 0 : r === L.INTERIOR ? 1 : f.NULL_VALUE;
      } }]), f;
    }();
    mc.NULL_VALUE = -1;
    var yc = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "getDepth", value: function() {
        return this._depth;
      } }, { key: "getCollapsedEdge", value: function() {
        var a = new Array(2).fill(null);
        return a[0] = this.pts[0], a[1] = this.pts[1], new o(a, Ke.toLineLabel(this._label));
      } }, { key: "isIsolated", value: function() {
        return this._isIsolated;
      } }, { key: "getCoordinates", value: function() {
        return this.pts;
      } }, { key: "setIsolated", value: function(a) {
        this._isIsolated = a;
      } }, { key: "setName", value: function(a) {
        this._name = a;
      } }, { key: "equals", value: function(a) {
        if (!(a instanceof o)) return !1;
        var l = a;
        if (this.pts.length !== l.pts.length) return !1;
        for (var d = !0, v = !0, x = this.pts.length, w = 0; w < this.pts.length; w++) if (this.pts[w].equals2D(l.pts[w]) || (d = !1), this.pts[w].equals2D(l.pts[--x]) || (v = !1), !d && !v) return !1;
        return !0;
      } }, { key: "getCoordinate", value: function() {
        if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null;
        if (arguments.length === 1) {
          var a = arguments[0];
          return this.pts[a];
        }
      } }, { key: "print", value: function(a) {
        a.print("edge " + this._name + ": "), a.print("LINESTRING (");
        for (var l = 0; l < this.pts.length; l++) l > 0 && a.print(","), a.print(this.pts[l].x + " " + this.pts[l].y);
        a.print(")  " + this._label + " " + this._depthDelta);
      } }, { key: "computeIM", value: function(a) {
        o.updateIM(this._label, a);
      } }, { key: "isCollapsed", value: function() {
        return !!this._label.isArea() && this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]);
      } }, { key: "isClosed", value: function() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      } }, { key: "getMaximumSegmentIndex", value: function() {
        return this.pts.length - 1;
      } }, { key: "getDepthDelta", value: function() {
        return this._depthDelta;
      } }, { key: "getNumPoints", value: function() {
        return this.pts.length;
      } }, { key: "printReverse", value: function(a) {
        a.print("edge " + this._name + ": ");
        for (var l = this.pts.length - 1; l >= 0; l--) a.print(this.pts[l] + " ");
        a.println("");
      } }, { key: "getMonotoneChainEdge", value: function() {
        return this._mce === null && (this._mce = new rv(this)), this._mce;
      } }, { key: "getEnvelope", value: function() {
        if (this._env === null) {
          this._env = new Ot();
          for (var a = 0; a < this.pts.length; a++) this._env.expandToInclude(this.pts[a]);
        }
        return this._env;
      } }, { key: "addIntersection", value: function(a, l, d, v) {
        var x = new B(a.getIntersection(v)), w = l, k = a.getEdgeDistance(d, v), N = w + 1;
        if (N < this.pts.length) {
          var P = this.pts[N];
          x.equals2D(P) && (w = N, k = 0);
        }
        this.eiList.add(x, w, k);
      } }, { key: "toString", value: function() {
        var a = new Co();
        a.append("edge " + this._name + ": "), a.append("LINESTRING (");
        for (var l = 0; l < this.pts.length; l++) l > 0 && a.append(","), a.append(this.pts[l].x + " " + this.pts[l].y);
        return a.append(")  " + this._label + " " + this._depthDelta), a.toString();
      } }, { key: "isPointwiseEqual", value: function(a) {
        if (this.pts.length !== a.pts.length) return !1;
        for (var l = 0; l < this.pts.length; l++) if (!this.pts[l].equals2D(a.pts[l])) return !1;
        return !0;
      } }, { key: "setDepthDelta", value: function(a) {
        this._depthDelta = a;
      } }, { key: "getEdgeIntersectionList", value: function() {
        return this.eiList;
      } }, { key: "addIntersections", value: function(a, l, d) {
        for (var v = 0; v < a.getIntersectionNum(); v++) this.addIntersection(a, l, d, v);
      } }], [{ key: "constructor_", value: function() {
        if (this.pts = null, this._env = null, this.eiList = new tv(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new mc(), this._depthDelta = 0, arguments.length === 1) {
          var a = arguments[0];
          o.constructor_.call(this, a, null);
        } else if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          this.pts = l, this._label = d;
        }
      } }, { key: "updateIM", value: function() {
        if (!(arguments.length === 2 && arguments[1] instanceof ev && arguments[0] instanceof Ke)) return S(h(o), "updateIM", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1];
        l.setAtLeastIfValid(a.getLocation(0, H.ON), a.getLocation(1, H.ON), 1), a.isArea() && (l.setAtLeastIfValid(a.getLocation(0, H.LEFT), a.getLocation(1, H.LEFT), 2), l.setAtLeastIfValid(a.getLocation(0, H.RIGHT), a.getLocation(1, H.RIGHT), 2));
      } }]), o;
    }(Kh), pc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "setWorkingPrecisionModel", value: function(r) {
        this._workingPrecisionModel = r;
      } }, { key: "insertUniqueEdge", value: function(r) {
        var o = this._edgeList.findEqualEdge(r);
        if (o !== null) {
          var a = o.getLabel(), l = r.getLabel();
          o.isPointwiseEqual(r) || (l = new Ke(r.getLabel())).flip(), a.merge(l);
          var d = f.depthDelta(l), v = o.getDepthDelta() + d;
          o.setDepthDelta(v);
        } else this._edgeList.add(r), r.setDepthDelta(f.depthDelta(r.getLabel()));
      } }, { key: "buildSubgraphs", value: function(r, o) {
        for (var a = new ut(), l = r.iterator(); l.hasNext(); ) {
          var d = l.next(), v = d.getRightmostCoordinate(), x = new hc(a).getDepth(v);
          d.computeDepth(x), d.findResultEdges(), a.add(d), o.add(d.getDirectedEdges(), d.getNodes());
        }
      } }, { key: "createSubgraphs", value: function(r) {
        for (var o = new ut(), a = r.getNodes().iterator(); a.hasNext(); ) {
          var l = a.next();
          if (!l.isVisited()) {
            var d = new Ir();
            d.create(l), o.add(d);
          }
        }
        return Tr.sort(o, Tr.reverseOrder()), o;
      } }, { key: "createEmptyResultGeometry", value: function() {
        return this._geomFact.createPolygon();
      } }, { key: "getNoder", value: function(r) {
        if (this._workingNoder !== null) return this._workingNoder;
        var o = new du(), a = new qi();
        return a.setPrecisionModel(r), o.setSegmentIntersector(new Jp(a)), o;
      } }, { key: "buffer", value: function(r, o) {
        var a = this._workingPrecisionModel;
        a === null && (a = r.getPrecisionModel()), this._geomFact = r.getFactory();
        var l = new Wp(a, this._bufParams), d = new qp(r, o, l).getCurves();
        if (d.size() <= 0) return this.createEmptyResultGeometry();
        this.computeNodedEdges(d, a), this._graph = new nc(new Kp()), this._graph.addEdges(this._edgeList.getEdges());
        var v = this.createSubgraphs(this._graph), x = new Lp(this._geomFact);
        this.buildSubgraphs(v, x);
        var w = x.getPolygons();
        return w.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(w);
      } }, { key: "computeNodedEdges", value: function(r, o) {
        var a = this.getNoder(o);
        a.computeNodes(r);
        for (var l = a.getNodedSubstrings().iterator(); l.hasNext(); ) {
          var d = l.next(), v = d.getCoordinates();
          if (v.length !== 2 || !v[0].equals2D(v[1])) {
            var x = d.getData(), w = new yc(d.getCoordinates(), new Ke(x));
            this.insertUniqueEdge(w);
          }
        }
      } }, { key: "setNoder", value: function(r) {
        this._workingNoder = r;
      } }], [{ key: "constructor_", value: function() {
        this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new $p();
        var r = arguments[0];
        this._bufParams = r;
      } }, { key: "depthDelta", value: function(r) {
        var o = r.getLocation(0, H.LEFT), a = r.getLocation(0, H.RIGHT);
        return o === L.INTERIOR && a === L.EXTERIOR ? 1 : o === L.EXTERIOR && a === L.INTERIOR ? -1 : 0;
      } }, { key: "convertSegStrings", value: function(r) {
        for (var o = new Rr(), a = new ut(); r.hasNext(); ) {
          var l = r.next(), d = o.createLineString(l.getCoordinates());
          a.add(d);
        }
        return o.buildGeometry(a);
      } }]), f;
    }(), sv = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "rescale", value: function() {
        if (ht(arguments[0], mt)) for (var r = arguments[0], o = r.iterator(); o.hasNext(); ) {
          var a = o.next();
          this.rescale(a.getCoordinates());
        }
        else if (arguments[0] instanceof Array) {
          for (var l = arguments[0], d = 0; d < l.length; d++) l[d].x = l[d].x / this._scaleFactor + this._offsetX, l[d].y = l[d].y / this._scaleFactor + this._offsetY;
          l.length === 2 && l[0].equals2D(l[1]) && ge.out.println(l);
        }
      } }, { key: "scale", value: function() {
        if (ht(arguments[0], mt)) {
          for (var r = arguments[0], o = new ut(r.size()), a = r.iterator(); a.hasNext(); ) {
            var l = a.next();
            o.add(new Ui(this.scale(l.getCoordinates()), l.getData()));
          }
          return o;
        }
        if (arguments[0] instanceof Array) {
          for (var d = arguments[0], v = new Array(d.length).fill(null), x = 0; x < d.length; x++) v[x] = new B(Math.round((d[x].x - this._offsetX) * this._scaleFactor), Math.round((d[x].y - this._offsetY) * this._scaleFactor), d[x].getZ());
          var w = ne.removeRepeatedPoints(v);
          return w;
        }
      } }, { key: "isIntegerPrecision", value: function() {
        return this._scaleFactor === 1;
      } }, { key: "getNodedSubstrings", value: function() {
        var r = this._noder.getNodedSubstrings();
        return this._isScaled && this.rescale(r), r;
      } }, { key: "computeNodes", value: function(r) {
        var o = r;
        this._isScaled && (o = this.scale(r)), this._noder.computeNodes(o);
      } }, { key: "interfaces_", get: function() {
        return [gu];
      } }], [{ key: "constructor_", value: function() {
        if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) {
          var r = arguments[0], o = arguments[1];
          f.constructor_.call(this, r, o, 0, 0);
        } else if (arguments.length === 4) {
          var a = arguments[0], l = arguments[1];
          this._noder = a, this._scaleFactor = l, this._isScaled = !this.isIntegerPrecision();
        }
      } }]), f;
    }(), vc = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "checkEndPtVertexIntersections", value: function() {
        if (arguments.length === 0) for (var r = this._segStrings.iterator(); r.hasNext(); ) {
          var o = r.next(), a = o.getCoordinates();
          this.checkEndPtVertexIntersections(a[0], this._segStrings), this.checkEndPtVertexIntersections(a[a.length - 1], this._segStrings);
        }
        else if (arguments.length === 2) {
          for (var l = arguments[0], d = arguments[1], v = d.iterator(); v.hasNext(); ) for (var x = v.next(), w = x.getCoordinates(), k = 1; k < w.length - 1; k++) if (w[k].equals(l)) throw new Et("found endpt/interior pt intersection at index " + k + " :pt " + l);
        }
      } }, { key: "checkInteriorIntersections", value: function() {
        if (arguments.length === 0) for (var r = this._segStrings.iterator(); r.hasNext(); ) for (var o = r.next(), a = this._segStrings.iterator(); a.hasNext(); ) {
          var l = a.next();
          this.checkInteriorIntersections(o, l);
        }
        else if (arguments.length === 2) for (var d = arguments[0], v = arguments[1], x = d.getCoordinates(), w = v.getCoordinates(), k = 0; k < x.length - 1; k++) for (var N = 0; N < w.length - 1; N++) this.checkInteriorIntersections(d, k, v, N);
        else if (arguments.length === 4) {
          var P = arguments[0], W = arguments[1], tt = arguments[2], $ = arguments[3];
          if (P === tt && W === $) return null;
          var ot = P.getCoordinates()[W], ft = P.getCoordinates()[W + 1], pt = tt.getCoordinates()[$], Pt = tt.getCoordinates()[$ + 1];
          if (this._li.computeIntersection(ot, ft, pt, Pt), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, ot, ft) || this.hasInteriorIntersection(this._li, pt, Pt))) throw new Et("found non-noded intersection at " + ot + "-" + ft + " and " + pt + "-" + Pt);
        }
      } }, { key: "checkValid", value: function() {
        this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
      } }, { key: "checkCollapses", value: function() {
        if (arguments.length === 0) for (var r = this._segStrings.iterator(); r.hasNext(); ) {
          var o = r.next();
          this.checkCollapses(o);
        }
        else if (arguments.length === 1) for (var a = arguments[0], l = a.getCoordinates(), d = 0; d < l.length - 2; d++) this.checkCollapse(l[d], l[d + 1], l[d + 2]);
      } }, { key: "hasInteriorIntersection", value: function(r, o, a) {
        for (var l = 0; l < r.getIntersectionNum(); l++) {
          var d = r.getIntersection(l);
          if (!d.equals(o) && !d.equals(a)) return !0;
        }
        return !1;
      } }, { key: "checkCollapse", value: function(r, o, a) {
        if (r.equals(a)) throw new Et("found non-noded collapse at " + f.fact.createLineString([r, o, a]));
      } }], [{ key: "constructor_", value: function() {
        this._li = new qi(), this._segStrings = null;
        var r = arguments[0];
        this._segStrings = r;
      } }]), f;
    }();
    vc.fact = new Rr();
    var yu = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "intersectsScaled", value: function(r, o) {
        var a = Math.min(r.x, o.x), l = Math.max(r.x, o.x), d = Math.min(r.y, o.y), v = Math.max(r.y, o.y), x = this._maxx < a || this._minx > l || this._maxy < d || this._miny > v;
        if (x) return !1;
        var w = this.intersectsToleranceSquare(r, o);
        return X.isTrue(!(x && w), "Found bad envelope test"), w;
      } }, { key: "initCorners", value: function(r) {
        var o = 0.5;
        this._minx = r.x - o, this._maxx = r.x + o, this._miny = r.y - o, this._maxy = r.y + o, this._corner[0] = new B(this._maxx, this._maxy), this._corner[1] = new B(this._minx, this._maxy), this._corner[2] = new B(this._minx, this._miny), this._corner[3] = new B(this._maxx, this._miny);
      } }, { key: "intersects", value: function(r, o) {
        return this._scaleFactor === 1 ? this.intersectsScaled(r, o) : (this.copyScaled(r, this._p0Scaled), this.copyScaled(o, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
      } }, { key: "scale", value: function(r) {
        return Math.round(r * this._scaleFactor);
      } }, { key: "getCoordinate", value: function() {
        return this._originalPt;
      } }, { key: "copyScaled", value: function(r, o) {
        o.x = this.scale(r.x), o.y = this.scale(r.y);
      } }, { key: "getSafeEnvelope", value: function() {
        if (this._safeEnv === null) {
          var r = f.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
          this._safeEnv = new Ot(this._originalPt.x - r, this._originalPt.x + r, this._originalPt.y - r, this._originalPt.y + r);
        }
        return this._safeEnv;
      } }, { key: "intersectsPixelClosure", value: function(r, o) {
        return this._li.computeIntersection(r, o, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(r, o, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(r, o, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(r, o, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
      } }, { key: "intersectsToleranceSquare", value: function(r, o) {
        var a = !1, l = !1;
        return this._li.computeIntersection(r, o, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(r, o, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (a = !0), this._li.computeIntersection(r, o, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (l = !0), this._li.computeIntersection(r, o, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!a || !l) || !!r.equals(this._pt) || !!o.equals(this._pt))));
      } }, { key: "addSnappedNode", value: function(r, o) {
        var a = r.getCoordinate(o), l = r.getCoordinate(o + 1);
        return !!this.intersects(a, l) && (r.addIntersection(this.getCoordinate(), o), !0);
      } }], [{ key: "constructor_", value: function() {
        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
        var r = arguments[0], o = arguments[1], a = arguments[2];
        if (this._originalPt = r, this._pt = r, this._scaleFactor = o, this._li = a, o <= 0) throw new M("Scale factor must be non-zero");
        o !== 1 && (this._pt = new B(this.scale(r.x), this.scale(r.y)), this._p0Scaled = new B(), this._p1Scaled = new B()), this.initCorners(this._pt);
      } }]), f;
    }();
    yu.SAFE_ENV_EXPANSION_FACTOR = 0.75;
    var ov = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "select", value: function() {
        if (arguments.length !== 1) {
          if (arguments.length === 2) {
            var r = arguments[0], o = arguments[1];
            r.getLineSegment(o, this.selectedSegment), this.select(this.selectedSegment);
          }
        }
      } }], [{ key: "constructor_", value: function() {
        this.selectedSegment = new Ge();
      } }]), f;
    }(), _c = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "snap", value: function() {
        if (arguments.length === 1) {
          var r = arguments[0];
          return this.snap(r, null, -1);
        }
        if (arguments.length === 3) {
          var o = arguments[0], a = arguments[1], l = arguments[2], d = o.getSafeEnvelope(), v = new Ec(o, a, l);
          return this._index.query(d, new (function() {
            function x() {
              e(this, x);
            }
            return s(x, [{ key: "interfaces_", get: function() {
              return [rc];
            } }, { key: "visitItem", value: function(w) {
              w.select(d, v);
            } }]), x;
          }())()), v.isNodeAdded();
        }
      } }], [{ key: "constructor_", value: function() {
        this._index = null;
        var r = arguments[0];
        this._index = r;
      } }]), f;
    }(), Ec = function(f) {
      u(o, f);
      var r = E(o);
      function o() {
        var a;
        return e(this, o), a = r.call(this), o.constructor_.apply(p(a), arguments), a;
      }
      return s(o, [{ key: "isNodeAdded", value: function() {
        return this._isNodeAdded;
      } }, { key: "select", value: function() {
        if (!(arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof oc)) return S(h(o.prototype), "select", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1], d = a.getContext();
        if (this._parentEdge === d && (l === this._hotPixelVertexIndex || l + 1 === this._hotPixelVertexIndex)) return null;
        this._isNodeAdded |= this._hotPixel.addSnappedNode(d, l);
      } }], [{ key: "constructor_", value: function() {
        this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
        var a = arguments[0], l = arguments[1], d = arguments[2];
        this._hotPixel = a, this._parentEdge = l, this._hotPixelVertexIndex = d;
      } }]), o;
    }(ov);
    _c.HotPixelSnapAction = Ec;
    var av = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "processIntersections", value: function(r, o, a, l) {
        if (r === a && o === l) return null;
        var d = r.getCoordinates()[o], v = r.getCoordinates()[o + 1], x = a.getCoordinates()[l], w = a.getCoordinates()[l + 1];
        if (this._li.computeIntersection(d, v, x, w), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
          for (var k = 0; k < this._li.getIntersectionNum(); k++) this._interiorIntersections.add(this._li.getIntersection(k));
          r.addIntersections(this._li, o, 0), a.addIntersections(this._li, l, 1);
        }
      } }, { key: "isDone", value: function() {
        return !1;
      } }, { key: "getInteriorIntersections", value: function() {
        return this._interiorIntersections;
      } }, { key: "interfaces_", get: function() {
        return [dc];
      } }], [{ key: "constructor_", value: function() {
        this._li = null, this._interiorIntersections = null;
        var r = arguments[0];
        this._li = r, this._interiorIntersections = new ut();
      } }]), f;
    }(), uv = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "checkCorrectness", value: function(r) {
        var o = Ui.getNodedSubstrings(r), a = new vc(o);
        try {
          a.checkValid();
        } catch (l) {
          if (!(l instanceof O)) throw l;
          l.printStackTrace();
        }
      } }, { key: "getNodedSubstrings", value: function() {
        return Ui.getNodedSubstrings(this._nodedSegStrings);
      } }, { key: "snapRound", value: function(r, o) {
        var a = this.findInteriorIntersections(r, o);
        this.computeIntersectionSnaps(a), this.computeVertexSnaps(r);
      } }, { key: "findInteriorIntersections", value: function(r, o) {
        var a = new av(o);
        return this._noder.setSegmentIntersector(a), this._noder.computeNodes(r), a.getInteriorIntersections();
      } }, { key: "computeVertexSnaps", value: function() {
        if (ht(arguments[0], mt)) for (var r = arguments[0], o = r.iterator(); o.hasNext(); ) {
          var a = o.next();
          this.computeVertexSnaps(a);
        }
        else if (arguments[0] instanceof Ui) for (var l = arguments[0], d = l.getCoordinates(), v = 0; v < d.length; v++) {
          var x = new yu(d[v], this._scaleFactor, this._li), w = this._pointSnapper.snap(x, l, v);
          w && l.addIntersection(d[v], v);
        }
      } }, { key: "computeNodes", value: function(r) {
        this._nodedSegStrings = r, this._noder = new du(), this._pointSnapper = new _c(this._noder.getIndex()), this.snapRound(r, this._li);
      } }, { key: "computeIntersectionSnaps", value: function(r) {
        for (var o = r.iterator(); o.hasNext(); ) {
          var a = o.next(), l = new yu(a, this._scaleFactor, this._li);
          this._pointSnapper.snap(l);
        }
      } }, { key: "interfaces_", get: function() {
        return [gu];
      } }], [{ key: "constructor_", value: function() {
        this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
        var r = arguments[0];
        this._pm = r, this._li = new qi(), this._li.setPrecisionModel(r), this._scaleFactor = r.getScale();
      } }]), f;
    }(), Or = function() {
      function f() {
        e(this, f), f.constructor_.apply(this, arguments);
      }
      return s(f, [{ key: "bufferFixedPrecision", value: function(r) {
        var o = new sv(new uv(new ln(1)), r.getScale()), a = new pc(this._bufParams);
        a.setWorkingPrecisionModel(r), a.setNoder(o), this._resultGeometry = a.buffer(this._argGeom, this._distance);
      } }, { key: "bufferReducedPrecision", value: function() {
        if (arguments.length === 0) {
          for (var r = f.MAX_PRECISION_DIGITS; r >= 0; r--) {
            try {
              this.bufferReducedPrecision(r);
            } catch (d) {
              if (!(d instanceof fe)) throw d;
              this._saveException = d;
            }
            if (this._resultGeometry !== null) return null;
          }
          throw this._saveException;
        }
        if (arguments.length === 1) {
          var o = arguments[0], a = f.precisionScaleFactor(this._argGeom, this._distance, o), l = new ln(a);
          this.bufferFixedPrecision(l);
        }
      } }, { key: "computeGeometry", value: function() {
        if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null;
        var r = this._argGeom.getFactory().getPrecisionModel();
        r.getType() === ln.FIXED ? this.bufferFixedPrecision(r) : this.bufferReducedPrecision();
      } }, { key: "setQuadrantSegments", value: function(r) {
        this._bufParams.setQuadrantSegments(r);
      } }, { key: "bufferOriginalPrecision", value: function() {
        try {
          var r = new pc(this._bufParams);
          this._resultGeometry = r.buffer(this._argGeom, this._distance);
        } catch (o) {
          if (!(o instanceof Et)) throw o;
          this._saveException = o;
        }
      } }, { key: "getResultGeometry", value: function(r) {
        return this._distance = r, this.computeGeometry(), this._resultGeometry;
      } }, { key: "setEndCapStyle", value: function(r) {
        this._bufParams.setEndCapStyle(r);
      } }], [{ key: "constructor_", value: function() {
        if (this._argGeom = null, this._distance = null, this._bufParams = new T(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
          var r = arguments[0];
          this._argGeom = r;
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this._argGeom = o, this._bufParams = a;
        }
      } }, { key: "bufferOp", value: function() {
        if (arguments.length === 2) {
          var r = arguments[0], o = arguments[1], a = new f(r), l = a.getResultGeometry(o);
          return l;
        }
        if (arguments.length === 3) {
          if (Number.isInteger(arguments[2]) && arguments[0] instanceof it && typeof arguments[1] == "number") {
            var d = arguments[0], v = arguments[1], x = arguments[2], w = new f(d);
            w.setQuadrantSegments(x);
            var k = w.getResultGeometry(v);
            return k;
          }
          if (arguments[2] instanceof T && arguments[0] instanceof it && typeof arguments[1] == "number") {
            var N = arguments[0], P = arguments[1], W = arguments[2], tt = new f(N, W), $ = tt.getResultGeometry(P);
            return $;
          }
        } else if (arguments.length === 4) {
          var ot = arguments[0], ft = arguments[1], pt = arguments[2], Pt = arguments[3], Zt = new f(ot);
          Zt.setQuadrantSegments(pt), Zt.setEndCapStyle(Pt);
          var _e = Zt.getResultGeometry(ft);
          return _e;
        }
      } }, { key: "precisionScaleFactor", value: function(r, o, a) {
        var l = r.getEnvelopeInternal(), d = un.max(Math.abs(l.getMaxX()), Math.abs(l.getMaxY()), Math.abs(l.getMinX()), Math.abs(l.getMinY())) + 2 * (o > 0 ? o : 0), v = a - Math.trunc(Math.log(d) / Math.log(10) + 1);
        return Math.pow(10, v);
      } }]), f;
    }();
    Or.CAP_ROUND = T.CAP_ROUND, Or.CAP_BUTT = T.CAP_FLAT, Or.CAP_FLAT = T.CAP_FLAT, Or.CAP_SQUARE = T.CAP_SQUARE, Or.MAX_PRECISION_DIGITS = 12;
    var lv = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], xc = function() {
      function f(r) {
        e(this, f), this.geometryFactory = r || new Rr();
      }
      return s(f, [{ key: "read", value: function(r) {
        var o, a = (o = typeof r == "string" ? JSON.parse(r) : r).type;
        if (!Je[a]) throw new Error("Unknown GeoJSON type: " + o.type);
        return lv.indexOf(a) !== -1 ? Je[a].call(this, o.coordinates) : a === "GeometryCollection" ? Je[a].call(this, o.geometries) : Je[a].call(this, o);
      } }, { key: "write", value: function(r) {
        var o = r.getGeometryType();
        if (!bn[o]) throw new Error("Geometry is not supported");
        return bn[o].call(this, r);
      } }]), f;
    }(), Je = { Feature: function(f) {
      var r = {};
      for (var o in f) r[o] = f[o];
      if (f.geometry) {
        var a = f.geometry.type;
        if (!Je[a]) throw new Error("Unknown GeoJSON type: " + f.type);
        r.geometry = this.read(f.geometry);
      }
      return f.bbox && (r.bbox = Je.bbox.call(this, f.bbox)), r;
    }, FeatureCollection: function(f) {
      var r = {};
      if (f.features) {
        r.features = [];
        for (var o = 0; o < f.features.length; ++o) r.features.push(this.read(f.features[o]));
      }
      return f.bbox && (r.bbox = this.parse.bbox.call(this, f.bbox)), r;
    }, coordinates: function(f) {
      for (var r = [], o = 0; o < f.length; ++o) {
        var a = f[o];
        r.push(m(B, I(a)));
      }
      return r;
    }, bbox: function(f) {
      return this.geometryFactory.createLinearRing([new B(f[0], f[1]), new B(f[2], f[1]), new B(f[2], f[3]), new B(f[0], f[3]), new B(f[0], f[1])]);
    }, Point: function(f) {
      var r = m(B, I(f));
      return this.geometryFactory.createPoint(r);
    }, MultiPoint: function(f) {
      for (var r = [], o = 0; o < f.length; ++o) r.push(Je.Point.call(this, f[o]));
      return this.geometryFactory.createMultiPoint(r);
    }, LineString: function(f) {
      var r = Je.coordinates.call(this, f);
      return this.geometryFactory.createLineString(r);
    }, MultiLineString: function(f) {
      for (var r = [], o = 0; o < f.length; ++o) r.push(Je.LineString.call(this, f[o]));
      return this.geometryFactory.createMultiLineString(r);
    }, Polygon: function(f) {
      for (var r = Je.coordinates.call(this, f[0]), o = this.geometryFactory.createLinearRing(r), a = [], l = 1; l < f.length; ++l) {
        var d = f[l], v = Je.coordinates.call(this, d), x = this.geometryFactory.createLinearRing(v);
        a.push(x);
      }
      return this.geometryFactory.createPolygon(o, a);
    }, MultiPolygon: function(f) {
      for (var r = [], o = 0; o < f.length; ++o) {
        var a = f[o];
        r.push(Je.Polygon.call(this, a));
      }
      return this.geometryFactory.createMultiPolygon(r);
    }, GeometryCollection: function(f) {
      for (var r = [], o = 0; o < f.length; ++o) {
        var a = f[o];
        r.push(this.read(a));
      }
      return this.geometryFactory.createGeometryCollection(r);
    } }, bn = { coordinate: function(f) {
      var r = [f.x, f.y];
      return f.z && r.push(f.z), f.m && r.push(f.m), r;
    }, Point: function(f) {
      return { type: "Point", coordinates: bn.coordinate.call(this, f.getCoordinate()) };
    }, MultiPoint: function(f) {
      for (var r = [], o = 0; o < f._geometries.length; ++o) {
        var a = f._geometries[o], l = bn.Point.call(this, a);
        r.push(l.coordinates);
      }
      return { type: "MultiPoint", coordinates: r };
    }, LineString: function(f) {
      for (var r = [], o = f.getCoordinates(), a = 0; a < o.length; ++a) {
        var l = o[a];
        r.push(bn.coordinate.call(this, l));
      }
      return { type: "LineString", coordinates: r };
    }, MultiLineString: function(f) {
      for (var r = [], o = 0; o < f._geometries.length; ++o) {
        var a = f._geometries[o], l = bn.LineString.call(this, a);
        r.push(l.coordinates);
      }
      return { type: "MultiLineString", coordinates: r };
    }, Polygon: function(f) {
      var r = [], o = bn.LineString.call(this, f._shell);
      r.push(o.coordinates);
      for (var a = 0; a < f._holes.length; ++a) {
        var l = f._holes[a], d = bn.LineString.call(this, l);
        r.push(d.coordinates);
      }
      return { type: "Polygon", coordinates: r };
    }, MultiPolygon: function(f) {
      for (var r = [], o = 0; o < f._geometries.length; ++o) {
        var a = f._geometries[o], l = bn.Polygon.call(this, a);
        r.push(l.coordinates);
      }
      return { type: "MultiPolygon", coordinates: r };
    }, GeometryCollection: function(f) {
      for (var r = [], o = 0; o < f._geometries.length; ++o) {
        var a = f._geometries[o], l = a.getGeometryType();
        r.push(bn[l].call(this, a));
      }
      return { type: "GeometryCollection", geometries: r };
    } };
    return { BufferOp: Or, GeoJSONReader: function() {
      function f(r) {
        e(this, f), this.parser = new xc(r || new Rr());
      }
      return s(f, [{ key: "read", value: function(r) {
        return this.parser.read(r);
      } }]), f;
    }(), GeoJSONWriter: function() {
      function f() {
        e(this, f), this.parser = new xc(this.geometryFactory);
      }
      return s(f, [{ key: "write", value: function(r) {
        return this.parser.write(r);
      } }]), f;
    }() };
  });
})(Hy);
var _b = Hy.exports;
const Eb = /* @__PURE__ */ zm(_b);
function Bi() {
  return new Pa();
}
function Pa() {
  this.reset();
}
Pa.prototype = {
  constructor: Pa,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(n) {
    rd(qo, n, this.t), rd(this, qo.s, this.s), this.s ? this.t += qo.t : this.s = qo.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var qo = new Pa();
function rd(n, t, e) {
  var i = n.s = t + e, s = i - t, u = i - s;
  n.t = t - u + (e - s);
}
var qt = 1e-6, Nt = Math.PI, Nn = Nt / 2, sd = Nt / 4, Pn = Nt * 2, vi = 180 / Nt, tn = Nt / 180, he = Math.abs, xb = Math.atan, us = Math.atan2, Ht = Math.cos, Kt = Math.sin, vs = Math.sqrt;
function Ky(n) {
  return n > 1 ? 0 : n < -1 ? Nt : Math.acos(n);
}
function cr(n) {
  return n > 1 ? Nn : n < -1 ? -Nn : Math.asin(n);
}
function Xs() {
}
function Da(n, t) {
  n && ad.hasOwnProperty(n.type) && ad[n.type](n, t);
}
var od = {
  Feature: function(n, t) {
    Da(n.geometry, t);
  },
  FeatureCollection: function(n, t) {
    for (var e = n.features, i = -1, s = e.length; ++i < s; ) Da(e[i].geometry, t);
  }
}, ad = {
  Sphere: function(n, t) {
    t.sphere();
  },
  Point: function(n, t) {
    n = n.coordinates, t.point(n[0], n[1], n[2]);
  },
  MultiPoint: function(n, t) {
    for (var e = n.coordinates, i = -1, s = e.length; ++i < s; ) n = e[i], t.point(n[0], n[1], n[2]);
  },
  LineString: function(n, t) {
    Bl(n.coordinates, t, 0);
  },
  MultiLineString: function(n, t) {
    for (var e = n.coordinates, i = -1, s = e.length; ++i < s; ) Bl(e[i], t, 0);
  },
  Polygon: function(n, t) {
    ud(n.coordinates, t);
  },
  MultiPolygon: function(n, t) {
    for (var e = n.coordinates, i = -1, s = e.length; ++i < s; ) ud(e[i], t);
  },
  GeometryCollection: function(n, t) {
    for (var e = n.geometries, i = -1, s = e.length; ++i < s; ) Da(e[i], t);
  }
};
function Bl(n, t, e) {
  var i = -1, s = n.length - e, u;
  for (t.lineStart(); ++i < s; ) u = n[i], t.point(u[0], u[1], u[2]);
  t.lineEnd();
}
function ud(n, t) {
  var e = -1, i = n.length;
  for (t.polygonStart(); ++e < i; ) Bl(n[e], t, 1);
  t.polygonEnd();
}
function Sb(n, t) {
  n && od.hasOwnProperty(n.type) ? od[n.type](n, t) : Da(n, t);
}
Bi();
Bi();
function zl(n) {
  return [us(n[1], n[0]), cr(n[2])];
}
function ls(n) {
  var t = n[0], e = n[1], i = Ht(e);
  return [i * Ht(t), i * Kt(t), Kt(e)];
}
function Uo(n, t) {
  return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
}
function Fa(n, t) {
  return [n[1] * t[2] - n[2] * t[1], n[2] * t[0] - n[0] * t[2], n[0] * t[1] - n[1] * t[0]];
}
function Ju(n, t) {
  n[0] += t[0], n[1] += t[1], n[2] += t[2];
}
function jo(n, t) {
  return [n[0] * t, n[1] * t, n[2] * t];
}
function Yl(n) {
  var t = vs(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  n[0] /= t, n[1] /= t, n[2] /= t;
}
Bi();
function $y(n, t) {
  function e(i, s) {
    return i = n(i, s), t(i[0], i[1]);
  }
  return n.invert && t.invert && (e.invert = function(i, s) {
    return i = t.invert(i, s), i && n.invert(i[0], i[1]);
  }), e;
}
function Wl(n, t) {
  return [n > Nt ? n - Pn : n < -Nt ? n + Pn : n, t];
}
Wl.invert = Wl;
function wb(n, t, e) {
  return (n %= Pn) ? t || e ? $y(hd(n), cd(t, e)) : hd(n) : t || e ? cd(t, e) : Wl;
}
function ld(n) {
  return function(t, e) {
    return t += n, [t > Nt ? t - Pn : t < -Nt ? t + Pn : t, e];
  };
}
function hd(n) {
  var t = ld(n);
  return t.invert = ld(-n), t;
}
function cd(n, t) {
  var e = Ht(n), i = Kt(n), s = Ht(t), u = Kt(t);
  function h(c, g) {
    var m = Ht(g), y = Ht(c) * m, p = Kt(c) * m, _ = Kt(g), E = _ * e + y * i;
    return [
      us(p * s - E * u, y * e - _ * i),
      cr(E * s + p * u)
    ];
  }
  return h.invert = function(c, g) {
    var m = Ht(g), y = Ht(c) * m, p = Kt(c) * m, _ = Kt(g), E = _ * s - p * u;
    return [
      us(p * s + _ * u, y * e + E * i),
      cr(E * e - y * i)
    ];
  }, h;
}
function Ib(n, t, e, i, s, u) {
  if (e) {
    var h = Ht(t), c = Kt(t), g = i * e;
    s == null ? (s = t + i * Pn, u = t - g / 2) : (s = fd(h, s), u = fd(h, u), (i > 0 ? s < u : s > u) && (s += i * Pn));
    for (var m, y = s; i > 0 ? y > u : y < u; y -= g)
      m = zl([h, -c * Ht(y), -c * Kt(y)]), n.point(m[0], m[1]);
  }
}
function fd(n, t) {
  t = ls(t), t[0] -= n, Yl(t);
  var e = Ky(-t[1]);
  return ((-t[2] < 0 ? -e : e) + Pn - qt) % Pn;
}
function Jy() {
  var n = [], t;
  return {
    point: function(e, i) {
      t.push([e, i]);
    },
    lineStart: function() {
      n.push(t = []);
    },
    lineEnd: Xs,
    rejoin: function() {
      n.length > 1 && n.push(n.pop().concat(n.shift()));
    },
    result: function() {
      var e = n;
      return n = [], t = null, e;
    }
  };
}
function kb(n, t, e, i, s, u) {
  var h = n[0], c = n[1], g = t[0], m = t[1], y = 0, p = 1, _ = g - h, E = m - c, S;
  if (S = e - h, !(!_ && S > 0)) {
    if (S /= _, _ < 0) {
      if (S < y) return;
      S < p && (p = S);
    } else if (_ > 0) {
      if (S > p) return;
      S > y && (y = S);
    }
    if (S = s - h, !(!_ && S < 0)) {
      if (S /= _, _ < 0) {
        if (S > p) return;
        S > y && (y = S);
      } else if (_ > 0) {
        if (S < y) return;
        S < p && (p = S);
      }
      if (S = i - c, !(!E && S > 0)) {
        if (S /= E, E < 0) {
          if (S < y) return;
          S < p && (p = S);
        } else if (E > 0) {
          if (S > p) return;
          S > y && (y = S);
        }
        if (S = u - c, !(!E && S < 0)) {
          if (S /= E, E < 0) {
            if (S > p) return;
            S > y && (y = S);
          } else if (E > 0) {
            if (S < y) return;
            S < p && (p = S);
          }
          return y > 0 && (n[0] = h + y * _, n[1] = c + y * E), p < 1 && (t[0] = h + p * _, t[1] = c + p * E), !0;
        }
      }
    }
  }
}
function aa(n, t) {
  return he(n[0] - t[0]) < qt && he(n[1] - t[1]) < qt;
}
function Vo(n, t, e, i) {
  this.x = n, this.z = t, this.o = e, this.e = i, this.v = !1, this.n = this.p = null;
}
function Qy(n, t, e, i, s) {
  var u = [], h = [], c, g;
  if (n.forEach(function(S) {
    if (!((I = S.length - 1) <= 0)) {
      var I, b = S[0], C = S[I], R;
      if (aa(b, C)) {
        for (s.lineStart(), c = 0; c < I; ++c) s.point((b = S[c])[0], b[1]);
        s.lineEnd();
        return;
      }
      u.push(R = new Vo(b, S, null, !0)), h.push(R.o = new Vo(b, null, R, !1)), u.push(R = new Vo(C, S, null, !1)), h.push(R.o = new Vo(C, null, R, !0));
    }
  }), !!u.length) {
    for (h.sort(t), gd(u), gd(h), c = 0, g = h.length; c < g; ++c)
      h[c].e = e = !e;
    for (var m = u[0], y, p; ; ) {
      for (var _ = m, E = !0; _.v; ) if ((_ = _.n) === m) return;
      y = _.z, s.lineStart();
      do {
        if (_.v = _.o.v = !0, _.e) {
          if (E)
            for (c = 0, g = y.length; c < g; ++c) s.point((p = y[c])[0], p[1]);
          else
            i(_.x, _.n.x, 1, s);
          _ = _.n;
        } else {
          if (E)
            for (y = _.p.z, c = y.length - 1; c >= 0; --c) s.point((p = y[c])[0], p[1]);
          else
            i(_.x, _.p.x, -1, s);
          _ = _.p;
        }
        _ = _.o, y = _.z, E = !E;
      } while (!_.v);
      s.lineEnd();
    }
  }
}
function gd(n) {
  if (t = n.length) {
    for (var t, e = 0, i = n[0], s; ++e < t; )
      i.n = s = n[e], s.p = i, i = s;
    i.n = s = n[0], s.p = i;
  }
}
function tp(n, t) {
  return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function bb(n) {
  return n.length === 1 && (n = Cb(n)), {
    left: function(t, e, i, s) {
      for (i == null && (i = 0), s == null && (s = t.length); i < s; ) {
        var u = i + s >>> 1;
        n(t[u], e) < 0 ? i = u + 1 : s = u;
      }
      return i;
    },
    right: function(t, e, i, s) {
      for (i == null && (i = 0), s == null && (s = t.length); i < s; ) {
        var u = i + s >>> 1;
        n(t[u], e) > 0 ? s = u : i = u + 1;
      }
      return i;
    }
  };
}
function Cb(n) {
  return function(t, e) {
    return tp(n(t), e);
  };
}
bb(tp);
function ep(n) {
  for (var t = n.length, e, i = -1, s = 0, u, h; ++i < t; ) s += n[i].length;
  for (u = new Array(s); --t >= 0; )
    for (h = n[t], e = h.length; --e >= 0; )
      u[--s] = h[e];
  return u;
}
var qs = 1e9, Zo = -qs;
function Rb(n, t, e, i) {
  function s(m, y) {
    return n <= m && m <= e && t <= y && y <= i;
  }
  function u(m, y, p, _) {
    var E = 0, S = 0;
    if (m == null || (E = h(m, p)) !== (S = h(y, p)) || g(m, y) < 0 ^ p > 0)
      do
        _.point(E === 0 || E === 3 ? n : e, E > 1 ? i : t);
      while ((E = (E + p + 4) % 4) !== S);
    else
      _.point(y[0], y[1]);
  }
  function h(m, y) {
    return he(m[0] - n) < qt ? y > 0 ? 0 : 3 : he(m[0] - e) < qt ? y > 0 ? 2 : 1 : he(m[1] - t) < qt ? y > 0 ? 1 : 0 : y > 0 ? 3 : 2;
  }
  function c(m, y) {
    return g(m.x, y.x);
  }
  function g(m, y) {
    var p = h(m, 1), _ = h(y, 1);
    return p !== _ ? p - _ : p === 0 ? y[1] - m[1] : p === 1 ? m[0] - y[0] : p === 2 ? m[1] - y[1] : y[0] - m[0];
  }
  return function(m) {
    var y = m, p = Jy(), _, E, S, I, b, C, R, T, O, M, G, D = {
      point: F,
      lineStart: U,
      lineEnd: nt,
      polygonStart: j,
      polygonEnd: et
    };
    function F(K, Z) {
      s(K, Z) && y.point(K, Z);
    }
    function A() {
      for (var K = 0, Z = 0, at = E.length; Z < at; ++Z)
        for (var gt = E[Z], xt = 1, Q = gt.length, _t = gt[0], Et, Wt, X = _t[0], pe = _t[1]; xt < Q; ++xt)
          Et = X, Wt = pe, _t = gt[xt], X = _t[0], pe = _t[1], Wt <= i ? pe > i && (X - Et) * (i - Wt) > (pe - Wt) * (n - Et) && ++K : pe <= i && (X - Et) * (i - Wt) < (pe - Wt) * (n - Et) && --K;
      return K;
    }
    function j() {
      y = p, _ = [], E = [], G = !0;
    }
    function et() {
      var K = A(), Z = G && K, at = (_ = ep(_)).length;
      (Z || at) && (m.polygonStart(), Z && (m.lineStart(), u(null, null, 1, m), m.lineEnd()), at && Qy(_, c, K, u, m), m.polygonEnd()), y = m, _ = E = S = null;
    }
    function U() {
      D.point = z, E && E.push(S = []), M = !0, O = !1, R = T = NaN;
    }
    function nt() {
      _ && (z(I, b), C && O && p.rejoin(), _.push(p.result())), D.point = F, O && y.lineEnd();
    }
    function z(K, Z) {
      var at = s(K, Z);
      if (E && S.push([K, Z]), M)
        I = K, b = Z, C = at, M = !1, at && (y.lineStart(), y.point(K, Z));
      else if (at && O) y.point(K, Z);
      else {
        var gt = [R = Math.max(Zo, Math.min(qs, R)), T = Math.max(Zo, Math.min(qs, T))], xt = [K = Math.max(Zo, Math.min(qs, K)), Z = Math.max(Zo, Math.min(qs, Z))];
        kb(gt, xt, n, t, e, i) ? (O || (y.lineStart(), y.point(gt[0], gt[1])), y.point(xt[0], xt[1]), at || y.lineEnd(), G = !1) : at && (y.lineStart(), y.point(K, Z), G = !1);
      }
      R = K, T = Z, O = at;
    }
    return D;
  };
}
var Qu = Bi();
function Lb(n, t) {
  var e = t[0], i = t[1], s = [Kt(e), -Ht(e), 0], u = 0, h = 0;
  Qu.reset();
  for (var c = 0, g = n.length; c < g; ++c)
    if (y = (m = n[c]).length)
      for (var m, y, p = m[y - 1], _ = p[0], E = p[1] / 2 + sd, S = Kt(E), I = Ht(E), b = 0; b < y; ++b, _ = R, S = O, I = M, p = C) {
        var C = m[b], R = C[0], T = C[1] / 2 + sd, O = Kt(T), M = Ht(T), G = R - _, D = G >= 0 ? 1 : -1, F = D * G, A = F > Nt, j = S * O;
        if (Qu.add(us(j * D * Kt(F), I * M + j * Ht(F))), u += A ? G + D * Pn : G, A ^ _ >= e ^ R >= e) {
          var et = Fa(ls(p), ls(C));
          Yl(et);
          var U = Fa(s, et);
          Yl(U);
          var nt = (A ^ G >= 0 ? -1 : 1) * cr(U[2]);
          (i > nt || i === nt && (et[0] || et[1])) && (h += A ^ G >= 0 ? 1 : -1);
        }
      }
  return (u < -qt || u < qt && Qu < -qt) ^ h & 1;
}
Bi();
function dd(n) {
  return n;
}
Bi();
Bi();
var hs = 1 / 0, Ga = hs, yo = -hs, Ba = yo, md = {
  point: Tb,
  lineStart: Xs,
  lineEnd: Xs,
  polygonStart: Xs,
  polygonEnd: Xs,
  result: function() {
    var n = [[hs, Ga], [yo, Ba]];
    return yo = Ba = -(Ga = hs = 1 / 0), n;
  }
};
function Tb(n, t) {
  n < hs && (hs = n), n > yo && (yo = n), t < Ga && (Ga = t), t > Ba && (Ba = t);
}
Bi();
function np(n, t, e, i) {
  return function(s, u) {
    var h = t(u), c = s.invert(i[0], i[1]), g = Jy(), m = t(g), y = !1, p, _, E, S = {
      point: I,
      lineStart: C,
      lineEnd: R,
      polygonStart: function() {
        S.point = T, S.lineStart = O, S.lineEnd = M, _ = [], p = [];
      },
      polygonEnd: function() {
        S.point = I, S.lineStart = C, S.lineEnd = R, _ = ep(_);
        var G = Lb(p, c);
        _.length ? (y || (u.polygonStart(), y = !0), Qy(_, Mb, G, e, u)) : G && (y || (u.polygonStart(), y = !0), u.lineStart(), e(null, null, 1, u), u.lineEnd()), y && (u.polygonEnd(), y = !1), _ = p = null;
      },
      sphere: function() {
        u.polygonStart(), u.lineStart(), e(null, null, 1, u), u.lineEnd(), u.polygonEnd();
      }
    };
    function I(G, D) {
      var F = s(G, D);
      n(G = F[0], D = F[1]) && u.point(G, D);
    }
    function b(G, D) {
      var F = s(G, D);
      h.point(F[0], F[1]);
    }
    function C() {
      S.point = b, h.lineStart();
    }
    function R() {
      S.point = I, h.lineEnd();
    }
    function T(G, D) {
      E.push([G, D]);
      var F = s(G, D);
      m.point(F[0], F[1]);
    }
    function O() {
      m.lineStart(), E = [];
    }
    function M() {
      T(E[0][0], E[0][1]), m.lineEnd();
      var G = m.clean(), D = g.result(), F, A = D.length, j, et, U;
      if (E.pop(), p.push(E), E = null, !!A) {
        if (G & 1) {
          if (et = D[0], (j = et.length - 1) > 0) {
            for (y || (u.polygonStart(), y = !0), u.lineStart(), F = 0; F < j; ++F) u.point((U = et[F])[0], U[1]);
            u.lineEnd();
          }
          return;
        }
        A > 1 && G & 2 && D.push(D.pop().concat(D.shift())), _.push(D.filter(Nb));
      }
    }
    return S;
  };
}
function Nb(n) {
  return n.length > 1;
}
function Mb(n, t) {
  return ((n = n.x)[0] < 0 ? n[1] - Nn - qt : Nn - n[1]) - ((t = t.x)[0] < 0 ? t[1] - Nn - qt : Nn - t[1]);
}
const yd = np(
  function() {
    return !0;
  },
  Ob,
  Pb,
  [-Nt, -Nn]
);
function Ob(n) {
  var t = NaN, e = NaN, i = NaN, s;
  return {
    lineStart: function() {
      n.lineStart(), s = 1;
    },
    point: function(u, h) {
      var c = u > 0 ? Nt : -Nt, g = he(u - t);
      he(g - Nt) < qt ? (n.point(t, e = (e + h) / 2 > 0 ? Nn : -Nn), n.point(i, e), n.lineEnd(), n.lineStart(), n.point(c, e), n.point(u, e), s = 0) : i !== c && g >= Nt && (he(t - i) < qt && (t -= i * qt), he(u - c) < qt && (u -= c * qt), e = Ab(t, e, u, h), n.point(i, e), n.lineEnd(), n.lineStart(), n.point(c, e), s = 0), n.point(t = u, e = h), i = c;
    },
    lineEnd: function() {
      n.lineEnd(), t = e = NaN;
    },
    clean: function() {
      return 2 - s;
    }
  };
}
function Ab(n, t, e, i) {
  var s, u, h = Kt(n - e);
  return he(h) > qt ? xb((Kt(t) * (u = Ht(i)) * Kt(e) - Kt(i) * (s = Ht(t)) * Kt(n)) / (s * u * h)) : (t + i) / 2;
}
function Pb(n, t, e, i) {
  var s;
  if (n == null)
    s = e * Nn, i.point(-Nt, s), i.point(0, s), i.point(Nt, s), i.point(Nt, 0), i.point(Nt, -s), i.point(0, -s), i.point(-Nt, -s), i.point(-Nt, 0), i.point(-Nt, s);
  else if (he(n[0] - t[0]) > qt) {
    var u = n[0] < t[0] ? Nt : -Nt;
    s = e * u / 2, i.point(-u, s), i.point(0, s), i.point(u, s);
  } else
    i.point(t[0], t[1]);
}
function Db(n, t) {
  var e = Ht(n), i = e > 0, s = he(e) > qt;
  function u(y, p, _, E) {
    Ib(E, n, t, _, y, p);
  }
  function h(y, p) {
    return Ht(y) * Ht(p) > e;
  }
  function c(y) {
    var p, _, E, S, I;
    return {
      lineStart: function() {
        S = E = !1, I = 1;
      },
      point: function(b, C) {
        var R = [b, C], T, O = h(b, C), M = i ? O ? 0 : m(b, C) : O ? m(b + (b < 0 ? Nt : -Nt), C) : 0;
        if (!p && (S = E = O) && y.lineStart(), O !== E && (T = g(p, R), (!T || aa(p, T) || aa(R, T)) && (R[0] += qt, R[1] += qt, O = h(R[0], R[1]))), O !== E)
          I = 0, O ? (y.lineStart(), T = g(R, p), y.point(T[0], T[1])) : (T = g(p, R), y.point(T[0], T[1]), y.lineEnd()), p = T;
        else if (s && p && i ^ O) {
          var G;
          !(M & _) && (G = g(R, p, !0)) && (I = 0, i ? (y.lineStart(), y.point(G[0][0], G[0][1]), y.point(G[1][0], G[1][1]), y.lineEnd()) : (y.point(G[1][0], G[1][1]), y.lineEnd(), y.lineStart(), y.point(G[0][0], G[0][1])));
        }
        O && (!p || !aa(p, R)) && y.point(R[0], R[1]), p = R, E = O, _ = M;
      },
      lineEnd: function() {
        E && y.lineEnd(), p = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return I | (S && E) << 1;
      }
    };
  }
  function g(y, p, _) {
    var E = ls(y), S = ls(p), I = [1, 0, 0], b = Fa(E, S), C = Uo(b, b), R = b[0], T = C - R * R;
    if (!T) return !_ && y;
    var O = e * C / T, M = -e * R / T, G = Fa(I, b), D = jo(I, O), F = jo(b, M);
    Ju(D, F);
    var A = G, j = Uo(D, A), et = Uo(A, A), U = j * j - et * (Uo(D, D) - 1);
    if (!(U < 0)) {
      var nt = vs(U), z = jo(A, (-j - nt) / et);
      if (Ju(z, D), z = zl(z), !_) return z;
      var K = y[0], Z = p[0], at = y[1], gt = p[1], xt;
      Z < K && (xt = K, K = Z, Z = xt);
      var Q = Z - K, _t = he(Q - Nt) < qt, Et = _t || Q < qt;
      if (!_t && gt < at && (xt = at, at = gt, gt = xt), Et ? _t ? at + gt > 0 ^ z[1] < (he(z[0] - K) < qt ? at : gt) : at <= z[1] && z[1] <= gt : Q > Nt ^ (K <= z[0] && z[0] <= Z)) {
        var Wt = jo(A, (-j + nt) / et);
        return Ju(Wt, D), [z, zl(Wt)];
      }
    }
  }
  function m(y, p) {
    var _ = i ? n : Nt - n, E = 0;
    return y < -_ ? E |= 1 : y > _ && (E |= 2), p < -_ ? E |= 4 : p > _ && (E |= 8), E;
  }
  return np(h, c, u, i ? [0, -n] : [-Nt, n - Nt]);
}
function ip(n) {
  return function(t) {
    var e = new Xl();
    for (var i in n) e[i] = n[i];
    return e.stream = t, e;
  };
}
function Xl() {
}
Xl.prototype = {
  constructor: Xl,
  point: function(n, t) {
    this.stream.point(n, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function rp(n, t, e) {
  var i = t[1][0] - t[0][0], s = t[1][1] - t[0][1], u = n.clipExtent && n.clipExtent();
  n.scale(150).translate([0, 0]), u != null && n.clipExtent(null), Sb(e, n.stream(md));
  var h = md.result(), c = Math.min(i / (h[1][0] - h[0][0]), s / (h[1][1] - h[0][1])), g = +t[0][0] + (i - c * (h[1][0] + h[0][0])) / 2, m = +t[0][1] + (s - c * (h[1][1] + h[0][1])) / 2;
  return u != null && n.clipExtent(u), n.scale(c * 150).translate([g, m]);
}
function Fb(n, t, e) {
  return rp(n, [[0, 0], t], e);
}
var pd = 16, Gb = Ht(30 * tn);
function vd(n, t) {
  return +t ? zb(n, t) : Bb(n);
}
function Bb(n) {
  return ip({
    point: function(t, e) {
      t = n(t, e), this.stream.point(t[0], t[1]);
    }
  });
}
function zb(n, t) {
  function e(i, s, u, h, c, g, m, y, p, _, E, S, I, b) {
    var C = m - i, R = y - s, T = C * C + R * R;
    if (T > 4 * t && I--) {
      var O = h + _, M = c + E, G = g + S, D = vs(O * O + M * M + G * G), F = cr(G /= D), A = he(he(G) - 1) < qt || he(u - p) < qt ? (u + p) / 2 : us(M, O), j = n(A, F), et = j[0], U = j[1], nt = et - i, z = U - s, K = R * nt - C * z;
      (K * K / T > t || he((C * nt + R * z) / T - 0.5) > 0.3 || h * _ + c * E + g * S < Gb) && (e(i, s, u, h, c, g, et, U, A, O /= D, M /= D, G, I, b), b.point(et, U), e(et, U, A, O, M, G, m, y, p, _, E, S, I, b));
    }
  }
  return function(i) {
    var s, u, h, c, g, m, y, p, _, E, S, I, b = {
      point: C,
      lineStart: R,
      lineEnd: O,
      polygonStart: function() {
        i.polygonStart(), b.lineStart = M;
      },
      polygonEnd: function() {
        i.polygonEnd(), b.lineStart = R;
      }
    };
    function C(F, A) {
      F = n(F, A), i.point(F[0], F[1]);
    }
    function R() {
      p = NaN, b.point = T, i.lineStart();
    }
    function T(F, A) {
      var j = ls([F, A]), et = n(F, A);
      e(p, _, y, E, S, I, p = et[0], _ = et[1], y = F, E = j[0], S = j[1], I = j[2], pd, i), i.point(p, _);
    }
    function O() {
      b.point = C, i.lineEnd();
    }
    function M() {
      R(), b.point = G, b.lineEnd = D;
    }
    function G(F, A) {
      T(s = F, A), u = p, h = _, c = E, g = S, m = I, b.point = T;
    }
    function D() {
      e(p, _, y, E, S, I, u, h, s, c, g, m, pd, i), b.lineEnd = O, O();
    }
    return b;
  };
}
var Yb = ip({
  point: function(n, t) {
    this.stream.point(n * tn, t * tn);
  }
});
function Wb(n) {
  return Xb(function() {
    return n;
  })();
}
function Xb(n) {
  var t, e = 150, i = 480, s = 250, u, h, c = 0, g = 0, m = 0, y = 0, p = 0, _, E, S = null, I = yd, b = null, C, R, T, O = dd, M = 0.5, G = vd(et, M), D, F;
  function A(z) {
    return z = E(z[0] * tn, z[1] * tn), [z[0] * e + u, h - z[1] * e];
  }
  function j(z) {
    return z = E.invert((z[0] - u) / e, (h - z[1]) / e), z && [z[0] * vi, z[1] * vi];
  }
  function et(z, K) {
    return z = t(z, K), [z[0] * e + u, h - z[1] * e];
  }
  A.stream = function(z) {
    return D && F === z ? D : D = Yb(I(_, G(O(F = z))));
  }, A.clipAngle = function(z) {
    return arguments.length ? (I = +z ? Db(S = z * tn, 6 * tn) : (S = null, yd), nt()) : S * vi;
  }, A.clipExtent = function(z) {
    return arguments.length ? (O = z == null ? (b = C = R = T = null, dd) : Rb(b = +z[0][0], C = +z[0][1], R = +z[1][0], T = +z[1][1]), nt()) : b == null ? null : [[b, C], [R, T]];
  }, A.scale = function(z) {
    return arguments.length ? (e = +z, U()) : e;
  }, A.translate = function(z) {
    return arguments.length ? (i = +z[0], s = +z[1], U()) : [i, s];
  }, A.center = function(z) {
    return arguments.length ? (c = z[0] % 360 * tn, g = z[1] % 360 * tn, U()) : [c * vi, g * vi];
  }, A.rotate = function(z) {
    return arguments.length ? (m = z[0] % 360 * tn, y = z[1] % 360 * tn, p = z.length > 2 ? z[2] % 360 * tn : 0, U()) : [m * vi, y * vi, p * vi];
  }, A.precision = function(z) {
    return arguments.length ? (G = vd(et, M = z * z), nt()) : vs(M);
  }, A.fitExtent = function(z, K) {
    return rp(A, z, K);
  }, A.fitSize = function(z, K) {
    return Fb(A, z, K);
  };
  function U() {
    E = $y(_ = wb(m, y, p), t);
    var z = t(c, g);
    return u = i - z[0] * e, h = s + z[1] * e, nt();
  }
  function nt() {
    return D = F = null, A;
  }
  return function() {
    return t = n.apply(this, arguments), A.invert = t.invert && j, U();
  };
}
function sp(n) {
  return function(t, e) {
    var i = Ht(t), s = Ht(e), u = n(i * s);
    return [
      u * s * Kt(t),
      u * Kt(e)
    ];
  };
}
function op(n) {
  return function(t, e) {
    var i = vs(t * t + e * e), s = n(i), u = Kt(s), h = Ht(s);
    return [
      us(t * u, i * h),
      cr(i && e * u / i)
    ];
  };
}
var qb = sp(function(n) {
  return vs(2 / (1 + n));
});
qb.invert = op(function(n) {
  return 2 * cr(n / 2);
});
var ap = sp(function(n) {
  return (n = Ky(n)) && n / Kt(n);
});
ap.invert = op(function(n) {
  return n;
});
function Ub() {
  return Wb(ap).scale(79.4188).clipAngle(180 - 1e-3);
}
function _d(n, t) {
  return [n, t];
}
_d.invert = _d;
var jb = Object.defineProperty, _s = (n, t) => jb(n, "name", { value: t, configurable: !0 }), { BufferOp: Vb, GeoJSONReader: Zb, GeoJSONWriter: Hb } = Eb;
function up(n, t, e) {
  e = e || {};
  var i = e.units || "kilometers", s = e.steps || 8;
  if (!n)
    throw new Error("geojson is required");
  if (typeof e != "object")
    throw new Error("options must be an object");
  if (typeof s != "number")
    throw new Error("steps must be an number");
  if (t === void 0)
    throw new Error("radius is required");
  if (s <= 0)
    throw new Error("steps must be greater than 0");
  var u = [];
  switch (n.type) {
    case "GeometryCollection":
      return ps(n, function(h) {
        var c = Ks(h, t, i, s);
        c && u.push(c);
      }), oi(u);
    case "FeatureCollection":
      return Aa(n, function(h) {
        var c = Ks(h, t, i, s);
        c && Aa(c, function(g) {
          g && u.push(g);
        });
      }), oi(u);
  }
  return Ks(n, t, i, s);
}
_s(up, "buffer");
function Ks(n, t, e, i) {
  var s = n.properties || {}, u = n.type === "Feature" ? n.geometry : n;
  if (u.type === "GeometryCollection") {
    var h = [];
    return ps(n, function(I) {
      var b = Ks(I, t, e, i);
      b && h.push(b);
    }), oi(h);
  }
  var c = lp(u), g = {
    type: u.type,
    coordinates: Bh(u.coordinates, c)
  }, m = new Zb(), y = m.read(g), p = Dh(eu(t, e), "meters"), _ = Vb.bufferOp(y, p, i), E = new Hb();
  if (_ = E.write(_), !Gh(_.coordinates)) {
    var S = {
      type: _.type,
      coordinates: zh(_.coordinates, c)
    };
    return En(S, s);
  }
}
_s(Ks, "bufferFeature");
function Gh(n) {
  return Array.isArray(n[0]) ? Gh(n[0]) : isNaN(n[0]);
}
_s(Gh, "coordsIsNaN");
function Bh(n, t) {
  return typeof n[0] != "object" ? t(n) : n.map(function(e) {
    return Bh(e, t);
  });
}
_s(Bh, "projectCoords");
function zh(n, t) {
  return typeof n[0] != "object" ? t.invert(n) : n.map(function(e) {
    return zh(e, t);
  });
}
_s(zh, "unprojectCoords");
function lp(n) {
  var t = Zy(n).geometry.coordinates, e = [-t[0], -t[1]];
  return Ub().rotate(e).scale(Te);
}
_s(lp, "defineProjection");
var Kb = up;
/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function $b(n, t) {
  var e = { label: 0, sent: function() {
    if (u[0] & 1) throw u[1];
    return u[1];
  }, trys: [], ops: [] }, i, s, u, h;
  return h = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (h[Symbol.iterator] = function() {
    return this;
  }), h;
  function c(m) {
    return function(y) {
      return g([m, y]);
    };
  }
  function g(m) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; e; ) try {
      if (i = 1, s && (u = m[0] & 2 ? s.return : m[0] ? s.throw || ((u = s.return) && u.call(s), 0) : s.next) && !(u = u.call(s, m[1])).done) return u;
      switch (s = 0, u && (m = [m[0] & 2, u.value]), m[0]) {
        case 0:
        case 1:
          u = m;
          break;
        case 4:
          return e.label++, { value: m[1], done: !1 };
        case 5:
          e.label++, s = m[1], m = [0];
          continue;
        case 7:
          m = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (u = e.trys, !(u = u.length > 0 && u[u.length - 1]) && (m[0] === 6 || m[0] === 2)) {
            e = 0;
            continue;
          }
          if (m[0] === 3 && (!u || m[1] > u[0] && m[1] < u[3])) {
            e.label = m[1];
            break;
          }
          if (m[0] === 6 && e.label < u[1]) {
            e.label = u[1], u = m;
            break;
          }
          if (u && e.label < u[2]) {
            e.label = u[2], e.ops.push(m);
            break;
          }
          u[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      m = t.call(n, e);
    } catch (y) {
      m = [6, y], s = 0;
    } finally {
      i = u = 0;
    }
    if (m[0] & 5) throw m[1];
    return { value: m[0] ? m[1] : void 0, done: !0 };
  }
}
var Di = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(t, e) {
      this.next = null, this.key = t, this.data = e, this.left = null, this.right = null;
    }
    return n;
  }()
);
function Jb(n, t) {
  return n > t ? 1 : n < t ? -1 : 0;
}
function Ei(n, t, e) {
  for (var i = new Di(null, null), s = i, u = i; ; ) {
    var h = e(n, t.key);
    if (h < 0) {
      if (t.left === null)
        break;
      if (e(n, t.left.key) < 0) {
        var c = t.left;
        if (t.left = c.right, c.right = t, t = c, t.left === null)
          break;
      }
      u.left = t, u = t, t = t.left;
    } else if (h > 0) {
      if (t.right === null)
        break;
      if (e(n, t.right.key) > 0) {
        var c = t.right;
        if (t.right = c.left, c.left = t, t = c, t.right === null)
          break;
      }
      s.right = t, s = t, t = t.right;
    } else
      break;
  }
  return s.right = t.left, u.left = t.right, t.left = i.right, t.right = i.left, t;
}
function tl(n, t, e, i) {
  var s = new Di(n, t);
  if (e === null)
    return s.left = s.right = null, s;
  e = Ei(n, e, i);
  var u = i(n, e.key);
  return u < 0 ? (s.left = e.left, s.right = e, e.left = null) : u >= 0 && (s.right = e.right, s.left = e, e.right = null), s;
}
function Ed(n, t, e) {
  var i = null, s = null;
  if (t) {
    t = Ei(n, t, e);
    var u = e(t.key, n);
    u === 0 ? (i = t.left, s = t.right) : u < 0 ? (s = t.right, t.right = null, i = t) : (i = t.left, t.left = null, s = t);
  }
  return { left: i, right: s };
}
function Qb(n, t, e) {
  return t === null ? n : (n === null || (t = Ei(n.key, t, e), t.left = n), t);
}
function ql(n, t, e, i, s) {
  if (n) {
    i("" + t + (e ? " " : " ") + s(n) + `
`);
    var u = t + (e ? "    " : "   ");
    n.left && ql(n.left, u, !1, i, s), n.right && ql(n.right, u, !0, i, s);
  }
}
var Yh = (
  /** @class */
  function() {
    function n(t) {
      t === void 0 && (t = Jb), this._root = null, this._size = 0, this._comparator = t;
    }
    return n.prototype.insert = function(t, e) {
      return this._size++, this._root = tl(t, e, this._root, this._comparator);
    }, n.prototype.add = function(t, e) {
      var i = new Di(t, e);
      this._root === null && (i.left = i.right = null, this._size++, this._root = i);
      var s = this._comparator, u = Ei(t, this._root, s), h = s(t, u.key);
      return h === 0 ? this._root = u : (h < 0 ? (i.left = u.left, i.right = u, u.left = null) : h > 0 && (i.right = u.right, i.left = u, u.right = null), this._size++, this._root = i), this._root;
    }, n.prototype.remove = function(t) {
      this._root = this._remove(t, this._root, this._comparator);
    }, n.prototype._remove = function(t, e, i) {
      var s;
      if (e === null)
        return null;
      e = Ei(t, e, i);
      var u = i(t, e.key);
      return u === 0 ? (e.left === null ? s = e.right : (s = Ei(t, e.left, i), s.right = e.right), this._size--, s) : e;
    }, n.prototype.pop = function() {
      var t = this._root;
      if (t) {
        for (; t.left; )
          t = t.left;
        return this._root = Ei(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), { key: t.key, data: t.data };
      }
      return null;
    }, n.prototype.findStatic = function(t) {
      for (var e = this._root, i = this._comparator; e; ) {
        var s = i(t, e.key);
        if (s === 0)
          return e;
        s < 0 ? e = e.left : e = e.right;
      }
      return null;
    }, n.prototype.find = function(t) {
      return this._root && (this._root = Ei(t, this._root, this._comparator), this._comparator(t, this._root.key) !== 0) ? null : this._root;
    }, n.prototype.contains = function(t) {
      for (var e = this._root, i = this._comparator; e; ) {
        var s = i(t, e.key);
        if (s === 0)
          return !0;
        s < 0 ? e = e.left : e = e.right;
      }
      return !1;
    }, n.prototype.forEach = function(t, e) {
      for (var i = this._root, s = [], u = !1; !u; )
        i !== null ? (s.push(i), i = i.left) : s.length !== 0 ? (i = s.pop(), t.call(e, i), i = i.right) : u = !0;
      return this;
    }, n.prototype.range = function(t, e, i, s) {
      for (var u = [], h = this._comparator, c = this._root, g; u.length !== 0 || c; )
        if (c)
          u.push(c), c = c.left;
        else {
          if (c = u.pop(), g = h(c.key, e), g > 0)
            break;
          if (h(c.key, t) >= 0 && i.call(s, c))
            return this;
          c = c.right;
        }
      return this;
    }, n.prototype.keys = function() {
      var t = [];
      return this.forEach(function(e) {
        var i = e.key;
        return t.push(i);
      }), t;
    }, n.prototype.values = function() {
      var t = [];
      return this.forEach(function(e) {
        var i = e.data;
        return t.push(i);
      }), t;
    }, n.prototype.min = function() {
      return this._root ? this.minNode(this._root).key : null;
    }, n.prototype.max = function() {
      return this._root ? this.maxNode(this._root).key : null;
    }, n.prototype.minNode = function(t) {
      if (t === void 0 && (t = this._root), t)
        for (; t.left; )
          t = t.left;
      return t;
    }, n.prototype.maxNode = function(t) {
      if (t === void 0 && (t = this._root), t)
        for (; t.right; )
          t = t.right;
      return t;
    }, n.prototype.at = function(t) {
      for (var e = this._root, i = !1, s = 0, u = []; !i; )
        if (e)
          u.push(e), e = e.left;
        else if (u.length > 0) {
          if (e = u.pop(), s === t)
            return e;
          s++, e = e.right;
        } else
          i = !0;
      return null;
    }, n.prototype.next = function(t) {
      var e = this._root, i = null;
      if (t.right) {
        for (i = t.right; i.left; )
          i = i.left;
        return i;
      }
      for (var s = this._comparator; e; ) {
        var u = s(t.key, e.key);
        if (u === 0)
          break;
        u < 0 ? (i = e, e = e.left) : e = e.right;
      }
      return i;
    }, n.prototype.prev = function(t) {
      var e = this._root, i = null;
      if (t.left !== null) {
        for (i = t.left; i.right; )
          i = i.right;
        return i;
      }
      for (var s = this._comparator; e; ) {
        var u = s(t.key, e.key);
        if (u === 0)
          break;
        u < 0 ? e = e.left : (i = e, e = e.right);
      }
      return i;
    }, n.prototype.clear = function() {
      return this._root = null, this._size = 0, this;
    }, n.prototype.toList = function() {
      return eC(this._root);
    }, n.prototype.load = function(t, e, i) {
      e === void 0 && (e = []), i === void 0 && (i = !1);
      var s = t.length, u = this._comparator;
      if (i && Vl(t, e, 0, s - 1, u), this._root === null)
        this._root = Ul(t, e, 0, s), this._size = s;
      else {
        var h = nC(this.toList(), tC(t, e), u);
        s = this._size + s, this._root = jl({ head: h }, 0, s);
      }
      return this;
    }, n.prototype.isEmpty = function() {
      return this._root === null;
    }, Object.defineProperty(n.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.toString = function(t) {
      t === void 0 && (t = function(i) {
        return String(i.key);
      });
      var e = [];
      return ql(this._root, "", !0, function(i) {
        return e.push(i);
      }, t), e.join("");
    }, n.prototype.update = function(t, e, i) {
      var s = this._comparator, u = Ed(t, this._root, s), h = u.left, c = u.right;
      s(t, e) < 0 ? c = tl(e, i, c, s) : h = tl(e, i, h, s), this._root = Qb(h, c, s);
    }, n.prototype.split = function(t) {
      return Ed(t, this._root, this._comparator);
    }, n.prototype[Symbol.iterator] = function() {
      var t, e, i;
      return $b(this, function(s) {
        switch (s.label) {
          case 0:
            t = this._root, e = [], i = !1, s.label = 1;
          case 1:
            return i ? [3, 6] : t === null ? [3, 2] : (e.push(t), t = t.left, [3, 5]);
          case 2:
            return e.length === 0 ? [3, 4] : (t = e.pop(), [4, t]);
          case 3:
            return s.sent(), t = t.right, [3, 5];
          case 4:
            i = !0, s.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    }, n;
  }()
);
function Ul(n, t, e, i) {
  var s = i - e;
  if (s > 0) {
    var u = e + Math.floor(s / 2), h = n[u], c = t[u], g = new Di(h, c);
    return g.left = Ul(n, t, e, u), g.right = Ul(n, t, u + 1, i), g;
  }
  return null;
}
function tC(n, t) {
  for (var e = new Di(null, null), i = e, s = 0; s < n.length; s++)
    i = i.next = new Di(n[s], t[s]);
  return i.next = null, e.next;
}
function eC(n) {
  for (var t = n, e = [], i = !1, s = new Di(null, null), u = s; !i; )
    t ? (e.push(t), t = t.left) : e.length > 0 ? (t = u = u.next = e.pop(), t = t.right) : i = !0;
  return u.next = null, s.next;
}
function jl(n, t, e) {
  var i = e - t;
  if (i > 0) {
    var s = t + Math.floor(i / 2), u = jl(n, t, s), h = n.head;
    return h.left = u, n.head = n.head.next, h.right = jl(n, s + 1, e), h;
  }
  return null;
}
function nC(n, t, e) {
  for (var i = new Di(null, null), s = i, u = n, h = t; u !== null && h !== null; )
    e(u.key, h.key) < 0 ? (s.next = u, u = u.next) : (s.next = h, h = h.next), s = s.next;
  return u !== null ? s.next = u : h !== null && (s.next = h), i.next;
}
function Vl(n, t, e, i, s) {
  if (!(e >= i)) {
    for (var u = n[e + i >> 1], h = e - 1, c = i + 1; ; ) {
      do
        h++;
      while (s(n[h], u) < 0);
      do
        c--;
      while (s(n[c], u) > 0);
      if (h >= c)
        break;
      var g = n[h];
      n[h] = n[c], n[c] = g, g = t[h], t[h] = t[c], t[c] = g;
    }
    Vl(n, t, e, c, s), Vl(n, t, c + 1, i, s);
  }
}
const ei = 11102230246251565e-32, Ee = 134217729, iC = (3 + 8 * ei) * ei;
function el(n, t, e, i, s) {
  let u, h, c, g, m = t[0], y = i[0], p = 0, _ = 0;
  y > m == y > -m ? (u = m, m = t[++p]) : (u = y, y = i[++_]);
  let E = 0;
  if (p < n && _ < e)
    for (y > m == y > -m ? (h = m + u, c = u - (h - m), m = t[++p]) : (h = y + u, c = u - (h - y), y = i[++_]), u = h, c !== 0 && (s[E++] = c); p < n && _ < e; )
      y > m == y > -m ? (h = u + m, g = h - u, c = u - (h - g) + (m - g), m = t[++p]) : (h = u + y, g = h - u, c = u - (h - g) + (y - g), y = i[++_]), u = h, c !== 0 && (s[E++] = c);
  for (; p < n; )
    h = u + m, g = h - u, c = u - (h - g) + (m - g), m = t[++p], u = h, c !== 0 && (s[E++] = c);
  for (; _ < e; )
    h = u + y, g = h - u, c = u - (h - g) + (y - g), y = i[++_], u = h, c !== 0 && (s[E++] = c);
  return (u !== 0 || E === 0) && (s[E++] = u), E;
}
function rC(n, t) {
  let e = t[0];
  for (let i = 1; i < n; i++) e += t[i];
  return e;
}
function ko(n) {
  return new Float64Array(n);
}
const sC = (3 + 16 * ei) * ei, oC = (2 + 12 * ei) * ei, aC = (9 + 64 * ei) * ei * ei, Yr = ko(4), xd = ko(8), Sd = ko(12), wd = ko(16), Re = ko(4);
function uC(n, t, e, i, s, u, h) {
  let c, g, m, y, p, _, E, S, I, b, C, R, T, O, M, G, D, F;
  const A = n - s, j = e - s, et = t - u, U = i - u;
  O = A * U, _ = Ee * A, E = _ - (_ - A), S = A - E, _ = Ee * U, I = _ - (_ - U), b = U - I, M = S * b - (O - E * I - S * I - E * b), G = et * j, _ = Ee * et, E = _ - (_ - et), S = et - E, _ = Ee * j, I = _ - (_ - j), b = j - I, D = S * b - (G - E * I - S * I - E * b), C = M - D, p = M - C, Yr[0] = M - (C + p) + (p - D), R = O + C, p = R - O, T = O - (R - p) + (C - p), C = T - G, p = T - C, Yr[1] = T - (C + p) + (p - G), F = R + C, p = F - R, Yr[2] = R - (F - p) + (C - p), Yr[3] = F;
  let nt = rC(4, Yr), z = oC * h;
  if (nt >= z || -nt >= z || (p = n - A, c = n - (A + p) + (p - s), p = e - j, m = e - (j + p) + (p - s), p = t - et, g = t - (et + p) + (p - u), p = i - U, y = i - (U + p) + (p - u), c === 0 && g === 0 && m === 0 && y === 0) || (z = aC * h + iC * Math.abs(nt), nt += A * y + U * c - (et * m + j * g), nt >= z || -nt >= z)) return nt;
  O = c * U, _ = Ee * c, E = _ - (_ - c), S = c - E, _ = Ee * U, I = _ - (_ - U), b = U - I, M = S * b - (O - E * I - S * I - E * b), G = g * j, _ = Ee * g, E = _ - (_ - g), S = g - E, _ = Ee * j, I = _ - (_ - j), b = j - I, D = S * b - (G - E * I - S * I - E * b), C = M - D, p = M - C, Re[0] = M - (C + p) + (p - D), R = O + C, p = R - O, T = O - (R - p) + (C - p), C = T - G, p = T - C, Re[1] = T - (C + p) + (p - G), F = R + C, p = F - R, Re[2] = R - (F - p) + (C - p), Re[3] = F;
  const K = el(4, Yr, 4, Re, xd);
  O = A * y, _ = Ee * A, E = _ - (_ - A), S = A - E, _ = Ee * y, I = _ - (_ - y), b = y - I, M = S * b - (O - E * I - S * I - E * b), G = et * m, _ = Ee * et, E = _ - (_ - et), S = et - E, _ = Ee * m, I = _ - (_ - m), b = m - I, D = S * b - (G - E * I - S * I - E * b), C = M - D, p = M - C, Re[0] = M - (C + p) + (p - D), R = O + C, p = R - O, T = O - (R - p) + (C - p), C = T - G, p = T - C, Re[1] = T - (C + p) + (p - G), F = R + C, p = F - R, Re[2] = R - (F - p) + (C - p), Re[3] = F;
  const Z = el(K, xd, 4, Re, Sd);
  O = c * y, _ = Ee * c, E = _ - (_ - c), S = c - E, _ = Ee * y, I = _ - (_ - y), b = y - I, M = S * b - (O - E * I - S * I - E * b), G = g * m, _ = Ee * g, E = _ - (_ - g), S = g - E, _ = Ee * m, I = _ - (_ - m), b = m - I, D = S * b - (G - E * I - S * I - E * b), C = M - D, p = M - C, Re[0] = M - (C + p) + (p - D), R = O + C, p = R - O, T = O - (R - p) + (C - p), C = T - G, p = T - C, Re[1] = T - (C + p) + (p - G), F = R + C, p = F - R, Re[2] = R - (F - p) + (C - p), Re[3] = F;
  const at = el(Z, Sd, 4, Re, wd);
  return wd[at - 1];
}
function lC(n, t, e, i, s, u) {
  const h = (t - u) * (e - s), c = (n - s) * (i - u), g = h - c, m = Math.abs(h + c);
  return Math.abs(g) >= sC * m ? g : -uC(n, t, e, i, s, u, m);
}
const Fs = (n, t) => n.ll.x <= t.x && t.x <= n.ur.x && n.ll.y <= t.y && t.y <= n.ur.y, Zl = (n, t) => {
  if (t.ur.x < n.ll.x || n.ur.x < t.ll.x || t.ur.y < n.ll.y || n.ur.y < t.ll.y) return null;
  const e = n.ll.x < t.ll.x ? t.ll.x : n.ll.x, i = n.ur.x < t.ur.x ? n.ur.x : t.ur.x, s = n.ll.y < t.ll.y ? t.ll.y : n.ll.y, u = n.ur.y < t.ur.y ? n.ur.y : t.ur.y;
  return {
    ll: {
      x: e,
      y: s
    },
    ur: {
      x: i,
      y: u
    }
  };
};
let Ci = Number.EPSILON;
Ci === void 0 && (Ci = Math.pow(2, -52));
const hC = Ci * Ci, Id = (n, t) => {
  if (-Ci < n && n < Ci && -Ci < t && t < Ci)
    return 0;
  const e = n - t;
  return e * e < hC * n * t ? 0 : n < t ? -1 : 1;
};
class cC {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new kd(), this.yRounder = new kd();
  }
  round(t, e) {
    return {
      x: this.xRounder.round(t),
      y: this.yRounder.round(e)
    };
  }
}
class kd {
  constructor() {
    this.tree = new Yh(), this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(t) {
    const e = this.tree.add(t), i = this.tree.prev(e);
    if (i !== null && Id(e.key, i.key) === 0)
      return this.tree.remove(t), i.key;
    const s = this.tree.next(e);
    return s !== null && Id(e.key, s.key) === 0 ? (this.tree.remove(t), s.key) : t;
  }
}
const po = new cC(), ua = (n, t) => n.x * t.y - n.y * t.x, hp = (n, t) => n.x * t.x + n.y * t.y, bd = (n, t, e) => {
  const i = lC(n.x, n.y, t.x, t.y, e.x, e.y);
  return i > 0 ? -1 : i < 0 ? 1 : 0;
}, za = (n) => Math.sqrt(hp(n, n)), fC = (n, t, e) => {
  const i = {
    x: t.x - n.x,
    y: t.y - n.y
  }, s = {
    x: e.x - n.x,
    y: e.y - n.y
  };
  return ua(s, i) / za(s) / za(i);
}, gC = (n, t, e) => {
  const i = {
    x: t.x - n.x,
    y: t.y - n.y
  }, s = {
    x: e.x - n.x,
    y: e.y - n.y
  };
  return hp(s, i) / za(s) / za(i);
}, Cd = (n, t, e) => t.y === 0 ? null : {
  x: n.x + t.x / t.y * (e - n.y),
  y: e
}, Rd = (n, t, e) => t.x === 0 ? null : {
  x: e,
  y: n.y + t.y / t.x * (e - n.x)
}, dC = (n, t, e, i) => {
  if (t.x === 0) return Rd(e, i, n.x);
  if (i.x === 0) return Rd(n, t, e.x);
  if (t.y === 0) return Cd(e, i, n.y);
  if (i.y === 0) return Cd(n, t, e.y);
  const s = ua(t, i);
  if (s == 0) return null;
  const u = {
    x: e.x - n.x,
    y: e.y - n.y
  }, h = ua(u, t) / s, c = ua(u, i) / s, g = n.x + c * t.x, m = e.x + h * i.x, y = n.y + c * t.y, p = e.y + h * i.y, _ = (g + m) / 2, E = (y + p) / 2;
  return {
    x: _,
    y: E
  };
};
class sn {
  // for ordering sweep events in the sweep event queue
  static compare(t, e) {
    const i = sn.comparePoints(t.point, e.point);
    return i !== 0 ? i : (t.point !== e.point && t.link(e), t.isLeft !== e.isLeft ? t.isLeft ? 1 : -1 : Ni.compare(t.segment, e.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(t, e) {
    return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(t, e) {
    t.events === void 0 ? t.events = [this] : t.events.push(this), this.point = t, this.isLeft = e;
  }
  link(t) {
    if (t.point === this.point)
      throw new Error("Tried to link already linked events");
    const e = t.point.events;
    for (let i = 0, s = e.length; i < s; i++) {
      const u = e[i];
      this.point.events.push(u), u.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const t = this.point.events.length;
    for (let e = 0; e < t; e++) {
      const i = this.point.events[e];
      if (i.segment.consumedBy === void 0)
        for (let s = e + 1; s < t; s++) {
          const u = this.point.events[s];
          u.consumedBy === void 0 && i.otherSE.point.events === u.otherSE.point.events && i.segment.consume(u.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const t = [];
    for (let e = 0, i = this.point.events.length; e < i; e++) {
      const s = this.point.events[e];
      s !== this && !s.segment.ringOut && s.segment.isInResult() && t.push(s);
    }
    return t;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(t) {
    const e = /* @__PURE__ */ new Map(), i = (s) => {
      const u = s.otherSE;
      e.set(s, {
        sine: fC(this.point, t.point, u.point),
        cosine: gC(this.point, t.point, u.point)
      });
    };
    return (s, u) => {
      e.has(s) || i(s), e.has(u) || i(u);
      const {
        sine: h,
        cosine: c
      } = e.get(s), {
        sine: g,
        cosine: m
      } = e.get(u);
      return h >= 0 && g >= 0 ? c < m ? 1 : c > m ? -1 : 0 : h < 0 && g < 0 ? c < m ? -1 : c > m ? 1 : 0 : g < h ? -1 : g > h ? 1 : 0;
    };
  }
}
let mC = 0;
class Ni {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(t, e) {
    const i = t.leftSE.point.x, s = e.leftSE.point.x, u = t.rightSE.point.x, h = e.rightSE.point.x;
    if (h < i) return 1;
    if (u < s) return -1;
    const c = t.leftSE.point.y, g = e.leftSE.point.y, m = t.rightSE.point.y, y = e.rightSE.point.y;
    if (i < s) {
      if (g < c && g < m) return 1;
      if (g > c && g > m) return -1;
      const p = t.comparePoint(e.leftSE.point);
      if (p < 0) return 1;
      if (p > 0) return -1;
      const _ = e.comparePoint(t.rightSE.point);
      return _ !== 0 ? _ : -1;
    }
    if (i > s) {
      if (c < g && c < y) return -1;
      if (c > g && c > y) return 1;
      const p = e.comparePoint(t.leftSE.point);
      if (p !== 0) return p;
      const _ = t.comparePoint(e.rightSE.point);
      return _ < 0 ? 1 : _ > 0 ? -1 : 1;
    }
    if (c < g) return -1;
    if (c > g) return 1;
    if (u < h) {
      const p = e.comparePoint(t.rightSE.point);
      if (p !== 0) return p;
    }
    if (u > h) {
      const p = t.comparePoint(e.rightSE.point);
      if (p < 0) return 1;
      if (p > 0) return -1;
    }
    if (u !== h) {
      const p = m - c, _ = u - i, E = y - g, S = h - s;
      if (p > _ && E < S) return 1;
      if (p < _ && E > S) return -1;
    }
    return u > h ? 1 : u < h || m < y ? -1 : m > y ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(t, e, i, s) {
    this.id = ++mC, this.leftSE = t, t.segment = this, t.otherSE = e, this.rightSE = e, e.segment = this, e.otherSE = t, this.rings = i, this.windings = s;
  }
  static fromRing(t, e, i) {
    let s, u, h;
    const c = sn.comparePoints(t, e);
    if (c < 0)
      s = t, u = e, h = 1;
    else if (c > 0)
      s = e, u = t, h = -1;
    else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);
    const g = new sn(s, !0), m = new sn(u, !1);
    return new Ni(g, m, [i], [h]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(t) {
    this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const t = this.leftSE.point.y, e = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: t < e ? t : e
      },
      ur: {
        x: this.rightSE.point.x,
        y: t > e ? t : e
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(t) {
    return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(t) {
    if (this.isAnEndpoint(t)) return 0;
    const e = this.leftSE.point, i = this.rightSE.point, s = this.vector();
    if (e.x === i.x)
      return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
    const u = (t.y - e.y) / s.y, h = e.x + u * s.x;
    if (t.x === h) return 0;
    const c = (t.x - e.x) / s.x, g = e.y + c * s.y;
    return t.y === g ? 0 : t.y < g ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(t) {
    const e = this.bbox(), i = t.bbox(), s = Zl(e, i);
    if (s === null) return null;
    const u = this.leftSE.point, h = this.rightSE.point, c = t.leftSE.point, g = t.rightSE.point, m = Fs(e, c) && this.comparePoint(c) === 0, y = Fs(i, u) && t.comparePoint(u) === 0, p = Fs(e, g) && this.comparePoint(g) === 0, _ = Fs(i, h) && t.comparePoint(h) === 0;
    if (y && m)
      return _ && !p ? h : !_ && p ? g : null;
    if (y)
      return p && u.x === g.x && u.y === g.y ? null : u;
    if (m)
      return _ && h.x === c.x && h.y === c.y ? null : c;
    if (_ && p) return null;
    if (_) return h;
    if (p) return g;
    const E = dC(u, this.vector(), c, t.vector());
    return E === null || !Fs(s, E) ? null : po.round(E.x, E.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(t) {
    const e = [], i = t.events !== void 0, s = new sn(t, !0), u = new sn(t, !1), h = this.rightSE;
    this.replaceRightSE(u), e.push(u), e.push(s);
    const c = new Ni(s, h, this.rings.slice(), this.windings.slice());
    return sn.comparePoints(c.leftSE.point, c.rightSE.point) > 0 && c.swapEvents(), sn.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), i && (s.checkForConsuming(), u.checkForConsuming()), e;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const t = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let e = 0, i = this.windings.length; e < i; e++)
      this.windings[e] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(t) {
    let e = this, i = t;
    for (; e.consumedBy; ) e = e.consumedBy;
    for (; i.consumedBy; ) i = i.consumedBy;
    const s = Ni.compare(e, i);
    if (s !== 0) {
      if (s > 0) {
        const u = e;
        e = i, i = u;
      }
      if (e.prev === i) {
        const u = e;
        e = i, i = u;
      }
      for (let u = 0, h = i.rings.length; u < h; u++) {
        const c = i.rings[u], g = i.windings[u], m = e.rings.indexOf(c);
        m === -1 ? (e.rings.push(c), e.windings.push(g)) : e.windings[m] += g;
      }
      i.rings = null, i.windings = null, i.consumedBy = e, i.leftSE.consumedBy = e.leftSE, i.rightSE.consumedBy = e.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const t = this.prev.consumedBy || this.prev;
      this._beforeState = t.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const t = this.beforeState();
    this._afterState = {
      rings: t.rings.slice(0),
      windings: t.windings.slice(0),
      multiPolys: []
    };
    const e = this._afterState.rings, i = this._afterState.windings, s = this._afterState.multiPolys;
    for (let c = 0, g = this.rings.length; c < g; c++) {
      const m = this.rings[c], y = this.windings[c], p = e.indexOf(m);
      p === -1 ? (e.push(m), i.push(y)) : i[p] += y;
    }
    const u = [], h = [];
    for (let c = 0, g = e.length; c < g; c++) {
      if (i[c] === 0) continue;
      const m = e[c], y = m.poly;
      if (h.indexOf(y) === -1)
        if (m.isExterior) u.push(y);
        else {
          h.indexOf(y) === -1 && h.push(y);
          const p = u.indexOf(m.poly);
          p !== -1 && u.splice(p, 1);
        }
    }
    for (let c = 0, g = u.length; c < g; c++) {
      const m = u[c].multiPoly;
      s.indexOf(m) === -1 && s.push(m);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const t = this.beforeState().multiPolys, e = this.afterState().multiPolys;
    switch (yn.type) {
      case "union": {
        const i = t.length === 0, s = e.length === 0;
        this._isInResult = i !== s;
        break;
      }
      case "intersection": {
        let i, s;
        t.length < e.length ? (i = t.length, s = e.length) : (i = e.length, s = t.length), this._isInResult = s === yn.numMultiPolys && i < s;
        break;
      }
      case "xor": {
        const i = Math.abs(t.length - e.length);
        this._isInResult = i % 2 === 1;
        break;
      }
      case "difference": {
        const i = (s) => s.length === 1 && s[0].isSubject;
        this._isInResult = i(t) !== i(e);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${yn.type}`);
    }
    return this._isInResult;
  }
}
class Ld {
  constructor(t, e, i) {
    if (!Array.isArray(t) || t.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = e, this.isExterior = i, this.segments = [], typeof t[0][0] != "number" || typeof t[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const s = po.round(t[0][0], t[0][1]);
    this.bbox = {
      ll: {
        x: s.x,
        y: s.y
      },
      ur: {
        x: s.x,
        y: s.y
      }
    };
    let u = s;
    for (let h = 1, c = t.length; h < c; h++) {
      if (typeof t[h][0] != "number" || typeof t[h][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      let g = po.round(t[h][0], t[h][1]);
      g.x === u.x && g.y === u.y || (this.segments.push(Ni.fromRing(u, g, this)), g.x < this.bbox.ll.x && (this.bbox.ll.x = g.x), g.y < this.bbox.ll.y && (this.bbox.ll.y = g.y), g.x > this.bbox.ur.x && (this.bbox.ur.x = g.x), g.y > this.bbox.ur.y && (this.bbox.ur.y = g.y), u = g);
    }
    (s.x !== u.x || s.y !== u.y) && this.segments.push(Ni.fromRing(u, s, this));
  }
  getSweepEvents() {
    const t = [];
    for (let e = 0, i = this.segments.length; e < i; e++) {
      const s = this.segments[e];
      t.push(s.leftSE), t.push(s.rightSE);
    }
    return t;
  }
}
class yC {
  constructor(t, e) {
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new Ld(t[0], this, !0), this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    }, this.interiorRings = [];
    for (let i = 1, s = t.length; i < s; i++) {
      const u = new Ld(t[i], this, !1);
      u.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = u.bbox.ll.x), u.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = u.bbox.ll.y), u.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = u.bbox.ur.x), u.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = u.bbox.ur.y), this.interiorRings.push(u);
    }
    this.multiPoly = e;
  }
  getSweepEvents() {
    const t = this.exteriorRing.getSweepEvents();
    for (let e = 0, i = this.interiorRings.length; e < i; e++) {
      const s = this.interiorRings[e].getSweepEvents();
      for (let u = 0, h = s.length; u < h; u++)
        t.push(s[u]);
    }
    return t;
  }
}
class Td {
  constructor(t, e) {
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof t[0][0][0] == "number" && (t = [t]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let i = 0, s = t.length; i < s; i++) {
      const u = new yC(t[i], this);
      u.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = u.bbox.ll.x), u.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = u.bbox.ll.y), u.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = u.bbox.ur.x), u.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = u.bbox.ur.y), this.polys.push(u);
    }
    this.isSubject = e;
  }
  getSweepEvents() {
    const t = [];
    for (let e = 0, i = this.polys.length; e < i; e++) {
      const s = this.polys[e].getSweepEvents();
      for (let u = 0, h = s.length; u < h; u++)
        t.push(s[u]);
    }
    return t;
  }
}
class Ya {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(t) {
    const e = [];
    for (let i = 0, s = t.length; i < s; i++) {
      const u = t[i];
      if (!u.isInResult() || u.ringOut) continue;
      let h = null, c = u.leftSE, g = u.rightSE;
      const m = [c], y = c.point, p = [];
      for (; h = c, c = g, m.push(c), c.point !== y; )
        for (; ; ) {
          const _ = c.getAvailableLinkedEvents();
          if (_.length === 0) {
            const I = m[0].point, b = m[m.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${I.x}, ${I.y}]. Last matching segment found ends at [${b.x}, ${b.y}].`);
          }
          if (_.length === 1) {
            g = _[0].otherSE;
            break;
          }
          let E = null;
          for (let I = 0, b = p.length; I < b; I++)
            if (p[I].point === c.point) {
              E = I;
              break;
            }
          if (E !== null) {
            const I = p.splice(E)[0], b = m.splice(I.index);
            b.unshift(b[0].otherSE), e.push(new Ya(b.reverse()));
            continue;
          }
          p.push({
            index: m.length,
            point: c.point
          });
          const S = c.getLeftmostComparator(h);
          g = _.sort(S)[0].otherSE;
          break;
        }
      e.push(new Ya(m));
    }
    return e;
  }
  constructor(t) {
    this.events = t;
    for (let e = 0, i = t.length; e < i; e++)
      t[e].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let t = this.events[0].point;
    const e = [t];
    for (let m = 1, y = this.events.length - 1; m < y; m++) {
      const p = this.events[m].point, _ = this.events[m + 1].point;
      bd(p, t, _) !== 0 && (e.push(p), t = p);
    }
    if (e.length === 1) return null;
    const i = e[0], s = e[1];
    bd(i, t, s) === 0 && e.shift(), e.push(e[0]);
    const u = this.isExteriorRing() ? 1 : -1, h = this.isExteriorRing() ? 0 : e.length - 1, c = this.isExteriorRing() ? e.length : -1, g = [];
    for (let m = h; m != c; m += u) g.push([e[m].x, e[m].y]);
    return g;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const t = this.enclosingRing();
      this._isExteriorRing = t ? !t.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let t = this.events[0];
    for (let s = 1, u = this.events.length; s < u; s++) {
      const h = this.events[s];
      sn.compare(t, h) > 0 && (t = h);
    }
    let e = t.segment.prevInResult(), i = e ? e.prevInResult() : null;
    for (; ; ) {
      if (!e) return null;
      if (!i) return e.ringOut;
      if (i.ringOut !== e.ringOut)
        return i.ringOut.enclosingRing() !== e.ringOut ? e.ringOut : e.ringOut.enclosingRing();
      e = i.prevInResult(), i = e ? e.prevInResult() : null;
    }
  }
}
class Nd {
  constructor(t) {
    this.exteriorRing = t, t.poly = this, this.interiorRings = [];
  }
  addInterior(t) {
    this.interiorRings.push(t), t.poly = this;
  }
  getGeom() {
    const t = [this.exteriorRing.getGeom()];
    if (t[0] === null) return null;
    for (let e = 0, i = this.interiorRings.length; e < i; e++) {
      const s = this.interiorRings[e].getGeom();
      s !== null && t.push(s);
    }
    return t;
  }
}
class pC {
  constructor(t) {
    this.rings = t, this.polys = this._composePolys(t);
  }
  getGeom() {
    const t = [];
    for (let e = 0, i = this.polys.length; e < i; e++) {
      const s = this.polys[e].getGeom();
      s !== null && t.push(s);
    }
    return t;
  }
  _composePolys(t) {
    const e = [];
    for (let i = 0, s = t.length; i < s; i++) {
      const u = t[i];
      if (!u.poly)
        if (u.isExteriorRing()) e.push(new Nd(u));
        else {
          const h = u.enclosingRing();
          h.poly || e.push(new Nd(h)), h.poly.addInterior(u);
        }
    }
    return e;
  }
}
class vC {
  constructor(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ni.compare;
    this.queue = t, this.tree = new Yh(e), this.segments = [];
  }
  process(t) {
    const e = t.segment, i = [];
    if (t.consumedBy)
      return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), i;
    const s = t.isLeft ? this.tree.add(e) : this.tree.find(e);
    if (!s) throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);
    let u = s, h = s, c, g;
    for (; c === void 0; )
      u = this.tree.prev(u), u === null ? c = null : u.key.consumedBy === void 0 && (c = u.key);
    for (; g === void 0; )
      h = this.tree.next(h), h === null ? g = null : h.key.consumedBy === void 0 && (g = h.key);
    if (t.isLeft) {
      let m = null;
      if (c) {
        const p = c.getIntersection(e);
        if (p !== null && (e.isAnEndpoint(p) || (m = p), !c.isAnEndpoint(p))) {
          const _ = this._splitSafely(c, p);
          for (let E = 0, S = _.length; E < S; E++)
            i.push(_[E]);
        }
      }
      let y = null;
      if (g) {
        const p = g.getIntersection(e);
        if (p !== null && (e.isAnEndpoint(p) || (y = p), !g.isAnEndpoint(p))) {
          const _ = this._splitSafely(g, p);
          for (let E = 0, S = _.length; E < S; E++)
            i.push(_[E]);
        }
      }
      if (m !== null || y !== null) {
        let p = null;
        m === null ? p = y : y === null ? p = m : p = sn.comparePoints(m, y) <= 0 ? m : y, this.queue.remove(e.rightSE), i.push(e.rightSE);
        const _ = e.split(p);
        for (let E = 0, S = _.length; E < S; E++)
          i.push(_[E]);
      }
      i.length > 0 ? (this.tree.remove(e), i.push(t)) : (this.segments.push(e), e.prev = c);
    } else {
      if (c && g) {
        const m = c.getIntersection(g);
        if (m !== null) {
          if (!c.isAnEndpoint(m)) {
            const y = this._splitSafely(c, m);
            for (let p = 0, _ = y.length; p < _; p++)
              i.push(y[p]);
          }
          if (!g.isAnEndpoint(m)) {
            const y = this._splitSafely(g, m);
            for (let p = 0, _ = y.length; p < _; p++)
              i.push(y[p]);
          }
        }
      }
      this.tree.remove(e);
    }
    return i;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(t, e) {
    this.tree.remove(t);
    const i = t.rightSE;
    this.queue.remove(i);
    const s = t.split(e);
    return s.push(i), t.consumedBy === void 0 && this.tree.add(t), s;
  }
}
const Md = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, _C = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class EC {
  run(t, e, i) {
    yn.type = t, po.reset();
    const s = [new Td(e, !0)];
    for (let p = 0, _ = i.length; p < _; p++)
      s.push(new Td(i[p], !1));
    if (yn.numMultiPolys = s.length, yn.type === "difference") {
      const p = s[0];
      let _ = 1;
      for (; _ < s.length; )
        Zl(s[_].bbox, p.bbox) !== null ? _++ : s.splice(_, 1);
    }
    if (yn.type === "intersection")
      for (let p = 0, _ = s.length; p < _; p++) {
        const E = s[p];
        for (let S = p + 1, I = s.length; S < I; S++)
          if (Zl(E.bbox, s[S].bbox) === null) return [];
      }
    const u = new Yh(sn.compare);
    for (let p = 0, _ = s.length; p < _; p++) {
      const E = s[p].getSweepEvents();
      for (let S = 0, I = E.length; S < I; S++)
        if (u.insert(E[S]), u.size > Md)
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
    }
    const h = new vC(u);
    let c = u.size, g = u.pop();
    for (; g; ) {
      const p = g.key;
      if (u.size === c) {
        const E = p.segment;
        throw new Error(`Unable to pop() ${p.isLeft ? "left" : "right"} SweepEvent [${p.point.x}, ${p.point.y}] from segment #${E.id} [${E.leftSE.point.x}, ${E.leftSE.point.y}] -> [${E.rightSE.point.x}, ${E.rightSE.point.y}] from queue.`);
      }
      if (u.size > Md)
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      if (h.segments.length > _C)
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      const _ = h.process(p);
      for (let E = 0, S = _.length; E < S; E++) {
        const I = _[E];
        I.consumedBy === void 0 && u.insert(I);
      }
      c = u.size, g = u.pop();
    }
    po.reset();
    const m = Ya.factory(h.segments);
    return new pC(m).getGeom();
  }
}
const yn = new EC(), xC = function(n) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return yn.run("union", n, e);
}, SC = function(n) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return yn.run("intersection", n, e);
}, wC = function(n) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return yn.run("xor", n, e);
}, IC = function(n) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return yn.run("difference", n, e);
};
var kC = {
  union: xC,
  intersection: SC,
  xor: wC,
  difference: IC
}, bC = Object.defineProperty, CC = (n, t) => bC(n, "name", { value: t, configurable: !0 });
function cp(n) {
  const t = [];
  if (ps(n, (s) => {
    t.push(s.coordinates);
  }), t.length < 2)
    throw new Error("Must have at least two features");
  const e = n.features[0].properties || {}, i = kC.difference(t[0], ...t.slice(1));
  return i.length === 0 ? null : i.length === 1 ? Io(i[0], e) : Ph(i, e);
}
CC(cp, "difference");
var RC = cp;
function Od(n) {
  let t;
  for (const e of n)
    t && e[0] - t[0] >= 180 ? e[0] -= 360 : t && e[0] - t[0] < -180 && (e[0] += 360), t = e;
}
function Ad(n, t) {
  const e = RC(
    oi([
      Io([
        [
          [180, 90],
          [-180, 90],
          [-180, -90],
          [180, -90],
          [180, 90]
        ]
      ]),
      n
    ])
  );
  if (!e)
    return;
  e.properties = { isMask: "y" };
  const i = Kb(n, 0);
  if (i) {
    if (i.geometry.type === "Polygon")
      for (const s of i.geometry.coordinates)
        Od(s);
    else
      for (const s of i.geometry.coordinates)
        for (const u of s)
          Od(u);
    t(oi([i, e]));
  }
}
const Pd = "EPSG:4326";
function LC(n) {
  var u;
  const t = n.getProperties(), { isMask: e } = t, i = (u = n.getGeometry()) == null ? void 0 : u.getType(), s = e ? 0 : i === "LineString" || i === "MultiLineString" ? 3 : 2;
  return new Ti({
    stroke: e ? void 0 : new rs({
      color: "#3170fe",
      lineDash: [s, s],
      width: s,
      lineCap: "butt"
    }),
    fill: e ? new lr({
      color: "#00000020"
    }) : void 0,
    image: new Eo({
      src: `/icons/marker_${t.isReverse ? "reverse" : t.isSelected ? "selected" : "unselected"}.svg`,
      anchor: [0.5, 1]
    }),
    zIndex: t.isSelected ? 2 : t.isReverse ? 0 : 1,
    text: t.isSelected && t.tooltip ? new Ha({
      backgroundFill: new lr({ color: "white" }),
      text: t.tooltip,
      offsetY: -40,
      backgroundStroke: new rs({
        color: "white",
        lineJoin: "round",
        width: 3
      }),
      padding: [2, 0, 0, 2]
    }) : void 0
  });
}
function TC(n, t = {}, e = {}, i = LC) {
  let s = -1, u, h, c, g = !1;
  const m = new jE({
    updateWhileAnimating: !0
  });
  n.addLayer(m);
  const y = new $E({});
  m.setSource(y), m.setStyle(i), n.on("click", (S) => {
    n.forEachFeatureAtPixel(S.pixel, (I) => {
      const b = I.getId();
      if (b)
        return S.stopPropagation(), h == null || h({ type: "markerClick", id: b }), I;
    });
  }), n.on("pointermove", (S) => {
    const I = n.forEachFeatureAtPixel(S.pixel, (b) => b.getId());
    u !== I && (u && (h == null || h({
      type: "markerMouseLeave",
      id: u
    })), I && (h == null || h({
      type: "markerMouseEnter",
      id: I
    })), n.getTargetElement().style.cursor = I ? "pointer" : g ? "crosshair" : "", u = I);
  });
  function p() {
    return n.getView().getProjection();
  }
  function _(S) {
    return S.transform(Pd, p());
  }
  const E = (S) => {
    h == null || h({
      type: "mapClick",
      coordinates: Ac(S.coordinate, p())
    });
  };
  return {
    setEventHandler(S) {
      S ? (h = S, n.on("click", E)) : (h = void 0, n.un("click", E));
    },
    flyTo(S, I) {
      n.getView().animate({
        center: Ao(S, p()),
        zoom: I,
        duration: 2e3,
        ...t
      });
    },
    fitBounds(S, I, b) {
      n.getView().fit(r_(S, Pd, p()), {
        padding: [I, I, I, I],
        maxZoom: b,
        duration: 2e3,
        ...e
      });
    },
    indicateReverse(S) {
      g = S, n.getTargetElement().style.cursor = S ? "crosshair" : "";
    },
    setReverseMarker(S) {
      c ? S ? c.getGeometry().setCoordinates(
        Ao(S, p())
      ) : (y.removeFeature(c), c.dispose(), c = void 0) : S && (c = new qn(
        new Li(Ao(S, p()))
      ), c.setProperties({ isReverse: !0 }), y.addFeature(c));
    },
    setMarkers(S, I) {
      function b(C) {
        var R;
        if (C)
          for (const T of C.features) {
            const O = T.geometry.type === "Polygon" ? new Oi(T.geometry.coordinates) : T.geometry.type === "MultiPolygon" ? new fo(T.geometry.coordinates) : null;
            O && y.addFeature(
              new qn({
                isMask: !!((R = T.properties) != null && R.isMask),
                geometry: _(O)
              })
            );
          }
      }
      if (y.clear(), c && y.addFeature(c), b(), I) {
        let C = !1;
        if (I.geometry.type === "GeometryCollection") {
          const R = I.geometry.geometries.map(
            (T) => T.type === "Polygon" ? new Oi(T.coordinates) : T.type === "MultiPolygon" ? new fo(T.coordinates) : null
          ).filter((T) => !!T);
          if (R.length > 0)
            y.addFeature(
              new qn(_(new ya(R)))
            ), C = !0;
          else
            for (const T of I.geometry.geometries)
              T.type === "LineString" ? (y.addFeature(
                new qn(
                  _(new hr(T.coordinates))
                )
              ), C = !0) : T.type === "MultiLineString" && y.addFeature(
                new qn(
                  _(new co(T.coordinates))
                )
              ), C = !0;
        }
        if (!C) {
          if (I.geometry.type === "Polygon")
            Ad(I, b);
          else if (I.geometry.type === "MultiPolygon")
            Ad(I, b);
          else if (I.geometry.type === "LineString") {
            y.addFeature(
              new qn(
                _(new hr(I.geometry.coordinates))
              )
            );
            return;
          } else if (I.geometry.type === "MultiLineString") {
            y.addFeature(
              new qn(
                _(new co(I.geometry.coordinates))
              )
            );
            return;
          }
        }
        y.addFeature(new qn(_(new Li(I.center))));
      }
      for (const C of S ?? []) {
        if (C === I)
          continue;
        const R = new qn(
          new Li(Ao(C.center, p()))
        );
        R.setId(C.id), R.setProperties({
          fuzzy: !!C.matching_text,
          tooltip: C.place_type[0] === "reverse" ? C.place_name : C.place_name.replace(/,.*/, "")
        }), y.addFeature(R);
      }
    },
    setSelectedMarker(S) {
      var C, R, T;
      const I = y.getFeatures(), b = (C = I[0]) != null && C.getProperties().isReverse ? 1 : 0;
      s > -1 && ((R = I[s + b]) == null || R.setProperties({
        isSelected: !1
      })), S > -1 && ((T = I[S + b]) == null || T.setProperties({
        isSelected: !0
      })), s = S;
    },
    getCenterAndZoom() {
      const S = n.getView(), I = S.getCenter(), b = S.getZoom();
      if (!(!I || b === void 0))
        return [b, ...Ac(I, p())];
    }
  };
}
var en, tr;
class qC extends Sv {
  constructor(e) {
    const i = document.createElement("div");
    i.className = "ol-search";
    super({
      element: i,
      target: e.target
    });
    _u(this, en);
    _u(this, tr);
    const { flyTo: s, fullGeometryStyle: u, ...h } = e;
    Mo(this, en, new gE({
      target: i,
      props: {
        flyTo: s === void 0 ? !0 : !!s,
        ...h
      }
    }));
    for (const c of [
      "select",
      "pick",
      "featuresListed",
      "featuresMarked",
      "response",
      "optionsVisibilityChange",
      "reverseToggle",
      "queryChange"
    ])
      fn(this, en).$on(c, (g) => {
        switch (c) {
          case "select":
            this.dispatchEvent(
              new NC(g.detail)
            );
            break;
          case "featuresListed":
            this.dispatchEvent(
              new MC(g.detail)
            );
            break;
          case "featuresMarked":
            this.dispatchEvent(
              new OC(g.detail)
            );
            break;
          case "optionsVisibilityChange":
            this.dispatchEvent(
              new AC(g.detail)
            );
            break;
          case "pick":
            this.dispatchEvent(
              new PC(g.detail)
            );
            break;
          case "queryChange":
            this.dispatchEvent(new DC(g.detail));
            break;
          case "response":
            this.dispatchEvent(
              new FC(
                g.detail.url,
                g.detail.featureCollection
              )
            );
            break;
          case "reverseToggle":
            this.dispatchEvent(new GC(g.detail));
            break;
        }
      });
    Mo(this, tr, e);
  }
  setMap(e) {
    var i;
    if (super.setMap(e), e) {
      const {
        // marker,
        // showResultMarkers,
        flyTo: s,
        fullGeometryStyle: u
      } = fn(this, tr), h = TC(
        e,
        typeof s == "boolean" ? void 0 : s,
        typeof s == "boolean" ? void 0 : s,
        // marker,
        // showResultMarkers,
        u
      );
      (i = fn(this, en)) == null || i.$set({ mapController: h });
    }
  }
  setOptions(e) {
    var h;
    Mo(this, tr, e);
    const { flyTo: i, fullGeometryStyle: s, ...u } = fn(this, tr);
    (h = fn(this, en)) == null || h.$set({
      ...u,
      flyTo: i === void 0 ? !0 : !!i
    });
  }
  setQuery(e, i = !0) {
    var s;
    (s = fn(this, en)) == null || s.setQuery(e, i);
  }
  clearMap() {
    var e;
    (e = fn(this, en)) == null || e.clearMap();
  }
  clearList() {
    var e;
    (e = fn(this, en)) == null || e.clearList();
  }
  focus() {
    var e;
    (e = fn(this, en)) == null || e.focus();
  }
  blur() {
    var e;
    (e = fn(this, en)) == null || e.blur();
  }
  // onRemove() {
  //   this.#gc?.$destroy();
  // }
}
en = new WeakMap(), tr = new WeakMap();
class NC extends je {
  constructor(e) {
    super("select");
    Ye(this, "feature");
    this.feature = e;
  }
}
class MC extends je {
  constructor(e) {
    super("featuresListed");
    Ye(this, "features");
    this.features = e;
  }
}
class OC extends je {
  constructor(e) {
    super("featuresMarked");
    Ye(this, "features");
    this.features = e;
  }
}
class AC extends je {
  constructor(e) {
    super("optionsVisibilityChange");
    Ye(this, "optionsVisible");
    this.optionsVisible = e;
  }
}
class PC extends je {
  constructor(e) {
    super("pick");
    Ye(this, "feature");
    this.feature = e;
  }
}
class DC extends je {
  constructor(e) {
    super("queryChange");
    Ye(this, "query");
    this.query = e;
  }
}
class FC extends je {
  constructor(e, i) {
    super("response");
    Ye(this, "url");
    Ye(this, "featureCollection");
    this.url = e, this.featureCollection = i;
  }
}
class GC extends je {
  constructor(e) {
    super("reverseToggle");
    Ye(this, "reverse");
    this.reverse = e;
  }
}
export {
  MC as FeaturesListedEvent,
  OC as FeaturesMarkedEvent,
  qC as GeocodingControl,
  AC as OptionsVisibilityChangeEvent,
  PC as PickEvent,
  DC as QueryChangeEvent,
  FC as ResponseEvent,
  GC as ReverseToggleEvent,
  NC as SelectEvent,
  TC as createOpenLayersMapController
};
//# sourceMappingURL=openlayers.js.map
