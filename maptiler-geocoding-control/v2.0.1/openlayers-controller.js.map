{"version":3,"file":"openlayers-controller.js","sources":["../node_modules/@turf/helpers/dist/esm/index.js","../node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/bbox/dist/esm/index.js","../node_modules/splaytree/dist/splay.esm.js","../node_modules/robust-predicates/esm/util.js","../node_modules/robust-predicates/esm/orient2d.js","../node_modules/polygon-clipping/dist/polygon-clipping.esm.js","../node_modules/@turf/difference/dist/esm/index.js","../node_modules/@turf/flatten/dist/esm/index.js","../node_modules/@turf/union/dist/esm/index.js","../src/geoUtils.ts","../src/mask.ts","../src/openlayers-controller.ts"],"sourcesContent":["// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 0)\n    return angle > 180 ? angle - 360 : angle;\n  return angle < -180 ? angle + 360 : angle;\n}\nfunction radiansToDegrees(radians) {\n  const degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null)\n    return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null)\n        continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\")\n              multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\")\n            multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\")\n              multiFeatureIndex++;\n            if (geomType === \"Polygon\")\n              geometryIndex++;\n          }\n          if (geomType === \"Polygon\")\n            multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false)\n          break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false)\n        break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else\n      previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry)\n      return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\")\n      return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson)\n    throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null)\n      return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options))\n    throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null)\n    return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0)\n        segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0)\n        geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options))\n    throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null)\n    return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0)\n        coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0)\n        geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { coordEach } from \"@turf/meta\";\nfunction bbox(geojson, options = {}) {\n  if (geojson.bbox != null && true !== options.recompute) {\n    return geojson.bbox;\n  }\n  const result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, (coord) => {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\nvar turf_bbox_default = bbox;\nexport {\n  bbox,\n  turf_bbox_default as default\n};\n//# sourceMappingURL=index.js.map","/**\n * splaytree v3.1.2\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    return Node;\r\n}());\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    var N = new Node(null, null);\r\n    var l = N;\r\n    var r = N;\r\n    while (true) {\r\n        var cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                var y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                var y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    var node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    var cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    var left = null;\r\n    var right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        var cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\r\n        var indent = prefix + (isTail ? '    ' : '│   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nvar Tree = /** @class */ (function () {\r\n    function Tree(comparator) {\r\n        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    Tree.prototype.insert = function (key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    Tree.prototype.add = function (key, data) {\r\n        var node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        var comparator = this._comparator;\r\n        var t = splay(key, this._root, comparator);\r\n        var cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    };\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    Tree.prototype.remove = function (key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    Tree.prototype._remove = function (i, t, comparator) {\r\n        var x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    };\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    Tree.prototype.pop = function () {\r\n        var node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    Tree.prototype.findStatic = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.find = function (key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    };\r\n    Tree.prototype.contains = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    };\r\n    Tree.prototype.forEach = function (visitor, ctx) {\r\n        var current = this._root;\r\n        var Q = []; /* Initialize stack s */\r\n        var done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    Tree.prototype.range = function (low, high, fn, ctx) {\r\n        var Q = [];\r\n        var compare = this._comparator;\r\n        var node = this._root;\r\n        var cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    Tree.prototype.keys = function () {\r\n        var keys = [];\r\n        this.forEach(function (_a) {\r\n            var key = _a.key;\r\n            return keys.push(key);\r\n        });\r\n        return keys;\r\n    };\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    Tree.prototype.values = function () {\r\n        var values = [];\r\n        this.forEach(function (_a) {\r\n            var data = _a.data;\r\n            return values.push(data);\r\n        });\r\n        return values;\r\n    };\r\n    Tree.prototype.min = function () {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.max = function () {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.minNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    };\r\n    Tree.prototype.maxNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    };\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    Tree.prototype.at = function (index) {\r\n        var current = this._root;\r\n        var done = false;\r\n        var i = 0;\r\n        var Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.next = function (d) {\r\n        var root = this._root;\r\n        var successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    };\r\n    Tree.prototype.prev = function (d) {\r\n        var root = this._root;\r\n        var predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    };\r\n    Tree.prototype.clear = function () {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    };\r\n    Tree.prototype.toList = function () {\r\n        return toList(this._root);\r\n    };\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    Tree.prototype.load = function (keys, values, presort) {\r\n        if (values === void 0) { values = []; }\r\n        if (presort === void 0) { presort = false; }\r\n        var size = keys.length;\r\n        var comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    };\r\n    Tree.prototype.isEmpty = function () { return this._root === null; };\r\n    Object.defineProperty(Tree.prototype, \"size\", {\r\n        get: function () { return this._size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"root\", {\r\n        get: function () { return this._root; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.toString = function (printNode) {\r\n        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n        var out = [];\r\n        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n        return out.join('');\r\n    };\r\n    Tree.prototype.update = function (key, newKey, newData) {\r\n        var comparator = this._comparator;\r\n        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    };\r\n    Tree.prototype.split = function (key) {\r\n        return split(key, this._root, this._comparator);\r\n    };\r\n    Tree.prototype[Symbol.iterator] = function () {\r\n        var current, Q, done;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    current = this._root;\r\n                    Q = [];\r\n                    done = false;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!!done) return [3 /*break*/, 6];\r\n                    if (!(current !== null)) return [3 /*break*/, 2];\r\n                    Q.push(current);\r\n                    current = current.left;\r\n                    return [3 /*break*/, 5];\r\n                case 2:\r\n                    if (!(Q.length !== 0)) return [3 /*break*/, 4];\r\n                    current = Q.pop();\r\n                    return [4 /*yield*/, current];\r\n                case 3:\r\n                    _a.sent();\r\n                    current = current.right;\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    done = true;\r\n                    _a.label = 5;\r\n                case 5: return [3 /*break*/, 1];\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tree;\r\n}());\r\nfunction loadRecursive(keys, values, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var key = keys[middle];\r\n        var data = values[middle];\r\n        var node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    for (var i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    var current = root;\r\n    var Q = [];\r\n    var done = false;\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var left = sortedListToBST(list, start, middle);\r\n        var root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    var head = new Node(null, null); // dummy\r\n    var p = head;\r\n    var p1 = l1;\r\n    var p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    var pivot = keys[(left + right) >> 1];\r\n    var i = left - 1;\r\n    var j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        var tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\nexport default Tree;\n//# sourceMappingURL=splay.esm.js.map\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import SplayTree from 'splaytree';\nimport { orient2d } from 'robust-predicates';\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nconst isInBbox = (bbox, point) => {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nconst getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n  // put those middle values together to get the overlap\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON;\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nconst EPSILON_SQ = epsilon * epsilon;\n\n/* FLP comparator */\nconst cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  }\n\n  // check if they're flp equal\n  const ab = a - b;\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor() {\n    this.reset();\n  }\n  reset() {\n    this.xRounder = new CoordRounder();\n    this.yRounder = new CoordRounder();\n  }\n  round(x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y)\n    };\n  }\n}\nclass CoordRounder {\n  constructor() {\n    this.tree = new SplayTree();\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0);\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round(coord) {\n    const node = this.tree.add(coord);\n    const prevNode = this.tree.prev(node);\n    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n      this.tree.remove(coord);\n      return prevNode.key;\n    }\n    const nextNode = this.tree.next(node);\n    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n      this.tree.remove(coord);\n      return nextNode.key;\n    }\n    return coord;\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\nconst crossProduct = (a, b) => a.x * b.y - a.y * b.x;\n\n/* Dot Product of two vectors with first point at origin */\nconst dotProduct = (a, b) => a.x * b.x + a.y * b.y;\n\n/* Comparator for two vectors with same starting point */\nconst compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n  if (res > 0) return -1;\n  if (res < 0) return 1;\n  return 0;\n};\nconst length = v => Math.sqrt(dotProduct(v, v));\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst intersection$1 = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  const ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  const d1 = crossProduct(ve, v1) / kross;\n  const d2 = crossProduct(ve, v2) / kross;\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x,\n    x2 = pt2.x + d1 * v2.x;\n  const y1 = pt1.y + d2 * v1.y,\n    y2 = pt2.y + d1 * v2.y;\n  const x = (x1 + x2) / 2;\n  const y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nclass SweepEvent {\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n    if (ptCmp !== 0) return ptCmp;\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b);\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment);\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x < bPt.x) return -1;\n    if (aPt.x > bPt.x) return 1;\n    if (aPt.y < bPt.y) return -1;\n    if (aPt.y > bPt.y) return 1;\n    return 0;\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n    // this.segment, this.otherSE set by factory\n  }\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\");\n    }\n    const otherEvents = other.point.events;\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i];\n      this.point.events.push(evt);\n      evt.point = this.point;\n    }\n    this.checkForConsuming();\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length;\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i];\n      if (evt1.segment.consumedBy !== undefined) continue;\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j];\n        if (evt2.consumedBy !== undefined) continue;\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n        evt1.segment.consume(evt2.segment);\n      }\n    }\n  }\n  getAvailableLinkedEvents() {\n    // point.events is always of length 2 or greater\n    const events = [];\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i];\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt);\n      }\n    }\n    return events;\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = new Map();\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE;\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      });\n    };\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a);\n      if (!cache.has(b)) fillCache(b);\n      const {\n        sine: asine,\n        cosine: acosine\n      } = cache.get(a);\n      const {\n        sine: bsine,\n        cosine: bcosine\n      } = cache.get(b);\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1;\n        if (acosine > bcosine) return -1;\n        return 0;\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1;\n        if (acosine > bcosine) return 1;\n        return 0;\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1;\n      if (bsine > asine) return 1;\n      return 0;\n    };\n  }\n}\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0;\nclass Segment {\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x;\n    const blx = b.leftSE.point.x;\n    const arx = a.rightSE.point.x;\n    const brx = b.rightSE.point.x;\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1;\n    if (arx < blx) return -1;\n    const aly = a.leftSE.point.y;\n    const bly = b.leftSE.point.y;\n    const ary = a.rightSE.point.y;\n    const bry = b.rightSE.point.y;\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1;\n      if (bly > aly && bly > ary) return -1;\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point);\n      if (aCmpBLeft < 0) return 1;\n      if (aCmpBLeft > 0) return -1;\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1;\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1;\n      if (aly > bly && aly > bry) return 1;\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point);\n      if (bCmpALeft !== 0) return bCmpALeft;\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1;\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1;\n    if (aly > bly) return 1;\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n    }\n    if (arx !== brx) {\n      // are these two [almost] vertical segments with opposite orientation?\n      // if so, the one with the lower right endpoint comes first\n      const ay = ary - aly;\n      const ax = arx - alx;\n      const by = bry - bly;\n      const bx = brx - blx;\n      if (ay > ax && by < bx) return 1;\n      if (ay < ax && by > bx) return -1;\n    }\n\n    // we have colinear segments with matching orientation\n    // consider the one with more left-more right endpoint to be first\n    if (arx > brx) return 1;\n    if (arx < brx) return -1;\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1;\n    if (ary > bry) return 1;\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1;\n    if (a.id > b.id) return 1;\n\n    // identical segment, ie a === b\n    return 0;\n  }\n\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings;\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding;\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n    if (cmpPts < 0) {\n      leftPt = pt1;\n      rightPt = pt2;\n      winding = 1;\n    } else if (cmpPts > 0) {\n      leftPt = pt2;\n      rightPt = pt1;\n      winding = -1;\n    } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n    const leftSE = new SweepEvent(leftPt, true);\n    const rightSE = new SweepEvent(rightPt, false);\n    return new Segment(leftSE, rightSE, [ring], [winding]);\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE;\n    this.rightSE.segment = this;\n    this.rightSE.otherSE = this.leftSE;\n    this.leftSE.otherSE = this.rightSE;\n  }\n  bbox() {\n    const y1 = this.leftSE.point.y;\n    const y2 = this.rightSE.point.y;\n    return {\n      ll: {\n        x: this.leftSE.point.x,\n        y: y1 < y2 ? y1 : y2\n      },\n      ur: {\n        x: this.rightSE.point.x,\n        y: y1 > y2 ? y1 : y2\n      }\n    };\n  }\n\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    };\n  }\n  isAnEndpoint(pt) {\n    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n  }\n\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    if (this.isAnEndpoint(point)) return 0;\n    const lPt = this.leftSE.point;\n    const rPt = this.rightSE.point;\n    const v = this.vector();\n\n    // Exactly vertical segments.\n    if (lPt.x === rPt.x) {\n      if (point.x === lPt.x) return 0;\n      return point.x < lPt.x ? 1 : -1;\n    }\n\n    // Nearly vertical segments with an intersection.\n    // Check to see where a point on the line with matching Y coordinate is.\n    const yDist = (point.y - lPt.y) / v.y;\n    const xFromYDist = lPt.x + yDist * v.x;\n    if (point.x === xFromYDist) return 0;\n\n    // General case.\n    // Check to see where a point on the line with matching X coordinate is.\n    const xDist = (point.x - lPt.x) / v.x;\n    const yFromXDist = lPt.y + xDist * v.y;\n    if (point.y === yFromXDist) return 0;\n    return point.y < yFromXDist ? -1 : 1;\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const tBbox = this.bbox();\n    const oBbox = other.bbox();\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n    if (bboxOverlap === null) return null;\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    const tlp = this.leftSE.point;\n    const trp = this.rightSE.point;\n    const olp = other.leftSE.point;\n    const orp = other.rightSE.point;\n\n    // does each endpoint touch the other segment?\n    // note that we restrict the 'touching' definition to only allow segments\n    // to touch endpoints that lie forward from where we are in the sweep line pass\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return trp;\n      if (!touchesThisRSE && touchesOtherRSE) return orp;\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null;\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE) {\n        if (tlp.x === orp.x && tlp.y === orp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return tlp;\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE) {\n        if (trp.x === olp.x && trp.y === olp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return olp;\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null;\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return trp;\n    if (touchesOtherRSE) return orp;\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null;\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null;\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y);\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = [];\n    const alreadyLinked = point.events !== undefined;\n    const newLeftSE = new SweepEvent(point, true);\n    const newRightSE = new SweepEvent(point, false);\n    const oldRightSE = this.rightSE;\n    this.replaceRightSE(newRightSE);\n    newEvents.push(newRightSE);\n    newEvents.push(newLeftSE);\n    const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n\n    // when splitting a nearly vertical downward-facing segment,\n    // sometimes one of the resulting new segments is vertical, in which\n    // case its left and right events may need to be swapped\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents();\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents();\n    }\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming();\n      newRightSE.checkForConsuming();\n    }\n    return newEvents;\n  }\n\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE;\n    this.rightSE = this.leftSE;\n    this.leftSE = tmpEvt;\n    this.leftSE.isLeft = true;\n    this.rightSE.isLeft = false;\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1;\n    }\n  }\n\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this;\n    let consumee = other;\n    while (consumer.consumedBy) consumer = consumer.consumedBy;\n    while (consumee.consumedBy) consumee = consumee.consumedBy;\n    const cmp = Segment.compare(consumer, consumee);\n    if (cmp === 0) return; // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp > 0) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i];\n      const winding = consumee.windings[i];\n      const index = consumer.rings.indexOf(ring);\n      if (index === -1) {\n        consumer.rings.push(ring);\n        consumer.windings.push(winding);\n      } else consumer.windings[index] += winding;\n    }\n    consumee.rings = null;\n    consumee.windings = null;\n    consumee.consumedBy = consumer;\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE;\n    consumee.rightSE.consumedBy = consumer.rightSE;\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== undefined) return this._prevInResult;\n    if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n    return this._prevInResult;\n  }\n  beforeState() {\n    if (this._beforeState !== undefined) return this._beforeState;\n    if (!this.prev) this._beforeState = {\n      rings: [],\n      windings: [],\n      multiPolys: []\n    };else {\n      const seg = this.prev.consumedBy || this.prev;\n      this._beforeState = seg.afterState();\n    }\n    return this._beforeState;\n  }\n  afterState() {\n    if (this._afterState !== undefined) return this._afterState;\n    const beforeState = this.beforeState();\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    };\n    const ringsAfter = this._afterState.rings;\n    const windingsAfter = this._afterState.windings;\n    const mpsAfter = this._afterState.multiPolys;\n\n    // calculate ringsAfter, windingsAfter\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i];\n      const winding = this.windings[i];\n      const index = ringsAfter.indexOf(ring);\n      if (index === -1) {\n        ringsAfter.push(ring);\n        windingsAfter.push(winding);\n      } else windingsAfter[index] += winding;\n    }\n\n    // calcualte polysAfter\n    const polysAfter = [];\n    const polysExclude = [];\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue; // non-zero rule\n      const ring = ringsAfter[i];\n      const poly = ring.poly;\n      if (polysExclude.indexOf(poly) !== -1) continue;\n      if (ring.isExterior) polysAfter.push(poly);else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n        const index = polysAfter.indexOf(ring.poly);\n        if (index !== -1) polysAfter.splice(index, 1);\n      }\n    }\n\n    // calculate multiPolysAfter\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly;\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n    }\n    return this._afterState;\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult() {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false;\n    if (this._isInResult !== undefined) return this._isInResult;\n    const mpsBefore = this.beforeState().multiPolys;\n    const mpsAfter = this.afterState().multiPolys;\n    switch (operation.type) {\n      case \"union\":\n        {\n          // UNION - included iff:\n          //  * On one side of us there is 0 poly interiors AND\n          //  * On the other side there is 1 or more.\n          const noBefores = mpsBefore.length === 0;\n          const noAfters = mpsAfter.length === 0;\n          this._isInResult = noBefores !== noAfters;\n          break;\n        }\n      case \"intersection\":\n        {\n          // INTERSECTION - included iff:\n          //  * on one side of us all multipolys are rep. with poly interiors AND\n          //  * on the other side of us, not all multipolys are repsented\n          //    with poly interiors\n          let least;\n          let most;\n          if (mpsBefore.length < mpsAfter.length) {\n            least = mpsBefore.length;\n            most = mpsAfter.length;\n          } else {\n            least = mpsAfter.length;\n            most = mpsBefore.length;\n          }\n          this._isInResult = most === operation.numMultiPolys && least < most;\n          break;\n        }\n      case \"xor\":\n        {\n          // XOR - included iff:\n          //  * the difference between the number of multipolys represented\n          //    with poly interiors on our two sides is an odd number\n          const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n          this._isInResult = diff % 2 === 1;\n          break;\n        }\n      case \"difference\":\n        {\n          // DIFFERENCE included iff:\n          //  * on exactly one side, we have just the subject\n          const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;\n          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n          break;\n        }\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`);\n    }\n    return this._isInResult;\n  }\n}\n\nclass RingIn {\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n    if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    let prevPoint = firstPoint;\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n      // skip repeated points\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    }\n    // add segment from last to first if last is not the same as first\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i];\n      sweepEvents.push(segment.leftSE);\n      sweepEvents.push(segment.rightSE);\n    }\n    return sweepEvents;\n  }\n}\nclass PolyIn {\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    // copy by value\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n    this.multiPoly = multiPoly;\n  }\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents();\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\nclass MultiPolyIn {\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === \"number\") geom = [geom];\n    } catch (ex) {\n      // The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n    this.isSubject = isSubject;\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents();\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\n\nclass RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = [];\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i];\n      if (!segment.isInResult() || segment.ringOut) continue;\n      let prevEvent = null;\n      let event = segment.leftSE;\n      let nextEvent = segment.rightSE;\n      const events = [event];\n      const startingPoint = event.point;\n      const intersectionLEs = [];\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event;\n        event = nextEvent;\n        events.push(event);\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break;\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents();\n\n          /* Did we hit a dead end? This shouldn't happen.\n           * Indicates some earlier part of the algorithm malfunctioned. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point;\n            const lastPt = events[events.length - 1].point;\n            throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE;\n            break;\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null;\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j;\n              break;\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0];\n            const ringEvents = events.splice(intersectionLE.index);\n            ringEvents.unshift(ringEvents[0].otherSE);\n            ringsOut.push(new RingOut(ringEvents.reverse()));\n            continue;\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point\n          });\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent);\n          nextEvent = availableLEs.sort(comparator)[0].otherSE;\n          break;\n        }\n      }\n      ringsOut.push(new RingOut(events));\n    }\n    return ringsOut;\n  }\n  constructor(events) {\n    this.events = events;\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n  getGeom() {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point;\n    const points = [prevPt];\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point;\n      const nextPt = this.events[i + 1].point;\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n      points.push(pt);\n      prevPt = pt;\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null;\n\n    // check if the starting point is necessary\n    const pt = points[0];\n    const nextPt = points[1];\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n    points.push(points[0]);\n    const step = this.isExteriorRing() ? 1 : -1;\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n    const iEnd = this.isExteriorRing() ? points.length : -1;\n    const orderedPoints = [];\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);\n    return orderedPoints;\n  }\n  isExteriorRing() {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing();\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n    }\n    return this._isExteriorRing;\n  }\n  enclosingRing() {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing();\n    }\n    return this._enclosingRing;\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0];\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i];\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n    }\n    let prevSeg = leftMostEvt.segment.prevInResult();\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null;\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut;\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut;\n        } else return prevSeg.ringOut.enclosingRing();\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult();\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    }\n  }\n}\nclass PolyOut {\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n  addInterior(ring) {\n    this.interiorRings.push(ring);\n    ring.poly = this;\n  }\n  getGeom() {\n    const geom = [this.exteriorRing.getGeom()];\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null;\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom();\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue;\n      geom.push(ringGeom);\n    }\n    return geom;\n  }\n}\nclass MultiPolyOut {\n  constructor(rings) {\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n  getGeom() {\n    const geom = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom();\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue;\n      geom.push(polyGeom);\n    }\n    return geom;\n  }\n  _composePolys(rings) {\n    const polys = [];\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i];\n      if (ring.poly) continue;\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n        const enclosingRing = ring.enclosingRing();\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n        enclosingRing.poly.addInterior(ring);\n      }\n    }\n    return polys;\n  }\n}\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nclass SweepLine {\n  constructor(queue) {\n    let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n    this.queue = queue;\n    this.tree = new SplayTree(comparator);\n    this.segments = [];\n  }\n  process(event) {\n    const segment = event.segment;\n    const newEvents = [];\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n      return newEvents;\n    }\n    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n    if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n    let prevNode = node;\n    let nextNode = node;\n    let prevSeg = undefined;\n    let nextSeg = undefined;\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode);\n      if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode);\n      if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n    }\n    if (event.isLeft) {\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null;\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment);\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null;\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment);\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null;\n        if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE);\n        newEvents.push(segment.rightSE);\n        const newEventsFromSplit = segment.split(mySplitter);\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i]);\n        }\n      }\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment);\n        newEvents.push(event);\n      } else {\n        // done with left event\n        this.segments.push(segment);\n        segment.prev = prevSeg;\n      }\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg);\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      this.tree.remove(segment);\n    }\n    return newEvents;\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg);\n    const rightSE = seg.rightSE;\n    this.queue.remove(rightSE);\n    const newEvents = seg.split(pt);\n    newEvents.push(rightSE);\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.add(seg);\n    return newEvents;\n  }\n}\n\n// Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\nconst POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nconst POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nclass Operation {\n  run(type, geom, moreGeoms) {\n    operation.type = type;\n    rounder.reset();\n\n    /* Convert inputs to MultiPoly objects */\n    const multipolys = [new MultiPolyIn(geom, true)];\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n    }\n    operation.numMultiPolys = multipolys.length;\n\n    /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */\n    if (operation.type === \"difference\") {\n      // in place removal\n      const subject = multipolys[0];\n      let i = 1;\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);\n      }\n    }\n\n    /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */\n    if (operation.type === \"intersection\") {\n      // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n      //       it could be optimized to O(n * ln(n))\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i];\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n        }\n      }\n    }\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new SplayTree(SweepEvent.compare);\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents();\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j]);\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n        }\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue);\n    let prevQueueSize = queue.size;\n    let node = queue.pop();\n    while (node) {\n      const evt = node.key;\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        const seg = evt.segment;\n        throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n      }\n      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n      }\n      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n      }\n      const newEvents = sweepLine.process(evt);\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i];\n        if (evt.consumedBy === undefined) queue.insert(evt);\n      }\n      prevQueueSize = queue.size;\n      node = queue.pop();\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset();\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = RingOut.factory(sweepLine.segments);\n    const result = new MultiPolyOut(ringsOut);\n    return result.getGeom();\n  }\n}\n\n// singleton available by import\nconst operation = new Operation();\n\nconst union = function (geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n  return operation.run(\"union\", geom, moreGeoms);\n};\nconst intersection = function (geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n  return operation.run(\"intersection\", geom, moreGeoms);\n};\nconst xor = function (geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n  return operation.run(\"xor\", geom, moreGeoms);\n};\nconst difference = function (subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n  return operation.run(\"difference\", subjectGeom, clippingGeoms);\n};\nvar index = {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference\n};\n\nexport { index as default };\n","// index.ts\nimport polygonClipping from \"polygon-clipping\";\nimport { polygon, multiPolygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nfunction difference(features) {\n  const geoms = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least two features\");\n  }\n  const properties = features.features[0].properties || {};\n  const differenced = polygonClipping.difference(geoms[0], ...geoms.slice(1));\n  if (differenced.length === 0)\n    return null;\n  if (differenced.length === 1)\n    return polygon(differenced[0], properties);\n  return multiPolygon(differenced, properties);\n}\nvar turf_difference_default = difference;\nexport {\n  turf_difference_default as default,\n  difference\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { flattenEach } from \"@turf/meta\";\nimport { featureCollection } from \"@turf/helpers\";\nfunction flatten(geojson) {\n  if (!geojson)\n    throw new Error(\"geojson is required\");\n  var results = [];\n  flattenEach(geojson, function(feature) {\n    results.push(feature);\n  });\n  return featureCollection(results);\n}\nvar turf_flatten_default = flatten;\nexport {\n  turf_flatten_default as default,\n  flatten\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport polygonClipping from \"polygon-clipping\";\nimport { multiPolygon, polygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nfunction union(features, options = {}) {\n  const geoms = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least 2 geometries\");\n  }\n  const unioned = polygonClipping.union(geoms[0], ...geoms.slice(1));\n  if (unioned.length === 0)\n    return null;\n  if (unioned.length === 1)\n    return polygon(unioned[0], options.properties);\n  else\n    return multiPolygon(unioned, options.properties);\n}\nvar turf_union_default = union;\nexport {\n  turf_union_default as default,\n  union\n};\n//# sourceMappingURL=index.js.map","import type { BBox } from \"./types\";\n\n// taken from Leaflet\nexport function wrapNum(\n  x: number,\n  range: [number, number],\n  includeMax: boolean,\n) {\n  const max = range[1],\n    min = range[0],\n    d = max - min;\n\n  return x === max && includeMax ? x : ((((x - min) % d) + d) % d) + min;\n}\n\nexport function unwrapBbox(bbox0: BBox): BBox {\n  const bbox = [...bbox0] satisfies BBox;\n\n  if (bbox[2] < bbox[0]) {\n    if (\n      Math.abs((bbox[0] + bbox[2] + 360) / 2) >\n      Math.abs((bbox[0] - 360 + bbox[2]) / 2)\n    ) {\n      bbox[0] -= 360;\n    } else {\n      bbox[2] += 360;\n    }\n  }\n\n  return bbox;\n}\n","import bbox from \"@turf/bbox\";\nimport difference from \"@turf/difference\";\nimport flatten from \"@turf/flatten\";\nimport { featureCollection, polygon } from \"@turf/helpers\";\nimport union from \"@turf/union\";\nimport type {\n  Feature,\n  FeatureCollection,\n  MultiPolygon,\n  Polygon,\n} from \"geojson\";\nimport { unwrapBbox } from \"./geoUtils\";\nimport type { BBox } from \"./types\";\n\nexport function setMask(\n  picked: Feature<Polygon | MultiPolygon>,\n  setData: (data?: FeatureCollection<Polygon | MultiPolygon>) => void,\n): void {\n  const diff = difference(\n    featureCollection([\n      polygon([\n        [\n          [180, 90],\n          [-180, 90],\n          [-180, -90],\n          [180, -90],\n          [180, 90],\n        ],\n      ]),\n      picked,\n    ]),\n  );\n\n  if (!diff) {\n    return;\n  }\n\n  diff.properties = { isMask: true };\n\n  const bb = unwrapBbox(bbox(picked) as BBox);\n\n  // bigger features (continents, oceans) have bigger tolerance\n  // because of the used source data simplification\n  const tolerance = (bb[2] - bb[0]) / 360 / 1_000;\n\n  const leaksLeft = bb[0] < -180;\n  const leaksRight = bb[2] > 180;\n\n  const flattened = flatten(picked);\n\n  if (flattened.features.length > 1 && (leaksLeft || leaksRight)) {\n    for (const poly of flattened.features) {\n      const bb = unwrapBbox(bbox(poly) as BBox);\n\n      if (leaksRight && bb[0] < -180 + tolerance) {\n        for (const ring of poly.geometry.coordinates) {\n          for (const position of ring) {\n            position[0] += 360 - tolerance;\n          }\n        }\n      }\n\n      if (leaksLeft && bb[2] > 180 - tolerance) {\n        for (const ring of poly.geometry.coordinates) {\n          for (const position of ring) {\n            position[0] -= 360 - tolerance;\n          }\n        }\n      }\n    }\n  }\n\n  setData(\n    featureCollection([\n      flattened.features.length < 2 ? picked : (union(flattened) ?? picked),\n      diff,\n    ]),\n  );\n}\n","import type { FeatureCollection, MultiPolygon, Polygon } from \"geojson\";\nimport { Feature as OlFeature, type MapBrowserEvent } from \"ol\";\nimport type { FeatureLike } from \"ol/Feature\";\nimport type Map from \"ol/Map\";\nimport type { AnimationOptions, FitOptions } from \"ol/View\";\nimport {\n  GeometryCollection as OlGeometryCollection,\n  LineString as OlLineString,\n  MultiLineString as OlMultiLineString,\n  MultiPolygon as OlMultiPolygon,\n  Point as OlPoint,\n  Polygon as OlPolygon,\n  type Geometry as OlGeometry,\n} from \"ol/geom\";\nimport VectorLayer from \"ol/layer/Vector\";\nimport {\n  fromLonLat,\n  getUserProjection,\n  toLonLat,\n  transformExtent,\n} from \"ol/proj\";\nimport VectorSource from \"ol/source/Vector\";\nimport Fill from \"ol/style/Fill\";\nimport Icon from \"ol/style/Icon\";\nimport Stroke from \"ol/style/Stroke\";\nimport Style, { type StyleLike } from \"ol/style/Style\";\nimport Text from \"ol/style/Text\";\nimport type { FlatStyleLike } from \"ol/style/flat\";\nimport { setMask } from \"./mask\";\nimport type {\n  BBox,\n  Feature as FeatureType,\n  MapController,\n  MapEvent,\n  Position,\n} from \"./types\";\n\nconst EPSG_4326 = \"EPSG:4326\";\n\nfunction defaultStyle(feature: FeatureLike) {\n  const properties = feature.getProperties();\n\n  const { isMask } = properties;\n\n  const type = feature.getGeometry()?.getType();\n\n  const weight = isMask\n    ? 0\n    : type === \"LineString\" || type === \"MultiLineString\"\n      ? 3\n      : 2;\n\n  return new Style({\n    stroke: isMask\n      ? undefined\n      : new Stroke({\n          color: \"#3170fe\",\n          lineDash: [weight, weight],\n          width: weight,\n          lineCap: \"butt\",\n        }),\n    fill: isMask\n      ? new Fill({\n          color: \"#00000020\",\n        })\n      : undefined,\n    image: new Icon({\n      src: `/icons/marker_${\n        properties.isReverse\n          ? \"reverse\"\n          : properties.isSelected\n            ? \"selected\"\n            : \"unselected\"\n      }.svg`,\n      anchor: [0.5, 1],\n    }),\n    zIndex: properties.isSelected ? 2 : properties.isReverse ? 0 : 1,\n    text:\n      properties.isSelected && properties.tooltip\n        ? new Text({\n            backgroundFill: new Fill({ color: \"white\" }),\n            text: properties.tooltip,\n            offsetY: -40,\n            backgroundStroke: new Stroke({\n              color: \"white\",\n              lineJoin: \"round\",\n              width: 3,\n            }),\n            padding: [2, 0, 0, 2],\n          })\n        : undefined,\n  });\n}\n\nexport function createOpenLayersMapController(\n  map: Map,\n  flyToOptions: AnimationOptions = {},\n  flyToBounds: FitOptions = {},\n  fullGeometryStyle: StyleLike | FlatStyleLike = defaultStyle,\n) {\n  let prevSelected = -1;\n\n  let prevHovered: string | undefined;\n\n  let eventHandler: ((e: MapEvent) => void) | undefined;\n\n  let reverseMarker: OlFeature | undefined;\n\n  let indicatingReverse = false;\n\n  const vectorLayer = new VectorLayer({\n    updateWhileAnimating: true,\n  });\n\n  map.addLayer(vectorLayer);\n\n  const source = new VectorSource({});\n\n  vectorLayer.setSource(source);\n\n  vectorLayer.setStyle(fullGeometryStyle);\n\n  map.on(\"click\", (e) => {\n    map.forEachFeatureAtPixel(e.pixel, (feature) => {\n      const id = feature.getId() as string;\n\n      if (!id) {\n        return;\n      }\n\n      e.stopPropagation();\n\n      eventHandler?.({ type: \"markerClick\", id });\n\n      return feature;\n    });\n  });\n\n  map.on(\"pointermove\", (e) => {\n    const featureId = map.forEachFeatureAtPixel(e.pixel, (feature) => {\n      return feature.getId() as string | undefined;\n    });\n\n    if (prevHovered === featureId) {\n      return;\n    }\n\n    if (prevHovered) {\n      eventHandler?.({\n        type: \"markerMouseLeave\",\n        id: prevHovered,\n      });\n    }\n\n    if (featureId) {\n      eventHandler?.({\n        type: \"markerMouseEnter\",\n        id: featureId,\n      });\n    }\n\n    map.getTargetElement().style.cursor = featureId\n      ? \"pointer\"\n      : indicatingReverse\n        ? \"crosshair\"\n        : \"\";\n\n    prevHovered = featureId;\n  });\n\n  function getProjection() {\n    return getUserProjection() ?? map.getView().getProjection();\n  }\n\n  function fromWgs84(geometry: OlGeometry) {\n    return geometry.transform(EPSG_4326, getProjection());\n  }\n\n  const handleMapClick = (e: MapBrowserEvent<PointerEvent>) => {\n    eventHandler?.({\n      type: \"mapClick\",\n      coordinates: toLonLat(e.coordinate, getProjection()) as [number, number],\n    });\n  };\n\n  return {\n    setEventHandler(handler: undefined | ((e: MapEvent) => void)): void {\n      if (handler) {\n        eventHandler = handler;\n        map.on(\"click\", handleMapClick);\n      } else {\n        eventHandler = undefined;\n        map.un(\"click\", handleMapClick);\n      }\n    },\n\n    flyTo(center: Position, zoom: number) {\n      map.getView().animate({\n        center: fromLonLat(center, getProjection()),\n        ...(zoom ? { zoom } : {}),\n        duration: 2000,\n        ...flyToOptions,\n      });\n    },\n\n    fitBounds(bbox: BBox, padding: number, maxZoom: number): void {\n      map.getView().fit(transformExtent(bbox, EPSG_4326, getProjection()), {\n        padding: [padding, padding, padding, padding],\n        ...(maxZoom ? { maxZoom } : {}),\n        duration: 2000,\n        ...flyToBounds,\n      });\n    },\n\n    indicateReverse(reverse: boolean): void {\n      indicatingReverse = reverse;\n\n      map.getTargetElement().style.cursor = reverse ? \"crosshair\" : \"\";\n    },\n\n    setReverseMarker(coordinates?: Position) {\n      if (reverseMarker) {\n        if (!coordinates) {\n          source.removeFeature(reverseMarker);\n\n          reverseMarker.dispose();\n\n          reverseMarker = undefined;\n        } else {\n          (reverseMarker.getGeometry() as OlPoint).setCoordinates(\n            fromLonLat(coordinates, getProjection()),\n          );\n        }\n      } else if (coordinates) {\n        reverseMarker = new OlFeature(\n          new OlPoint(fromLonLat(coordinates, getProjection())),\n        );\n\n        reverseMarker.setProperties({ isReverse: true });\n\n        source.addFeature(reverseMarker);\n      }\n    },\n\n    setFeatures(\n      markedFeatures: FeatureType[] | undefined,\n      picked: FeatureType | undefined,\n      showPolygonMarker: boolean,\n    ): void {\n      function setData(data?: FeatureCollection<Polygon | MultiPolygon>) {\n        if (!data) {\n          return;\n        }\n\n        for (const f of data.features) {\n          const geom =\n            f.geometry.type === \"Polygon\"\n              ? new OlPolygon(f.geometry.coordinates)\n              : f.geometry.type === \"MultiPolygon\"\n                ? new OlMultiPolygon(f.geometry.coordinates)\n                : null;\n\n          if (!geom) {\n            continue;\n          }\n\n          source.addFeature(\n            new OlFeature({\n              isMask: !!f.properties?.isMask,\n              geometry: fromWgs84(geom),\n            }),\n          );\n        }\n      }\n\n      source.clear();\n\n      if (reverseMarker) {\n        source.addFeature(reverseMarker);\n      }\n\n      if (picked) {\n        let handled = false;\n\n        if (picked.geometry.type === \"GeometryCollection\") {\n          const geoms = picked.geometry.geometries\n            .map((geometry) =>\n              geometry.type === \"Polygon\"\n                ? new OlPolygon(geometry.coordinates)\n                : geometry.type === \"MultiPolygon\"\n                  ? new OlMultiPolygon(geometry.coordinates)\n                  : null,\n            )\n            .filter(<T>(a: T | null): a is T => !!a);\n\n          if (geoms.length > 0) {\n            source.addFeature(\n              new OlFeature(fromWgs84(new OlGeometryCollection(geoms))),\n            );\n\n            handled = true;\n          } else {\n            for (const geometry of picked.geometry.geometries) {\n              if (geometry.type === \"LineString\") {\n                source.addFeature(\n                  new OlFeature(\n                    fromWgs84(new OlLineString(geometry.coordinates)),\n                  ),\n                );\n\n                handled = true;\n              } else if (geometry.type === \"MultiLineString\") {\n                source.addFeature(\n                  new OlFeature(\n                    fromWgs84(new OlMultiLineString(geometry.coordinates)),\n                  ),\n                );\n              }\n\n              handled = true;\n            }\n          }\n        }\n\n        if (handled) {\n          // nothing\n        } else if (picked.geometry.type === \"Polygon\") {\n          setMask(picked as FeatureType<Polygon>, setData);\n        } else if (picked.geometry.type === \"MultiPolygon\") {\n          setMask(picked as FeatureType<MultiPolygon>, setData);\n        } else if (picked.geometry.type === \"LineString\") {\n          source.addFeature(\n            new OlFeature(\n              fromWgs84(new OlLineString(picked.geometry.coordinates)),\n            ),\n          );\n\n          return; // no pin for (multi)linestrings\n        } else if (picked.geometry.type === \"MultiLineString\") {\n          source.addFeature(\n            new OlFeature(\n              fromWgs84(new OlMultiLineString(picked.geometry.coordinates)),\n            ),\n          );\n\n          return; // no pin for (multi)linestrings\n        }\n\n        if (!showPolygonMarker && picked.geometry.type !== \"Point\") {\n          return;\n        }\n\n        source.addFeature(new OlFeature(fromWgs84(new OlPoint(picked.center))));\n      }\n\n      for (const feature of markedFeatures ?? []) {\n        if (feature === picked) {\n          continue;\n        }\n\n        const marker = new OlFeature(\n          new OlPoint(fromLonLat(feature.center, getProjection())),\n        );\n\n        marker.setId(feature.id);\n\n        marker.setProperties({\n          fuzzy: !!feature.matching_text,\n          tooltip:\n            feature.place_type[0] === \"reverse\"\n              ? feature.place_name\n              : feature.place_name.replace(/,.*/, \"\"),\n        });\n\n        source.addFeature(marker);\n      }\n    },\n\n    setSelectedMarker(index: number): void {\n      const features = source.getFeatures();\n\n      const offset = features[0]?.getProperties().isReverse ? 1 : 0;\n\n      if (prevSelected > -1) {\n        features[prevSelected + offset]?.setProperties({\n          isSelected: false,\n        });\n      }\n\n      if (index > -1) {\n        features[index + offset]?.setProperties({\n          isSelected: true,\n        });\n      }\n\n      prevSelected = index;\n    },\n\n    getCenterAndZoom() {\n      const view = map.getView();\n\n      const center = view.getCenter();\n\n      const zoom = view.getZoom();\n\n      if (!center || zoom === undefined) {\n        return undefined;\n      }\n\n      return [zoom, ...(toLonLat(center, getProjection()) as Position)];\n    },\n  } satisfies MapController;\n}\n"],"names":["feature","geom","properties","options","feat","polygon","coordinates","ring","j","featureCollection","features","fc","multiPolygon","coordEach","geojson","callback","excludeWrapCoord","k","l","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","geomEach","i","g","featureProperties","featureBBox","featureId","flattenEach","bbox","id","coordinate","result","coord","turf_bbox_default","__generator","thisArg","body","_","t","f","y","verb","n","v","step","op","e","Node","key","data","DEFAULT_COMPARE","a","b","splay","comparator","N","r","cmp","insert","node","split","left","right","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","x","current","compare","visitor","ctx","Q","done","low","high","fn","keys","_a","values","index","d","successor","predecessor","toList","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","newKey","newData","start","end","middle","head","p","list","l1","l2","p1","p2","pivot","tmp","epsilon","splitter","resulterrbound","sum","elen","flen","h","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","isInBbox","point","getBboxOverlap","b1","b2","lowerX","upperX","lowerY","upperY","EPSILON_SQ","ab","PtRounder","CoordRounder","SplayTree","prevNode","nextNode","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","res","length","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection$1","pt1","v1","pt2","v2","kross","ve","d1","d2","x1","x2","y1","y2","SweepEvent","ptCmp","Segment","aPt","bPt","isLeft","other","otherEvents","iMax","evt","numEvents","evt1","evt2","events","baseEvent","cache","fillCache","linkedEvent","nextEvent","asine","acosine","bsine","bcosine","segmentId","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","bCmpARight","bCmpALeft","aCmpBRight","leftSE","rightSE","rings","windings","leftPt","rightPt","winding","cmpPts","newRightSE","lPt","rPt","yDist","xFromYDist","xDist","yFromXDist","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","newEvents","alreadyLinked","newLeftSE","oldRightSE","newSeg","tmpEvt","consumer","consumee","seg","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","poly","mp","mpsBefore","operation","noBefores","noAfters","least","most","diff","isJustSubject","mps","RingIn","geomRing","isExterior","firstPoint","prevPoint","sweepEvents","segment","PolyIn","geomPoly","multiPoly","ringSweepEvents","jMax","MultiPolyIn","isSubject","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","intersectionLE","ringEvents","prevPt","points","nextPt","iStart","iEnd","orderedPoints","enclosing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","exteriorRing","ringGeom","MultiPolyOut","polyGeom","polys","enclosingRing","SweepLine","queue","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","nextMySplitter","nextInter","mySplitter","inter","POLYGON_CLIPPING_MAX_QUEUE_SIZE","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","moreGeoms","multipolys","subject","mpA","sweepLine","prevQueueSize","union","_len","_key","intersection","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4","geoms","differenced","polygonClipping","turf_difference_default","flatten","results","turf_flatten_default","unioned","turf_union_default","unwrapBbox","bbox0","setMask","picked","setData","bb","tolerance","leaksLeft","leaksRight","flattened","position","EPSG_4326","defaultStyle","isMask","weight","Style","Stroke","Fill","Icon","Text","createOpenLayersMapController","map","flyToOptions","flyToBounds","fullGeometryStyle","prevSelected","prevHovered","eventHandler","reverseMarker","indicatingReverse","vectorLayer","VectorLayer","source","VectorSource","getProjection","getUserProjection","fromWgs84","handleMapClick","toLonLat","handler","center","zoom","fromLonLat","padding","maxZoom","transformExtent","reverse","OlFeature","OlPoint","markedFeatures","showPolygonMarker","OlPolygon","OlMultiPolygon","handled","OlGeometryCollection","OlLineString","OlMultiLineString","marker","offset","_b","_c","view"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}