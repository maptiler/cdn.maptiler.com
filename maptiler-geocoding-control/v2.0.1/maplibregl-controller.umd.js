(function(L,_){typeof exports=="object"&&typeof module<"u"?_(exports):typeof define=="function"&&define.amd?define(["exports"],_):(L=typeof globalThis<"u"?globalThis:L||self,_(L.maplibreglMaptilerGeocodingController={}))})(this,function(L){"use strict";var He=Object.defineProperty;var tn=(L,_,T)=>_ in L?He(L,_,{enumerable:!0,configurable:!0,writable:!0,value:T}):L[_]=T;var Et=(L,_,T)=>tn(L,typeof _!="symbol"?_+"":_,T);function _(i,t,e={}){const n={type:"Feature"};return(e.id===0||e.id)&&(n.id=e.id),e.bbox&&(n.bbox=e.bbox),n.properties=t||{},n.geometry=i,n}function T(i,t,e={}){for(const r of i){if(r.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(r[r.length-1].length!==r[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<r[r.length-1].length;o++)if(r[r.length-1][o]!==r[0][o])throw new Error("First and last Position are not equivalent.")}return _({type:"Polygon",coordinates:i},t,e)}function X(i,t={}){const e={type:"FeatureCollection"};return t.id&&(e.id=t.id),t.bbox&&(e.bbox=t.bbox),e.features=i,e}function mt(i,t,e={}){return _({type:"MultiPolygon",coordinates:i},t,e)}/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 *//*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */function Kt(i,t){var e={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},n,r,o,f;return f={next:l(0),throw:l(1),return:l(2)},typeof Symbol=="function"&&(f[Symbol.iterator]=function(){return this}),f;function l(u){return function(g){return c([u,g])}}function c(u){if(n)throw new TypeError("Generator is already executing.");for(;e;)try{if(n=1,r&&(o=u[0]&2?r.return:u[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,u[1])).done)return o;switch(r=0,o&&(u=[u[0]&2,o.value]),u[0]){case 0:case 1:o=u;break;case 4:return e.label++,{value:u[1],done:!1};case 5:e.label++,r=u[1],u=[0];continue;case 7:u=e.ops.pop(),e.trys.pop();continue;default:if(o=e.trys,!(o=o.length>0&&o[o.length-1])&&(u[0]===6||u[0]===2)){e=0;continue}if(u[0]===3&&(!o||u[1]>o[0]&&u[1]<o[3])){e.label=u[1];break}if(u[0]===6&&e.label<o[1]){e.label=o[1],o=u;break}if(o&&e.label<o[2]){e.label=o[2],e.ops.push(u);break}o[2]&&e.ops.pop(),e.trys.pop();continue}u=t.call(i,e)}catch(g){u=[6,g],r=0}finally{n=o=0}if(u[0]&5)throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}}var z=function(){function i(t,e){this.next=null,this.key=t,this.data=e,this.left=null,this.right=null}return i}();function Ht(i,t){return i>t?1:i<t?-1:0}function G(i,t,e){for(var n=new z(null,null),r=n,o=n;;){var f=e(i,t.key);if(f<0){if(t.left===null)break;if(e(i,t.left.key)<0){var l=t.left;if(t.left=l.right,l.right=t,t=l,t.left===null)break}o.left=t,o=t,t=t.left}else if(f>0){if(t.right===null)break;if(e(i,t.right.key)>0){var l=t.right;if(t.right=l.left,l.left=t,t=l,t.right===null)break}r.right=t,r=t,t=t.right}else break}return r.right=t.left,o.left=t.right,t.left=n.right,t.right=n.left,t}function st(i,t,e,n){var r=new z(i,t);if(e===null)return r.left=r.right=null,r;e=G(i,e,n);var o=n(i,e.key);return o<0?(r.left=e.left,r.right=e,e.left=null):o>=0&&(r.right=e.right,r.left=e,e.right=null),r}function wt(i,t,e){var n=null,r=null;if(t){t=G(i,t,e);var o=e(t.key,i);o===0?(n=t.left,r=t.right):o<0?(r=t.right,t.right=null,n=t):(n=t.left,t.left=null,r=t)}return{left:n,right:r}}function te(i,t,e){return t===null?i:(i===null||(t=G(i.key,t,e),t.left=i),t)}function lt(i,t,e,n,r){if(i){n(""+t+(e?"└── ":"├── ")+r(i)+`
`);var o=t+(e?"    ":"│   ");i.left&&lt(i.left,o,!1,n,r),i.right&&lt(i.right,o,!0,n,r)}}var ut=function(){function i(t){t===void 0&&(t=Ht),this._root=null,this._size=0,this._comparator=t}return i.prototype.insert=function(t,e){return this._size++,this._root=st(t,e,this._root,this._comparator)},i.prototype.add=function(t,e){var n=new z(t,e);this._root===null&&(n.left=n.right=null,this._size++,this._root=n);var r=this._comparator,o=G(t,this._root,r),f=r(t,o.key);return f===0?this._root=o:(f<0?(n.left=o.left,n.right=o,o.left=null):f>0&&(n.right=o.right,n.left=o,o.right=null),this._size++,this._root=n),this._root},i.prototype.remove=function(t){this._root=this._remove(t,this._root,this._comparator)},i.prototype._remove=function(t,e,n){var r;if(e===null)return null;e=G(t,e,n);var o=n(t,e.key);return o===0?(e.left===null?r=e.right:(r=G(t,e.left,n),r.right=e.right),this._size--,r):e},i.prototype.pop=function(){var t=this._root;if(t){for(;t.left;)t=t.left;return this._root=G(t.key,this._root,this._comparator),this._root=this._remove(t.key,this._root,this._comparator),{key:t.key,data:t.data}}return null},i.prototype.findStatic=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(r===0)return e;r<0?e=e.left:e=e.right}return null},i.prototype.find=function(t){return this._root&&(this._root=G(t,this._root,this._comparator),this._comparator(t,this._root.key)!==0)?null:this._root},i.prototype.contains=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(r===0)return!0;r<0?e=e.left:e=e.right}return!1},i.prototype.forEach=function(t,e){for(var n=this._root,r=[],o=!1;!o;)n!==null?(r.push(n),n=n.left):r.length!==0?(n=r.pop(),t.call(e,n),n=n.right):o=!0;return this},i.prototype.range=function(t,e,n,r){for(var o=[],f=this._comparator,l=this._root,c;o.length!==0||l;)if(l)o.push(l),l=l.left;else{if(l=o.pop(),c=f(l.key,e),c>0)break;if(f(l.key,t)>=0&&n.call(r,l))return this;l=l.right}return this},i.prototype.keys=function(){var t=[];return this.forEach(function(e){var n=e.key;return t.push(n)}),t},i.prototype.values=function(){var t=[];return this.forEach(function(e){var n=e.data;return t.push(n)}),t},i.prototype.min=function(){return this._root?this.minNode(this._root).key:null},i.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},i.prototype.minNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.left;)t=t.left;return t},i.prototype.maxNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.right;)t=t.right;return t},i.prototype.at=function(t){for(var e=this._root,n=!1,r=0,o=[];!n;)if(e)o.push(e),e=e.left;else if(o.length>0){if(e=o.pop(),r===t)return e;r++,e=e.right}else n=!0;return null},i.prototype.next=function(t){var e=this._root,n=null;if(t.right){for(n=t.right;n.left;)n=n.left;return n}for(var r=this._comparator;e;){var o=r(t.key,e.key);if(o===0)break;o<0?(n=e,e=e.left):e=e.right}return n},i.prototype.prev=function(t){var e=this._root,n=null;if(t.left!==null){for(n=t.left;n.right;)n=n.right;return n}for(var r=this._comparator;e;){var o=r(t.key,e.key);if(o===0)break;o<0?e=e.left:(n=e,e=e.right)}return n},i.prototype.clear=function(){return this._root=null,this._size=0,this},i.prototype.toList=function(){return ne(this._root)},i.prototype.load=function(t,e,n){e===void 0&&(e=[]),n===void 0&&(n=!1);var r=t.length,o=this._comparator;if(n&&ht(t,e,0,r-1,o),this._root===null)this._root=ft(t,e,0,r),this._size=r;else{var f=ie(this.toList(),ee(t,e),o);r=this._size+r,this._root=ct({head:f},0,r)}return this},i.prototype.isEmpty=function(){return this._root===null},Object.defineProperty(i.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),i.prototype.toString=function(t){t===void 0&&(t=function(n){return String(n.key)});var e=[];return lt(this._root,"",!0,function(n){return e.push(n)},t),e.join("")},i.prototype.update=function(t,e,n){var r=this._comparator,o=wt(t,this._root,r),f=o.left,l=o.right;r(t,e)<0?l=st(e,n,l,r):f=st(e,n,f,r),this._root=te(f,l,r)},i.prototype.split=function(t){return wt(t,this._root,this._comparator)},i.prototype[Symbol.iterator]=function(){var t,e,n;return Kt(this,function(r){switch(r.label){case 0:t=this._root,e=[],n=!1,r.label=1;case 1:return n?[3,6]:t===null?[3,2]:(e.push(t),t=t.left,[3,5]);case 2:return e.length===0?[3,4]:(t=e.pop(),[4,t]);case 3:return r.sent(),t=t.right,[3,5];case 4:n=!0,r.label=5;case 5:return[3,1];case 6:return[2]}})},i}();function ft(i,t,e,n){var r=n-e;if(r>0){var o=e+Math.floor(r/2),f=i[o],l=t[o],c=new z(f,l);return c.left=ft(i,t,e,o),c.right=ft(i,t,o+1,n),c}return null}function ee(i,t){for(var e=new z(null,null),n=e,r=0;r<i.length;r++)n=n.next=new z(i[r],t[r]);return n.next=null,e.next}function ne(i){for(var t=i,e=[],n=!1,r=new z(null,null),o=r;!n;)t?(e.push(t),t=t.left):e.length>0?(t=o=o.next=e.pop(),t=t.right):n=!0;return o.next=null,r.next}function ct(i,t,e){var n=e-t;if(n>0){var r=t+Math.floor(n/2),o=ct(i,t,r),f=i.head;return f.left=o,i.head=i.head.next,f.right=ct(i,r+1,e),f}return null}function ie(i,t,e){for(var n=new z(null,null),r=n,o=i,f=t;o!==null&&f!==null;)e(o.key,f.key)<0?(r.next=o,o=o.next):(r.next=f,f=f.next),r=r.next;return o!==null?r.next=o:f!==null&&(r.next=f),n.next}function ht(i,t,e,n,r){if(!(e>=n)){for(var o=i[e+n>>1],f=e-1,l=n+1;;){do f++;while(r(i[f],o)<0);do l--;while(r(i[l],o)>0);if(f>=l)break;var c=i[f];i[f]=i[l],i[l]=c,c=t[f],t[f]=t[l],t[l]=c}ht(i,t,e,l,r),ht(i,t,l+1,n,r)}}const N=11102230246251565e-32,S=134217729,re=(3+8*N)*N;function at(i,t,e,n,r){let o,f,l,c,u=t[0],g=n[0],s=0,h=0;g>u==g>-u?(o=u,u=t[++s]):(o=g,g=n[++h]);let a=0;if(s<i&&h<e)for(g>u==g>-u?(f=u+o,l=o-(f-u),u=t[++s]):(f=g+o,l=o-(f-g),g=n[++h]),o=f,l!==0&&(r[a++]=l);s<i&&h<e;)g>u==g>-u?(f=o+u,c=f-o,l=o-(f-c)+(u-c),u=t[++s]):(f=o+g,c=f-o,l=o-(f-c)+(g-c),g=n[++h]),o=f,l!==0&&(r[a++]=l);for(;s<i;)f=o+u,c=f-o,l=o-(f-c)+(u-c),u=t[++s],o=f,l!==0&&(r[a++]=l);for(;h<e;)f=o+g,c=f-o,l=o-(f-c)+(g-c),g=n[++h],o=f,l!==0&&(r[a++]=l);return(o!==0||a===0)&&(r[a++]=o),a}function oe(i,t){let e=t[0];for(let n=1;n<i;n++)e+=t[n];return e}function V(i){return new Float64Array(i)}const se=(3+16*N)*N,le=(2+12*N)*N,ue=(9+64*N)*N*N,Y=V(4),bt=V(8),_t=V(12),St=V(16),M=V(4);function fe(i,t,e,n,r,o,f){let l,c,u,g,s,h,a,d,x,p,y,w,v,E,m,b,C,P;const k=i-r,$=e-r,A=t-o,O=n-o;E=k*O,h=S*k,a=h-(h-k),d=k-a,h=S*O,x=h-(h-O),p=O-x,m=d*p-(E-a*x-d*x-a*p),b=A*$,h=S*A,a=h-(h-A),d=A-a,h=S*$,x=h-(h-$),p=$-x,C=d*p-(b-a*x-d*x-a*p),y=m-C,s=m-y,Y[0]=m-(y+s)+(s-C),w=E+y,s=w-E,v=E-(w-s)+(y-s),y=v-b,s=v-y,Y[1]=v-(y+s)+(s-b),P=w+y,s=P-w,Y[2]=w-(P-s)+(y-s),Y[3]=P;let B=oe(4,Y),H=le*f;if(B>=H||-B>=H||(s=i-k,l=i-(k+s)+(s-r),s=e-$,u=e-($+s)+(s-r),s=t-A,c=t-(A+s)+(s-o),s=n-O,g=n-(O+s)+(s-o),l===0&&c===0&&u===0&&g===0)||(H=ue*f+re*Math.abs(B),B+=k*g+O*l-(A*u+$*c),B>=H||-B>=H))return B;E=l*O,h=S*l,a=h-(h-l),d=l-a,h=S*O,x=h-(h-O),p=O-x,m=d*p-(E-a*x-d*x-a*p),b=c*$,h=S*c,a=h-(h-c),d=c-a,h=S*$,x=h-(h-$),p=$-x,C=d*p-(b-a*x-d*x-a*p),y=m-C,s=m-y,M[0]=m-(y+s)+(s-C),w=E+y,s=w-E,v=E-(w-s)+(y-s),y=v-b,s=v-y,M[1]=v-(y+s)+(s-b),P=w+y,s=P-w,M[2]=w-(P-s)+(y-s),M[3]=P;const We=at(4,Y,4,M,bt);E=k*g,h=S*k,a=h-(h-k),d=k-a,h=S*g,x=h-(h-g),p=g-x,m=d*p-(E-a*x-d*x-a*p),b=A*u,h=S*A,a=h-(h-A),d=A-a,h=S*u,x=h-(h-u),p=u-x,C=d*p-(b-a*x-d*x-a*p),y=m-C,s=m-y,M[0]=m-(y+s)+(s-C),w=E+y,s=w-E,v=E-(w-s)+(y-s),y=v-b,s=v-y,M[1]=v-(y+s)+(s-b),P=w+y,s=P-w,M[2]=w-(P-s)+(y-s),M[3]=P;const Je=at(We,bt,4,M,_t);E=l*g,h=S*l,a=h-(h-l),d=l-a,h=S*g,x=h-(h-g),p=g-x,m=d*p-(E-a*x-d*x-a*p),b=c*u,h=S*c,a=h-(h-c),d=c-a,h=S*u,x=h-(h-u),p=u-x,C=d*p-(b-a*x-d*x-a*p),y=m-C,s=m-y,M[0]=m-(y+s)+(s-C),w=E+y,s=w-E,v=E-(w-s)+(y-s),y=v-b,s=v-y,M[1]=v-(y+s)+(s-b),P=w+y,s=P-w,M[2]=w-(P-s)+(y-s),M[3]=P;const Ke=at(Je,_t,4,M,St);return St[Ke-1]}function ce(i,t,e,n,r,o){const f=(t-o)*(e-r),l=(i-r)*(n-o),c=f-l,u=Math.abs(f+l);return Math.abs(c)>=se*u?c:-fe(i,t,e,n,r,o,u)}const Z=(i,t)=>i.ll.x<=t.x&&t.x<=i.ur.x&&i.ll.y<=t.y&&t.y<=i.ur.y,gt=(i,t)=>{if(t.ur.x<i.ll.x||i.ur.x<t.ll.x||t.ur.y<i.ll.y||i.ur.y<t.ll.y)return null;const e=i.ll.x<t.ll.x?t.ll.x:i.ll.x,n=i.ur.x<t.ur.x?i.ur.x:t.ur.x,r=i.ll.y<t.ll.y?t.ll.y:i.ll.y,o=i.ur.y<t.ur.y?i.ur.y:t.ur.y;return{ll:{x:e,y:r},ur:{x:n,y:o}}};let U=Number.EPSILON;U===void 0&&(U=Math.pow(2,-52));const he=U*U,Pt=(i,t)=>{if(-U<i&&i<U&&-U<t&&t<U)return 0;const e=i-t;return e*e<he*i*t?0:i<t?-1:1};class ae{constructor(){this.reset()}reset(){this.xRounder=new Mt,this.yRounder=new Mt}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}}class Mt{constructor(){this.tree=new ut,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(n!==null&&Pt(e.key,n.key)===0)return this.tree.remove(t),n.key;const r=this.tree.next(e);return r!==null&&Pt(e.key,r.key)===0?(this.tree.remove(t),r.key):t}}const W=new ae,tt=(i,t)=>i.x*t.y-i.y*t.x,Lt=(i,t)=>i.x*t.x+i.y*t.y,Rt=(i,t,e)=>{const n=ce(i.x,i.y,t.x,t.y,e.x,e.y);return n>0?-1:n<0?1:0},et=i=>Math.sqrt(Lt(i,i)),ge=(i,t,e)=>{const n={x:t.x-i.x,y:t.y-i.y},r={x:e.x-i.x,y:e.y-i.y};return tt(r,n)/et(r)/et(n)},pe=(i,t,e)=>{const n={x:t.x-i.x,y:t.y-i.y},r={x:e.x-i.x,y:e.y-i.y};return Lt(r,n)/et(r)/et(n)},Ct=(i,t,e)=>t.y===0?null:{x:i.x+t.x/t.y*(e-i.y),y:e},It=(i,t,e)=>t.x===0?null:{x:e,y:i.y+t.y/t.x*(e-i.x)},ye=(i,t,e,n)=>{if(t.x===0)return It(e,n,i.x);if(n.x===0)return It(i,t,e.x);if(t.y===0)return Ct(e,n,i.y);if(n.y===0)return Ct(i,t,e.y);const r=tt(t,n);if(r==0)return null;const o={x:e.x-i.x,y:e.y-i.y},f=tt(o,t)/r,l=tt(o,n)/r,c=i.x+l*t.x,u=e.x+f*n.x,g=i.y+l*t.y,s=e.y+f*n.y,h=(c+u)/2,a=(g+s)/2;return{x:h,y:a}};class R{static compare(t,e){const n=R.comparePoints(t.point,e.point);return n!==0?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:j.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){t.events===void 0?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let n=0,r=e.length;n<r;n++){const o=e[n];this.point.events.push(o),o.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(n.segment.consumedBy===void 0)for(let r=e+1;r<t;r++){const o=this.point.events[r];o.consumedBy===void 0&&n.otherSE.point.events===o.otherSE.point.events&&n.segment.consume(o.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const r=this.point.events[e];r!==this&&!r.segment.ringOut&&r.segment.isInResult()&&t.push(r)}return t}getLeftmostComparator(t){const e=new Map,n=r=>{const o=r.otherSE;e.set(r,{sine:ge(this.point,t.point,o.point),cosine:pe(this.point,t.point,o.point)})};return(r,o)=>{e.has(r)||n(r),e.has(o)||n(o);const{sine:f,cosine:l}=e.get(r),{sine:c,cosine:u}=e.get(o);return f>=0&&c>=0?l<u?1:l>u?-1:0:f<0&&c<0?l<u?-1:l>u?1:0:c<f?-1:c>f?1:0}}}let de=0;class j{static compare(t,e){const n=t.leftSE.point.x,r=e.leftSE.point.x,o=t.rightSE.point.x,f=e.rightSE.point.x;if(f<n)return 1;if(o<r)return-1;const l=t.leftSE.point.y,c=e.leftSE.point.y,u=t.rightSE.point.y,g=e.rightSE.point.y;if(n<r){if(c<l&&c<u)return 1;if(c>l&&c>u)return-1;const s=t.comparePoint(e.leftSE.point);if(s<0)return 1;if(s>0)return-1;const h=e.comparePoint(t.rightSE.point);return h!==0?h:-1}if(n>r){if(l<c&&l<g)return-1;if(l>c&&l>g)return 1;const s=e.comparePoint(t.leftSE.point);if(s!==0)return s;const h=t.comparePoint(e.rightSE.point);return h<0?1:h>0?-1:1}if(l<c)return-1;if(l>c)return 1;if(o<f){const s=e.comparePoint(t.rightSE.point);if(s!==0)return s}if(o>f){const s=t.comparePoint(e.rightSE.point);if(s<0)return 1;if(s>0)return-1}if(o!==f){const s=u-l,h=o-n,a=g-c,d=f-r;if(s>h&&a<d)return 1;if(s<h&&a>d)return-1}return o>f?1:o<f||u<g?-1:u>g?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,r){this.id=++de,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=r}static fromRing(t,e,n){let r,o,f;const l=R.comparePoints(t,e);if(l<0)r=t,o=e,f=1;else if(l>0)r=e,o=t,f=-1;else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);const c=new R(r,!0),u=new R(o,!1);return new j(c,u,[n],[f])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,r=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const o=(t.y-e.y)/r.y,f=e.x+o*r.x;if(t.x===f)return 0;const l=(t.x-e.x)/r.x,c=e.y+l*r.y;return t.y===c?0:t.y<c?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),r=gt(e,n);if(r===null)return null;const o=this.leftSE.point,f=this.rightSE.point,l=t.leftSE.point,c=t.rightSE.point,u=Z(e,l)&&this.comparePoint(l)===0,g=Z(n,o)&&t.comparePoint(o)===0,s=Z(e,c)&&this.comparePoint(c)===0,h=Z(n,f)&&t.comparePoint(f)===0;if(g&&u)return h&&!s?f:!h&&s?c:null;if(g)return s&&o.x===c.x&&o.y===c.y?null:o;if(u)return h&&f.x===l.x&&f.y===l.y?null:l;if(h&&s)return null;if(h)return f;if(s)return c;const a=ye(o,this.vector(),l,t.vector());return a===null||!Z(r,a)?null:W.round(a.x,a.y)}split(t){const e=[],n=t.events!==void 0,r=new R(t,!0),o=new R(t,!1),f=this.rightSE;this.replaceRightSE(o),e.push(o),e.push(r);const l=new j(r,f,this.rings.slice(),this.windings.slice());return R.comparePoints(l.leftSE.point,l.rightSE.point)>0&&l.swapEvents(),R.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(r.checkForConsuming(),o.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const r=j.compare(e,n);if(r!==0){if(r>0){const o=e;e=n,n=o}if(e.prev===n){const o=e;e=n,n=o}for(let o=0,f=n.rings.length;o<f;o++){const l=n.rings[o],c=n.windings[o],u=e.rings.indexOf(l);u===-1?(e.rings.push(l),e.windings.push(c)):e.windings[u]+=c}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}beforeState(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else{const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}return this._beforeState}afterState(){if(this._afterState!==void 0)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,r=this._afterState.multiPolys;for(let l=0,c=this.rings.length;l<c;l++){const u=this.rings[l],g=this.windings[l],s=e.indexOf(u);s===-1?(e.push(u),n.push(g)):n[s]+=g}const o=[],f=[];for(let l=0,c=e.length;l<c;l++){if(n[l]===0)continue;const u=e[l],g=u.poly;if(f.indexOf(g)===-1)if(u.isExterior)o.push(g);else{f.indexOf(g)===-1&&f.push(g);const s=o.indexOf(u.poly);s!==-1&&o.splice(s,1)}}for(let l=0,c=o.length;l<c;l++){const u=o[l].multiPoly;r.indexOf(u)===-1&&r.push(u)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(this._isInResult!==void 0)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(I.type){case"union":{const n=t.length===0,r=e.length===0;this._isInResult=n!==r;break}case"intersection":{let n,r;t.length<e.length?(n=t.length,r=e.length):(n=e.length,r=t.length),this._isInResult=r===I.numMultiPolys&&n<r;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2===1;break}case"difference":{const n=r=>r.length===1&&r[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${I.type}`)}return this._isInResult}}class kt{constructor(t,e,n){if(!Array.isArray(t)||t.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],typeof t[0][0]!="number"||typeof t[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const r=W.round(t[0][0],t[0][1]);this.bbox={ll:{x:r.x,y:r.y},ur:{x:r.x,y:r.y}};let o=r;for(let f=1,l=t.length;f<l;f++){if(typeof t[f][0]!="number"||typeof t[f][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let c=W.round(t[f][0],t[f][1]);c.x===o.x&&c.y===o.y||(this.segments.push(j.fromRing(o,c,this)),c.x<this.bbox.ll.x&&(this.bbox.ll.x=c.x),c.y<this.bbox.ll.y&&(this.bbox.ll.y=c.y),c.x>this.bbox.ur.x&&(this.bbox.ur.x=c.x),c.y>this.bbox.ur.y&&(this.bbox.ur.y=c.y),o=c)}(r.x!==o.x||r.y!==o.y)&&this.segments.push(j.fromRing(o,r,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const r=this.segments[e];t.push(r.leftSE),t.push(r.rightSE)}return t}}class xe{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new kt(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,r=t.length;n<r;n++){const o=new kt(t[n],this,!1);o.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=o.bbox.ll.x),o.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=o.bbox.ll.y),o.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=o.bbox.ur.x),o.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=o.bbox.ur.y),this.interiorRings.push(o)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const r=this.interiorRings[e].getSweepEvents();for(let o=0,f=r.length;o<f;o++)t.push(r[o])}return t}}class $t{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof t[0][0][0]=="number"&&(t=[t])}catch{}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let n=0,r=t.length;n<r;n++){const o=new xe(t[n],this);o.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=o.bbox.ll.x),o.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=o.bbox.ll.y),o.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=o.bbox.ur.x),o.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=o.bbox.ur.y),this.polys.push(o)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const r=this.polys[e].getSweepEvents();for(let o=0,f=r.length;o<f;o++)t.push(r[o])}return t}}class nt{static factory(t){const e=[];for(let n=0,r=t.length;n<r;n++){const o=t[n];if(!o.isInResult()||o.ringOut)continue;let f=null,l=o.leftSE,c=o.rightSE;const u=[l],g=l.point,s=[];for(;f=l,l=c,u.push(l),l.point!==g;)for(;;){const h=l.getAvailableLinkedEvents();if(h.length===0){const x=u[0].point,p=u[u.length-1].point;throw new Error(`Unable to complete output ring starting at [${x.x}, ${x.y}]. Last matching segment found ends at [${p.x}, ${p.y}].`)}if(h.length===1){c=h[0].otherSE;break}let a=null;for(let x=0,p=s.length;x<p;x++)if(s[x].point===l.point){a=x;break}if(a!==null){const x=s.splice(a)[0],p=u.splice(x.index);p.unshift(p[0].otherSE),e.push(new nt(p.reverse()));continue}s.push({index:u.length,point:l.point});const d=l.getLeftmostComparator(f);c=h.sort(d)[0].otherSE;break}e.push(new nt(u))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let u=1,g=this.events.length-1;u<g;u++){const s=this.events[u].point,h=this.events[u+1].point;Rt(s,t,h)!==0&&(e.push(s),t=s)}if(e.length===1)return null;const n=e[0],r=e[1];Rt(n,t,r)===0&&e.shift(),e.push(e[0]);const o=this.isExteriorRing()?1:-1,f=this.isExteriorRing()?0:e.length-1,l=this.isExteriorRing()?e.length:-1,c=[];for(let u=f;u!=l;u+=o)c.push([e[u].x,e[u].y]);return c}isExteriorRing(){if(this._isExteriorRing===void 0){const t=this.enclosingRing();this._isExteriorRing=t?!t.isExteriorRing():!0}return this._isExteriorRing}enclosingRing(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let r=1,o=this.events.length;r<o;r++){const f=this.events[r];R.compare(t,f)>0&&(t=f)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class At{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(t[0]===null)return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const r=this.interiorRings[e].getGeom();r!==null&&t.push(r)}return t}}class ve{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const r=this.polys[e].getGeom();r!==null&&t.push(r)}return t}_composePolys(t){const e=[];for(let n=0,r=t.length;n<r;n++){const o=t[n];if(!o.poly)if(o.isExteriorRing())e.push(new At(o));else{const f=o.enclosingRing();f.poly||e.push(new At(f)),f.poly.addInterior(o)}}return e}}class Ee{constructor(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:j.compare;this.queue=t,this.tree=new ut(e),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const r=t.isLeft?this.tree.add(e):this.tree.find(e);if(!r)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let o=r,f=r,l,c;for(;l===void 0;)o=this.tree.prev(o),o===null?l=null:o.key.consumedBy===void 0&&(l=o.key);for(;c===void 0;)f=this.tree.next(f),f===null?c=null:f.key.consumedBy===void 0&&(c=f.key);if(t.isLeft){let u=null;if(l){const s=l.getIntersection(e);if(s!==null&&(e.isAnEndpoint(s)||(u=s),!l.isAnEndpoint(s))){const h=this._splitSafely(l,s);for(let a=0,d=h.length;a<d;a++)n.push(h[a])}}let g=null;if(c){const s=c.getIntersection(e);if(s!==null&&(e.isAnEndpoint(s)||(g=s),!c.isAnEndpoint(s))){const h=this._splitSafely(c,s);for(let a=0,d=h.length;a<d;a++)n.push(h[a])}}if(u!==null||g!==null){let s=null;u===null?s=g:g===null?s=u:s=R.comparePoints(u,g)<=0?u:g,this.queue.remove(e.rightSE),n.push(e.rightSE);const h=e.split(s);for(let a=0,d=h.length;a<d;a++)n.push(h[a])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=l)}else{if(l&&c){const u=l.getIntersection(c);if(u!==null){if(!l.isAnEndpoint(u)){const g=this._splitSafely(l,u);for(let s=0,h=g.length;s<h;s++)n.push(g[s])}if(!c.isAnEndpoint(u)){const g=this._splitSafely(c,u);for(let s=0,h=g.length;s<h;s++)n.push(g[s])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const r=t.split(e);return r.push(n),t.consumedBy===void 0&&this.tree.add(t),r}}const Ot=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,me=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;class we{run(t,e,n){I.type=t,W.reset();const r=[new $t(e,!0)];for(let s=0,h=n.length;s<h;s++)r.push(new $t(n[s],!1));if(I.numMultiPolys=r.length,I.type==="difference"){const s=r[0];let h=1;for(;h<r.length;)gt(r[h].bbox,s.bbox)!==null?h++:r.splice(h,1)}if(I.type==="intersection")for(let s=0,h=r.length;s<h;s++){const a=r[s];for(let d=s+1,x=r.length;d<x;d++)if(gt(a.bbox,r[d].bbox)===null)return[]}const o=new ut(R.compare);for(let s=0,h=r.length;s<h;s++){const a=r[s].getSweepEvents();for(let d=0,x=a.length;d<x;d++)if(o.insert(a[d]),o.size>Ot)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const f=new Ee(o);let l=o.size,c=o.pop();for(;c;){const s=c.key;if(o.size===l){const a=s.segment;throw new Error(`Unable to pop() ${s.isLeft?"left":"right"} SweepEvent [${s.point.x}, ${s.point.y}] from segment #${a.id} [${a.leftSE.point.x}, ${a.leftSE.point.y}] -> [${a.rightSE.point.x}, ${a.rightSE.point.y}] from queue.`)}if(o.size>Ot)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(f.segments.length>me)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const h=f.process(s);for(let a=0,d=h.length;a<d;a++){const x=h[a];x.consumedBy===void 0&&o.insert(x)}l=o.size,c=o.pop()}W.reset();const u=nt.factory(f.segments);return new ve(u).getGeom()}}const I=new we;var Nt={union:function(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return I.run("union",i,e)},intersection:function(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return I.run("intersection",i,e)},xor:function(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return I.run("xor",i,e)},difference:function(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return I.run("difference",i,e)}};function Bt(i,t,e){if(i!==null)for(var n,r,o,f,l,c,u,g=0,s=0,h,a=i.type,d=a==="FeatureCollection",x=a==="Feature",p=d?i.features.length:1,y=0;y<p;y++){u=d?i.features[y].geometry:x?i.geometry:i,h=u?u.type==="GeometryCollection":!1,l=h?u.geometries.length:1;for(var w=0;w<l;w++){var v=0,E=0;if(f=h?u.geometries[w]:u,f!==null){c=f.coordinates;var m=f.type;switch(g=0,m){case null:break;case"Point":if(t(c,s,y,v,E)===!1)return!1;s++,v++;break;case"LineString":case"MultiPoint":for(n=0;n<c.length;n++){if(t(c[n],s,y,v,E)===!1)return!1;s++,m==="MultiPoint"&&v++}m==="LineString"&&v++;break;case"Polygon":case"MultiLineString":for(n=0;n<c.length;n++){for(r=0;r<c[n].length-g;r++){if(t(c[n][r],s,y,v,E)===!1)return!1;s++}m==="MultiLineString"&&v++,m==="Polygon"&&E++}m==="Polygon"&&v++;break;case"MultiPolygon":for(n=0;n<c.length;n++){for(E=0,r=0;r<c[n].length;r++){for(o=0;o<c[n][r].length-g;o++){if(t(c[n][r][o],s,y,v,E)===!1)return!1;s++}E++}v++}break;case"GeometryCollection":for(n=0;n<f.geometries.length;n++)if(Bt(f.geometries[n],t)===!1)return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function pt(i,t){var e,n,r,o,f,l,c,u,g,s,h=0,a=i.type==="FeatureCollection",d=i.type==="Feature",x=a?i.features.length:1;for(e=0;e<x;e++){for(l=a?i.features[e].geometry:d?i.geometry:i,u=a?i.features[e].properties:d?i.properties:{},g=a?i.features[e].bbox:d?i.bbox:void 0,s=a?i.features[e].id:d?i.id:void 0,c=l?l.type==="GeometryCollection":!1,f=c?l.geometries.length:1,r=0;r<f;r++){if(o=c?l.geometries[r]:l,o===null){if(t(null,h,u,g,s)===!1)return!1;continue}switch(o.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":{if(t(o,h,u,g,s)===!1)return!1;break}case"GeometryCollection":{for(n=0;n<o.geometries.length;n++)if(t(o.geometries[n],h,u,g,s)===!1)return!1;break}default:throw new Error("Unknown Geometry Type")}}h++}}function be(i,t){pt(i,function(e,n,r,o,f){var l=e===null?null:e.type;switch(l){case null:case"Point":case"LineString":case"Polygon":return t(_(e,r,{bbox:o,id:f}),n,0)===!1?!1:void 0}var c;switch(l){case"MultiPoint":c="Point";break;case"MultiLineString":c="LineString";break;case"MultiPolygon":c="Polygon";break}for(var u=0;u<e.coordinates.length;u++){var g=e.coordinates[u],s={type:c,coordinates:g};if(t(_(s,r),n,u)===!1)return!1}})}function _e(i,t={}){const e=[];if(pt(i,r=>{e.push(r.coordinates)}),e.length<2)throw new Error("Must have at least 2 geometries");const n=Nt.union(e[0],...e.slice(1));return n.length===0?null:n.length===1?T(n[0],t.properties):mt(n,t.properties)}var Tt=_e;function J(){}function zt(i){return i()}function Gt(){return Object.create(null)}function it(i){i.forEach(zt)}function Ut(i){return typeof i=="function"}function Se(i,t){return i!=i?t==t:i!==t||i&&typeof i=="object"||typeof i=="function"}function Pe(i){return Object.keys(i).length===0}function Me(i,t){i.appendChild(t)}function Le(i,t,e){i.insertBefore(t,e||null)}function jt(i){i.parentNode&&i.parentNode.removeChild(i)}function qt(i){return document.createElementNS("http://www.w3.org/2000/svg",i)}function q(i,t,e){e==null?i.removeAttribute(t):i.getAttribute(t)!==e&&i.setAttribute(t,e)}function Re(i){return Array.from(i.childNodes)}function rt(i,t,e){i.classList.toggle(t,!!e)}let yt;function K(i){yt=i}const F=[],Yt=[];let Q=[];const Ft=[],Ce=Promise.resolve();let dt=!1;function Ie(){dt||(dt=!0,Ce.then(Qt))}function xt(i){Q.push(i)}const vt=new Set;let D=0;function Qt(){if(D!==0)return;const i=yt;do{try{for(;D<F.length;){const t=F[D];D++,K(t),ke(t.$$)}}catch(t){throw F.length=0,D=0,t}for(K(null),F.length=0,D=0;Yt.length;)Yt.pop()();for(let t=0;t<Q.length;t+=1){const e=Q[t];vt.has(e)||(vt.add(e),e())}Q.length=0}while(F.length);for(;Ft.length;)Ft.pop()();dt=!1,vt.clear(),K(i)}function ke(i){if(i.fragment!==null){i.update(),it(i.before_update);const t=i.dirty;i.dirty=[-1],i.fragment&&i.fragment.p(i.ctx,t),i.after_update.forEach(xt)}}function $e(i){const t=[],e=[];Q.forEach(n=>i.indexOf(n)===-1?t.push(n):e.push(n)),e.forEach(n=>n()),Q=t}const Ae=new Set;function Oe(i,t){i&&i.i&&(Ae.delete(i),i.i(t))}function Ne(i,t,e){const{fragment:n,after_update:r}=i.$$;n&&n.m(t,e),xt(()=>{const o=i.$$.on_mount.map(zt).filter(Ut);i.$$.on_destroy?i.$$.on_destroy.push(...o):it(o),i.$$.on_mount=[]}),r.forEach(xt)}function Be(i,t){const e=i.$$;e.fragment!==null&&($e(e.after_update),it(e.on_destroy),e.fragment&&e.fragment.d(t),e.on_destroy=e.fragment=null,e.ctx=[])}function Te(i,t){i.$$.dirty[0]===-1&&(F.push(i),Ie(),i.$$.dirty.fill(0)),i.$$.dirty[t/31|0]|=1<<t%31}function ze(i,t,e,n,r,o,f=null,l=[-1]){const c=yt;K(i);const u=i.$$={fragment:null,ctx:[],props:o,update:J,not_equal:r,bound:Gt(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(c?c.$$.context:[])),callbacks:Gt(),dirty:l,skip_bound:!1,root:t.target||c.$$.root};f&&f(u.root);let g=!1;if(u.ctx=e?e(i,t.props||{},(s,h,...a)=>{const d=a.length?a[0]:h;return u.ctx&&r(u.ctx[s],u.ctx[s]=d)&&(!u.skip_bound&&u.bound[s]&&u.bound[s](d),g&&Te(i,s)),h}):[],u.update(),g=!0,it(u.before_update),u.fragment=n?n(u.ctx):!1,t.target){if(t.hydrate){const s=Re(t.target);u.fragment&&u.fragment.l(s),s.forEach(jt)}else u.fragment&&u.fragment.c();t.intro&&Oe(i.$$.fragment),Ne(i,t.target,t.anchor),Qt()}K(c)}class Ge{constructor(){Et(this,"$$");Et(this,"$$set")}$destroy(){Be(this,1),this.$destroy=J}$on(t,e){if(!Ut(e))return J;const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const r=n.indexOf(e);r!==-1&&n.splice(r,1)}}$set(t){this.$$set&&!Pe(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const Ue="4";typeof window<"u"&&(window.__svelte||(window.__svelte={v:new Set})).v.add(Ue);function je(i){let t,e,n;return{c(){t=qt("svg"),e=qt("path"),q(e,"stroke-width","4"),q(e,"d","M 5,33.103579 C 5,17.607779 18.457,5 35,5 C 51.543,5 65,17.607779 65,33.103579 C 65,56.388679 40.4668,76.048179 36.6112,79.137779 C 36.3714,79.329879 36.2116,79.457979 36.1427,79.518879 C 35.8203,79.800879 35.4102,79.942779 35,79.942779 C 34.5899,79.942779 34.1797,79.800879 33.8575,79.518879 C 33.7886,79.457979 33.6289,79.330079 33.3893,79.138079 C 29.5346,76.049279 5,56.389379 5,33.103579 Z M 35.0001,49.386379 C 43.1917,49.386379 49.8323,42.646079 49.8323,34.331379 C 49.8323,26.016779 43.1917,19.276479 35.0001,19.276479 C 26.8085,19.276479 20.1679,26.016779 20.1679,34.331379 C 20.1679,42.646079 26.8085,49.386379 35.0001,49.386379 Z"),q(e,"class","svelte-gzo3ar"),q(t,"width",n=i[0]==="list"?20:void 0),q(t,"viewBox","0 0 70 85"),q(t,"fill","none"),q(t,"class","svelte-gzo3ar"),rt(t,"in-map",i[0]!=="list"),rt(t,"list-icon",i[0]==="list")},m(r,o){Le(r,t,o),Me(t,e)},p(r,[o]){o&1&&n!==(n=r[0]==="list"?20:void 0)&&q(t,"width",n),o&1&&rt(t,"in-map",r[0]!=="list"),o&1&&rt(t,"list-icon",r[0]==="list")},i:J,o:J,d(r){r&&jt(t)}}}function qe(i,t,e){let{displayIn:n}=t;return i.$$set=r=>{"displayIn"in r&&e(0,n=r.displayIn)},[n]}class Ye extends Ge{constructor(t){super(),ze(this,t,qe,je,Se,{displayIn:0})}}function Fe(i,t={}){if(i.bbox!=null&&t.recompute!==!0)return i.bbox;const e=[1/0,1/0,-1/0,-1/0];return Bt(i,n=>{e[0]>n[0]&&(e[0]=n[0]),e[1]>n[1]&&(e[1]=n[1]),e[2]<n[0]&&(e[2]=n[0]),e[3]<n[1]&&(e[3]=n[1])}),e}var Dt=Fe;function Qe(i){const t=[];if(pt(i,r=>{t.push(r.coordinates)}),t.length<2)throw new Error("Must have at least two features");const e=i.features[0].properties||{},n=Nt.difference(t[0],...t.slice(1));return n.length===0?null:n.length===1?T(n[0],e):mt(n,e)}var De=Qe;function Xe(i){if(!i)throw new Error("geojson is required");var t=[];return be(i,function(e){t.push(e)}),X(t)}var Ve=Xe;function Xt(i){const t=[...i];return t[2]<t[0]&&(Math.abs((t[0]+t[2]+360)/2)>Math.abs((t[0]-360+t[2])/2)?t[0]-=360:t[2]+=360),t}function Vt(i,t){const e=De(X([T([[[180,90],[-180,90],[-180,-90],[180,-90],[180,90]]]),i]));if(!e)return;e.properties={isMask:!0};const n=Xt(Dt(i)),r=(n[2]-n[0])/360/1e3,o=n[0]<-180,f=n[2]>180,l=Ve(i);if(l.features.length>1&&(o||f))for(const c of l.features){const u=Xt(Dt(c));if(f&&u[0]<-180+r)for(const g of c.geometry.coordinates)for(const s of g)s[0]+=360-r;if(o&&u[2]>180-r)for(const g of c.geometry.coordinates)for(const s of g)s[0]-=360-r}t(X([l.features.length<2?i:Tt(l)??i,e]))}const Zt={fill:{paint:{"fill-color":"#000","fill-opacity":.1},filter:["all",["==",["geometry-type"],"Polygon"],["has","isMask"]]},line:{layout:{"line-cap":"square"},paint:{"line-width":["case",["==",["geometry-type"],"Polygon"],2,3],"line-dasharray":[1,1],"line-color":"#3170fe"},filter:["!",["has","isMask"]]}},ot="mtlr-gc-full-geom",Wt="mtlr-gc-full-geom-fill",Jt="mtlr-gc-full-geom-line";function Ze(i,t,e=!0,n=!0,r={},o={},f=Zt){let l;const c=[];let u,g,s;function h(){if(!i.loaded){i.once("load",h);return}const p=f?f===!0?Zt:f:void 0;if(!(p!=null&&p.fill)&&!(p!=null&&p.line))return;const y=i.getSource(ot);if(y)y.setData(s??X([]));else if(s)i.addSource(ot,{type:"geojson",data:s});else return;!i.getLayer(Wt)&&(p!=null&&p.fill)&&i.addLayer({...p==null?void 0:p.fill,id:Wt,type:"fill",source:ot}),!i.getLayer(Jt)&&(p!=null&&p.line)&&i.addLayer({...p==null?void 0:p.line,id:Jt,type:"line",source:ot})}function a(p){s=p,h()}i.on("styledata",()=>{setTimeout(()=>{s&&h()})});const d=p=>{l==null||l({type:"mapClick",coordinates:[p.lngLat.lng,p.lngLat.lat]})};function x(p=!1){if(!t)throw new Error;const y=document.createElement("div");return p&&y.classList.add("marker-interactive"),new Ye({props:{displayIn:"maplibre"},target:y}),new t.Marker({element:y,offset:[1,-13]})}return{setEventHandler(p){p?(l=p,i.on("click",d)):(l=void 0,i.off("click",d))},flyTo(p,y){i.flyTo({center:p,...y?{zoom:y}:{},...r})},fitBounds(p,y,w){i.fitBounds([[p[0],p[1]],[p[2],p[3]]],{padding:y,...w?{maxZoom:w}:{},...o})},indicateReverse(p){i.getCanvasContainer().style.cursor=p?"crosshair":""},setReverseMarker(p){!t||!e||(g?p?g.setLngLat(p):(g.remove(),g=void 0):p&&(e instanceof Function?g=e(i)??void 0:(g=(typeof e=="object"?new t.Marker(e):x()).setLngLat(p).addTo(i),g.getElement().classList.add("marker-reverse"))))},setFeatures(p,y,w){for(const v of c)v.remove();if(c.length=0,a(void 0),!!t){if(y){let v=!1;if(y.geometry.type==="GeometryCollection"){const E=y.geometry.geometries.filter(m=>m.type==="Polygon"||m.type==="MultiPolygon");t:if(E.length>0){const m=Tt(X(E.map(b=>_(b))));if(!m)break t;Vt({...y,geometry:m.geometry},a),v=!0}else{const m=y.geometry.geometries.filter(b=>b.type==="LineString"||b.type==="MultiLineString");m.length>0&&(a({...y,geometry:{type:"GeometryCollection",geometries:m}}),v=!0)}}if(!v){if(y.geometry.type==="Polygon"||y.geometry.type==="MultiPolygon")Vt(y,a);else if(y.geometry.type==="LineString"||y.geometry.type==="MultiLineString"){a(y);return}}if(!w&&y.geometry.type!=="Point")return;if(e instanceof Function){const E=e(i,y);E&&c.push(E)}else e&&c.push(typeof e=="object"?new t.Marker(e):x().setLngLat(y.center).addTo(i))}if(n)for(const v of p??[]){if(v===y)continue;let E;if(n instanceof Function){if(E=n(i,v),!E)continue}else E=(typeof n=="object"?new t.Marker(n):x(!0)).setLngLat(v.center).setPopup(new t.Popup({offset:[1,-27],closeButton:!1,closeOnMove:!0,className:"maptiler-gc-popup"}).setText(v.place_type[0]==="reverse"?v.place_name:v.place_name.replace(/,.*/,""))).addTo(i);const m=E.getElement();m.addEventListener("click",b=>{b.stopPropagation(),l==null||l({type:"markerClick",id:v.id})}),m.addEventListener("mouseenter",()=>{l==null||l({type:"markerMouseEnter",id:v.id}),E.togglePopup()}),m.addEventListener("mouseleave",()=>{l==null||l({type:"markerMouseLeave",id:v.id}),E.togglePopup()}),c.push(E)}}},setSelectedMarker(p){u&&u.getElement().classList.toggle("marker-selected",!1),u=p>-1?c[p]:void 0,u==null||u.getElement().classList.toggle("marker-selected",!0)},getCenterAndZoom(){const p=i.getCenter();return[i.getZoom(),p.lng,p.lat]}}}L.createMapLibreGlMapController=Ze,Object.defineProperty(L,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=maplibregl-controller.umd.js.map
