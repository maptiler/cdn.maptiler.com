{"version":3,"file":"openlayers-controller.js","sources":["../node_modules/@turf/helpers/dist/esm/index.js","../node_modules/@turf/meta/dist/esm/index.js","../node_modules/@turf/bbox/dist/esm/index.js","../node_modules/bignumber.js/bignumber.mjs","../node_modules/splaytree-ts/dist/esm/index.js","../node_modules/polyclip-ts/dist/esm/index.js","../node_modules/@turf/difference/dist/esm/index.js","../node_modules/@turf/flatten/dist/esm/index.js","../node_modules/@turf/union/dist/esm/index.js","../src/geoUtils.ts","../src/mask.ts","../src/openlayers-controller.ts"],"sourcesContent":["// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n  return angle;\n}\nfunction radiansToDegrees(radians) {\n  const normalisedRadians = radians % (2 * Math.PI);\n  return normalisedRadians * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const normalisedDegrees = degrees % 360;\n  return normalisedDegrees * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { coordEach } from \"@turf/meta\";\nfunction bbox(geojson, options = {}) {\n  if (geojson.bbox != null && true !== options.recompute) {\n    return geojson.bbox;\n  }\n  const result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, (coord) => {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\nvar turf_bbox_default = bbox;\nexport {\n  bbox,\n  turf_bbox_default as default\n};\n//# sourceMappingURL=index.js.map","/*\r\n *      bignumber.js v9.1.2\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\nvar\r\n  isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n  mathceil = Math.ceil,\r\n  mathfloor = Math.floor,\r\n\r\n  bignumberError = '[BigNumber Error] ',\r\n  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n  BASE = 1e14,\r\n  LOG_BASE = 14,\r\n  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n  SQRT_BASE = 1e7,\r\n\r\n  // EDITABLE\r\n  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n  // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n  MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n/*\r\n * Create and return a BigNumber constructor.\r\n */\r\nfunction clone(configObject) {\r\n  var div, convertBase, parseNumeric,\r\n    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n    ONE = new BigNumber(1),\r\n\r\n\r\n    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n    // The default values below must be integers within the inclusive ranges stated.\r\n    // The values can also be changed at run-time using BigNumber.set.\r\n\r\n    // The maximum number of decimal places for operations involving division.\r\n    DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n    // The rounding mode used when rounding to the above decimal places, and when using\r\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n    // UP         0 Away from zero.\r\n    // DOWN       1 Towards zero.\r\n    // CEIL       2 Towards +Infinity.\r\n    // FLOOR      3 Towards -Infinity.\r\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n    // The exponent value at and beneath which toString returns exponential notation.\r\n    // Number type: -7\r\n    TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n    // The exponent value at and above which toString returns exponential notation.\r\n    // Number type: 21\r\n    TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n    // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // Number type: -324  (5e-324)\r\n    MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // Number type:  308  (1.7976931348623157e+308)\r\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n    MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    CRYPTO = false,                          // true or false\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN      1 The remainder has the same sign as the dividend.\r\n    //             This modulo mode is commonly known as 'truncated division' and is\r\n    //             equivalent to (a % n) in JavaScript.\r\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n    //             The remainder is always positive.\r\n    //\r\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n    // modes are commonly used for the modulus operation.\r\n    // Although the other rounding modes can also be used, they may not give useful results.\r\n    MODULO_MODE = 1,                         // 0 to 9\r\n\r\n    // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n    POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n    // The format specification used by the BigNumber.prototype.toFormat method.\r\n    FORMAT = {\r\n      prefix: '',\r\n      groupSize: 3,\r\n      secondaryGroupSize: 0,\r\n      groupSeparator: ',',\r\n      decimalSeparator: '.',\r\n      fractionGroupSize: 0,\r\n      fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n      suffix: ''\r\n    },\r\n\r\n    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n    // '-', '.', whitespace, or repeated character.\r\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n    alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n  //------------------------------------------------------------------------------------------\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n\r\n  /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */\r\n  function BigNumber(v, b) {\r\n    var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n      x = this;\r\n\r\n    // Enable constructor call without `new`.\r\n    if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n    if (b == null) {\r\n\r\n      if (v && v._isBigNumber === true) {\r\n        x.s = v.s;\r\n\r\n        if (!v.c || v.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n        } else if (v.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.c = v.c.slice();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n        // Use `1 / n` to handle minus zero also.\r\n        x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n        // Fast path for integers, where n < 2147483648 (2**31).\r\n        if (v === ~~v) {\r\n          for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n          if (e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else {\r\n            x.e = e;\r\n            x.c = [v];\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        str = String(v);\r\n      } else {\r\n\r\n        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n      // Exponential form?\r\n      if ((i = str.search(/e/i)) > 0) {\r\n\r\n        // Determine exponent.\r\n        if (e < 0) e = i;\r\n        e += +str.slice(i + 1);\r\n        str = str.substring(0, i);\r\n      } else if (e < 0) {\r\n\r\n        // Integer.\r\n        e = str.length;\r\n      }\r\n\r\n    } else {\r\n\r\n      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n      intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n      // Allow exponential notation to be used with base 10 argument, while\r\n      // also rounding to DECIMAL_PLACES as with other bases.\r\n      if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n        x = new BigNumber(v);\r\n        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n      }\r\n\r\n      str = String(v);\r\n\r\n      if (isNum = typeof v == 'number') {\r\n\r\n        // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n          throw Error\r\n           (tooManyDigits + v);\r\n        }\r\n      } else {\r\n        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      alphabet = ALPHABET.slice(0, b);\r\n      e = i = 0;\r\n\r\n      // Check that str is a valid base b number.\r\n      // Don't use RegExp, so alphabet can contain special characters.\r\n      for (len = str.length; i < len; i++) {\r\n        if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n          if (c == '.') {\r\n\r\n            // If '.' is not the first character and it has not be found before.\r\n            if (i > e) {\r\n              e = len;\r\n              continue;\r\n            }\r\n          } else if (!caseChanged) {\r\n\r\n            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n              caseChanged = true;\r\n              i = -1;\r\n              e = 0;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          return parseNumeric(x, String(v), isNum, b);\r\n        }\r\n      }\r\n\r\n      // Prevent later check for length on converted number.\r\n      isNum = false;\r\n      str = convertBase(str, b, 10, x.s);\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n      else e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n    if (str = str.slice(i, ++len)) {\r\n      len -= i;\r\n\r\n      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n      if (isNum && BigNumber.DEBUG &&\r\n        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n          throw Error\r\n           (tooManyDigits + (x.s * v));\r\n      }\r\n\r\n       // Overflow?\r\n      if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        x.c = x.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      } else {\r\n        x.e = e;\r\n        x.c = [];\r\n\r\n        // Transform base\r\n\r\n        // e is the base 10 exponent.\r\n        // i is where to slice str to get the first element of the coefficient array.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n        if (i < len) {\r\n          if (i) x.c.push(+str.slice(0, i));\r\n\r\n          for (len -= LOG_BASE; i < len;) {\r\n            x.c.push(+str.slice(i, i += LOG_BASE));\r\n          }\r\n\r\n          i = LOG_BASE - (str = str.slice(i)).length;\r\n        } else {\r\n          i -= len;\r\n        }\r\n\r\n        for (; i--; str += '0');\r\n        x.c.push(+str);\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    }\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n  BigNumber.clone = clone;\r\n\r\n  BigNumber.ROUND_UP = 0;\r\n  BigNumber.ROUND_DOWN = 1;\r\n  BigNumber.ROUND_CEIL = 2;\r\n  BigNumber.ROUND_FLOOR = 3;\r\n  BigNumber.ROUND_HALF_UP = 4;\r\n  BigNumber.ROUND_HALF_DOWN = 5;\r\n  BigNumber.ROUND_HALF_EVEN = 6;\r\n  BigNumber.ROUND_HALF_CEIL = 7;\r\n  BigNumber.ROUND_HALF_FLOOR = 8;\r\n  BigNumber.EUCLID = 9;\r\n\r\n\r\n  /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */\r\n  BigNumber.config = BigNumber.set = function (obj) {\r\n    var p, v;\r\n\r\n    if (obj != null) {\r\n\r\n      if (typeof obj == 'object') {\r\n\r\n        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          DECIMAL_PLACES = v;\r\n        }\r\n\r\n        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 8, p);\r\n          ROUNDING_MODE = v;\r\n        }\r\n\r\n        // EXPONENTIAL_AT {number|number[]}\r\n        // Integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, 0, p);\r\n            intCheck(v[1], 0, MAX, p);\r\n            TO_EXP_NEG = v[0];\r\n            TO_EXP_POS = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n          }\r\n        }\r\n\r\n        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n        if (obj.hasOwnProperty(p = 'RANGE')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, -1, p);\r\n            intCheck(v[1], 1, MAX, p);\r\n            MIN_EXP = v[0];\r\n            MAX_EXP = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            if (v) {\r\n              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' cannot be zero: ' + v);\r\n            }\r\n          }\r\n        }\r\n\r\n        // CRYPTO {boolean} true or false.\r\n        // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n        // '[BigNumber Error] crypto unavailable'\r\n        if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n          v = obj[p];\r\n          if (v === !!v) {\r\n            if (v) {\r\n              if (typeof crypto != 'undefined' && crypto &&\r\n               (crypto.getRandomValues || crypto.randomBytes)) {\r\n                CRYPTO = v;\r\n              } else {\r\n                CRYPTO = !v;\r\n                throw Error\r\n                 (bignumberError + 'crypto unavailable');\r\n              }\r\n            } else {\r\n              CRYPTO = v;\r\n            }\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' not true or false: ' + v);\r\n          }\r\n        }\r\n\r\n        // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 9, p);\r\n          MODULO_MODE = v;\r\n        }\r\n\r\n        // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          POW_PRECISION = v;\r\n        }\r\n\r\n        // FORMAT {object}\r\n        // '[BigNumber Error] FORMAT not an object: {v}'\r\n        if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n          v = obj[p];\r\n          if (typeof v == 'object') FORMAT = v;\r\n          else throw Error\r\n           (bignumberError + p + ' not an object: ' + v);\r\n        }\r\n\r\n        // ALPHABET {string}\r\n        // '[BigNumber Error] ALPHABET invalid: {v}'\r\n        if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n          v = obj[p];\r\n\r\n          // Disallow if less than two characters,\r\n          // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n          if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n            ALPHABET = v;\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' invalid: ' + v);\r\n          }\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Object expected: {v}'\r\n        throw Error\r\n         (bignumberError + 'Object expected: ' + obj);\r\n      }\r\n    }\r\n\r\n    return {\r\n      DECIMAL_PLACES: DECIMAL_PLACES,\r\n      ROUNDING_MODE: ROUNDING_MODE,\r\n      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n      RANGE: [MIN_EXP, MAX_EXP],\r\n      CRYPTO: CRYPTO,\r\n      MODULO_MODE: MODULO_MODE,\r\n      POW_PRECISION: POW_PRECISION,\r\n      FORMAT: FORMAT,\r\n      ALPHABET: ALPHABET\r\n    };\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */\r\n  BigNumber.isBigNumber = function (v) {\r\n    if (!v || v._isBigNumber !== true) return false;\r\n    if (!BigNumber.DEBUG) return true;\r\n\r\n    var i, n,\r\n      c = v.c,\r\n      e = v.e,\r\n      s = v.s;\r\n\r\n    out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n        // If the first element is zero, the BigNumber value must be zero.\r\n        if (c[0] === 0) {\r\n          if (e === 0 && c.length === 1) return true;\r\n          break out;\r\n        }\r\n\r\n        // Calculate number of digits that c[0] should have, based on the exponent.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (i < 1) i += LOG_BASE;\r\n\r\n        // Calculate number of digits of c[0].\r\n        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n        if (String(c[0]).length == i) {\r\n\r\n          for (i = 0; i < c.length; i++) {\r\n            n = c[i];\r\n            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n          }\r\n\r\n          // Last element cannot be zero, unless it is the only element.\r\n          if (n !== 0) return true;\r\n        }\r\n      }\r\n\r\n    // Infinity/NaN\r\n    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n      return true;\r\n    }\r\n\r\n    throw Error\r\n      (bignumberError + 'Invalid BigNumber: ' + v);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.maximum = BigNumber.max = function () {\r\n    return maxOrMin(arguments, -1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.minimum = BigNumber.min = function () {\r\n    return maxOrMin(arguments, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */\r\n  BigNumber.random = (function () {\r\n    var pow2_53 = 0x20000000000000;\r\n\r\n    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n    // Check if Math.random() produces more than 32 bits of randomness.\r\n    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n     ? function () { return mathfloor(Math.random() * pow2_53); }\r\n     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n       (Math.random() * 0x800000 | 0); };\r\n\r\n    return function (dp) {\r\n      var a, b, e, k, v,\r\n        i = 0,\r\n        c = [],\r\n        rand = new BigNumber(ONE);\r\n\r\n      if (dp == null) dp = DECIMAL_PLACES;\r\n      else intCheck(dp, 0, MAX);\r\n\r\n      k = mathceil(dp / LOG_BASE);\r\n\r\n      if (CRYPTO) {\r\n\r\n        // Browsers supporting crypto.getRandomValues.\r\n        if (crypto.getRandomValues) {\r\n\r\n          a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n          for (; i < k;) {\r\n\r\n            // 53 bits:\r\n            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n            //                                     11111 11111111 11111111\r\n            // 0x20000 is 2^21.\r\n            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n            // Rejection sampling:\r\n            // 0 <= v < 9007199254740992\r\n            // Probability that v >= 9e15, is\r\n            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n            if (v >= 9e15) {\r\n              b = crypto.getRandomValues(new Uint32Array(2));\r\n              a[i] = b[0];\r\n              a[i + 1] = b[1];\r\n            } else {\r\n\r\n              // 0 <= v <= 8999999999999999\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 2;\r\n            }\r\n          }\r\n          i = k / 2;\r\n\r\n        // Node.js supporting crypto.randomBytes.\r\n        } else if (crypto.randomBytes) {\r\n\r\n          // buffer\r\n          a = crypto.randomBytes(k *= 7);\r\n\r\n          for (; i < k;) {\r\n\r\n            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n            // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n            // 0 <= v < 9007199254740992\r\n            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n            if (v >= 9e15) {\r\n              crypto.randomBytes(7).copy(a, i);\r\n            } else {\r\n\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 7;\r\n            }\r\n          }\r\n          i = k / 7;\r\n        } else {\r\n          CRYPTO = false;\r\n          throw Error\r\n           (bignumberError + 'crypto unavailable');\r\n        }\r\n      }\r\n\r\n      // Use Math.random.\r\n      if (!CRYPTO) {\r\n\r\n        for (; i < k;) {\r\n          v = random53bitInt();\r\n          if (v < 9e15) c[i++] = v % 1e14;\r\n        }\r\n      }\r\n\r\n      k = c[--i];\r\n      dp %= LOG_BASE;\r\n\r\n      // Convert trailing digits to zeros according to dp.\r\n      if (k && dp) {\r\n        v = POWS_TEN[LOG_BASE - dp];\r\n        c[i] = mathfloor(k / v) * v;\r\n      }\r\n\r\n      // Remove trailing elements which are zero.\r\n      for (; c[i] === 0; c.pop(), i--);\r\n\r\n      // Zero?\r\n      if (i < 0) {\r\n        c = [e = 0];\r\n      } else {\r\n\r\n        // Remove leading elements which are zero and adjust exponent accordingly.\r\n        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n        // Count the digits of the first element of c to determine leading zeros, and...\r\n        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n        // adjust the exponent accordingly.\r\n        if (i < LOG_BASE) e -= LOG_BASE - i;\r\n      }\r\n\r\n      rand.e = e;\r\n      rand.c = c;\r\n      return rand;\r\n    };\r\n  })();\r\n\r\n\r\n   /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.sum = function () {\r\n    var i = 1,\r\n      args = arguments,\r\n      sum = new BigNumber(args[0]);\r\n    for (; i < args.length;) sum = sum.plus(args[i++]);\r\n    return sum;\r\n  };\r\n\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n\r\n  // Called by BigNumber and BigNumber.prototype.toString.\r\n  convertBase = (function () {\r\n    var decimal = '0123456789';\r\n\r\n    /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */\r\n    function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n      var j,\r\n        arr = [0],\r\n        arrL,\r\n        i = 0,\r\n        len = str.length;\r\n\r\n      for (; i < len;) {\r\n        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n        arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n        for (j = 0; j < arr.length; j++) {\r\n\r\n          if (arr[j] > baseOut - 1) {\r\n            if (arr[j + 1] == null) arr[j + 1] = 0;\r\n            arr[j + 1] += arr[j] / baseOut | 0;\r\n            arr[j] %= baseOut;\r\n          }\r\n        }\r\n      }\r\n\r\n      return arr.reverse();\r\n    }\r\n\r\n    // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n    // If the caller is toString, we are converting from base 10 to baseOut.\r\n    // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n    return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n      var alphabet, d, e, k, r, x, xc, y,\r\n        i = str.indexOf('.'),\r\n        dp = DECIMAL_PLACES,\r\n        rm = ROUNDING_MODE;\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        k = POW_PRECISION;\r\n\r\n        // Unlimited precision.\r\n        POW_PRECISION = 0;\r\n        str = str.replace('.', '');\r\n        y = new BigNumber(baseIn);\r\n        x = y.pow(str.length - i);\r\n        POW_PRECISION = k;\r\n\r\n        // Convert str as if an integer, then restore the fraction part by dividing the\r\n        // result by its base raised to a power.\r\n\r\n        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n         10, baseOut, decimal);\r\n        y.e = y.c.length;\r\n      }\r\n\r\n      // Convert the number as integer.\r\n\r\n      xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n       ? (alphabet = ALPHABET, decimal)\r\n       : (alphabet = decimal, ALPHABET));\r\n\r\n      // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n      e = k = xc.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xc[--k] == 0; xc.pop());\r\n\r\n      // Zero?\r\n      if (!xc[0]) return alphabet.charAt(0);\r\n\r\n      // Does str represent an integer? If so, no need for the division.\r\n      if (i < 0) {\r\n        --e;\r\n      } else {\r\n        x.c = xc;\r\n        x.e = e;\r\n\r\n        // The sign is needed for correct rounding.\r\n        x.s = sign;\r\n        x = div(x, y, dp, rm, baseOut);\r\n        xc = x.c;\r\n        r = x.r;\r\n        e = x.e;\r\n      }\r\n\r\n      // xc now represents str converted to baseOut.\r\n\r\n      // THe index of the rounding digit.\r\n      d = e + dp + 1;\r\n\r\n      // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n      i = xc[d];\r\n\r\n      // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n      k = baseOut / 2;\r\n      r = r || d < 0 || xc[d + 1] != null;\r\n\r\n      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n      // If the index of the rounding digit is not greater than zero, or xc represents\r\n      // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n      // such as 0.00001.\r\n      if (d < 1 || !xc[0]) {\r\n\r\n        // 1^-dp or 0\r\n        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n      } else {\r\n\r\n        // Truncate xc to the required number of decimal places.\r\n        xc.length = d;\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (--baseOut; ++xc[--d] > baseOut;) {\r\n            xc[d] = 0;\r\n\r\n            if (!d) {\r\n              ++e;\r\n              xc = [1].concat(xc);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (k = xc.length; !xc[--k];);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n        // Add leading zeros, decimal point and trailing zeros as required.\r\n        str = toFixedPoint(str, e, alphabet.charAt(0));\r\n      }\r\n\r\n      // The caller will add the sign.\r\n      return str;\r\n    };\r\n  })();\r\n\r\n\r\n  // Perform division in the specified base. Called by div and convertBase.\r\n  div = (function () {\r\n\r\n    // Assume non-zero x and k.\r\n    function multiply(x, k, base) {\r\n      var m, temp, xlo, xhi,\r\n        carry = 0,\r\n        i = x.length,\r\n        klo = k % SQRT_BASE,\r\n        khi = k / SQRT_BASE | 0;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        xlo = x[i] % SQRT_BASE;\r\n        xhi = x[i] / SQRT_BASE | 0;\r\n        m = khi * xlo + xhi * klo;\r\n        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n        x[i] = temp % base;\r\n      }\r\n\r\n      if (carry) x = [carry].concat(x);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, cmp;\r\n\r\n      if (aL != bL) {\r\n        cmp = aL > bL ? 1 : -1;\r\n      } else {\r\n\r\n        for (i = cmp = 0; i < aL; i++) {\r\n\r\n          if (a[i] != b[i]) {\r\n            cmp = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return cmp;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n    }\r\n\r\n    // x: dividend, y: divisor.\r\n    return function (x, y, dp, rm, base) {\r\n      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n        yL, yz,\r\n        s = x.s == y.s ? 1 : -1,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n        return new BigNumber(\r\n\r\n         // Return NaN if either NaN, or both Infinity or 0.\r\n         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n          xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n       );\r\n      }\r\n\r\n      q = new BigNumber(s);\r\n      qc = q.c = [];\r\n      e = x.e - y.e;\r\n      s = dp + e + 1;\r\n\r\n      if (!base) {\r\n        base = BASE;\r\n        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n        s = s / LOG_BASE | 0;\r\n      }\r\n\r\n      // Result exponent may be one less then the current value of e.\r\n      // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n      for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n      if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n      if (s < 0) {\r\n        qc.push(1);\r\n        more = true;\r\n      } else {\r\n        xL = xc.length;\r\n        yL = yc.length;\r\n        i = 0;\r\n        s += 2;\r\n\r\n        // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n        n = mathfloor(base / (yc[0] + 1));\r\n\r\n        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n        if (n > 1) {\r\n          yc = multiply(yc, n, base);\r\n          xc = multiply(xc, n, base);\r\n          yL = yc.length;\r\n          xL = xc.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xc.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL; rem[remL++] = 0);\r\n        yz = yc.slice();\r\n        yz = [0].concat(yz);\r\n        yc0 = yc[0];\r\n        if (yc[1] >= base / 2) yc0++;\r\n        // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n        do {\r\n          n = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yc, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, n.\r\n\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // n is how many times the divisor goes into the current remainder.\r\n            n = mathfloor(rem0 / yc0);\r\n\r\n            //  Algorithm:\r\n            //  product = divisor multiplied by trial digit (n).\r\n            //  Compare product and remainder.\r\n            //  If product is greater than remainder:\r\n            //    Subtract divisor from product, decrement trial digit.\r\n            //  Subtract product from remainder.\r\n            //  If product was less than remainder at the last compare:\r\n            //    Compare new remainder and divisor.\r\n            //    If remainder is greater than divisor:\r\n            //      Subtract divisor from remainder, increment trial digit.\r\n\r\n            if (n > 1) {\r\n\r\n              // n may be > base only when base is 3.\r\n              if (n >= base) n = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiply(yc, n, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              // If product > remainder then trial digit n too high.\r\n              // n is 1 too high about 5% of the time, and is not known to have\r\n              // ever been more than 1 too high.\r\n              while (compare(prod, rem, prodL, remL) == 1) {\r\n                n--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                prodL = prod.length;\r\n                cmp = 1;\r\n              }\r\n            } else {\r\n\r\n              // n is 0 or 1, cmp is -1.\r\n              // If n is 0, there is no need to compare yc and rem again below,\r\n              // so change cmp to 1 to avoid it.\r\n              // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n              if (n == 0) {\r\n\r\n                // divisor < remainder, so n must be at least 1.\r\n                cmp = n = 1;\r\n              }\r\n\r\n              // product = divisor\r\n              prod = yc.slice();\r\n              prodL = prod.length;\r\n            }\r\n\r\n            if (prodL < remL) prod = [0].concat(prod);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n            remL = rem.length;\r\n\r\n             // If product was < remainder.\r\n            if (cmp == -1) {\r\n\r\n              // Compare divisor and new remainder.\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              // Trial digit n too low.\r\n              // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n              while (compare(yc, rem, yL, remL) < 1) {\r\n                n++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                remL = rem.length;\r\n              }\r\n            }\r\n          } else if (cmp === 0) {\r\n            n++;\r\n            rem = [0];\r\n          } // else cmp === 1 and n will be 0\r\n\r\n          // Add the next digit, n, to the result array.\r\n          qc[i++] = n;\r\n\r\n          // Update the remainder.\r\n          if (rem[0]) {\r\n            rem[remL++] = xc[xi] || 0;\r\n          } else {\r\n            rem = [xc[xi]];\r\n            remL = 1;\r\n          }\r\n        } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n        more = rem[0] != null;\r\n\r\n        // Leading zero?\r\n        if (!qc[0]) qc.splice(0, 1);\r\n      }\r\n\r\n      if (base == BASE) {\r\n\r\n        // To calculate q.e, first get the number of digits of qc[0].\r\n        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n      // Caller is convertBase.\r\n      } else {\r\n        q.e = e;\r\n        q.r = +more;\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */\r\n  function format(n, i, rm, id) {\r\n    var c0, e, ne, len, str;\r\n\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n\r\n    if (!n.c) return n.toString();\r\n\r\n    c0 = n.c[0];\r\n    ne = n.e;\r\n\r\n    if (i == null) {\r\n      str = coeffToString(n.c);\r\n      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n       ? toExponential(str, ne)\r\n       : toFixedPoint(str, ne, '0');\r\n    } else {\r\n      n = round(new BigNumber(n), i, rm);\r\n\r\n      // n.e may have changed if the value was rounded up.\r\n      e = n.e;\r\n\r\n      str = coeffToString(n.c);\r\n      len = str.length;\r\n\r\n      // toPrecision returns exponential notation if the number of significant digits\r\n      // specified is less than the number of digits necessary to represent the integer\r\n      // part of the value in fixed-point notation.\r\n\r\n      // Exponential notation.\r\n      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n        // Append zeros?\r\n        for (; len < i; str += '0', len++);\r\n        str = toExponential(str, e);\r\n\r\n      // Fixed-point notation.\r\n      } else {\r\n        i -= ne;\r\n        str = toFixedPoint(str, e, '0');\r\n\r\n        // Append zeros?\r\n        if (e + 1 > len) {\r\n          if (--i > 0) for (str += '.'; i--; str += '0');\r\n        } else {\r\n          i += e - len;\r\n          if (i > 0) {\r\n            if (e + 1 == len) str += '.';\r\n            for (; i--; str += '0');\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n.s < 0 && c0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Handle BigNumber.max and BigNumber.min.\r\n  // If any number is NaN, return NaN.\r\n  function maxOrMin(args, n) {\r\n    var k, y,\r\n      i = 1,\r\n      x = new BigNumber(args[0]);\r\n\r\n    for (; i < args.length; i++) {\r\n      y = new BigNumber(args[i]);\r\n      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */\r\n  function normalise(n, c, e) {\r\n    var i = 1,\r\n      j = c.length;\r\n\r\n     // Remove trailing zeros.\r\n    for (; !c[--j]; c.pop());\r\n\r\n    // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n    for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n    // Overflow?\r\n    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n      // Infinity.\r\n      n.c = n.e = null;\r\n\r\n    // Underflow?\r\n    } else if (e < MIN_EXP) {\r\n\r\n      // Zero.\r\n      n.c = [n.e = 0];\r\n    } else {\r\n      n.e = e;\r\n      n.c = c;\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  // Handle values that fail the validity test in BigNumber.\r\n  parseNumeric = (function () {\r\n    var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n      dotAfter = /^([^.]+)\\.$/,\r\n      dotBefore = /^\\.([^.]+)$/,\r\n      isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n      whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n    return function (x, str, isNum, b) {\r\n      var base,\r\n        s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n      // No exception on Infinity or NaN.\r\n      if (isInfinityOrNaN.test(s)) {\r\n        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n      } else {\r\n        if (!isNum) {\r\n\r\n          // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n          s = s.replace(basePrefix, function (m, p1, p2) {\r\n            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n            return !b || b == base ? p1 : m;\r\n          });\r\n\r\n          if (b) {\r\n            base = b;\r\n\r\n            // E.g. '1.' to '1', '.1' to '0.1'\r\n            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n          }\r\n\r\n          if (str != s) return new BigNumber(s, base);\r\n        }\r\n\r\n        // '[BigNumber Error] Not a number: {n}'\r\n        // '[BigNumber Error] Not a base {b} number: {n}'\r\n        if (BigNumber.DEBUG) {\r\n          throw Error\r\n            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n        }\r\n\r\n        // NaN\r\n        x.s = null;\r\n      }\r\n\r\n      x.c = x.e = null;\r\n    }\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */\r\n  function round(x, sd, rm, r) {\r\n    var d, i, j, k, n, ni, rd,\r\n      xc = x.c,\r\n      pows10 = POWS_TEN;\r\n\r\n    // if x is not Infinity or NaN...\r\n    if (xc) {\r\n\r\n      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n      // ni is the index of n within x.c.\r\n      // d is the number of digits of n.\r\n      // i is the index of rd within n including leading zeros.\r\n      // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n      out: {\r\n\r\n        // Get the number of digits of the first element of xc.\r\n        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n        i = sd - d;\r\n\r\n        // If the rounding digit is in the first element of xc...\r\n        if (i < 0) {\r\n          i += LOG_BASE;\r\n          j = sd;\r\n          n = xc[ni = 0];\r\n\r\n          // Get the rounding digit at index j of n.\r\n          rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n        } else {\r\n          ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n          if (ni >= xc.length) {\r\n\r\n            if (r) {\r\n\r\n              // Needed by sqrt.\r\n              for (; xc.length <= ni; xc.push(0));\r\n              n = rd = 0;\r\n              d = 1;\r\n              i %= LOG_BASE;\r\n              j = i - LOG_BASE + 1;\r\n            } else {\r\n              break out;\r\n            }\r\n          } else {\r\n            n = k = xc[ni];\r\n\r\n            // Get the number of digits of n.\r\n            for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n            // Get the index of rd within n.\r\n            i %= LOG_BASE;\r\n\r\n            // Get the index of rd within n, adjusted for leading zeros.\r\n            // The number of leading zeros of n is given by LOG_BASE - d.\r\n            j = i - LOG_BASE + d;\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n          }\r\n        }\r\n\r\n        r = r || sd < 0 ||\r\n\r\n        // Are there any non-zero digits after the rounding digit?\r\n        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n        r = rm < 4\r\n         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n           rm == (x.s < 0 ? 8 : 7));\r\n\r\n        if (sd < 1 || !xc[0]) {\r\n          xc.length = 0;\r\n\r\n          if (r) {\r\n\r\n            // Convert sd to decimal places.\r\n            sd -= x.e + 1;\r\n\r\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n            x.e = -sd || 0;\r\n          } else {\r\n\r\n            // Zero.\r\n            xc[0] = x.e = 0;\r\n          }\r\n\r\n          return x;\r\n        }\r\n\r\n        // Remove excess digits.\r\n        if (i == 0) {\r\n          xc.length = ni;\r\n          k = 1;\r\n          ni--;\r\n        } else {\r\n          xc.length = ni + 1;\r\n          k = pows10[LOG_BASE - i];\r\n\r\n          // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n          // j > 0 means i > number of leading zeros of n.\r\n          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n        }\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          for (; ;) {\r\n\r\n            // If the digit to be rounded up is in the first element of xc...\r\n            if (ni == 0) {\r\n\r\n              // i will be the length of xc[0] before k is added.\r\n              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n              j = xc[0] += k;\r\n              for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n              // if i != k the length has increased.\r\n              if (i != k) {\r\n                x.e++;\r\n                if (xc[0] == BASE) xc[0] = 1;\r\n              }\r\n\r\n              break;\r\n            } else {\r\n              xc[ni] += k;\r\n              if (xc[ni] != BASE) break;\r\n              xc[ni--] = 0;\r\n              k = 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = xc.length; xc[--i] === 0; xc.pop());\r\n      }\r\n\r\n      // Overflow? Infinity.\r\n      if (x.e > MAX_EXP) {\r\n        x.c = x.e = null;\r\n\r\n      // Underflow? Zero.\r\n      } else if (x.e < MIN_EXP) {\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function valueOf(n) {\r\n    var str,\r\n      e = n.e;\r\n\r\n    if (e === null) return n.toString();\r\n\r\n    str = coeffToString(n.c);\r\n\r\n    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n      ? toExponential(str, e)\r\n      : toFixedPoint(str, e, '0');\r\n\r\n    return n.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new BigNumber(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */\r\n  P.comparedTo = function (y, b) {\r\n    return compare(this, new BigNumber(y, b));\r\n  };\r\n\r\n\r\n  /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.decimalPlaces = P.dp = function (dp, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), dp + x.e + 1, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last number.\r\n    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n    if (n < 0) n = 0;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.dividedBy = P.div = function (y, b) {\r\n    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n    return div(this, new BigNumber(y, b), 0, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */\r\n  P.exponentiatedBy = P.pow = function (n, m) {\r\n    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n      x = this;\r\n\r\n    n = new BigNumber(n);\r\n\r\n    // Allow NaN and Infinity, but not other non-integers.\r\n    if (n.c && !n.isInteger()) {\r\n      throw Error\r\n        (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n    }\r\n\r\n    if (m != null) m = new BigNumber(m);\r\n\r\n    // Exponent of MAX_SAFE_INTEGER is 15.\r\n    nIsBig = n.e > 14;\r\n\r\n    // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n      // The sign of the result of pow when x is negative depends on the evenness of n.\r\n      // If +n overflows to Infinity, the evenness of n would be not be known.\r\n      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n      return m ? y.mod(m) : y;\r\n    }\r\n\r\n    nIsNeg = n.s < 0;\r\n\r\n    if (m) {\r\n\r\n      // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n      isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n      if (isModExp) x = x.mod(m);\r\n\r\n    // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n    // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n      // [1, 240000000]\r\n      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n      // [80000000000000]  [99999750000000]\r\n      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n      // If x is negative and n is odd, k = -0, else k = 0.\r\n      k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n      // If x >= 1, k = Infinity.\r\n      if (x.e > -1) k = 1 / k;\r\n\r\n      // If n is negative return 0, else return Infinity.\r\n      return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n    } else if (POW_PRECISION) {\r\n\r\n      // Truncating each coefficient array to a length of k after each multiplication\r\n      // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n      // i.e. there will be a minimum of 28 guard digits retained.\r\n      k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n    }\r\n\r\n    if (nIsBig) {\r\n      half = new BigNumber(0.5);\r\n      if (nIsNeg) n.s = 1;\r\n      nIsOdd = isOdd(n);\r\n    } else {\r\n      i = Math.abs(+valueOf(n));\r\n      nIsOdd = i % 2;\r\n    }\r\n\r\n    y = new BigNumber(ONE);\r\n\r\n    // Performs 54 loop iterations for n of 9007199254740991.\r\n    for (; ;) {\r\n\r\n      if (nIsOdd) {\r\n        y = y.times(x);\r\n        if (!y.c) break;\r\n\r\n        if (k) {\r\n          if (y.c.length > k) y.c.length = k;\r\n        } else if (isModExp) {\r\n          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (i) {\r\n        i = mathfloor(i / 2);\r\n        if (i === 0) break;\r\n        nIsOdd = i % 2;\r\n      } else {\r\n        n = n.times(half);\r\n        round(n, n.e + 1, 1);\r\n\r\n        if (n.e > 14) {\r\n          nIsOdd = isOdd(n);\r\n        } else {\r\n          i = +valueOf(n);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        }\r\n      }\r\n\r\n      x = x.times(x);\r\n\r\n      if (k) {\r\n        if (x.c && x.c.length > k) x.c.length = k;\r\n      } else if (isModExp) {\r\n        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n      }\r\n    }\r\n\r\n    if (isModExp) return y;\r\n    if (nIsNeg) y = ONE.div(y);\r\n\r\n    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */\r\n  P.integerValue = function (rm) {\r\n    var n = new BigNumber(this);\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n    return round(n, n.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isEqualTo = P.eq = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.c;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isGreaterThan = P.gt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */\r\n  P.isInteger = function () {\r\n    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isLessThan = P.lt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */\r\n  P.isNegative = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */\r\n  P.isPositive = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.c && this.c[0] == 0;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.minus = function (y, b) {\r\n    var i, j, t, xLTy,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Either Infinity?\r\n      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n      // Either zero?\r\n      if (!xc[0] || !yc[0]) {\r\n\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n         ROUNDING_MODE == 3 ? -0 : 0);\r\n      }\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Determine which is the bigger number.\r\n    if (a = xe - ye) {\r\n\r\n      if (xLTy = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      for (b = a; b--; t.push(0));\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n\r\n        if (xc[b] != yc[b]) {\r\n          xLTy = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xLTy) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    b = (j = yc.length) - (i = xc.length);\r\n\r\n    // Append zeros to xc if shorter.\r\n    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n    if (b > 0) for (; b--; xc[i++] = 0);\r\n    b = BASE - 1;\r\n\r\n    // Subtract yc from xc.\r\n    for (; j > a;) {\r\n\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i]; xc[i] = b);\r\n        --xc[i];\r\n        xc[j] += BASE;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n    // Zero?\r\n    if (!xc[0]) {\r\n\r\n      // Following IEEE 754 (2008) 6.3,\r\n      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n      y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n    // for finite x and y.\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */\r\n  P.modulo = P.mod = function (y, b) {\r\n    var q, s,\r\n      x = this;\r\n\r\n    y = new BigNumber(y, b);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n    if (!x.c || !y.s || y.c && !y.c[0]) {\r\n      return new BigNumber(NaN);\r\n\r\n    // Return x if y is Infinity or x is zero.\r\n    } else if (!y.c || x.c && !x.c[0]) {\r\n      return new BigNumber(x);\r\n    }\r\n\r\n    if (MODULO_MODE == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // r = x - qy    where  0 <= r < abs(y)\r\n      s = y.s;\r\n      y.s = 1;\r\n      q = div(x, y, 0, 3);\r\n      y.s = s;\r\n      q.s *= s;\r\n    } else {\r\n      q = div(x, y, 0, MODULO_MODE);\r\n    }\r\n\r\n    y = x.minus(q.times(y));\r\n\r\n    // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */\r\n  P.multipliedBy = P.times = function (y, b) {\r\n    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n      base, sqrtBase,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new BigNumber(y, b)).c;\r\n\r\n    // Either NaN, Infinity or 0?\r\n    if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n      // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n        y.c = y.e = y.s = null;\r\n      } else {\r\n        y.s *= x.s;\r\n\r\n        // Return Infinity if either is Infinity.\r\n        if (!xc || !yc) {\r\n          y.c = y.e = null;\r\n\r\n        // Return 0 if either is 0.\r\n        } else {\r\n          y.c = [0];\r\n          y.e = 0;\r\n        }\r\n      }\r\n\r\n      return y;\r\n    }\r\n\r\n    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n    y.s *= x.s;\r\n    xcL = xc.length;\r\n    ycL = yc.length;\r\n\r\n    // Ensure xc points to longer array and xcL to its length.\r\n    if (xcL < ycL) {\r\n      zc = xc;\r\n      xc = yc;\r\n      yc = zc;\r\n      i = xcL;\r\n      xcL = ycL;\r\n      ycL = i;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n    base = BASE;\r\n    sqrtBase = SQRT_BASE;\r\n\r\n    for (i = ycL; --i >= 0;) {\r\n      c = 0;\r\n      ylo = yc[i] % sqrtBase;\r\n      yhi = yc[i] / sqrtBase | 0;\r\n\r\n      for (k = xcL, j = i + k; j > i;) {\r\n        xlo = xc[--k] % sqrtBase;\r\n        xhi = xc[k] / sqrtBase | 0;\r\n        m = yhi * xlo + xhi * ylo;\r\n        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n        zc[j--] = xlo % base;\r\n      }\r\n\r\n      zc[j] = c;\r\n    }\r\n\r\n    if (c) {\r\n      ++e;\r\n    } else {\r\n      zc.splice(0, 1);\r\n    }\r\n\r\n    return normalise(y, zc, e);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */\r\n  P.negated = function () {\r\n    var x = new BigNumber(this);\r\n    x.s = -x.s || null;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.plus = function (y, b) {\r\n    var t,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n     if (a != b) {\r\n      y.s = -b;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Return Infinity if either Infinity.\r\n      if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n      // Either zero?\r\n      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n    if (a = xe - ye) {\r\n      if (a > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        a = -a;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; a--; t.push(0));\r\n      t.reverse();\r\n    }\r\n\r\n    a = xc.length;\r\n    b = yc.length;\r\n\r\n    // Point xc to the longer array, and b to the shorter length.\r\n    if (a - b < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n      b = a;\r\n    }\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n    for (a = 0; b;) {\r\n      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n    }\r\n\r\n    if (a) {\r\n      xc = [a].concat(xc);\r\n      ++ye;\r\n    }\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    // ye = MAX_EXP + 1 possible\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.precision = P.sd = function (sd, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (sd != null && sd !== !!sd) {\r\n      intCheck(sd, 1, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), sd, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    v = c.length - 1;\r\n    n = v * LOG_BASE + 1;\r\n\r\n    if (v = c[v]) {\r\n\r\n      // Subtract the number of trailing zeros of the last element.\r\n      for (; v % 10 == 0; v /= 10, n--);\r\n\r\n      // Add the number of digits of the first element.\r\n      for (v = c[0]; v >= 10; v /= 10, n++);\r\n    }\r\n\r\n    if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */\r\n  P.shiftedBy = function (k) {\r\n    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n    return this.times('1e' + k);\r\n  };\r\n\r\n\r\n  /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, r, rep, t,\r\n      x = this,\r\n      c = x.c,\r\n      s = x.s,\r\n      e = x.e,\r\n      dp = DECIMAL_PLACES + 4,\r\n      half = new BigNumber('0.5');\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !c || !c[0]) {\r\n      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n    }\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+valueOf(x));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = coeffToString(c);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(+n);\r\n      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new BigNumber(n);\r\n    } else {\r\n      r = new BigNumber(s + '');\r\n    }\r\n\r\n    // Check for zero.\r\n    // r could be zero if MIN_EXP is changed after the this value was created.\r\n    // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n    // coeffToString to throw.\r\n    if (r.c[0]) {\r\n      e = r.e;\r\n      s = e + dp;\r\n      if (s < 3) s = 0;\r\n\r\n      // Newton-Raphson iteration.\r\n      for (; ;) {\r\n        t = r;\r\n        r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n          // The exponent of r may here be one less than the final result exponent,\r\n          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n          // are indexed correctly.\r\n          if (r.e < e) --s;\r\n          n = n.slice(s - 3, s + 1);\r\n\r\n          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n          // iteration.\r\n          if (n == '9999' || !rep && n == '4999') {\r\n\r\n            // On the first iteration only, check to see if rounding up gives the\r\n            // exact result as the nines may infinitely repeat.\r\n            if (!rep) {\r\n              round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n              if (t.times(t).eq(x)) {\r\n                r = t;\r\n                break;\r\n              }\r\n            }\r\n\r\n            dp += 4;\r\n            s += 4;\r\n            rep = 1;\r\n          } else {\r\n\r\n            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n            // result. If not, then there are further digits and m will be truthy.\r\n            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n              // Truncate to the first rounding digit.\r\n              round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n              m = !r.times(r).eq(x);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp++;\r\n    }\r\n    return format(this, dp, rm, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp = dp + this.e + 1;\r\n    }\r\n    return format(this, dp, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */\r\n  P.toFormat = function (dp, rm, format) {\r\n    var str,\r\n      x = this;\r\n\r\n    if (format == null) {\r\n      if (dp != null && rm && typeof rm == 'object') {\r\n        format = rm;\r\n        rm = null;\r\n      } else if (dp && typeof dp == 'object') {\r\n        format = dp;\r\n        dp = rm = null;\r\n      } else {\r\n        format = FORMAT;\r\n      }\r\n    } else if (typeof format != 'object') {\r\n      throw Error\r\n        (bignumberError + 'Argument not an object: ' + format);\r\n    }\r\n\r\n    str = x.toFixed(dp, rm);\r\n\r\n    if (x.c) {\r\n      var i,\r\n        arr = str.split('.'),\r\n        g1 = +format.groupSize,\r\n        g2 = +format.secondaryGroupSize,\r\n        groupSeparator = format.groupSeparator || '',\r\n        intPart = arr[0],\r\n        fractionPart = arr[1],\r\n        isNeg = x.s < 0,\r\n        intDigits = isNeg ? intPart.slice(1) : intPart,\r\n        len = intDigits.length;\r\n\r\n      if (g2) {\r\n        i = g1;\r\n        g1 = g2;\r\n        g2 = i;\r\n        len -= i;\r\n      }\r\n\r\n      if (g1 > 0 && len > 0) {\r\n        i = len % g1 || g1;\r\n        intPart = intDigits.substr(0, i);\r\n        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n        if (isNeg) intPart = '-' + intPart;\r\n      }\r\n\r\n      str = fractionPart\r\n       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n        ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n         '$&' + (format.fractionGroupSeparator || ''))\r\n        : fractionPart)\r\n       : intPart;\r\n    }\r\n\r\n    return (format.prefix || '') + str + (format.suffix || '');\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */\r\n  P.toFraction = function (md) {\r\n    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n      x = this,\r\n      xc = x.c;\r\n\r\n    if (md != null) {\r\n      n = new BigNumber(md);\r\n\r\n      // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n        throw Error\r\n          (bignumberError + 'Argument ' +\r\n            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n      }\r\n    }\r\n\r\n    if (!xc) return new BigNumber(x);\r\n\r\n    d = new BigNumber(ONE);\r\n    n1 = d0 = new BigNumber(ONE);\r\n    d1 = n0 = new BigNumber(ONE);\r\n    s = coeffToString(xc);\r\n\r\n    // Determine initial denominator.\r\n    // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n    e = d.e = s.length - x.e - 1;\r\n    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n    exp = MAX_EXP;\r\n    MAX_EXP = 1 / 0;\r\n    n = new BigNumber(s);\r\n\r\n    // n0 = d1 = 0\r\n    n0.c[0] = 0;\r\n\r\n    for (; ;)  {\r\n      q = div(n, d, 0, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.comparedTo(md) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      n1 = n0.plus(q.times(d2 = n1));\r\n      n0 = d2;\r\n      d = n.minus(q.times(d2 = d));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = div(md.minus(d0), d1, 0, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n    e = e * 2;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n    MAX_EXP = exp;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */\r\n  P.toNumber = function () {\r\n    return +valueOf(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    if (sd != null) intCheck(sd, 1, MAX);\r\n    return format(this, sd, rm, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */\r\n  P.toString = function (b) {\r\n    var str,\r\n      n = this,\r\n      s = n.s,\r\n      e = n.e;\r\n\r\n    // Infinity or NaN?\r\n    if (e === null) {\r\n      if (s) {\r\n        str = 'Infinity';\r\n        if (s < 0) str = '-' + str;\r\n      } else {\r\n        str = 'NaN';\r\n      }\r\n    } else {\r\n      if (b == null) {\r\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n         ? toExponential(coeffToString(n.c), e)\r\n         : toFixedPoint(coeffToString(n.c), e, '0');\r\n      } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n        str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n      } else {\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n      }\r\n\r\n      if (s < 0 && n.c[0]) str = '-' + str;\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    return valueOf(this);\r\n  };\r\n\r\n\r\n  P._isBigNumber = true;\r\n\r\n  P[Symbol.toStringTag] = 'BigNumber';\r\n\r\n  // Node.js v10.12.0+\r\n  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n\r\n  if (configObject != null) BigNumber.set(configObject);\r\n\r\n  return BigNumber;\r\n}\r\n\r\n\r\n// PRIVATE HELPER FUNCTIONS\r\n\r\n// These functions don't need access to variables,\r\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\nfunction bitFloor(n) {\r\n  var i = n | 0;\r\n  return n > 0 || n === i ? i : i - 1;\r\n}\r\n\r\n\r\n// Return a coefficient array as a string of base 10 digits.\r\nfunction coeffToString(a) {\r\n  var s, z,\r\n    i = 1,\r\n    j = a.length,\r\n    r = a[0] + '';\r\n\r\n  for (; i < j;) {\r\n    s = a[i++] + '';\r\n    z = LOG_BASE - s.length;\r\n    for (; z--; s = '0' + s);\r\n    r += s;\r\n  }\r\n\r\n  // Determine trailing zeros.\r\n  for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n  return r.slice(0, j + 1 || 1);\r\n}\r\n\r\n\r\n// Compare the value of BigNumbers x and y.\r\nfunction compare(x, y) {\r\n  var a, b,\r\n    xc = x.c,\r\n    yc = y.c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either NaN?\r\n  if (!i || !j) return null;\r\n\r\n  a = xc && !xc[0];\r\n  b = yc && !yc[0];\r\n\r\n  // Either zero?\r\n  if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  a = i < 0;\r\n  b = k == l;\r\n\r\n  // Either Infinity?\r\n  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n  // Compare exponents.\r\n  if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n}\r\n\r\n\r\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */\r\nfunction intCheck(n, min, max, name) {\r\n  if (n < min || n > max || n !== mathfloor(n)) {\r\n    throw Error\r\n     (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n       ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n       : ' not a primitive number: ') + String(n));\r\n  }\r\n}\r\n\r\n\r\n// Assumes finite n.\r\nfunction isOdd(n) {\r\n  var k = n.c.length - 1;\r\n  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n}\r\n\r\n\r\nfunction toExponential(str, e) {\r\n  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n   (e < 0 ? 'e' : 'e+') + e;\r\n}\r\n\r\n\r\nfunction toFixedPoint(str, e, z) {\r\n  var len, zs;\r\n\r\n  // Negative exponent?\r\n  if (e < 0) {\r\n\r\n    // Prepend zeros.\r\n    for (zs = z + '.'; ++e; zs += z);\r\n    str = zs + str;\r\n\r\n  // Positive exponent\r\n  } else {\r\n    len = str.length;\r\n\r\n    // Append zeros.\r\n    if (++e > len) {\r\n      for (zs = z, e -= len; --e; zs += z);\r\n      str += zs;\r\n    } else if (e < len) {\r\n      str = str.slice(0, e) + '.' + str.slice(e);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// EXPORT\r\n\r\n\r\nexport var BigNumber = clone();\r\n\r\nexport default BigNumber;\r\n","// src/index.ts\nvar SplayTreeNode = class {\n  key;\n  left = null;\n  right = null;\n  constructor(key) {\n    this.key = key;\n  }\n};\nvar SplayTreeSetNode = class extends SplayTreeNode {\n  constructor(key) {\n    super(key);\n  }\n};\nvar SplayTreeMapNode = class _SplayTreeMapNode extends SplayTreeNode {\n  value;\n  constructor(key, value) {\n    super(key);\n    this.value = value;\n  }\n  replaceValue(value) {\n    const node = new _SplayTreeMapNode(this.key, value);\n    node.left = this.left;\n    node.right = this.right;\n    return node;\n  }\n};\nvar SplayTree = class {\n  size = 0;\n  modificationCount = 0;\n  splayCount = 0;\n  splay(key) {\n    const root = this.root;\n    if (root == null) {\n      this.compare(key, key);\n      return -1;\n    }\n    let right = null;\n    let newTreeRight = null;\n    let left = null;\n    let newTreeLeft = null;\n    let current = root;\n    const compare = this.compare;\n    let comp;\n    while (true) {\n      comp = compare(current.key, key);\n      if (comp > 0) {\n        let currentLeft = current.left;\n        if (currentLeft == null) break;\n        comp = compare(currentLeft.key, key);\n        if (comp > 0) {\n          current.left = currentLeft.right;\n          currentLeft.right = current;\n          current = currentLeft;\n          currentLeft = current.left;\n          if (currentLeft == null) break;\n        }\n        if (right == null) {\n          newTreeRight = current;\n        } else {\n          right.left = current;\n        }\n        right = current;\n        current = currentLeft;\n      } else if (comp < 0) {\n        let currentRight = current.right;\n        if (currentRight == null) break;\n        comp = compare(currentRight.key, key);\n        if (comp < 0) {\n          current.right = currentRight.left;\n          currentRight.left = current;\n          current = currentRight;\n          currentRight = current.right;\n          if (currentRight == null) break;\n        }\n        if (left == null) {\n          newTreeLeft = current;\n        } else {\n          left.right = current;\n        }\n        left = current;\n        current = currentRight;\n      } else {\n        break;\n      }\n    }\n    if (left != null) {\n      left.right = current.left;\n      current.left = newTreeLeft;\n    }\n    if (right != null) {\n      right.left = current.right;\n      current.right = newTreeRight;\n    }\n    if (this.root !== current) {\n      this.root = current;\n      this.splayCount++;\n    }\n    return comp;\n  }\n  splayMin(node) {\n    let current = node;\n    let nextLeft = current.left;\n    while (nextLeft != null) {\n      const left = nextLeft;\n      current.left = left.right;\n      left.right = current;\n      current = left;\n      nextLeft = current.left;\n    }\n    return current;\n  }\n  splayMax(node) {\n    let current = node;\n    let nextRight = current.right;\n    while (nextRight != null) {\n      const right = nextRight;\n      current.right = right.left;\n      right.left = current;\n      current = right;\n      nextRight = current.right;\n    }\n    return current;\n  }\n  _delete(key) {\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp != 0) return null;\n    let root = this.root;\n    const result = root;\n    const left = root.left;\n    this.size--;\n    if (left == null) {\n      this.root = root.right;\n    } else {\n      const right = root.right;\n      root = this.splayMax(left);\n      root.right = right;\n      this.root = root;\n    }\n    this.modificationCount++;\n    return result;\n  }\n  addNewRoot(node, comp) {\n    this.size++;\n    this.modificationCount++;\n    const root = this.root;\n    if (root == null) {\n      this.root = node;\n      return;\n    }\n    if (comp < 0) {\n      node.left = root;\n      node.right = root.right;\n      root.right = null;\n    } else {\n      node.right = root;\n      node.left = root.left;\n      root.left = null;\n    }\n    this.root = node;\n  }\n  _first() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMin(root);\n    return this.root;\n  }\n  _last() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMax(root);\n    return this.root;\n  }\n  clear() {\n    this.root = null;\n    this.size = 0;\n    this.modificationCount++;\n  }\n  has(key) {\n    return this.validKey(key) && this.splay(key) == 0;\n  }\n  defaultCompare() {\n    return (a, b) => a < b ? -1 : a > b ? 1 : 0;\n  }\n  wrap() {\n    return {\n      getRoot: () => {\n        return this.root;\n      },\n      setRoot: (root) => {\n        this.root = root;\n      },\n      getSize: () => {\n        return this.size;\n      },\n      getModificationCount: () => {\n        return this.modificationCount;\n      },\n      getSplayCount: () => {\n        return this.splayCount;\n      },\n      setSplayCount: (count) => {\n        this.splayCount = count;\n      },\n      splay: (key) => {\n        return this.splay(key);\n      },\n      has: (key) => {\n        return this.has(key);\n      }\n    };\n  }\n};\nvar SplayTreeMap = class extends SplayTree {\n  root = null;\n  compare;\n  validKey;\n  constructor(compare, isValidKey) {\n    super();\n    this.compare = compare ?? this.defaultCompare();\n    this.validKey = isValidKey ?? ((a) => a != null && a != void 0);\n  }\n  delete(key) {\n    if (!this.validKey(key)) return false;\n    return this._delete(key) != null;\n  }\n  forEach(f) {\n    const nodes = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value[1], result.value[0], this);\n    }\n  }\n  get(key) {\n    if (!this.validKey(key)) return void 0;\n    if (this.root != null) {\n      const comp = this.splay(key);\n      if (comp == 0) {\n        return this.root.value;\n      }\n    }\n    return void 0;\n  }\n  hasValue(value) {\n    const initialSplayCount = this.splayCount;\n    const visit = (node) => {\n      while (node != null) {\n        if (node.value == value) return true;\n        if (initialSplayCount != this.splayCount) {\n          throw \"Concurrent modification during iteration.\";\n        }\n        if (node.right != null && visit(node.right)) {\n          return true;\n        }\n        node = node.left;\n      }\n      return false;\n    };\n    return visit(this.root);\n  }\n  set(key, value) {\n    const comp = this.splay(key);\n    if (comp == 0) {\n      this.root = this.root.replaceValue(value);\n      this.splayCount += 1;\n      return this;\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return this;\n  }\n  setAll(other) {\n    other.forEach((value, key) => {\n      this.set(key, value);\n    });\n  }\n  setIfAbsent(key, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      return this.root.value;\n    }\n    const modificationCount = this.modificationCount;\n    const splayCount = this.splayCount;\n    const value = ifAbsent();\n    if (modificationCount != this.modificationCount) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (splayCount != this.splayCount) {\n      comp = this.splay(key);\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return value;\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return !this.isEmpty();\n  }\n  firstKey() {\n    if (this.root == null) return null;\n    return this._first().key;\n  }\n  lastKey() {\n    if (this.root == null) return null;\n    return this._last().key;\n  }\n  lastKeyBefore(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstKeyAfter(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  update(key, update, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = update(this.root.value);\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        this.splay(key);\n      }\n      this.root = this.root.replaceValue(newValue);\n      this.splayCount += 1;\n      return newValue;\n    }\n    if (ifAbsent != null) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = ifAbsent();\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        comp = this.splay(key);\n      }\n      this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);\n      return newValue;\n    }\n    throw \"Invalid argument (key): Key not in map.\";\n  }\n  updateAll(update) {\n    const root = this.root;\n    if (root == null) return;\n    const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let node;\n    while (node = iterator.next(), !node.done) {\n      const newValue = update(...node.value);\n      iterator.replaceValue(newValue);\n    }\n  }\n  keys() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  values() {\n    return new SplayTreeValueIterableIterator(this.wrap());\n  }\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeMapEntryIterableIterator(this.wrap());\n  }\n  [Symbol.toStringTag] = \"[object Map]\";\n};\nvar SplayTreeSet = class _SplayTreeSet extends SplayTree {\n  root = null;\n  compare;\n  validKey;\n  constructor(compare, isValidKey) {\n    super();\n    this.compare = compare ?? this.defaultCompare();\n    this.validKey = isValidKey ?? ((v) => v != null && v != void 0);\n  }\n  delete(element) {\n    if (!this.validKey(element)) return false;\n    return this._delete(element) != null;\n  }\n  deleteAll(elements) {\n    for (const element of elements) {\n      this.delete(element);\n    }\n  }\n  forEach(f) {\n    const nodes = this[Symbol.iterator]();\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value, result.value, this);\n    }\n  }\n  add(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this;\n  }\n  addAndReturn(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this.root.key;\n  }\n  addAll(elements) {\n    for (const element of elements) {\n      this.add(element);\n    }\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return this.root != null;\n  }\n  single() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    if (this.size > 1) throw \"Bad state: Too many element\";\n    return this.root.key;\n  }\n  first() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._first().key;\n  }\n  last() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._last().key;\n  }\n  lastBefore(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstAfter(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  retainAll(elements) {\n    const retainSet = new _SplayTreeSet(this.compare, this.validKey);\n    const modificationCount = this.modificationCount;\n    for (const object of elements) {\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (this.validKey(object) && this.splay(object) == 0) {\n        retainSet.add(this.root.key);\n      }\n    }\n    if (retainSet.size != this.size) {\n      this.root = retainSet.root;\n      this.size = retainSet.size;\n      this.modificationCount++;\n    }\n  }\n  lookup(object) {\n    if (!this.validKey(object)) return null;\n    const comp = this.splay(object);\n    if (comp != 0) return null;\n    return this.root.key;\n  }\n  intersection(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  difference(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (!other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  union(other) {\n    const u = this.clone();\n    u.addAll(other);\n    return u;\n  }\n  clone() {\n    const set = new _SplayTreeSet(this.compare, this.validKey);\n    set.size = this.size;\n    set.root = this.copyNode(this.root);\n    return set;\n  }\n  copyNode(node) {\n    if (node == null) return null;\n    function copyChildren(node2, dest) {\n      let left;\n      let right;\n      do {\n        left = node2.left;\n        right = node2.right;\n        if (left != null) {\n          const newLeft = new SplayTreeSetNode(left.key);\n          dest.left = newLeft;\n          copyChildren(left, newLeft);\n        }\n        if (right != null) {\n          const newRight = new SplayTreeSetNode(right.key);\n          dest.right = newRight;\n          node2 = right;\n          dest = newRight;\n        }\n      } while (right != null);\n    }\n    const result = new SplayTreeSetNode(node.key);\n    copyChildren(node, result);\n    return result;\n  }\n  toSet() {\n    return this.clone();\n  }\n  entries() {\n    return new SplayTreeSetEntryIterableIterator(this.wrap());\n  }\n  keys() {\n    return this[Symbol.iterator]();\n  }\n  values() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  [Symbol.toStringTag] = \"[object Set]\";\n};\nvar SplayTreeIterableIterator = class {\n  tree;\n  path = new Array();\n  modificationCount = null;\n  splayCount;\n  constructor(tree) {\n    this.tree = tree;\n    this.splayCount = tree.getSplayCount();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    if (this.moveNext()) return { done: false, value: this.current() };\n    return { done: true, value: null };\n  }\n  current() {\n    if (!this.path.length) return null;\n    const node = this.path[this.path.length - 1];\n    return this.getValue(node);\n  }\n  rebuildPath(key) {\n    this.path.splice(0, this.path.length);\n    this.tree.splay(key);\n    this.path.push(this.tree.getRoot());\n    this.splayCount = this.tree.getSplayCount();\n  }\n  findLeftMostDescendent(node) {\n    while (node != null) {\n      this.path.push(node);\n      node = node.left;\n    }\n  }\n  moveNext() {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      if (this.modificationCount == null) {\n        this.modificationCount = this.tree.getModificationCount();\n        let node2 = this.tree.getRoot();\n        while (node2 != null) {\n          this.path.push(node2);\n          node2 = node2.left;\n        }\n        return this.path.length > 0;\n      }\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (!this.path.length) return false;\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    let node = this.path[this.path.length - 1];\n    let next = node.right;\n    if (next != null) {\n      while (next != null) {\n        this.path.push(next);\n        next = next.left;\n      }\n      return true;\n    }\n    this.path.pop();\n    while (this.path.length && this.path[this.path.length - 1].right === node) {\n      node = this.path.pop();\n    }\n    return this.path.length > 0;\n  }\n};\nvar SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return node.key;\n  }\n};\nvar SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return [node.key, node.key];\n  }\n};\nvar SplayTreeValueIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return node.value;\n  }\n};\nvar SplayTreeMapEntryIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return [node.key, node.value];\n  }\n  replaceValue(value) {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    const last = this.path.pop();\n    const newLast = last.replaceValue(value);\n    if (!this.path.length) {\n      this.tree.setRoot(newLast);\n    } else {\n      const parent = this.path[this.path.length - 1];\n      if (last === parent.left) {\n        parent.left = newLast;\n      } else {\n        parent.right = newLast;\n      }\n    }\n    this.path.push(newLast);\n    const count = this.tree.getSplayCount() + 1;\n    this.tree.setSplayCount(count);\n    this.splayCount = count;\n  }\n};\nexport {\n  SplayTreeMap,\n  SplayTreeSet\n};\n//# sourceMappingURL=index.js.map","// src/geom-in.ts\nimport BigNumber2 from \"bignumber.js\";\n\n// src/constant.ts\nvar constant_default = (x) => {\n  return () => {\n    return x;\n  };\n};\n\n// src/compare.ts\nvar compare_default = (eps) => {\n  const almostEqual = eps ? (a, b) => b.minus(a).abs().isLessThanOrEqualTo(eps) : constant_default(false);\n  return (a, b) => {\n    if (almostEqual(a, b)) return 0;\n    return a.comparedTo(b);\n  };\n};\n\n// src/orient.ts\nfunction orient_default(eps) {\n  const almostCollinear = eps ? (area2, ax, ay, cx, cy) => area2.exponentiatedBy(2).isLessThanOrEqualTo(\n    cx.minus(ax).exponentiatedBy(2).plus(cy.minus(ay).exponentiatedBy(2)).times(eps)\n  ) : constant_default(false);\n  return (a, b, c) => {\n    const ax = a.x, ay = a.y, cx = c.x, cy = c.y;\n    const area2 = ay.minus(cy).times(b.x.minus(cx)).minus(ax.minus(cx).times(b.y.minus(cy)));\n    if (almostCollinear(area2, ax, ay, cx, cy)) return 0;\n    return area2.comparedTo(0);\n  };\n}\n\n// src/snap.ts\nimport BigNumber from \"bignumber.js\";\nimport { SplayTreeSet } from \"splaytree-ts\";\n\n// src/identity.ts\nvar identity_default = (x) => {\n  return x;\n};\n\n// src/snap.ts\nvar snap_default = (eps) => {\n  if (eps) {\n    const xTree = new SplayTreeSet(compare_default(eps));\n    const yTree = new SplayTreeSet(compare_default(eps));\n    const snapCoord = (coord, tree) => {\n      return tree.addAndReturn(coord);\n    };\n    const snap = (v) => {\n      return {\n        x: snapCoord(v.x, xTree),\n        y: snapCoord(v.y, yTree)\n      };\n    };\n    snap({ x: new BigNumber(0), y: new BigNumber(0) });\n    return snap;\n  }\n  return identity_default;\n};\n\n// src/precision.ts\nvar set = (eps) => {\n  return {\n    set: (eps2) => {\n      precision = set(eps2);\n    },\n    reset: () => set(eps),\n    compare: compare_default(eps),\n    snap: snap_default(eps),\n    orient: orient_default(eps)\n  };\n};\nvar precision = set();\n\n// src/bbox.ts\nvar isInBbox = (bbox, point) => {\n  return bbox.ll.x.isLessThanOrEqualTo(point.x) && point.x.isLessThanOrEqualTo(bbox.ur.x) && bbox.ll.y.isLessThanOrEqualTo(point.y) && point.y.isLessThanOrEqualTo(bbox.ur.y);\n};\nvar getBboxOverlap = (b1, b2) => {\n  if (b2.ur.x.isLessThan(b1.ll.x) || b1.ur.x.isLessThan(b2.ll.x) || b2.ur.y.isLessThan(b1.ll.y) || b1.ur.y.isLessThan(b2.ll.y))\n    return null;\n  const lowerX = b1.ll.x.isLessThan(b2.ll.x) ? b2.ll.x : b1.ll.x;\n  const upperX = b1.ur.x.isLessThan(b2.ur.x) ? b1.ur.x : b2.ur.x;\n  const lowerY = b1.ll.y.isLessThan(b2.ll.y) ? b2.ll.y : b1.ll.y;\n  const upperY = b1.ur.y.isLessThan(b2.ur.y) ? b1.ur.y : b2.ur.y;\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };\n};\n\n// src/operation.ts\nimport { SplayTreeSet as SplayTreeSet3 } from \"splaytree-ts\";\n\n// src/vector.ts\nvar crossProduct = (a, b) => a.x.times(b.y).minus(a.y.times(b.x));\nvar dotProduct = (a, b) => a.x.times(b.x).plus(a.y.times(b.y));\nvar length = (v) => dotProduct(v, v).sqrt();\nvar sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };\n  const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };\n  return crossProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));\n};\nvar cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };\n  const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };\n  return dotProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));\n};\nvar horizontalIntersection = (pt, v, y) => {\n  if (v.y.isZero()) return null;\n  return { x: pt.x.plus(v.x.div(v.y).times(y.minus(pt.y))), y };\n};\nvar verticalIntersection = (pt, v, x) => {\n  if (v.x.isZero()) return null;\n  return { x, y: pt.y.plus(v.y.div(v.x).times(x.minus(pt.x))) };\n};\nvar intersection = (pt1, v1, pt2, v2) => {\n  if (v1.x.isZero()) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x.isZero()) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y.isZero()) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y.isZero()) return horizontalIntersection(pt1, v1, pt2.y);\n  const kross = crossProduct(v1, v2);\n  if (kross.isZero()) return null;\n  const ve = { x: pt2.x.minus(pt1.x), y: pt2.y.minus(pt1.y) };\n  const d1 = crossProduct(ve, v1).div(kross);\n  const d2 = crossProduct(ve, v2).div(kross);\n  const x1 = pt1.x.plus(d2.times(v1.x)), x2 = pt2.x.plus(d1.times(v2.x));\n  const y1 = pt1.y.plus(d2.times(v1.y)), y2 = pt2.y.plus(d1.times(v2.y));\n  const x = x1.plus(x2).div(2);\n  const y = y1.plus(y2).div(2);\n  return { x, y };\n};\n\n// src/sweep-event.ts\nvar SweepEvent = class _SweepEvent {\n  point;\n  isLeft;\n  segment;\n  otherSE;\n  consumedBy;\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    const ptCmp = _SweepEvent.comparePoints(a.point, b.point);\n    if (ptCmp !== 0) return ptCmp;\n    if (a.point !== b.point) a.link(b);\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n    return Segment.compare(a.segment, b.segment);\n  }\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x.isLessThan(bPt.x)) return -1;\n    if (aPt.x.isGreaterThan(bPt.x)) return 1;\n    if (aPt.y.isLessThan(bPt.y)) return -1;\n    if (aPt.y.isGreaterThan(bPt.y)) return 1;\n    return 0;\n  }\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === void 0) point.events = [this];\n    else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n  }\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\");\n    }\n    const otherEvents = other.point.events;\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i];\n      this.point.events.push(evt);\n      evt.point = this.point;\n    }\n    this.checkForConsuming();\n  }\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    const numEvents = this.point.events.length;\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i];\n      if (evt1.segment.consumedBy !== void 0) continue;\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j];\n        if (evt2.consumedBy !== void 0) continue;\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n        evt1.segment.consume(evt2.segment);\n      }\n    }\n  }\n  getAvailableLinkedEvents() {\n    const events = [];\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i];\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt);\n      }\n    }\n    return events;\n  }\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = /* @__PURE__ */ new Map();\n    const fillCache = (linkedEvent) => {\n      const nextEvent = linkedEvent.otherSE;\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      });\n    };\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a);\n      if (!cache.has(b)) fillCache(b);\n      const { sine: asine, cosine: acosine } = cache.get(a);\n      const { sine: bsine, cosine: bcosine } = cache.get(b);\n      if (asine.isGreaterThanOrEqualTo(0) && bsine.isGreaterThanOrEqualTo(0)) {\n        if (acosine.isLessThan(bcosine)) return 1;\n        if (acosine.isGreaterThan(bcosine)) return -1;\n        return 0;\n      }\n      if (asine.isLessThan(0) && bsine.isLessThan(0)) {\n        if (acosine.isLessThan(bcosine)) return -1;\n        if (acosine.isGreaterThan(bcosine)) return 1;\n        return 0;\n      }\n      if (bsine.isLessThan(asine)) return -1;\n      if (bsine.isGreaterThan(asine)) return 1;\n      return 0;\n    };\n  }\n};\n\n// src/geom-out.ts\nvar RingOut = class _RingOut {\n  events;\n  poly;\n  _isExteriorRing;\n  _enclosingRing;\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = [];\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i];\n      if (!segment.isInResult() || segment.ringOut) continue;\n      let prevEvent = null;\n      let event = segment.leftSE;\n      let nextEvent = segment.rightSE;\n      const events = [event];\n      const startingPoint = event.point;\n      const intersectionLEs = [];\n      while (true) {\n        prevEvent = event;\n        event = nextEvent;\n        events.push(event);\n        if (event.point === startingPoint) break;\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents();\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point;\n            const lastPt = events[events.length - 1].point;\n            throw new Error(\n              `Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`\n            );\n          }\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE;\n            break;\n          }\n          let indexLE = null;\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j;\n              break;\n            }\n          }\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0];\n            const ringEvents = events.splice(intersectionLE.index);\n            ringEvents.unshift(ringEvents[0].otherSE);\n            ringsOut.push(new _RingOut(ringEvents.reverse()));\n            continue;\n          }\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point\n          });\n          const comparator = event.getLeftmostComparator(prevEvent);\n          nextEvent = availableLEs.sort(comparator)[0].otherSE;\n          break;\n        }\n      }\n      ringsOut.push(new _RingOut(events));\n    }\n    return ringsOut;\n  }\n  constructor(events) {\n    this.events = events;\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n  getGeom() {\n    let prevPt = this.events[0].point;\n    const points = [prevPt];\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt2 = this.events[i].point;\n      const nextPt2 = this.events[i + 1].point;\n      if (precision.orient(pt2, prevPt, nextPt2) === 0) continue;\n      points.push(pt2);\n      prevPt = pt2;\n    }\n    if (points.length === 1) return null;\n    const pt = points[0];\n    const nextPt = points[1];\n    if (precision.orient(pt, prevPt, nextPt) === 0) points.shift();\n    points.push(points[0]);\n    const step = this.isExteriorRing() ? 1 : -1;\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n    const iEnd = this.isExteriorRing() ? points.length : -1;\n    const orderedPoints = [];\n    for (let i = iStart; i != iEnd; i += step)\n      orderedPoints.push([points[i].x.toNumber(), points[i].y.toNumber()]);\n    return orderedPoints;\n  }\n  isExteriorRing() {\n    if (this._isExteriorRing === void 0) {\n      const enclosing = this.enclosingRing();\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n    }\n    return this._isExteriorRing;\n  }\n  enclosingRing() {\n    if (this._enclosingRing === void 0) {\n      this._enclosingRing = this._calcEnclosingRing();\n    }\n    return this._enclosingRing;\n  }\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    let leftMostEvt = this.events[0];\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i];\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n    }\n    let prevSeg = leftMostEvt.segment.prevInResult();\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    while (true) {\n      if (!prevSeg) return null;\n      if (!prevPrevSeg) return prevSeg.ringOut;\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut?.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut;\n        } else return prevSeg.ringOut?.enclosingRing();\n      }\n      prevSeg = prevPrevSeg.prevInResult();\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    }\n  }\n};\nvar PolyOut = class {\n  exteriorRing;\n  interiorRings;\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n  addInterior(ring) {\n    this.interiorRings.push(ring);\n    ring.poly = this;\n  }\n  getGeom() {\n    const geom0 = this.exteriorRing.getGeom();\n    if (geom0 === null) return null;\n    const geom = [geom0];\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom();\n      if (ringGeom === null) continue;\n      geom.push(ringGeom);\n    }\n    return geom;\n  }\n};\nvar MultiPolyOut = class {\n  rings;\n  polys;\n  constructor(rings) {\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n  getGeom() {\n    const geom = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom();\n      if (polyGeom === null) continue;\n      geom.push(polyGeom);\n    }\n    return geom;\n  }\n  _composePolys(rings) {\n    const polys = [];\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i];\n      if (ring.poly) continue;\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));\n      else {\n        const enclosingRing = ring.enclosingRing();\n        if (!enclosingRing?.poly) polys.push(new PolyOut(enclosingRing));\n        enclosingRing?.poly?.addInterior(ring);\n      }\n    }\n    return polys;\n  }\n};\n\n// src/sweep-line.ts\nimport { SplayTreeSet as SplayTreeSet2 } from \"splaytree-ts\";\nvar SweepLine = class {\n  queue;\n  tree;\n  segments;\n  constructor(queue, comparator = Segment.compare) {\n    this.queue = queue;\n    this.tree = new SplayTreeSet2(comparator);\n    this.segments = [];\n  }\n  process(event) {\n    const segment = event.segment;\n    const newEvents = [];\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.delete(event.otherSE);\n      else this.tree.delete(segment);\n      return newEvents;\n    }\n    if (event.isLeft) this.tree.add(segment);\n    let prevSeg = segment;\n    let nextSeg = segment;\n    do {\n      prevSeg = this.tree.lastBefore(prevSeg);\n    } while (prevSeg != null && prevSeg.consumedBy != void 0);\n    do {\n      nextSeg = this.tree.firstAfter(nextSeg);\n    } while (nextSeg != null && nextSeg.consumedBy != void 0);\n    if (event.isLeft) {\n      let prevMySplitter = null;\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment);\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      let nextMySplitter = null;\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment);\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null;\n        if (prevMySplitter === null) mySplitter = nextMySplitter;\n        else if (nextMySplitter === null) mySplitter = prevMySplitter;\n        else {\n          const cmpSplitters = SweepEvent.comparePoints(\n            prevMySplitter,\n            nextMySplitter\n          );\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n        }\n        this.queue.delete(segment.rightSE);\n        newEvents.push(segment.rightSE);\n        const newEventsFromSplit = segment.split(mySplitter);\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i]);\n        }\n      }\n      if (newEvents.length > 0) {\n        this.tree.delete(segment);\n        newEvents.push(event);\n      } else {\n        this.segments.push(segment);\n        segment.prev = prevSeg;\n      }\n    } else {\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg);\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      this.tree.delete(segment);\n    }\n    return newEvents;\n  }\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    this.tree.delete(seg);\n    const rightSE = seg.rightSE;\n    this.queue.delete(rightSE);\n    const newEvents = seg.split(pt);\n    newEvents.push(rightSE);\n    if (seg.consumedBy === void 0) this.tree.add(seg);\n    return newEvents;\n  }\n};\n\n// src/operation.ts\nvar Operation = class {\n  type;\n  numMultiPolys;\n  run(type, geom, moreGeoms) {\n    operation.type = type;\n    const multipolys = [new MultiPolyIn(geom, true)];\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n    }\n    operation.numMultiPolys = multipolys.length;\n    if (operation.type === \"difference\") {\n      const subject = multipolys[0];\n      let i = 1;\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;\n        else multipolys.splice(i, 1);\n      }\n    }\n    if (operation.type === \"intersection\") {\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i];\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n        }\n      }\n    }\n    const queue = new SplayTreeSet3(SweepEvent.compare);\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents();\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.add(sweepEvents[j]);\n      }\n    }\n    const sweepLine = new SweepLine(queue);\n    let evt = null;\n    if (queue.size != 0) {\n      evt = queue.first();\n      queue.delete(evt);\n    }\n    while (evt) {\n      const newEvents = sweepLine.process(evt);\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt2 = newEvents[i];\n        if (evt2.consumedBy === void 0) queue.add(evt2);\n      }\n      if (queue.size != 0) {\n        evt = queue.first();\n        queue.delete(evt);\n      } else {\n        evt = null;\n      }\n    }\n    precision.reset();\n    const ringsOut = RingOut.factory(sweepLine.segments);\n    const result = new MultiPolyOut(ringsOut);\n    return result.getGeom();\n  }\n};\nvar operation = new Operation();\nvar operation_default = operation;\n\n// src/segment.ts\nvar segmentId = 0;\nvar Segment = class _Segment {\n  id;\n  leftSE;\n  rightSE;\n  rings;\n  windings;\n  ringOut;\n  consumedBy;\n  prev;\n  _prevInResult;\n  _beforeState;\n  _afterState;\n  _isInResult;\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x;\n    const blx = b.leftSE.point.x;\n    const arx = a.rightSE.point.x;\n    const brx = b.rightSE.point.x;\n    if (brx.isLessThan(alx)) return 1;\n    if (arx.isLessThan(blx)) return -1;\n    const aly = a.leftSE.point.y;\n    const bly = b.leftSE.point.y;\n    const ary = a.rightSE.point.y;\n    const bry = b.rightSE.point.y;\n    if (alx.isLessThan(blx)) {\n      if (bly.isLessThan(aly) && bly.isLessThan(ary)) return 1;\n      if (bly.isGreaterThan(aly) && bly.isGreaterThan(ary)) return -1;\n      const aCmpBLeft = a.comparePoint(b.leftSE.point);\n      if (aCmpBLeft < 0) return 1;\n      if (aCmpBLeft > 0) return -1;\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n      return -1;\n    }\n    if (alx.isGreaterThan(blx)) {\n      if (aly.isLessThan(bly) && aly.isLessThan(bry)) return -1;\n      if (aly.isGreaterThan(bly) && aly.isGreaterThan(bry)) return 1;\n      const bCmpALeft = b.comparePoint(a.leftSE.point);\n      if (bCmpALeft !== 0) return bCmpALeft;\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n      return 1;\n    }\n    if (aly.isLessThan(bly)) return -1;\n    if (aly.isGreaterThan(bly)) return 1;\n    if (arx.isLessThan(brx)) {\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n    }\n    if (arx.isGreaterThan(brx)) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n    }\n    if (!arx.eq(brx)) {\n      const ay = ary.minus(aly);\n      const ax = arx.minus(alx);\n      const by = bry.minus(bly);\n      const bx = brx.minus(blx);\n      if (ay.isGreaterThan(ax) && by.isLessThan(bx)) return 1;\n      if (ay.isLessThan(ax) && by.isGreaterThan(bx)) return -1;\n    }\n    if (arx.isGreaterThan(brx)) return 1;\n    if (arx.isLessThan(brx)) return -1;\n    if (ary.isLessThan(bry)) return -1;\n    if (ary.isGreaterThan(bry)) return 1;\n    if (a.id < b.id) return -1;\n    if (a.id > b.id) return 1;\n    return 0;\n  }\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings;\n  }\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding;\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n    if (cmpPts < 0) {\n      leftPt = pt1;\n      rightPt = pt2;\n      winding = 1;\n    } else if (cmpPts > 0) {\n      leftPt = pt2;\n      rightPt = pt1;\n      winding = -1;\n    } else\n      throw new Error(\n        `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`\n      );\n    const leftSE = new SweepEvent(leftPt, true);\n    const rightSE = new SweepEvent(rightPt, false);\n    return new _Segment(leftSE, rightSE, [ring], [winding]);\n  }\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE;\n    this.rightSE.segment = this;\n    this.rightSE.otherSE = this.leftSE;\n    this.leftSE.otherSE = this.rightSE;\n  }\n  bbox() {\n    const y1 = this.leftSE.point.y;\n    const y2 = this.rightSE.point.y;\n    return {\n      ll: { x: this.leftSE.point.x, y: y1.isLessThan(y2) ? y1 : y2 },\n      ur: { x: this.rightSE.point.x, y: y1.isGreaterThan(y2) ? y1 : y2 }\n    };\n  }\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x.minus(this.leftSE.point.x),\n      y: this.rightSE.point.y.minus(this.leftSE.point.y)\n    };\n  }\n  isAnEndpoint(pt) {\n    return pt.x.eq(this.leftSE.point.x) && pt.y.eq(this.leftSE.point.y) || pt.x.eq(this.rightSE.point.x) && pt.y.eq(this.rightSE.point.y);\n  }\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    return precision.orient(this.leftSE.point, point, this.rightSE.point);\n  }\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    const tBbox = this.bbox();\n    const oBbox = other.bbox();\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n    if (bboxOverlap === null) return null;\n    const tlp = this.leftSE.point;\n    const trp = this.rightSE.point;\n    const olp = other.leftSE.point;\n    const orp = other.rightSE.point;\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n    if (touchesThisLSE && touchesOtherLSE) {\n      if (touchesThisRSE && !touchesOtherRSE) return trp;\n      if (!touchesThisRSE && touchesOtherRSE) return orp;\n      return null;\n    }\n    if (touchesThisLSE) {\n      if (touchesOtherRSE) {\n        if (tlp.x.eq(orp.x) && tlp.y.eq(orp.y)) return null;\n      }\n      return tlp;\n    }\n    if (touchesOtherLSE) {\n      if (touchesThisRSE) {\n        if (trp.x.eq(olp.x) && trp.y.eq(olp.y)) return null;\n      }\n      return olp;\n    }\n    if (touchesThisRSE && touchesOtherRSE) return null;\n    if (touchesThisRSE) return trp;\n    if (touchesOtherRSE) return orp;\n    const pt = intersection(tlp, this.vector(), olp, other.vector());\n    if (pt === null) return null;\n    if (!isInBbox(bboxOverlap, pt)) return null;\n    return precision.snap(pt);\n  }\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = [];\n    const alreadyLinked = point.events !== void 0;\n    const newLeftSE = new SweepEvent(point, true);\n    const newRightSE = new SweepEvent(point, false);\n    const oldRightSE = this.rightSE;\n    this.replaceRightSE(newRightSE);\n    newEvents.push(newRightSE);\n    newEvents.push(newLeftSE);\n    const newSeg = new _Segment(\n      newLeftSE,\n      oldRightSE,\n      this.rings.slice(),\n      this.windings.slice()\n    );\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents();\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents();\n    }\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming();\n      newRightSE.checkForConsuming();\n    }\n    return newEvents;\n  }\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE;\n    this.rightSE = this.leftSE;\n    this.leftSE = tmpEvt;\n    this.leftSE.isLeft = true;\n    this.rightSE.isLeft = false;\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1;\n    }\n  }\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this;\n    let consumee = other;\n    while (consumer.consumedBy) consumer = consumer.consumedBy;\n    while (consumee.consumedBy) consumee = consumee.consumedBy;\n    const cmp = _Segment.compare(consumer, consumee);\n    if (cmp === 0) return;\n    if (cmp > 0) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    if (consumer.prev === consumee) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i];\n      const winding = consumee.windings[i];\n      const index = consumer.rings.indexOf(ring);\n      if (index === -1) {\n        consumer.rings.push(ring);\n        consumer.windings.push(winding);\n      } else consumer.windings[index] += winding;\n    }\n    consumee.rings = null;\n    consumee.windings = null;\n    consumee.consumedBy = consumer;\n    consumee.leftSE.consumedBy = consumer.leftSE;\n    consumee.rightSE.consumedBy = consumer.rightSE;\n  }\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== void 0) return this._prevInResult;\n    if (!this.prev) this._prevInResult = null;\n    else if (this.prev.isInResult()) this._prevInResult = this.prev;\n    else this._prevInResult = this.prev.prevInResult();\n    return this._prevInResult;\n  }\n  beforeState() {\n    if (this._beforeState !== void 0) return this._beforeState;\n    if (!this.prev)\n      this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };\n    else {\n      const seg = this.prev.consumedBy || this.prev;\n      this._beforeState = seg.afterState();\n    }\n    return this._beforeState;\n  }\n  afterState() {\n    if (this._afterState !== void 0) return this._afterState;\n    const beforeState = this.beforeState();\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    };\n    const ringsAfter = this._afterState.rings;\n    const windingsAfter = this._afterState.windings;\n    const mpsAfter = this._afterState.multiPolys;\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i];\n      const winding = this.windings[i];\n      const index = ringsAfter.indexOf(ring);\n      if (index === -1) {\n        ringsAfter.push(ring);\n        windingsAfter.push(winding);\n      } else windingsAfter[index] += winding;\n    }\n    const polysAfter = [];\n    const polysExclude = [];\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue;\n      const ring = ringsAfter[i];\n      const poly = ring.poly;\n      if (polysExclude.indexOf(poly) !== -1) continue;\n      if (ring.isExterior) polysAfter.push(poly);\n      else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n        const index = polysAfter.indexOf(ring.poly);\n        if (index !== -1) polysAfter.splice(index, 1);\n      }\n    }\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly;\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n    }\n    return this._afterState;\n  }\n  /* Is this segment part of the final result? */\n  isInResult() {\n    if (this.consumedBy) return false;\n    if (this._isInResult !== void 0) return this._isInResult;\n    const mpsBefore = this.beforeState().multiPolys;\n    const mpsAfter = this.afterState().multiPolys;\n    switch (operation_default.type) {\n      case \"union\": {\n        const noBefores = mpsBefore.length === 0;\n        const noAfters = mpsAfter.length === 0;\n        this._isInResult = noBefores !== noAfters;\n        break;\n      }\n      case \"intersection\": {\n        let least;\n        let most;\n        if (mpsBefore.length < mpsAfter.length) {\n          least = mpsBefore.length;\n          most = mpsAfter.length;\n        } else {\n          least = mpsAfter.length;\n          most = mpsBefore.length;\n        }\n        this._isInResult = most === operation_default.numMultiPolys && least < most;\n        break;\n      }\n      case \"xor\": {\n        const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n        this._isInResult = diff % 2 === 1;\n        break;\n      }\n      case \"difference\": {\n        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;\n        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n        break;\n      }\n    }\n    return this._isInResult;\n  }\n};\n\n// src/geom-in.ts\nvar RingIn = class {\n  poly;\n  isExterior;\n  segments;\n  bbox;\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n    if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    const firstPoint = precision.snap({ x: new BigNumber2(geomRing[0][0]), y: new BigNumber2(geomRing[0][1]) });\n    this.bbox = {\n      ll: { x: firstPoint.x, y: firstPoint.y },\n      ur: { x: firstPoint.x, y: firstPoint.y }\n    };\n    let prevPoint = firstPoint;\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      const point = precision.snap({ x: new BigNumber2(geomRing[i][0]), y: new BigNumber2(geomRing[i][1]) });\n      if (point.x.eq(prevPoint.x) && point.y.eq(prevPoint.y)) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = point.x;\n      if (point.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = point.y;\n      if (point.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = point.x;\n      if (point.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    }\n    if (!firstPoint.x.eq(prevPoint.x) || !firstPoint.y.eq(prevPoint.y)) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i];\n      sweepEvents.push(segment.leftSE);\n      sweepEvents.push(segment.rightSE);\n    }\n    return sweepEvents;\n  }\n};\nvar PolyIn = class {\n  multiPoly;\n  exteriorRing;\n  interiorRings;\n  bbox;\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    this.bbox = {\n      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },\n      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }\n    };\n    this.interiorRings = [];\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n    this.multiPoly = multiPoly;\n  }\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents();\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n};\nvar MultiPolyIn = class {\n  isSubject;\n  polys;\n  bbox;\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    try {\n      if (typeof geom[0][0][0] === \"number\") geom = [geom];\n    } catch (ex) {\n    }\n    this.polys = [];\n    this.bbox = {\n      ll: { x: new BigNumber2(Number.POSITIVE_INFINITY), y: new BigNumber2(Number.POSITIVE_INFINITY) },\n      ur: { x: new BigNumber2(Number.NEGATIVE_INFINITY), y: new BigNumber2(Number.NEGATIVE_INFINITY) }\n    };\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n    this.isSubject = isSubject;\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents();\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n};\n\n// src/index.ts\nvar union = (geom, ...moreGeoms) => operation_default.run(\"union\", geom, moreGeoms);\nvar intersection2 = (geom, ...moreGeoms) => operation_default.run(\"intersection\", geom, moreGeoms);\nvar xor = (geom, ...moreGeoms) => operation_default.run(\"xor\", geom, moreGeoms);\nvar difference = (geom, ...moreGeoms) => operation_default.run(\"difference\", geom, moreGeoms);\nvar setPrecision = precision.set;\nexport {\n  difference,\n  intersection2 as intersection,\n  setPrecision,\n  union,\n  xor\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport * as polyclip from \"polyclip-ts\";\nimport { polygon, multiPolygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nfunction difference2(features) {\n  const geoms = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least two features\");\n  }\n  const properties = features.features[0].properties || {};\n  const differenced = polyclip.difference(geoms[0], ...geoms.slice(1));\n  if (differenced.length === 0) return null;\n  if (differenced.length === 1) return polygon(differenced[0], properties);\n  return multiPolygon(differenced, properties);\n}\nvar turf_difference_default = difference2;\nexport {\n  turf_difference_default as default,\n  difference2 as difference\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { flattenEach } from \"@turf/meta\";\nimport { featureCollection } from \"@turf/helpers\";\nfunction flatten(geojson) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  var results = [];\n  flattenEach(geojson, function(feature) {\n    results.push(feature);\n  });\n  return featureCollection(results);\n}\nvar turf_flatten_default = flatten;\nexport {\n  turf_flatten_default as default,\n  flatten\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport * as polyclip from \"polyclip-ts\";\nimport { multiPolygon, polygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nfunction union2(features, options = {}) {\n  const geoms = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least 2 geometries\");\n  }\n  const unioned = polyclip.union(geoms[0], ...geoms.slice(1));\n  if (unioned.length === 0) return null;\n  if (unioned.length === 1) return polygon(unioned[0], options.properties);\n  else return multiPolygon(unioned, options.properties);\n}\nvar turf_union_default = union2;\nexport {\n  turf_union_default as default,\n  union2 as union\n};\n//# sourceMappingURL=index.js.map","import type { BBox } from \"./types\";\n\n// taken from Leaflet\nexport function wrapNum(\n  x: number,\n  range: [number, number],\n  includeMax: boolean,\n) {\n  const max = range[1],\n    min = range[0],\n    d = max - min;\n\n  return x === max && includeMax ? x : ((((x - min) % d) + d) % d) + min;\n}\n\nexport function unwrapBbox(bbox0: BBox): BBox {\n  const bbox = [...bbox0] satisfies BBox;\n\n  if (bbox[2] < bbox[0]) {\n    if (\n      Math.abs((bbox[0] + bbox[2] + 360) / 2) >\n      Math.abs((bbox[0] - 360 + bbox[2]) / 2)\n    ) {\n      bbox[0] -= 360;\n    } else {\n      bbox[2] += 360;\n    }\n  }\n\n  return bbox;\n}\n","import bbox from \"@turf/bbox\";\nimport difference from \"@turf/difference\";\nimport flatten from \"@turf/flatten\";\nimport { featureCollection, polygon } from \"@turf/helpers\";\nimport union from \"@turf/union\";\nimport type {\n  Feature,\n  FeatureCollection,\n  MultiPolygon,\n  Polygon,\n} from \"geojson\";\nimport { unwrapBbox } from \"./geoUtils\";\nimport type { BBox } from \"./types\";\n\nexport function setMask(\n  picked: Feature<Polygon | MultiPolygon>,\n  setData: (data?: FeatureCollection<Polygon | MultiPolygon>) => void,\n): void {\n  const diff = difference(\n    featureCollection([\n      polygon([\n        [\n          [180, 90],\n          [-180, 90],\n          [-180, -90],\n          [180, -90],\n          [180, 90],\n        ],\n      ]),\n      picked,\n    ]),\n  );\n\n  if (!diff) {\n    return;\n  }\n\n  diff.properties = { isMask: true };\n\n  const bb = unwrapBbox(bbox(picked) as BBox);\n\n  // bigger features (continents, oceans) have bigger tolerance\n  // because of the used source data simplification\n  const tolerance = (bb[2] - bb[0]) / 360 / 1_000;\n\n  const leaksLeft = bb[0] < -180;\n  const leaksRight = bb[2] > 180;\n\n  const flattened = flatten(picked);\n\n  if (flattened.features.length > 1 && (leaksLeft || leaksRight)) {\n    for (const poly of flattened.features) {\n      const bb = unwrapBbox(bbox(poly) as BBox);\n\n      if (leaksRight && bb[0] < -180 + tolerance) {\n        for (const ring of poly.geometry.coordinates) {\n          for (const position of ring) {\n            position[0] += 360 - tolerance;\n          }\n        }\n      }\n\n      if (leaksLeft && bb[2] > 180 - tolerance) {\n        for (const ring of poly.geometry.coordinates) {\n          for (const position of ring) {\n            position[0] -= 360 - tolerance;\n          }\n        }\n      }\n    }\n  }\n\n  setData(\n    featureCollection([\n      flattened.features.length < 2 ? picked : (union(flattened) ?? picked),\n      diff,\n    ]),\n  );\n}\n","import type { FeatureCollection, MultiPolygon, Polygon } from \"geojson\";\nimport { Feature as OlFeature, type MapBrowserEvent } from \"ol\";\nimport type { FeatureLike } from \"ol/Feature\";\nimport type Map from \"ol/Map\";\nimport type { AnimationOptions, FitOptions } from \"ol/View\";\nimport {\n  GeometryCollection as OlGeometryCollection,\n  LineString as OlLineString,\n  MultiLineString as OlMultiLineString,\n  MultiPolygon as OlMultiPolygon,\n  Point as OlPoint,\n  Polygon as OlPolygon,\n  type Geometry as OlGeometry,\n} from \"ol/geom\";\nimport VectorLayer from \"ol/layer/Vector\";\nimport {\n  fromLonLat,\n  getUserProjection,\n  toLonLat,\n  transformExtent,\n} from \"ol/proj\";\nimport VectorSource from \"ol/source/Vector\";\nimport Fill from \"ol/style/Fill\";\nimport Icon from \"ol/style/Icon\";\nimport Stroke from \"ol/style/Stroke\";\nimport Style, { type StyleLike } from \"ol/style/Style\";\nimport Text from \"ol/style/Text\";\nimport type { FlatStyleLike } from \"ol/style/flat\";\nimport { setMask } from \"./mask\";\nimport type {\n  BBox,\n  Feature as FeatureType,\n  MapController,\n  MapEvent,\n  Position,\n} from \"./types\";\n\nconst EPSG_4326 = \"EPSG:4326\";\n\nfunction defaultStyle(feature: FeatureLike) {\n  const properties = feature.getProperties();\n\n  const { isMask } = properties;\n\n  const type = feature.getGeometry()?.getType();\n\n  const weight = isMask\n    ? 0\n    : type === \"LineString\" || type === \"MultiLineString\"\n      ? 3\n      : 2;\n\n  return new Style({\n    stroke: isMask\n      ? undefined\n      : new Stroke({\n          color: \"#3170fe\",\n          lineDash: [weight, weight],\n          width: weight,\n          lineCap: \"butt\",\n        }),\n    fill: isMask\n      ? new Fill({\n          color: \"#00000020\",\n        })\n      : undefined,\n    image: new Icon({\n      src: `/icons/marker_${\n        properties.isReverse\n          ? \"reverse\"\n          : properties.isSelected\n            ? \"selected\"\n            : \"unselected\"\n      }.svg`,\n      anchor: [0.5, 1],\n    }),\n    zIndex: properties.isSelected ? 2 : properties.isReverse ? 0 : 1,\n    text:\n      properties.isSelected && properties.tooltip\n        ? new Text({\n            backgroundFill: new Fill({ color: \"white\" }),\n            text: properties.tooltip,\n            offsetY: -40,\n            backgroundStroke: new Stroke({\n              color: \"white\",\n              lineJoin: \"round\",\n              width: 3,\n            }),\n            padding: [2, 0, 0, 2],\n          })\n        : undefined,\n  });\n}\n\nexport function createOpenLayersMapController(\n  map: Map,\n  flyToOptions: AnimationOptions = {},\n  flyToBounds: FitOptions = {},\n  fullGeometryStyle: StyleLike | FlatStyleLike = defaultStyle,\n) {\n  let prevSelected = -1;\n\n  let prevHovered: string | undefined;\n\n  let eventHandler: ((e: MapEvent) => void) | undefined;\n\n  let reverseMarker: OlFeature | undefined;\n\n  let indicatingReverse = false;\n\n  const vectorLayer = new VectorLayer({\n    updateWhileAnimating: true,\n  });\n\n  map.addLayer(vectorLayer);\n\n  const source = new VectorSource({});\n\n  vectorLayer.setSource(source);\n\n  vectorLayer.setStyle(fullGeometryStyle);\n\n  map.on(\"click\", (e) => {\n    map.forEachFeatureAtPixel(e.pixel, (feature) => {\n      const id = feature.getId() as string;\n\n      if (!id) {\n        return;\n      }\n\n      e.stopPropagation();\n\n      eventHandler?.({ type: \"markerClick\", id });\n\n      return feature;\n    });\n  });\n\n  map.on(\"pointermove\", (e) => {\n    const featureId = map.forEachFeatureAtPixel(e.pixel, (feature) => {\n      return feature.getId() as string | undefined;\n    });\n\n    if (prevHovered === featureId) {\n      return;\n    }\n\n    if (prevHovered) {\n      eventHandler?.({\n        type: \"markerMouseLeave\",\n        id: prevHovered,\n      });\n    }\n\n    if (featureId) {\n      eventHandler?.({\n        type: \"markerMouseEnter\",\n        id: featureId,\n      });\n    }\n\n    map.getTargetElement().style.cursor = featureId\n      ? \"pointer\"\n      : indicatingReverse\n        ? \"crosshair\"\n        : \"\";\n\n    prevHovered = featureId;\n  });\n\n  function getProjection() {\n    return getUserProjection() ?? map.getView().getProjection();\n  }\n\n  function fromWgs84(geometry: OlGeometry) {\n    return geometry.transform(EPSG_4326, getProjection());\n  }\n\n  const handleMapClick = (e: MapBrowserEvent<PointerEvent>) => {\n    eventHandler?.({\n      type: \"mapClick\",\n      coordinates: toLonLat(e.coordinate, getProjection()) as [number, number],\n    });\n  };\n\n  return {\n    setEventHandler(handler: undefined | ((e: MapEvent) => void)): void {\n      if (handler) {\n        eventHandler = handler;\n        map.on(\"click\", handleMapClick);\n      } else {\n        eventHandler = undefined;\n        map.un(\"click\", handleMapClick);\n      }\n    },\n\n    flyTo(center: Position, zoom: number) {\n      map.getView().animate({\n        center: fromLonLat(center, getProjection()),\n        ...(zoom ? { zoom } : {}),\n        duration: 2000,\n        ...flyToOptions,\n      });\n    },\n\n    fitBounds(bbox: BBox, padding: number, maxZoom: number): void {\n      map.getView().fit(transformExtent(bbox, EPSG_4326, getProjection()), {\n        padding: [padding, padding, padding, padding],\n        ...(maxZoom ? { maxZoom } : {}),\n        duration: 2000,\n        ...flyToBounds,\n      });\n    },\n\n    indicateReverse(reverse: boolean): void {\n      indicatingReverse = reverse;\n\n      map.getTargetElement().style.cursor = reverse ? \"crosshair\" : \"\";\n    },\n\n    setReverseMarker(coordinates?: Position) {\n      if (reverseMarker) {\n        if (!coordinates) {\n          source.removeFeature(reverseMarker);\n\n          reverseMarker.dispose();\n\n          reverseMarker = undefined;\n        } else {\n          (reverseMarker.getGeometry() as OlPoint).setCoordinates(\n            fromLonLat(coordinates, getProjection()),\n          );\n        }\n      } else if (coordinates) {\n        reverseMarker = new OlFeature(\n          new OlPoint(fromLonLat(coordinates, getProjection())),\n        );\n\n        reverseMarker.setProperties({ isReverse: true });\n\n        source.addFeature(reverseMarker);\n      }\n    },\n\n    setFeatures(\n      markedFeatures: FeatureType[] | undefined,\n      picked: FeatureType | undefined,\n      showPolygonMarker: boolean,\n    ): void {\n      function setData(data?: FeatureCollection<Polygon | MultiPolygon>) {\n        if (!data) {\n          return;\n        }\n\n        for (const f of data.features) {\n          const geom =\n            f.geometry.type === \"Polygon\"\n              ? new OlPolygon(f.geometry.coordinates)\n              : f.geometry.type === \"MultiPolygon\"\n                ? new OlMultiPolygon(f.geometry.coordinates)\n                : null;\n\n          if (!geom) {\n            continue;\n          }\n\n          source.addFeature(\n            new OlFeature({\n              isMask: !!f.properties?.isMask,\n              geometry: fromWgs84(geom),\n            }),\n          );\n        }\n      }\n\n      source.clear();\n\n      if (reverseMarker) {\n        source.addFeature(reverseMarker);\n      }\n\n      block: if (picked) {\n        let handled = false;\n\n        if (picked.geometry.type === \"GeometryCollection\") {\n          const geoms = picked.geometry.geometries\n            .map((geometry) =>\n              geometry.type === \"Polygon\"\n                ? new OlPolygon(geometry.coordinates)\n                : geometry.type === \"MultiPolygon\"\n                  ? new OlMultiPolygon(geometry.coordinates)\n                  : null,\n            )\n            .filter(<T>(a: T | null): a is T => !!a);\n\n          if (geoms.length > 0) {\n            source.addFeature(\n              new OlFeature(fromWgs84(new OlGeometryCollection(geoms))),\n            );\n\n            handled = true;\n          } else {\n            for (const geometry of picked.geometry.geometries) {\n              if (geometry.type === \"LineString\") {\n                source.addFeature(\n                  new OlFeature(\n                    fromWgs84(new OlLineString(geometry.coordinates)),\n                  ),\n                );\n\n                handled = true;\n              } else if (geometry.type === \"MultiLineString\") {\n                source.addFeature(\n                  new OlFeature(\n                    fromWgs84(new OlMultiLineString(geometry.coordinates)),\n                  ),\n                );\n              }\n\n              handled = true;\n            }\n          }\n        }\n\n        if (handled) {\n          // nothing\n        } else if (picked.geometry.type === \"Polygon\") {\n          setMask(picked as FeatureType<Polygon>, setData);\n        } else if (picked.geometry.type === \"MultiPolygon\") {\n          setMask(picked as FeatureType<MultiPolygon>, setData);\n        } else if (picked.geometry.type === \"LineString\") {\n          source.addFeature(\n            new OlFeature(\n              fromWgs84(new OlLineString(picked.geometry.coordinates)),\n            ),\n          );\n\n          break block; // no pin for (multi)linestrings\n        } else if (picked.geometry.type === \"MultiLineString\") {\n          source.addFeature(\n            new OlFeature(\n              fromWgs84(new OlMultiLineString(picked.geometry.coordinates)),\n            ),\n          );\n\n          break block; // no pin for (multi)linestrings\n        }\n\n        if (!showPolygonMarker && !picked.geometry.type.endsWith(\"Point\")) {\n          break block;\n        }\n\n        source.addFeature(new OlFeature(fromWgs84(new OlPoint(picked.center))));\n      }\n\n      for (const feature of markedFeatures ?? []) {\n        if (feature === picked) {\n          continue;\n        }\n\n        const marker = new OlFeature(\n          new OlPoint(fromLonLat(feature.center, getProjection())),\n        );\n\n        marker.setId(feature.id);\n\n        marker.setProperties({\n          fuzzy: !!feature.matching_text,\n          tooltip:\n            feature.place_type[0] === \"reverse\"\n              ? feature.place_name\n              : feature.place_name.replace(/,.*/, \"\"),\n        });\n\n        source.addFeature(marker);\n      }\n    },\n\n    setSelectedMarker(index: number): void {\n      const features = source.getFeatures();\n\n      const offset = features[0]?.getProperties().isReverse ? 1 : 0;\n\n      if (prevSelected > -1) {\n        features[prevSelected + offset]?.setProperties({\n          isSelected: false,\n        });\n      }\n\n      if (index > -1) {\n        features[index + offset]?.setProperties({\n          isSelected: true,\n        });\n      }\n\n      prevSelected = index;\n    },\n\n    getCenterAndZoom() {\n      const view = map.getView();\n\n      const center = view.getCenter();\n\n      const zoom = view.getZoom();\n\n      if (!center || zoom === undefined) {\n        return undefined;\n      }\n\n      return [zoom, ...(toLonLat(center, getProjection()) as Position)];\n    },\n  } satisfies MapController;\n}\n"],"names":["feature","geom","properties","options","feat","polygon","coordinates","ring","j","featureCollection","features","fc","multiPolygon","coordEach","geojson","callback","excludeWrapCoord","k","l","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","geomEach","i","g","featureProperties","featureBBox","featureId","flattenEach","bbox","id","coordinate","result","coord","turf_bbox_default","isNumeric","mathceil","mathfloor","bignumberError","tooManyDigits","BASE","LOG_BASE","MAX_SAFE_INTEGER","POWS_TEN","SQRT_BASE","MAX","clone","configObject","div","convertBase","parseNumeric","P","BigNumber","ONE","DECIMAL_PLACES","ROUNDING_MODE","TO_EXP_NEG","TO_EXP_POS","MIN_EXP","MAX_EXP","CRYPTO","MODULO_MODE","POW_PRECISION","FORMAT","ALPHABET","alphabetHasNormalDecimalDigits","v","b","alphabet","c","caseChanged","e","isNum","len","str","x","intCheck","round","obj","p","n","s","out","maxOrMin","pow2_53","random53bitInt","dp","a","rand","args","sum","decimal","toBaseOut","baseIn","baseOut","arr","arrL","sign","callerIsToString","d","r","xc","y","rm","toFixedPoint","coeffToString","multiply","base","m","temp","xlo","xhi","carry","klo","khi","compare","aL","bL","cmp","subtract","more","prod","prodL","q","qc","rem","remL","rem0","xi","xL","yc0","yL","yz","yc","bitFloor","format","c0","ne","toExponential","normalise","basePrefix","dotAfter","dotBefore","isInfinityOrNaN","whitespaceOrPlus","p1","p2","sd","ni","rd","pows10","valueOf","half","isModExp","nIsBig","nIsNeg","nIsOdd","isOdd","t","xLTy","xe","ye","xcL","ycL","ylo","yhi","zc","sqrtBase","rep","g1","g2","groupSeparator","intPart","fractionPart","isNeg","intDigits","md","d0","d1","d2","exp","n0","n1","z","min","max","name","zs","SplayTreeNode","key","__publicField","SplayTreeSetNode","SplayTree","root","right","newTreeRight","left","newTreeLeft","current","comp","currentLeft","currentRight","node","nextLeft","nextRight","count","SplayTreeSet","_SplayTreeSet","isValidKey","_a","element","elements","f","nodes","nodeRight","nodeLeft","retainSet","modificationCount","object","other","u","set","copyChildren","node2","dest","newLeft","newRight","SplayTreeSetEntryIterableIterator","_b","SplayTreeKeyIterableIterator","SplayTreeIterableIterator","tree","next","constant_default","compare_default","eps","almostEqual","orient_default","almostCollinear","area2","ax","ay","cx","cy","identity_default","snap_default","xTree","yTree","snapCoord","snap","eps2","precision","isInBbox","point","getBboxOverlap","b1","b2","lowerX","upperX","lowerY","upperY","crossProduct","dotProduct","length","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection","pt1","v1","pt2","v2","kross","ve","x1","x2","y1","y2","SweepEvent","_SweepEvent","isLeft","ptCmp","Segment","aPt","bPt","otherEvents","iMax","evt","numEvents","evt1","evt2","events","baseEvent","cache","fillCache","linkedEvent","nextEvent","asine","acosine","bsine","bcosine","RingOut","_RingOut","allSegments","ringsOut","segment","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","jMax","intersectionLE","ringEvents","comparator","prevPt","points","nextPt2","nextPt","step","iStart","iEnd","orderedPoints","enclosing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","exteriorRing","geom0","ringGeom","MultiPolyOut","rings","polyGeom","polys","enclosingRing","SweepLine","queue","SplayTreeSet2","newEvents","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","nextMySplitter","nextInter","mySplitter","inter","seg","rightSE","Operation","moreGeoms","operation","multipolys","MultiPolyIn","subject","mpA","SplayTreeSet3","sweepEvents","sweepLine","operation_default","segmentId","_Segment","leftSE","windings","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","bCmpARight","bCmpALeft","aCmpBRight","by","bx","leftPt","rightPt","winding","cmpPts","newRightSE","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","alreadyLinked","newLeftSE","oldRightSE","newSeg","tmpEvt","consumer","consumee","tmp","index","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","poly","mp","mpsBefore","noBefores","noAfters","least","most","diff","isJustSubject","mps","RingIn","geomRing","isExterior","firstPoint","BigNumber2","prevPoint","PolyIn","geomPoly","multiPoly","ringSweepEvents","isSubject","polySweepEvents","union","difference","difference2","geoms","differenced","polyclip.difference","turf_difference_default","flatten","results","turf_flatten_default","union2","unioned","polyclip.union","turf_union_default","unwrapBbox","bbox0","setMask","picked","setData","bb","tolerance","leaksLeft","leaksRight","flattened","position","EPSG_4326","defaultStyle","isMask","weight","Style","Stroke","Fill","Icon","Text","createOpenLayersMapController","map","flyToOptions","flyToBounds","fullGeometryStyle","prevSelected","prevHovered","eventHandler","reverseMarker","indicatingReverse","vectorLayer","VectorLayer","source","VectorSource","getProjection","getUserProjection","fromWgs84","handleMapClick","toLonLat","handler","center","zoom","fromLonLat","padding","maxZoom","transformExtent","reverse","OlFeature","OlPoint","markedFeatures","showPolygonMarker","data","OlPolygon","OlMultiPolygon","block","handled","OlGeometryCollection","OlLineString","OlMultiLineString","marker","offset","_c","view"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}