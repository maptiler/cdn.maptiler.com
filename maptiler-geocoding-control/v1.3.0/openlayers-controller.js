var Wp = Object.defineProperty;
var Up = (i, t, e) => t in i ? Wp(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var Oh = (i, t, e) => Up(i, typeof t != "symbol" ? t + "" : t, e);
import { Feature as yn } from "ol";
class ks {
  /**
   * @param {string} type Type.
   */
  constructor(t) {
    this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
const Ig = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class jp {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function Vp(i, t, e) {
  let r, s;
  e = e || Ei;
  let u = 0, h = i.length, f = !1;
  for (; u < h; )
    r = u + (h - u >> 1), s = +e(i[r], t), s < 0 ? u = r + 1 : (h = r, f = !s);
  return f ? u : ~u;
}
function Ei(i, t) {
  return i > t ? 1 : i < t ? -1 : 0;
}
function wg(i, t, e) {
  if (i[0] <= t)
    return 0;
  const r = i.length;
  if (t <= i[r - 1])
    return r - 1;
  if (typeof e == "function") {
    for (let s = 1; s < r; ++s) {
      const u = i[s];
      if (u === t)
        return s;
      if (u < t)
        return e(t, i[s - 1], u) > 0 ? s - 1 : s;
    }
    return r - 1;
  }
  if (e > 0) {
    for (let s = 1; s < r; ++s)
      if (i[s] < t)
        return s - 1;
    return r - 1;
  }
  if (e < 0) {
    for (let s = 1; s < r; ++s)
      if (i[s] <= t)
        return s;
    return r - 1;
  }
  for (let s = 1; s < r; ++s) {
    if (i[s] == t)
      return s;
    if (i[s] < t)
      return i[s - 1] - t < t - i[s] ? s - 1 : s;
  }
  return r - 1;
}
function Zp(i, t, e) {
  for (; t < e; ) {
    const r = i[t];
    i[t] = i[e], i[e] = r, ++t, --e;
  }
}
function on(i, t) {
  const e = Array.isArray(t) ? t : [t], r = e.length;
  for (let s = 0; s < r; s++)
    i[i.length] = e[s];
}
function xr(i, t) {
  const e = i.length;
  if (e !== t.length)
    return !1;
  for (let r = 0; r < e; r++)
    if (i[r] !== t[r])
      return !1;
  return !0;
}
function Hp() {
  return !0;
}
function as() {
}
function kg(i) {
  let t = !1, e, r, s;
  return function() {
    const u = Array.prototype.slice.call(arguments);
    return (!t || this !== s || !xr(u, r)) && (t = !0, s = this, r = u, e = i.apply(this, arguments)), e;
  };
}
function rl(i) {
  for (const t in i)
    delete i[t];
}
function hr(i) {
  let t;
  for (t in i)
    return !1;
  return !t;
}
class Cg extends jp {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(t) {
    super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(t, e) {
    if (!t || !e)
      return;
    const r = this.listeners_ || (this.listeners_ = {}), s = r[t] || (r[t] = []);
    s.includes(e) || s.push(e);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(t) {
    const e = typeof t == "string", r = e ? t : t.type, s = this.listeners_ && this.listeners_[r];
    if (!s)
      return;
    const u = e ? new ks(t) : (
      /** @type {Event} */
      t
    );
    u.target || (u.target = this.eventTarget_ || this);
    const h = this.dispatching_ || (this.dispatching_ = {}), f = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    r in h || (h[r] = 0, f[r] = 0), ++h[r];
    let g;
    for (let y = 0, p = s.length; y < p; ++y)
      if ("handleEvent" in s[y] ? g = /** @type {import("../events.js").ListenerObject} */
      s[y].handleEvent(u) : g = /** @type {import("../events.js").ListenerFunction} */
      s[y].call(this, u), g === !1 || u.propagationStopped) {
        g = !1;
        break;
      }
    if (--h[r] === 0) {
      let y = f[r];
      for (delete f[r]; y--; )
        this.removeEventListener(r, as);
      delete h[r];
    }
    return g;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && rl(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(t) {
    return this.listeners_ && this.listeners_[t] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(t) {
    return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(t, e) {
    if (!this.listeners_)
      return;
    const r = this.listeners_[t];
    if (!r)
      return;
    const s = r.indexOf(e);
    s !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (r[s] = as, ++this.pendingRemovals_[t]) : (r.splice(s, 1), r.length === 0 && delete this.listeners_[t]));
  }
}
const Ue = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function En(i, t, e, r, s) {
  if (r && r !== i && (e = e.bind(r)), s) {
    const h = e;
    e = function() {
      i.removeEventListener(t, e), h.apply(this, arguments);
    };
  }
  const u = {
    target: i,
    type: t,
    listener: e
  };
  return i.addEventListener(t, e), u;
}
function Lh(i, t, e, r) {
  return En(i, t, e, r, !0);
}
function Hn(i) {
  i && i.target && (i.target.removeEventListener(i.type, i.listener), rl(i));
}
class Cs extends Cg {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(Ue.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(t, e) {
    if (Array.isArray(t)) {
      const r = t.length, s = new Array(r);
      for (let u = 0; u < r; ++u)
        s[u] = En(this, t[u], e);
      return s;
    }
    return En(
      this,
      /** @type {string} */
      t,
      e
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(t, e) {
    let r;
    if (Array.isArray(t)) {
      const s = t.length;
      r = new Array(s);
      for (let u = 0; u < s; ++u)
        r[u] = Lh(this, t[u], e);
    } else
      r = Lh(
        this,
        /** @type {string} */
        t,
        e
      );
    return e.ol_key = r, r;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(t, e) {
    const r = (
      /** @type {Object} */
      e.ol_key
    );
    if (r)
      Jp(r);
    else if (Array.isArray(t))
      for (let s = 0, u = t.length; s < u; ++s)
        this.removeEventListener(t[s], e);
    else
      this.removeEventListener(t, e);
  }
}
Cs.prototype.on;
Cs.prototype.once;
Cs.prototype.un;
function Jp(i) {
  if (Array.isArray(i))
    for (let t = 0, e = i.length; t < e; ++t)
      Hn(i[t]);
  else
    Hn(
      /** @type {import("./events.js").EventsKey} */
      i
    );
}
function Tt() {
  throw new Error("Unimplemented abstract method.");
}
let Kp = 0;
function jt(i) {
  return i.ol_uid || (i.ol_uid = String(++Kp));
}
class Ah extends ks {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(t, e, r) {
    super(t), this.key = e, this.oldValue = r;
  }
}
class Er extends Cs {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, jt(this), this.values_ = null, t !== void 0 && this.setProperties(t);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(t) {
    let e;
    return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(t, e) {
    let r;
    r = `change:${t}`, this.hasListener(r) && this.dispatchEvent(new Ah(r, t, e)), r = Ig.PROPERTYCHANGE, this.hasListener(r) && this.dispatchEvent(new Ah(r, t, e));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(t, e) {
    this.addEventListener(`change:${t}`, e);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(t, e) {
    this.removeEventListener(`change:${t}`, e);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(t, e, r) {
    const s = this.values_ || (this.values_ = {});
    if (r)
      s[t] = e;
    else {
      const u = s[t];
      s[t] = e, u !== e && this.notify(t, u);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(t, e) {
    for (const r in t)
      this.set(r, t[r], e);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(t) {
    t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(t, e) {
    if (this.values_ && t in this.values_) {
      const r = this.values_[t];
      delete this.values_[t], hr(this.values_) && (this.values_ = null), e || this.notify(t, r);
    }
  }
}
function te(i, t) {
  if (!i)
    throw new Error(t);
}
new Array(6);
function Sn() {
  return [1, 0, 0, 1, 0, 0];
}
function Qp(i, t) {
  return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i;
}
function le(i, t) {
  const e = t[0], r = t[1];
  return t[0] = i[0] * e + i[2] * r + i[4], t[1] = i[1] * e + i[3] * r + i[5], t;
}
function Oi(i, t, e, r, s, u, h, f) {
  const g = Math.sin(u), y = Math.cos(u);
  return i[0] = r * y, i[1] = s * g, i[2] = -r * g, i[3] = s * y, i[4] = h * r * y - f * r * g + t, i[5] = h * s * g + f * s * y + e, i;
}
function tm(i, t) {
  const e = em(t);
  te(e !== 0, "Transformation matrix cannot be inverted");
  const r = t[0], s = t[1], u = t[2], h = t[3], f = t[4], g = t[5];
  return i[0] = h / e, i[1] = -s / e, i[2] = -u / e, i[3] = r / e, i[4] = (u * g - h * f) / e, i[5] = -(r * g - s * f) / e, i;
}
function em(i) {
  return i[0] * i[3] - i[1] * i[2];
}
const Ph = [1e6, 1e6, 1e6, 1e6, 2, 2];
function nm(i) {
  return "matrix(" + i.map(
    (e, r) => Math.round(e * Ph[r]) / Ph[r]
  ).join(", ") + ")";
}
const Xt = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function im(i, t, e) {
  const r = Math.min.apply(null, i), s = Math.min.apply(null, t), u = Math.max.apply(null, i), h = Math.max.apply(null, t);
  return Ci(r, s, u, h, e);
}
function sl(i, t, e) {
  return e ? (e[0] = i[0] - t, e[1] = i[1] - t, e[2] = i[2] + t, e[3] = i[3] + t, e) : [
    i[0] - t,
    i[1] - t,
    i[2] + t,
    i[3] + t
  ];
}
function rm(i, t) {
  return i.slice();
}
function Li(i, t, e) {
  let r, s;
  return t < i[0] ? r = i[0] - t : i[2] < t ? r = t - i[2] : r = 0, e < i[1] ? s = i[1] - e : i[3] < e ? s = e - i[3] : s = 0, r * r + s * s;
}
function du(i, t) {
  return ol(i, t[0], t[1]);
}
function rr(i, t) {
  return i[0] <= t[0] && t[2] <= i[2] && i[1] <= t[1] && t[3] <= i[3];
}
function ol(i, t, e) {
  return i[0] <= t && t <= i[2] && i[1] <= e && e <= i[3];
}
function yu(i, t) {
  const e = i[0], r = i[1], s = i[2], u = i[3], h = t[0], f = t[1];
  let g = Xt.UNKNOWN;
  return h < e ? g = g | Xt.LEFT : h > s && (g = g | Xt.RIGHT), f < r ? g = g | Xt.BELOW : f > u && (g = g | Xt.ABOVE), g === Xt.UNKNOWN && (g = Xt.INTERSECTING), g;
}
function ki() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function Ci(i, t, e, r, s) {
  return s ? (s[0] = i, s[1] = t, s[2] = e, s[3] = r, s) : [i, t, e, r];
}
function Jo(i) {
  return Ci(1 / 0, 1 / 0, -1 / 0, -1 / 0, i);
}
function Rg(i, t) {
  const e = i[0], r = i[1];
  return Ci(e, r, e, r, t);
}
function al(i, t, e, r, s) {
  const u = Jo(s);
  return Tg(u, i, t, e, r);
}
function bg(i, t) {
  return i[0] == t[0] && i[2] == t[2] && i[1] == t[1] && i[3] == t[3];
}
function sm(i, t) {
  return t[0] < i[0] && (i[0] = t[0]), t[2] > i[2] && (i[2] = t[2]), t[1] < i[1] && (i[1] = t[1]), t[3] > i[3] && (i[3] = t[3]), i;
}
function om(i, t) {
  t[0] < i[0] && (i[0] = t[0]), t[0] > i[2] && (i[2] = t[0]), t[1] < i[1] && (i[1] = t[1]), t[1] > i[3] && (i[3] = t[1]);
}
function Tg(i, t, e, r, s) {
  for (; e < r; e += s)
    am(i, t[e], t[e + 1]);
  return i;
}
function am(i, t, e) {
  i[0] = Math.min(i[0], t), i[1] = Math.min(i[1], e), i[2] = Math.max(i[2], t), i[3] = Math.max(i[3], e);
}
function um(i, t) {
  let e;
  return e = t(Ng(i)), e || (e = t(Mg(i)), e) || (e = t(Lg(i)), e) || (e = t(Og(i)), e) ? e : !1;
}
function Ng(i) {
  return [i[0], i[1]];
}
function Mg(i) {
  return [i[2], i[1]];
}
function Ri(i) {
  return [(i[0] + i[2]) / 2, (i[1] + i[3]) / 2];
}
function lm(i, t, e, r, s) {
  const [u, h, f, g, y, p, m, _] = hm(
    i,
    t,
    e,
    r
  );
  return Ci(
    Math.min(u, f, y, m),
    Math.min(h, g, p, _),
    Math.max(u, f, y, m),
    Math.max(h, g, p, _),
    s
  );
}
function hm(i, t, e, r) {
  const s = t * r[0] / 2, u = t * r[1] / 2, h = Math.cos(e), f = Math.sin(e), g = s * h, y = s * f, p = u * h, m = u * f, _ = i[0], x = i[1];
  return [
    _ - g + m,
    x - y - p,
    _ - g - m,
    x - y + p,
    _ + g - m,
    x + y + p,
    _ + g + m,
    x + y - p,
    _ - g + m,
    x - y - p
  ];
}
function Cn(i) {
  return i[3] - i[1];
}
function Og(i) {
  return [i[0], i[3]];
}
function Lg(i) {
  return [i[2], i[3]];
}
function he(i) {
  return i[2] - i[0];
}
function qe(i, t) {
  return i[0] <= t[2] && i[2] >= t[0] && i[1] <= t[3] && i[3] >= t[1];
}
function ul(i) {
  return i[2] < i[0] || i[3] < i[1];
}
function cm(i, t) {
  return t ? (t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t) : i;
}
function fm(i, t, e) {
  let r = !1;
  const s = yu(i, t), u = yu(i, e);
  if (s === Xt.INTERSECTING || u === Xt.INTERSECTING)
    r = !0;
  else {
    const h = i[0], f = i[1], g = i[2], y = i[3], p = t[0], m = t[1], _ = e[0], x = e[1], I = (x - m) / (_ - p);
    let k, C;
    u & Xt.ABOVE && !(s & Xt.ABOVE) && (k = _ - (x - y) / I, r = k >= h && k <= g), !r && u & Xt.RIGHT && !(s & Xt.RIGHT) && (C = x - (_ - g) * I, r = C >= f && C <= y), !r && u & Xt.BELOW && !(s & Xt.BELOW) && (k = _ - (x - f) / I, r = k >= h && k <= g), !r && u & Xt.LEFT && !(s & Xt.LEFT) && (C = x - (_ - h) * I, r = C >= f && C <= y);
  }
  return r;
}
function gm(i, t, e, r) {
  if (ul(i))
    return Jo(e);
  let s = [];
  s = [
    i[0],
    i[1],
    i[2],
    i[1],
    i[2],
    i[3],
    i[0],
    i[3]
  ], t(s, s, 2);
  const u = [], h = [];
  for (let f = 0, g = s.length; f < g; f += 2)
    u.push(s[f]), h.push(s[f + 1]);
  return im(u, h, e);
}
function Ag(i, t) {
  const e = t.getExtent(), r = Ri(i);
  if (t.canWrapX() && (r[0] < e[0] || r[0] >= e[2])) {
    const s = he(e), h = Math.floor(
      (r[0] - e[0]) / s
    ) * s;
    i[0] -= h, i[2] -= h;
  }
  return i;
}
function dm(i, t) {
  if (t.canWrapX()) {
    const e = t.getExtent();
    if (!isFinite(i[0]) || !isFinite(i[2]))
      return [[e[0], i[1], e[2], i[3]]];
    Ag(i, t);
    const r = he(e);
    if (he(i) > r)
      return [[e[0], i[1], e[2], i[3]]];
    if (i[0] < e[0])
      return [
        [i[0] + r, i[1], e[2], i[3]],
        [e[0], i[1], i[2], i[3]]
      ];
    if (i[2] > e[2])
      return [
        [i[0], i[1], e[2], i[3]],
        [e[0], i[1], i[2] - r, i[3]]
      ];
  }
  return [i];
}
const Pg = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class Dg {
  /**
   * @param {Options} options Projection options.
   */
  constructor(t) {
    this.code_ = t.code, this.units_ = /** @type {import("./Units.js").Units} */
    t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || Pg[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(t) {
    this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(t) {
    this.defaultTileGrid_ = t;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(t) {
    this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(t) {
    this.worldExtent_ = t;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(t) {
    this.getPointResolutionFunc_ = t;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const Rs = 6378137, sr = Math.PI * Rs, ym = [-sr, -sr, sr, sr], pm = [-180, -85, 180, 85], Ws = Rs * Math.log(Math.tan(Math.PI / 2));
class Vi extends Dg {
  /**
   * @param {string} code Code.
   */
  constructor(t) {
    super({
      code: t,
      units: "m",
      extent: ym,
      global: !0,
      worldExtent: pm,
      getPointResolution: function(e, r) {
        return e / Math.cosh(r[1] / Rs);
      }
    });
  }
}
const Dh = [
  new Vi("EPSG:3857"),
  new Vi("EPSG:102100"),
  new Vi("EPSG:102113"),
  new Vi("EPSG:900913"),
  new Vi("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new Vi("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function mm(i, t, e) {
  const r = i.length;
  e = e > 1 ? e : 2, t === void 0 && (e > 2 ? t = i.slice() : t = new Array(r));
  for (let s = 0; s < r; s += e) {
    t[s] = sr * i[s] / 180;
    let u = Rs * Math.log(Math.tan(Math.PI * (+i[s + 1] + 90) / 360));
    u > Ws ? u = Ws : u < -Ws && (u = -Ws), t[s + 1] = u;
  }
  return t;
}
function vm(i, t, e) {
  const r = i.length;
  e = e > 1 ? e : 2, t === void 0 && (e > 2 ? t = i.slice() : t = new Array(r));
  for (let s = 0; s < r; s += e)
    t[s] = 180 * i[s] / sr, t[s + 1] = 360 * Math.atan(Math.exp(i[s + 1] / Rs)) / Math.PI - 90;
  return t;
}
const _m = 6378137, Fh = [-180, -90, 180, 90], xm = Math.PI * _m / 180;
class yi extends Dg {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(t, e) {
    super({
      code: t,
      units: "degrees",
      extent: Fh,
      axisOrientation: e,
      global: !0,
      metersPerUnit: xm,
      worldExtent: Fh
    });
  }
}
const Gh = [
  new yi("CRS:84"),
  new yi("EPSG:4326", "neu"),
  new yi("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new yi("urn:ogc:def:crs:OGC:2:84"),
  new yi("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new yi("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new yi("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let pu = {};
function Em(i) {
  return pu[i] || pu[i.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function Sm(i, t) {
  pu[i] = t;
}
let ur = {};
function vo(i, t, e) {
  const r = i.getCode(), s = t.getCode();
  r in ur || (ur[r] = {}), ur[r][s] = e;
}
function Im(i, t) {
  let e;
  return i in ur && t in ur[i] && (e = ur[i][t]), e;
}
function ee(i, t, e) {
  return Math.min(Math.max(i, t), e);
}
function wm(i, t, e, r, s, u) {
  const h = s - e, f = u - r;
  if (h !== 0 || f !== 0) {
    const g = ((i - e) * h + (t - r) * f) / (h * h + f * f);
    g > 1 ? (e = s, r = u) : g > 0 && (e += h * g, r += f * g);
  }
  return Si(i, t, e, r);
}
function Si(i, t, e, r) {
  const s = e - i, u = r - t;
  return s * s + u * u;
}
function km(i) {
  return i * Math.PI / 180;
}
function mu(i, t) {
  const e = i % t;
  return e * t < 0 ? e + t : e;
}
function xe(i, t, e) {
  return i + e * (t - i);
}
function Cm(i, t) {
  const e = Math.pow(10, t);
  return Math.round(i * e) / e;
}
function Rm(i, t) {
  return i[0] += +t[0], i[1] += +t[1], i;
}
function _o(i, t) {
  let e = !0;
  for (let r = i.length - 1; r >= 0; --r)
    if (i[r] != t[r]) {
      e = !1;
      break;
    }
  return e;
}
function bm(i, t) {
  const e = Math.cos(t), r = Math.sin(t), s = i[0] * e - i[1] * r, u = i[1] * e + i[0] * r;
  return i[0] = s, i[1] = u, i;
}
function Tm(i, t) {
  if (t.canWrapX()) {
    const e = he(t.getExtent()), r = Nm(i, t, e);
    r && (i[0] -= r * e);
  }
  return i;
}
function Nm(i, t, e) {
  const r = t.getExtent();
  let s = 0;
  return t.canWrapX() && (i[0] < r[0] || i[0] > r[2]) && (e = e || he(r), s = Math.floor(
    (i[0] - r[0]) / e
  )), s;
}
function Mm(...i) {
  console.warn(...i);
}
let vu = !0;
function Fg(i) {
  vu = !1;
}
function Gg(i, t) {
  if (t !== void 0) {
    for (let e = 0, r = i.length; e < r; ++e)
      t[e] = i[e];
    t = t;
  } else
    t = i.slice();
  return t;
}
function Om(i, t) {
  if (t !== void 0 && i !== t) {
    for (let e = 0, r = i.length; e < r; ++e)
      t[e] = i[e];
    i = t;
  }
  return i;
}
function Lm(i) {
  Sm(i.getCode(), i), vo(i, i, Gg);
}
function Am(i) {
  i.forEach(Lm);
}
function bi(i) {
  return typeof i == "string" ? Em(
    /** @type {string} */
    i
  ) : (
    /** @type {Projection} */
    i || null
  );
}
function Bh(i) {
  Am(i), i.forEach(function(t) {
    i.forEach(function(e) {
      t !== e && vo(t, e, Gg);
    });
  });
}
function Pm(i, t, e, r) {
  i.forEach(function(s) {
    t.forEach(function(u) {
      vo(s, u, e), vo(u, s, r);
    });
  });
}
function ll(i, t) {
  return i ? typeof i == "string" ? bi(i) : (
    /** @type {Projection} */
    i
  ) : bi(t);
}
function Us(i, t) {
  return Fg(), Bg(
    i,
    "EPSG:4326",
    t !== void 0 ? t : "EPSG:3857"
  );
}
function Yh(i, t) {
  const e = Bg(
    i,
    t !== void 0 ? t : "EPSG:3857",
    "EPSG:4326"
  ), r = e[0];
  return (r < -180 || r > 180) && (e[0] = mu(r + 180, 360) - 180), e;
}
function Dm(i, t) {
  const e = i.getCode(), r = t.getCode();
  let s = Im(e, r);
  return s || (s = Om), s;
}
function xo(i, t) {
  const e = bi(i), r = bi(t);
  return Dm(e, r);
}
function Bg(i, t, e) {
  return xo(t, e)(i, void 0, i.length);
}
function Fm(i, t, e, r) {
  const s = xo(t, e);
  return gm(i, s, void 0);
}
function zh(i, t) {
  return i;
}
function Pn(i, t) {
  return vu && !_o(i, [0, 0]) && i[0] >= -180 && i[0] <= 180 && i[1] >= -90 && i[1] <= 90 && (vu = !1, Mm(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), i;
}
function Yg(i, t) {
  return i;
}
function Zr(i, t) {
  return i;
}
function Gm() {
  Bh(Dh), Bh(Gh), Pm(
    Gh,
    Dh,
    mm,
    vm
  );
}
Gm();
function Jn(i, t, e, r, s, u) {
  u = u || [];
  let h = 0;
  for (let f = t; f < e; f += r) {
    const g = i[f], y = i[f + 1];
    u[h++] = s[0] * g + s[2] * y + s[4], u[h++] = s[1] * g + s[3] * y + s[5];
  }
  return u && u.length != h && (u.length = h), u;
}
function zg(i, t, e, r, s, u, h) {
  h = h || [];
  const f = Math.cos(s), g = Math.sin(s), y = u[0], p = u[1];
  let m = 0;
  for (let _ = t; _ < e; _ += r) {
    const x = i[_] - y, I = i[_ + 1] - p;
    h[m++] = y + x * f - I * g, h[m++] = p + x * g + I * f;
    for (let k = _ + 2; k < _ + r; ++k)
      h[m++] = i[k];
  }
  return h && h.length != m && (h.length = m), h;
}
function Bm(i, t, e, r, s, u, h, f) {
  f = f || [];
  const g = h[0], y = h[1];
  let p = 0;
  for (let m = t; m < e; m += r) {
    const _ = i[m] - g, x = i[m + 1] - y;
    f[p++] = g + s * _, f[p++] = y + u * x;
    for (let I = m + 2; I < m + r; ++I)
      f[p++] = i[I];
  }
  return f && f.length != p && (f.length = p), f;
}
function Ym(i, t, e, r, s, u, h) {
  h = h || [];
  let f = 0;
  for (let g = t; g < e; g += r) {
    h[f++] = i[g] + s, h[f++] = i[g + 1] + u;
    for (let y = g + 2; y < g + r; ++y)
      h[f++] = i[y];
  }
  return h && h.length != f && (h.length = f), h;
}
const $h = Sn();
class $g extends Er {
  constructor() {
    super(), this.extent_ = ki(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = kg(
      (t, e, r) => {
        if (!r)
          return this.getSimplifiedGeometry(e);
        const s = this.clone();
        return s.applyTransform(r), s.getSimplifiedGeometry(e);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(t, e) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      t,
      e
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return Tt();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    return Tt();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    const r = this.getClosestPoint([t, e]);
    return r[0] === t && r[1] === e;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(t, e) {
    return e = e || [NaN, NaN], this.closestPointXY(t[0], t[1], e, 1 / 0), e;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(t) {
    return this.containsXY(t[0], t[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return Tt();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(t) {
    if (this.extentRevision_ != this.getRevision()) {
      const e = this.computeExtent(this.extent_);
      (isNaN(e[0]) || isNaN(e[1])) && Jo(e), this.extentRevision_ = this.getRevision();
    }
    return cm(this.extent_, t);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, e) {
    Tt();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, e, r) {
    Tt();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(t) {
    return this.getSimplifiedGeometry(t * t);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return Tt();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return Tt();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(t) {
    Tt();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(t) {
    return Tt();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, e) {
    Tt();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(t, e) {
    const r = bi(t), s = r.getUnits() == "tile-pixels" ? function(u, h, f) {
      const g = r.getExtent(), y = r.getWorldExtent(), p = Cn(y) / Cn(g);
      return Oi(
        $h,
        y[0],
        y[3],
        p,
        -p,
        0,
        0,
        0
      ), Jn(
        u,
        0,
        u.length,
        f,
        $h,
        h
      ), xo(r, e)(
        u,
        h,
        f
      );
    } : xo(r, e);
    return this.applyTransform(s), this;
  }
}
class Ai extends $g {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return al(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return Tt();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const e = this.getSimplifiedGeometryInternal(t);
    return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(t, e) {
    this.stride = Xh(t), this.layout = t, this.flatCoordinates = e;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(t, e) {
    Tt();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(t, e, r) {
    let s;
    if (t)
      s = Xh(t);
    else {
      for (let u = 0; u < r; ++u) {
        if (e.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        e = /** @type {Array<unknown>} */
        e[0];
      }
      s = e.length, t = zm(s);
    }
    this.layout = t, this.stride = s;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(t) {
    this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, e) {
    const r = this.getFlatCoordinates();
    if (r) {
      const s = this.getStride();
      zg(
        r,
        0,
        r.length,
        s,
        t,
        e,
        r
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, e, r) {
    e === void 0 && (e = t), r || (r = Ri(this.getExtent()));
    const s = this.getFlatCoordinates();
    if (s) {
      const u = this.getStride();
      Bm(
        s,
        0,
        s.length,
        u,
        t,
        e,
        r,
        s
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, e) {
    const r = this.getFlatCoordinates();
    if (r) {
      const s = this.getStride();
      Ym(
        r,
        0,
        r.length,
        s,
        t,
        e,
        r
      ), this.changed();
    }
  }
}
function zm(i) {
  let t;
  return i == 2 ? t = "XY" : i == 3 ? t = "XYZ" : i == 4 && (t = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  t;
}
function Xh(i) {
  let t;
  return i == "XY" ? t = 2 : i == "XYZ" || i == "XYM" ? t = 3 : i == "XYZM" && (t = 4), /** @type {number} */
  t;
}
function $m(i, t, e) {
  const r = i.getFlatCoordinates();
  if (!r)
    return null;
  const s = i.getStride();
  return Jn(
    r,
    0,
    r.length,
    s,
    t,
    e
  );
}
function Xm(i, t, e, r) {
  for (let s = 0, u = e.length; s < u; ++s)
    i[t++] = e[s];
  return t;
}
function Ko(i, t, e, r) {
  for (let s = 0, u = e.length; s < u; ++s) {
    const h = e[s];
    for (let f = 0; f < r; ++f)
      i[t++] = h[f];
  }
  return t;
}
function hl(i, t, e, r, s) {
  s = s || [];
  let u = 0;
  for (let h = 0, f = e.length; h < f; ++h) {
    const g = Ko(
      i,
      t,
      e[h],
      r
    );
    s[u++] = g, t = g;
  }
  return s.length = u, s;
}
function qm(i, t, e, r, s) {
  s = s || [];
  let u = 0;
  for (let h = 0, f = e.length; h < f; ++h) {
    const g = hl(
      i,
      t,
      e[h],
      r,
      s[u]
    );
    g.length === 0 && (g[0] = t), s[u++] = g, t = g[g.length - 1];
  }
  return s.length = u, s;
}
class Eo extends $g {
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  constructor(t) {
    super(), this.geometries_ = t, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(Hn), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    const t = this.geometries_;
    for (let e = 0, r = t.length; e < r; ++e)
      this.changeEventsKeys_.push(
        En(t[e], Ue.CHANGE, this.changed, this)
      );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const t = new Eo(
      La(this.geometries_)
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    if (s < Li(this.getExtent(), t, e))
      return s;
    const u = this.geometries_;
    for (let h = 0, f = u.length; h < f; ++h)
      s = u[h].closestPointXY(
        t,
        e,
        r,
        s
      );
    return s;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    const r = this.geometries_;
    for (let s = 0, u = r.length; s < u; ++s)
      if (r[s].containsXY(t, e))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    Jo(t);
    const e = this.geometries_;
    for (let r = 0, s = e.length; r < s; ++r)
      sm(t, e[r].getExtent());
    return t;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return La(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let t = [];
    const e = this.geometries_;
    for (let r = 0, s = e.length; r < s; ++r)
      e[r].getType() === this.getType() ? t = t.concat(
        /** @type {GeometryCollection} */
        e[r].getGeometriesArrayRecursive()
      ) : t.push(e[r]);
    return t;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const e = [], r = this.geometries_;
    let s = !1;
    for (let u = 0, h = r.length; u < h; ++u) {
      const f = r[u], g = f.getSimplifiedGeometry(t);
      e.push(g), g !== f && (s = !0);
    }
    return s ? new Eo(
      e
    ) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const e = this.geometries_;
    for (let r = 0, s = e.length; r < s; ++r)
      if (e[r].intersectsExtent(t))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, e) {
    const r = this.geometries_;
    for (let s = 0, u = r.length; s < u; ++s)
      r[s].rotate(t, e);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, e, r) {
    r || (r = Ri(this.getExtent()));
    const s = this.geometries_;
    for (let u = 0, h = s.length; u < h; ++u)
      s[u].scale(t, e, r);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(t) {
    this.setGeometriesArray(La(t));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(t) {
    this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(t) {
    const e = this.geometries_;
    for (let r = 0, s = e.length; r < s; ++r)
      e[r].applyTransform(t);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, e) {
    const r = this.geometries_;
    for (let s = 0, u = r.length; s < u; ++s)
      r[s].translate(t, e);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function La(i) {
  return i.map((t) => t.clone());
}
function qh(i, t, e, r, s, u, h) {
  const f = i[t], g = i[t + 1], y = i[e] - f, p = i[e + 1] - g;
  let m;
  if (y === 0 && p === 0)
    m = t;
  else {
    const _ = ((s - f) * y + (u - g) * p) / (y * y + p * p);
    if (_ > 1)
      m = e;
    else if (_ > 0) {
      for (let x = 0; x < r; ++x)
        h[x] = xe(
          i[t + x],
          i[e + x],
          _
        );
      h.length = r;
      return;
    } else
      m = t;
  }
  for (let _ = 0; _ < r; ++_)
    h[_] = i[m + _];
  h.length = r;
}
function cl(i, t, e, r, s) {
  let u = i[t], h = i[t + 1];
  for (t += r; t < e; t += r) {
    const f = i[t], g = i[t + 1], y = Si(u, h, f, g);
    y > s && (s = y), u = f, h = g;
  }
  return s;
}
function fl(i, t, e, r, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    const f = e[u];
    s = cl(i, t, f, r, s), t = f;
  }
  return s;
}
function Wm(i, t, e, r, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    const f = e[u];
    s = fl(i, t, f, r, s), t = f[f.length - 1];
  }
  return s;
}
function gl(i, t, e, r, s, u, h, f, g, y, p) {
  if (t == e)
    return y;
  let m, _;
  if (s === 0) {
    if (_ = Si(
      h,
      f,
      i[t],
      i[t + 1]
    ), _ < y) {
      for (m = 0; m < r; ++m)
        g[m] = i[t + m];
      return g.length = r, _;
    }
    return y;
  }
  p = p || [NaN, NaN];
  let x = t + r;
  for (; x < e; )
    if (qh(
      i,
      x - r,
      x,
      r,
      h,
      f,
      p
    ), _ = Si(h, f, p[0], p[1]), _ < y) {
      for (y = _, m = 0; m < r; ++m)
        g[m] = p[m];
      g.length = r, x += r;
    } else
      x += r * Math.max(
        (Math.sqrt(_) - Math.sqrt(y)) / s | 0,
        1
      );
  if (u && (qh(
    i,
    e - r,
    t,
    r,
    h,
    f,
    p
  ), _ = Si(h, f, p[0], p[1]), _ < y)) {
    for (y = _, m = 0; m < r; ++m)
      g[m] = p[m];
    g.length = r;
  }
  return y;
}
function dl(i, t, e, r, s, u, h, f, g, y, p) {
  p = p || [NaN, NaN];
  for (let m = 0, _ = e.length; m < _; ++m) {
    const x = e[m];
    y = gl(
      i,
      t,
      x,
      r,
      s,
      u,
      h,
      f,
      g,
      y,
      p
    ), t = x;
  }
  return y;
}
function Um(i, t, e, r, s, u, h, f, g, y, p) {
  p = p || [NaN, NaN];
  for (let m = 0, _ = e.length; m < _; ++m) {
    const x = e[m];
    y = dl(
      i,
      t,
      x,
      r,
      s,
      u,
      h,
      f,
      g,
      y,
      p
    ), t = x[x.length - 1];
  }
  return y;
}
function Qo(i, t, e, r, s, u, h) {
  const f = (e - t) / r;
  if (f < 3) {
    for (; t < e; t += r)
      u[h++] = i[t], u[h++] = i[t + 1];
    return h;
  }
  const g = new Array(f);
  g[0] = 1, g[f - 1] = 1;
  const y = [t, e - r];
  let p = 0;
  for (; y.length > 0; ) {
    const m = y.pop(), _ = y.pop();
    let x = 0;
    const I = i[_], k = i[_ + 1], C = i[m], R = i[m + 1];
    for (let b = _ + r; b < m; b += r) {
      const O = i[b], A = i[b + 1], L = wm(O, A, I, k, C, R);
      L > x && (p = b, x = L);
    }
    x > s && (g[(p - t) / r] = 1, _ + r < p && y.push(_, p), p + r < m && y.push(p, m));
  }
  for (let m = 0; m < f; ++m)
    g[m] && (u[h++] = i[t + m * r], u[h++] = i[t + m * r + 1]);
  return h;
}
function Xg(i, t, e, r, s, u, h, f) {
  for (let g = 0, y = e.length; g < y; ++g) {
    const p = e[g];
    h = Qo(
      i,
      t,
      p,
      r,
      s,
      u,
      h
    ), f.push(h), t = p;
  }
  return h;
}
function pi(i, t) {
  return t * Math.round(i / t);
}
function jm(i, t, e, r, s, u, h) {
  if (t == e)
    return h;
  let f = pi(i[t], s), g = pi(i[t + 1], s);
  t += r, u[h++] = f, u[h++] = g;
  let y, p;
  do
    if (y = pi(i[t], s), p = pi(i[t + 1], s), t += r, t == e)
      return u[h++] = y, u[h++] = p, h;
  while (y == f && p == g);
  for (; t < e; ) {
    const m = pi(i[t], s), _ = pi(i[t + 1], s);
    if (t += r, m == y && _ == p)
      continue;
    const x = y - f, I = p - g, k = m - f, C = _ - g;
    if (x * C == I * k && (x < 0 && k < x || x == k || x > 0 && k > x) && (I < 0 && C < I || I == C || I > 0 && C > I)) {
      y = m, p = _;
      continue;
    }
    u[h++] = y, u[h++] = p, f = y, g = p, y = m, p = _;
  }
  return u[h++] = y, u[h++] = p, h;
}
function yl(i, t, e, r, s, u, h, f) {
  for (let g = 0, y = e.length; g < y; ++g) {
    const p = e[g];
    h = jm(
      i,
      t,
      p,
      r,
      s,
      u,
      h
    ), f.push(h), t = p;
  }
  return h;
}
function Vm(i, t, e, r, s, u, h, f) {
  for (let g = 0, y = e.length; g < y; ++g) {
    const p = e[g], m = [];
    h = yl(
      i,
      t,
      p,
      r,
      s,
      u,
      h,
      m
    ), f.push(m), t = p[p.length - 1];
  }
  return h;
}
function qn(i, t, e, r, s) {
  s = s !== void 0 ? s : [];
  let u = 0;
  for (let h = t; h < e; h += r)
    s[u++] = i.slice(h, h + r);
  return s.length = u, s;
}
function us(i, t, e, r, s) {
  s = s !== void 0 ? s : [];
  let u = 0;
  for (let h = 0, f = e.length; h < f; ++h) {
    const g = e[h];
    s[u++] = qn(
      i,
      t,
      g,
      r,
      s[u]
    ), t = g;
  }
  return s.length = u, s;
}
function _u(i, t, e, r, s) {
  s = s !== void 0 ? s : [];
  let u = 0;
  for (let h = 0, f = e.length; h < f; ++h) {
    const g = e[h];
    s[u++] = g.length === 1 && g[0] === t ? [] : us(
      i,
      t,
      g,
      r,
      s[u]
    ), t = g[g.length - 1];
  }
  return s.length = u, s;
}
function qg(i, t, e, r) {
  let s = 0, u = i[e - r], h = i[e - r + 1];
  for (; t < e; t += r) {
    const f = i[t], g = i[t + 1];
    s += h * f - u * g, u = f, h = g;
  }
  return s / 2;
}
function Wg(i, t, e, r) {
  let s = 0;
  for (let u = 0, h = e.length; u < h; ++u) {
    const f = e[u];
    s += qg(i, t, f, r), t = f;
  }
  return s;
}
function Zm(i, t, e, r) {
  let s = 0;
  for (let u = 0, h = e.length; u < h; ++u) {
    const f = e[u];
    s += Wg(i, t, f, r), t = f[f.length - 1];
  }
  return s;
}
class ls extends Ai {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new ls(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    return s < Li(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      cl(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), gl(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      r,
      s
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return qg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return qn(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [];
    return e.length = Qo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      0
    ), new ls(e, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ko(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
function Ug(i, t, e, r, s) {
  let u;
  for (t += r; t < e; t += r)
    if (u = s(
      i.slice(t - r, t),
      i.slice(t, t + r)
    ), u)
      return u;
  return !1;
}
function So(i, t, e, r, s, u, h) {
  let f, g;
  const y = (e - t) / r;
  if (y === 1)
    f = t;
  else if (y === 2)
    f = t, g = s;
  else if (y !== 0) {
    let p = i[t], m = i[t + 1], _ = 0;
    const x = [0];
    for (let C = t + r; C < e; C += r) {
      const R = i[C], b = i[C + 1];
      _ += Math.sqrt((R - p) * (R - p) + (b - m) * (b - m)), x.push(_), p = R, m = b;
    }
    const I = s * _, k = Vp(x, I);
    k < 0 ? (g = (I - x[-k - 2]) / (x[-k - 1] - x[-k - 2]), f = t + (-k - 2) * r) : f = t + k * r;
  }
  h = h > 1 ? h : 2, u = u || new Array(h);
  for (let p = 0; p < h; ++p)
    u[p] = f === void 0 ? NaN : g === void 0 ? i[f + p] : xe(i[f + p], i[f + r + p], g);
  return u;
}
function xu(i, t, e, r, s, u) {
  if (e == t)
    return null;
  let h;
  if (s < i[t + r - 1])
    return u ? (h = i.slice(t, t + r), h[r - 1] = s, h) : null;
  if (i[e - 1] < s)
    return u ? (h = i.slice(e - r, e), h[r - 1] = s, h) : null;
  if (s == i[t + r - 1])
    return i.slice(t, t + r);
  let f = t / r, g = e / r;
  for (; f < g; ) {
    const _ = f + g >> 1;
    s < i[(_ + 1) * r - 1] ? g = _ : f = _ + 1;
  }
  const y = i[f * r - 1];
  if (s == y)
    return i.slice((f - 1) * r, (f - 1) * r + r);
  const p = i[(f + 1) * r - 1], m = (s - y) / (p - y);
  h = [];
  for (let _ = 0; _ < r - 1; ++_)
    h.push(
      xe(
        i[(f - 1) * r + _],
        i[f * r + _],
        m
      )
    );
  return h.push(s), h;
}
function Hm(i, t, e, r, s, u, h) {
  if (h)
    return xu(
      i,
      t,
      e[e.length - 1],
      r,
      s,
      u
    );
  let f;
  if (s < i[r - 1])
    return u ? (f = i.slice(0, r), f[r - 1] = s, f) : null;
  if (i[i.length - 1] < s)
    return u ? (f = i.slice(i.length - r), f[r - 1] = s, f) : null;
  for (let g = 0, y = e.length; g < y; ++g) {
    const p = e[g];
    if (t != p) {
      if (s < i[t + r - 1])
        return null;
      if (s <= i[p - 1])
        return xu(
          i,
          t,
          p,
          r,
          s,
          !1
        );
      t = p;
    }
  }
  return null;
}
function Jm(i, t, e, r, s) {
  return !um(
    s,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(h) {
      return !mi(
        i,
        t,
        e,
        r,
        h[0],
        h[1]
      );
    }
  );
}
function mi(i, t, e, r, s, u) {
  let h = 0, f = i[e - r], g = i[e - r + 1];
  for (; t < e; t += r) {
    const y = i[t], p = i[t + 1];
    g <= u ? p > u && (y - f) * (u - g) - (s - f) * (p - g) > 0 && h++ : p <= u && (y - f) * (u - g) - (s - f) * (p - g) < 0 && h--, f = y, g = p;
  }
  return h !== 0;
}
function pl(i, t, e, r, s, u) {
  if (e.length === 0 || !mi(i, t, e[0], r, s, u))
    return !1;
  for (let h = 1, f = e.length; h < f; ++h)
    if (mi(i, e[h - 1], e[h], r, s, u))
      return !1;
  return !0;
}
function Km(i, t, e, r, s, u) {
  if (e.length === 0)
    return !1;
  for (let h = 0, f = e.length; h < f; ++h) {
    const g = e[h];
    if (pl(i, t, g, r, s, u))
      return !0;
    t = g[g.length - 1];
  }
  return !1;
}
function ta(i, t, e, r, s) {
  const u = Tg(
    ki(),
    i,
    t,
    e,
    r
  );
  return qe(s, u) ? rr(s, u) || u[0] >= s[0] && u[2] <= s[2] || u[1] >= s[1] && u[3] <= s[3] ? !0 : Ug(
    i,
    t,
    e,
    r,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(h, f) {
      return fm(s, h, f);
    }
  ) : !1;
}
function Qm(i, t, e, r, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    if (ta(i, t, e[u], r, s))
      return !0;
    t = e[u];
  }
  return !1;
}
function tv(i, t, e, r, s) {
  return !!(ta(i, t, e, r, s) || mi(
    i,
    t,
    e,
    r,
    s[0],
    s[1]
  ) || mi(
    i,
    t,
    e,
    r,
    s[0],
    s[3]
  ) || mi(
    i,
    t,
    e,
    r,
    s[2],
    s[1]
  ) || mi(
    i,
    t,
    e,
    r,
    s[2],
    s[3]
  ));
}
function jg(i, t, e, r, s) {
  if (!tv(i, t, e[0], r, s))
    return !1;
  if (e.length === 1)
    return !0;
  for (let u = 1, h = e.length; u < h; ++u)
    if (Jm(
      i,
      e[u - 1],
      e[u],
      r,
      s
    ) && !ta(
      i,
      e[u - 1],
      e[u],
      r,
      s
    ))
      return !1;
  return !0;
}
function ev(i, t, e, r, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    const f = e[u];
    if (jg(i, t, f, r, s))
      return !0;
    t = f[f.length - 1];
  }
  return !1;
}
function Vg(i, t, e, r) {
  let s = i[t], u = i[t + 1], h = 0;
  for (let f = t + r; f < e; f += r) {
    const g = i[f], y = i[f + 1];
    h += Math.sqrt((g - s) * (g - s) + (y - u) * (y - u)), s = g, u = y;
  }
  return h;
}
class Ti extends Ai {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(t) {
    on(this.flatCoordinates, t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const t = new Ti(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    return s < Li(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      cl(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), gl(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      e,
      r,
      s
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(t) {
    return Ug(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, e) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (e = e !== void 0 ? e : !1, xu(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return qn(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(t, e) {
    return So(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return Vg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
      0.5,
      this.flatMidpoint_ ?? void 0
    ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
    this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [];
    return e.length = Qo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      0
    ), new Ti(e, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return ta(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ko(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
class hs extends Ai {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(t, e, r) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        t,
        e
      );
    else if (e !== void 0 && r)
      this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ), this.ends_ = r;
    else {
      const s = (
        /** @type {Array<LineString>} */
        t
      ), u = [], h = [];
      for (let g = 0, y = s.length; g < y; ++g) {
        const p = s[g];
        on(u, p.getFlatCoordinates()), h.push(u.length);
      }
      const f = s.length === 0 ? this.getLayout() : s[0].getLayout();
      this.setFlatCoordinates(f, u), this.ends_ = h;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(t) {
    on(this.flatCoordinates, t.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const t = new hs(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    return s < Li(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      fl(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), dl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      e,
      r,
      s
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, e, r) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (e = e !== void 0 ? e : !1, r = r !== void 0 ? r : !1, Hm(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      e,
      r
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return us(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(t) {
    return t < 0 || this.ends_.length <= t ? null : new Ti(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const t = this.flatCoordinates, e = this.ends_, r = this.layout, s = [];
    let u = 0;
    for (let h = 0, f = e.length; h < f; ++h) {
      const g = e[h], y = new Ti(
        t.slice(u, g),
        r
      );
      s.push(y), u = g;
    }
    return s;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const t = [], e = this.flatCoordinates;
    let r = 0;
    const s = this.ends_, u = this.stride;
    for (let h = 0, f = s.length; h < f; ++h) {
      const g = s[h], y = So(
        e,
        r,
        g,
        u,
        0.5
      );
      on(t, y), r = g;
    }
    return t;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], r = [];
    return e.length = Xg(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      e,
      0,
      r
    ), new hs(e, "XY", r);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return Qm(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const r = hl(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1], this.changed();
  }
}
class Kn extends Ai {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.setCoordinates(t, e);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const t = new Kn(this.flatCoordinates.slice(), this.layout);
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    const u = this.flatCoordinates, h = Si(
      t,
      e,
      u[0],
      u[1]
    );
    if (h < s) {
      const f = this.stride;
      for (let g = 0; g < f; ++g)
        r[g] = u[g];
      return r.length = f, h;
    }
    return s;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return Rg(this.flatCoordinates, t);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return ol(t, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Xm(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
class ml extends Ai {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(t) {
    on(this.flatCoordinates, t.getFlatCoordinates()), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const t = new ml(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    if (s < Li(this.getExtent(), t, e))
      return s;
    const u = this.flatCoordinates, h = this.stride;
    for (let f = 0, g = u.length; f < g; f += h) {
      const y = Si(
        t,
        e,
        u[f],
        u[f + 1]
      );
      if (y < s) {
        s = y;
        for (let p = 0; p < h; ++p)
          r[p] = u[f + p];
        r.length = h;
      }
    }
    return s;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return qn(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(t) {
    const e = this.flatCoordinates.length / this.stride;
    return t < 0 || e <= t ? null : new Kn(
      this.flatCoordinates.slice(
        t * this.stride,
        (t + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const t = this.flatCoordinates, e = this.layout, r = this.stride, s = [];
    for (let u = 0, h = t.length; u < h; u += r) {
      const f = new Kn(t.slice(u, u + r), e);
      s.push(f);
    }
    return s;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const e = this.flatCoordinates, r = this.stride;
    for (let s = 0, u = e.length; s < u; s += r) {
      const h = e[s], f = e[s + 1];
      if (ol(t, h, f))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Ko(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
function vl(i, t, e, r, s, u, h) {
  let f, g, y, p, m, _, x;
  const I = s[u + 1], k = [];
  for (let b = 0, O = e.length; b < O; ++b) {
    const A = e[b];
    for (p = i[A - r], _ = i[A - r + 1], f = t; f < A; f += r)
      m = i[f], x = i[f + 1], (I <= _ && x <= I || _ <= I && I <= x) && (y = (I - _) / (x - _) * (m - p) + p, k.push(y)), p = m, _ = x;
  }
  let C = NaN, R = -1 / 0;
  for (k.sort(Ei), p = k[0], f = 1, g = k.length; f < g; ++f) {
    m = k[f];
    const b = Math.abs(m - p);
    b > R && (y = (p + m) / 2, pl(i, t, e, r, y, I) && (C = y, R = b)), p = m;
  }
  return isNaN(C) && (C = s[u]), h ? (h.push(C, I, R), h) : [C, I, R];
}
function Zg(i, t, e, r, s) {
  let u = [];
  for (let h = 0, f = e.length; h < f; ++h) {
    const g = e[h];
    u = vl(
      i,
      t,
      g,
      r,
      s,
      2 * h,
      u
    ), t = g[g.length - 1];
  }
  return u;
}
function nv(i, t, e, r) {
  for (; t < e - r; ) {
    for (let s = 0; s < r; ++s) {
      const u = i[t + s];
      i[t + s] = i[e - r + s], i[e - r + s] = u;
    }
    t += r, e -= r;
  }
}
function _l(i, t, e, r) {
  let s = 0, u = i[e - r], h = i[e - r + 1];
  for (; t < e; t += r) {
    const f = i[t], g = i[t + 1];
    s += (f - u) * (g + h), u = f, h = g;
  }
  return s === 0 ? void 0 : s > 0;
}
function Hg(i, t, e, r, s) {
  s = s !== void 0 ? s : !1;
  for (let u = 0, h = e.length; u < h; ++u) {
    const f = e[u], g = _l(
      i,
      t,
      f,
      r
    );
    if (u === 0) {
      if (s && g || !s && !g)
        return !1;
    } else if (s && !g || !s && g)
      return !1;
    t = f;
  }
  return !0;
}
function iv(i, t, e, r, s) {
  for (let u = 0, h = e.length; u < h; ++u) {
    const f = e[u];
    if (!Hg(i, t, f, r, s))
      return !1;
    f.length && (t = f[f.length - 1]);
  }
  return !0;
}
function Eu(i, t, e, r, s) {
  s = s !== void 0 ? s : !1;
  for (let u = 0, h = e.length; u < h; ++u) {
    const f = e[u], g = _l(
      i,
      t,
      f,
      r
    );
    (u === 0 ? s && g || !s && !g : s && !g || !s && g) && nv(i, t, f, r), t = f;
  }
  return t;
}
function Wh(i, t, e, r, s) {
  for (let u = 0, h = e.length; u < h; ++u)
    t = Eu(
      i,
      t,
      e[u],
      r,
      s
    );
  return t;
}
function rv(i, t) {
  const e = [];
  let r = 0, s = 0, u;
  for (let h = 0, f = t.length; h < f; ++h) {
    const g = t[h], y = _l(i, r, g, 2);
    if (u === void 0 && (u = y), y === u)
      e.push(t.slice(s, h + 1));
    else {
      if (e.length === 0)
        continue;
      e[e.length - 1].push(t[s]);
    }
    s = h + 1, r = g;
  }
  return e;
}
class ei extends Ai {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(t, e, r) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, e !== void 0 && r ? (this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ), this.ends_ = r) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      t,
      e
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(t) {
    this.flatCoordinates ? on(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const t = new ei(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    return s < Li(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      fl(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), dl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      r,
      s
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    return pl(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t,
      e
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return Wg(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(t) {
    let e;
    return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), Eu(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, us(e, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const t = Ri(this.getExtent());
      this.flatInteriorPoint_ = vl(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Kn(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(t) {
    return t < 0 || this.ends_.length <= t ? null : new ls(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const t = this.layout, e = this.flatCoordinates, r = this.ends_, s = [];
    let u = 0;
    for (let h = 0, f = r.length; h < f; ++h) {
      const g = r[h], y = new ls(
        e.slice(u, g),
        t
      );
      s.push(y), u = g;
    }
    return s;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      Hg(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Eu(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], r = [];
    return e.length = yl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(t),
      e,
      0,
      r
    ), new ei(e, "XY", r);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return jg(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const r = hl(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1], this.changed();
  }
}
function Uh(i) {
  if (ul(i))
    throw new Error("Cannot create polygon from empty extent");
  const t = i[0], e = i[1], r = i[2], s = i[3], u = [
    t,
    e,
    t,
    s,
    r,
    s,
    r,
    e,
    t,
    e
  ];
  return new ei(u, "XY", [u.length]);
}
function Jg(i, t, e, r) {
  const s = [];
  let u = ki();
  for (let h = 0, f = e.length; h < f; ++h) {
    const g = e[h];
    u = al(
      i,
      t,
      g[0],
      r
    ), s.push((u[0] + u[2]) / 2, (u[1] + u[3]) / 2), t = g[g.length - 1];
  }
  return s;
}
class cs extends Ai {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(t, e, r) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !r && !Array.isArray(t[0])) {
      const s = (
        /** @type {Array<Polygon>} */
        t
      ), u = [], h = [];
      for (let f = 0, g = s.length; f < g; ++f) {
        const y = s[f], p = u.length, m = y.getEnds();
        for (let _ = 0, x = m.length; _ < x; ++_)
          m[_] += p;
        on(u, y.getFlatCoordinates()), h.push(m);
      }
      e = s.length === 0 ? this.getLayout() : s[0].getLayout(), t = u, r = h;
    }
    e !== void 0 && r ? (this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ), this.endss_ = r) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      t,
      e
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(t) {
    let e;
    if (!this.flatCoordinates)
      this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push();
    else {
      const r = this.flatCoordinates.length;
      on(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice();
      for (let s = 0, u = e.length; s < u; ++s)
        e[s] += r;
    }
    this.endss_.push(e), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const t = this.endss_.length, e = new Array(t);
    for (let s = 0; s < t; ++s)
      e[s] = this.endss_[s].slice();
    const r = new cs(
      this.flatCoordinates.slice(),
      this.layout,
      e
    );
    return r.applyProperties(this), r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, r, s) {
    return s < Li(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Wm(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Um(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      r,
      s
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    return Km(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t,
      e
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return Zm(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(t) {
    let e;
    return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), Wh(
      e,
      0,
      this.endss_,
      this.stride,
      t
    )) : e = this.flatCoordinates, _u(
      e,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const t = Jg(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = Zg(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.flatInteriorPoints_
    );
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new ml(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      iv(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Wh(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], r = [];
    return e.length = Vm(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(t),
      e,
      0,
      r
    ), new cs(e, "XY", r);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(t) {
    if (t < 0 || this.endss_.length <= t)
      return null;
    let e;
    if (t === 0)
      e = 0;
    else {
      const u = this.endss_[t - 1];
      e = u[u.length - 1];
    }
    const r = this.endss_[t].slice(), s = r[r.length - 1];
    if (e !== 0)
      for (let u = 0, h = r.length; u < h; ++u)
        r[u] -= e;
    return new ei(
      this.flatCoordinates.slice(e, s),
      this.layout,
      r
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const t = this.layout, e = this.flatCoordinates, r = this.endss_, s = [];
    let u = 0;
    for (let h = 0, f = r.length; h < f; ++h) {
      const g = r[h].slice(), y = g[g.length - 1];
      if (u !== 0)
        for (let m = 0, _ = g.length; m < _; ++m)
          g[m] -= u;
      const p = new ei(
        e.slice(u, y),
        t,
        g
      );
      s.push(p), u = y;
    }
    return s;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return ev(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const r = qm(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.endss_
    );
    if (r.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const s = r[r.length - 1];
      this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1];
    }
    this.changed();
  }
}
const Ct = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
class sv extends Er {
  /**
   * @param {Options} options Layer options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, this.background_ = t.background;
    const e = Object.assign({}, t);
    typeof t.properties == "object" && (delete e.properties, Object.assign(e, t.properties)), e[Ct.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, te(
      typeof e[Ct.OPACITY] == "number",
      "Layer opacity must be a number"
    ), e[Ct.VISIBLE] = t.visible !== void 0 ? t.visible : !0, e[Ct.Z_INDEX] = t.zIndex, e[Ct.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, e[Ct.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, e[Ct.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, e[Ct.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = e.className !== void 0 ? e.className : "ol-layer", delete e.className, this.setProperties(e), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(t) {
    const e = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: t === void 0 ? !0 : t
    }, r = this.getZIndex();
    return e.opacity = ee(Math.round(this.getOpacity() * 100) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = r === void 0 && !e.managed ? 1 / 0 : r, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return Tt();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return Tt();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Ct.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Ct.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Ct.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Ct.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Ct.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Ct.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return Tt();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Ct.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(Ct.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(t) {
    this.background_ = t, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(t) {
    this.set(Ct.EXTENT, t);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(t) {
    this.set(Ct.MAX_RESOLUTION, t);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(t) {
    this.set(Ct.MIN_RESOLUTION, t);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(t) {
    this.set(Ct.MAX_ZOOM, t);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(t) {
    this.set(Ct.MIN_ZOOM, t);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(t) {
    te(typeof t == "number", "Layer opacity must be a number"), this.set(Ct.OPACITY, t);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(t) {
    this.set(Ct.VISIBLE, t);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(t) {
    this.set(Ct.Z_INDEX, t);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const vi = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, Oe = {
  ANIMATING: 0,
  INTERACTING: 1
}, $e = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, ov = 256;
function jh(i, t, e) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(r, s, u, h, f) {
      if (!r)
        return;
      if (!s && !t)
        return r;
      const g = t ? 0 : u[0] * s, y = t ? 0 : u[1] * s, p = f ? f[0] : 0, m = f ? f[1] : 0;
      let _ = i[0] + g / 2 + p, x = i[2] - g / 2 + p, I = i[1] + y / 2 + m, k = i[3] - y / 2 + m;
      _ > x && (_ = (x + _) / 2, x = _), I > k && (I = (k + I) / 2, k = I);
      let C = ee(r[0], _, x), R = ee(r[1], I, k);
      if (h && e && s) {
        const b = 30 * s;
        C += -b * Math.log(1 + Math.max(0, _ - r[0]) / b) + b * Math.log(1 + Math.max(0, r[0] - x) / b), R += -b * Math.log(1 + Math.max(0, I - r[1]) / b) + b * Math.log(1 + Math.max(0, r[1] - k) / b);
      }
      return [C, R];
    }
  );
}
function av(i) {
  return i;
}
function xl(i, t, e, r) {
  const s = he(t) / e[0], u = Cn(t) / e[1];
  return r ? Math.min(i, Math.max(s, u)) : Math.min(i, Math.min(s, u));
}
function El(i, t, e) {
  let r = Math.min(i, t);
  const s = 50;
  return r *= Math.log(1 + s * Math.max(0, i / t - 1)) / s + 1, e && (r = Math.max(r, e), r /= Math.log(1 + s * Math.max(0, e / i - 1)) / s + 1), ee(r, e / 2, t * 2);
}
function uv(i, t, e, r) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(s, u, h, f) {
    if (s !== void 0) {
      const g = i[0], y = i[i.length - 1], p = e ? xl(
        g,
        e,
        h,
        r
      ) : g;
      if (f)
        return t ? El(
          s,
          p,
          y
        ) : ee(s, y, p);
      const m = Math.min(p, s), _ = Math.floor(wg(i, m, u));
      return i[_] > p && _ < i.length - 1 ? i[_ + 1] : i[_];
    }
  };
}
function lv(i, t, e, r, s, u) {
  return r = r !== void 0 ? r : !0, e = e !== void 0 ? e : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(h, f, g, y) {
    if (h !== void 0) {
      const p = s ? xl(
        t,
        s,
        g,
        u
      ) : t;
      if (y)
        return r ? El(
          h,
          p,
          e
        ) : ee(h, e, p);
      const m = 1e-9, _ = Math.ceil(
        Math.log(t / p) / Math.log(i) - m
      ), x = -f * (0.5 - m) + 0.5, I = Math.min(p, h), k = Math.floor(
        Math.log(t / I) / Math.log(i) + x
      ), C = Math.max(_, k), R = t / Math.pow(i, C);
      return ee(R, e, p);
    }
  };
}
function Vh(i, t, e, r, s) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(u, h, f, g) {
    if (u !== void 0) {
      const y = r ? xl(
        i,
        r,
        f,
        s
      ) : i;
      return !e || !g ? ee(u, t, y) : El(
        u,
        y,
        t
      );
    }
  };
}
function hv(i) {
  if (i !== void 0)
    return 0;
}
function Zh(i) {
  if (i !== void 0)
    return i;
}
function cv(i) {
  const t = 2 * Math.PI / i;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(e, r) {
      if (r)
        return e;
      if (e !== void 0)
        return e = Math.floor(e / t + 0.5) * t, e;
    }
  );
}
function fv(i) {
  const t = km(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(e, r) {
      return r || e === void 0 ? e : Math.abs(e) <= t ? 0 : e;
    }
  );
}
function gv(i) {
  return Math.pow(i, 3);
}
function dv(i) {
  return 1 - gv(1 - i);
}
function yv(i) {
  return 3 * i * i - 2 * i * i * i;
}
const Aa = 0;
class Hh extends Er {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = ll(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && Fg(), t.center && (t.center = Pn(t.center, this.projection_)), t.extent && (t.extent = Zr(t.extent, this.projection_)), this.applyOptions_(t);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(t) {
    const e = Object.assign({}, t);
    for (const f in $e)
      delete e[f];
    this.setProperties(e, !0);
    const r = mv(t);
    this.maxResolution_ = r.maxResolution, this.minResolution_ = r.minResolution, this.zoomFactor_ = r.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = r.minZoom;
    const s = pv(t), u = r.constraint, h = vv(t);
    this.constraints_ = {
      center: s,
      resolution: u,
      rotation: h
    }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(
      t.center !== void 0 ? t.center : null
    ), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(t) {
    let e = this.padding_;
    this.padding_ = t;
    const r = this.getCenterInternal();
    if (r) {
      const s = t || [0, 0, 0, 0];
      e = e || [0, 0, 0, 0];
      const u = this.getResolution(), h = u / 2 * (s[3] - e[3] + e[1] - s[1]), f = u / 2 * (s[0] - e[0] + e[2] - s[2]);
      this.setCenterInternal([r[0] + h, r[1] - f]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(t) {
    const e = this.getProperties();
    return e.resolution !== void 0 ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), Object.assign({}, e, t);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(t) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const e = new Array(arguments.length);
    for (let r = 0; r < e.length; ++r) {
      let s = arguments[r];
      s.center && (s = Object.assign({}, s), s.center = Pn(
        s.center,
        this.getProjection()
      )), s.anchor && (s = Object.assign({}, s), s.anchor = Pn(
        s.anchor,
        this.getProjection()
      )), e[r] = s;
    }
    this.animateInternal.apply(this, e);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(t) {
    let e = arguments.length, r;
    e > 1 && typeof arguments[e - 1] == "function" && (r = arguments[e - 1], --e);
    let s = 0;
    for (; s < e && !this.isDef(); ++s) {
      const p = arguments[s];
      p.center && this.setCenterInternal(p.center), p.zoom !== void 0 ? this.setZoom(p.zoom) : p.resolution && this.setResolution(p.resolution), p.rotation !== void 0 && this.setRotation(p.rotation);
    }
    if (s === e) {
      r && js(r, !0);
      return;
    }
    let u = Date.now(), h = this.targetCenter_.slice(), f = this.targetResolution_, g = this.targetRotation_;
    const y = [];
    for (; s < e; ++s) {
      const p = (
        /** @type {AnimationOptions} */
        arguments[s]
      ), m = {
        start: u,
        complete: !1,
        anchor: p.anchor,
        duration: p.duration !== void 0 ? p.duration : 1e3,
        easing: p.easing || yv,
        callback: r
      };
      if (p.center && (m.sourceCenter = h, m.targetCenter = p.center.slice(), h = m.targetCenter), p.zoom !== void 0 ? (m.sourceResolution = f, m.targetResolution = this.getResolutionForZoom(p.zoom), f = m.targetResolution) : p.resolution && (m.sourceResolution = f, m.targetResolution = p.resolution, f = m.targetResolution), p.rotation !== void 0) {
        m.sourceRotation = g;
        const _ = mu(p.rotation - g + Math.PI, 2 * Math.PI) - Math.PI;
        m.targetRotation = g + _, g = m.targetRotation;
      }
      _v(m) ? m.complete = !0 : u += m.duration, y.push(m);
    }
    this.animations_.push(y), this.setHint(Oe.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[Oe.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[Oe.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(Oe.ANIMATING, -this.hints_[Oe.ANIMATING]);
    let t;
    for (let e = 0, r = this.animations_.length; e < r; ++e) {
      const s = this.animations_[e];
      if (s[0].callback && js(s[0].callback, !1), !t)
        for (let u = 0, h = s.length; u < h; ++u) {
          const f = s[u];
          if (!f.complete) {
            t = f.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const t = Date.now();
    let e = !1;
    for (let r = this.animations_.length - 1; r >= 0; --r) {
      const s = this.animations_[r];
      let u = !0;
      for (let h = 0, f = s.length; h < f; ++h) {
        const g = s[h];
        if (g.complete)
          continue;
        const y = t - g.start;
        let p = g.duration > 0 ? y / g.duration : 1;
        p >= 1 ? (g.complete = !0, p = 1) : u = !1;
        const m = g.easing(p);
        if (g.sourceCenter) {
          const _ = g.sourceCenter[0], x = g.sourceCenter[1], I = g.targetCenter[0], k = g.targetCenter[1];
          this.nextCenter_ = g.targetCenter;
          const C = _ + m * (I - _), R = x + m * (k - x);
          this.targetCenter_ = [C, R];
        }
        if (g.sourceResolution && g.targetResolution) {
          const _ = m === 1 ? g.targetResolution : g.sourceResolution + m * (g.targetResolution - g.sourceResolution);
          if (g.anchor) {
            const x = this.getViewportSize_(this.getRotation()), I = this.constraints_.resolution(
              _,
              0,
              x,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              I,
              g.anchor
            );
          }
          this.nextResolution_ = g.targetResolution, this.targetResolution_ = _, this.applyTargetState_(!0);
        }
        if (g.sourceRotation !== void 0 && g.targetRotation !== void 0) {
          const _ = m === 1 ? mu(g.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : g.sourceRotation + m * (g.targetRotation - g.sourceRotation);
          if (g.anchor) {
            const x = this.constraints_.rotation(
              _,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              x,
              g.anchor
            );
          }
          this.nextRotation_ = g.targetRotation, this.targetRotation_ = _;
        }
        if (this.applyTargetState_(!0), e = !0, !g.complete)
          break;
      }
      if (u) {
        this.animations_[r] = null, this.setHint(Oe.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const h = s[0].callback;
        h && js(h, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), e && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(t, e) {
    let r;
    const s = this.getCenterInternal();
    return s !== void 0 && (r = [s[0] - e[0], s[1] - e[1]], bm(r, t - this.getRotation()), Rm(r, e)), r;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(t, e) {
    let r;
    const s = this.getCenterInternal(), u = this.getResolution();
    if (s !== void 0 && u !== void 0) {
      const h = e[0] - t * (e[0] - s[0]) / u, f = e[1] - t * (e[1] - s[1]) / u;
      r = [h, f];
    }
    return r;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(t) {
    const e = this.viewportSize_;
    if (t) {
      const r = e[0], s = e[1];
      return [
        Math.abs(r * Math.cos(t)) + Math.abs(s * Math.sin(t)),
        Math.abs(r * Math.sin(t)) + Math.abs(s * Math.cos(t))
      ];
    }
    return e;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(t) {
    this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const t = this.getCenterInternal();
    return t && zh(t, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get($e.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(t) {
    return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(t) {
    const e = this.calculateExtentInternal(t);
    return Yg(e, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(t) {
    t = t || this.getViewportSizeMinusPadding_();
    const e = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    te(e, "The view center is not defined");
    const r = (
      /** @type {!number} */
      this.getResolution()
    );
    te(r !== void 0, "The view resolution is not defined");
    const s = (
      /** @type {!number} */
      this.getRotation()
    );
    return te(s !== void 0, "The view rotation is not defined"), lm(e, r, s, t);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(t) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get($e.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(t, e) {
    return this.getResolutionForExtentInternal(
      Zr(t, this.getProjection()),
      e
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(t, e) {
    e = e || this.getViewportSizeMinusPadding_();
    const r = he(t) / e[0], s = Cn(t) / e[1];
    return Math.max(r, s);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(t) {
    t = t || 2;
    const e = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, s = Math.log(e / r) / Math.log(t);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(u) {
        return e / Math.pow(t, u * s);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get($e.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(t) {
    const e = Math.log(t || 2), r = this.getConstrainedResolution(this.maxResolution_), s = this.minResolution_, u = Math.log(r / s) / e;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(h) {
        return Math.log(r / h) / e / u;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(t) {
    let e = this.getViewportSize_(t);
    const r = this.padding_;
    return r && (e = [
      e[0] - r[1] - r[3],
      e[1] - r[0] - r[2]
    ]), e;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const t = this.getProjection(), e = this.getResolution(), r = this.getRotation();
    let s = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const u = this.padding_;
    if (u) {
      const h = this.getViewportSizeMinusPadding_();
      s = Pa(
        s,
        this.getViewportSize_(),
        [h[0] / 2 + u[3], h[1] / 2 + u[0]],
        e,
        r
      );
    }
    return {
      center: s.slice(0),
      projection: t !== void 0 ? t : null,
      resolution: e,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: r,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let t;
    const e = this.getResolution();
    return e !== void 0 && (t = this.getZoomForResolution(e)), t;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(t) {
    let e = this.minZoom_ || 0, r, s;
    if (this.resolutions_) {
      const u = wg(this.resolutions_, t, 1);
      e = u, r = this.resolutions_[u], u == this.resolutions_.length - 1 ? s = 2 : s = r / this.resolutions_[u + 1];
    } else
      r = this.maxResolution_, s = this.zoomFactor_;
    return e + Math.log(r / t) / Math.log(s);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(t) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const e = ee(
        Math.floor(t),
        0,
        this.resolutions_.length - 2
      ), r = this.resolutions_[e] / this.resolutions_[e + 1];
      return this.resolutions_[e] / Math.pow(r, ee(t - e, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(t, e) {
    let r;
    if (te(
      Array.isArray(t) || typeof /** @type {?} */
      t.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(t)) {
      te(
        !ul(t),
        "Cannot fit empty extent provided as `geometry`"
      );
      const s = Zr(t, this.getProjection());
      r = Uh(s);
    } else if (t.getType() === "Circle") {
      const s = Zr(
        t.getExtent(),
        this.getProjection()
      );
      r = Uh(s), r.rotate(this.getRotation(), Ri(s));
    } else
      r = t;
    this.fitInternal(r, e);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(t) {
    const e = this.getRotation(), r = Math.cos(e), s = Math.sin(-e), u = t.getFlatCoordinates(), h = t.getStride();
    let f = 1 / 0, g = 1 / 0, y = -1 / 0, p = -1 / 0;
    for (let m = 0, _ = u.length; m < _; m += h) {
      const x = u[m] * r - u[m + 1] * s, I = u[m] * s + u[m + 1] * r;
      f = Math.min(f, x), g = Math.min(g, I), y = Math.max(y, x), p = Math.max(p, I);
    }
    return [f, g, y, p];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(t, e) {
    e = e || {};
    let r = e.size;
    r || (r = this.getViewportSizeMinusPadding_());
    const s = e.padding !== void 0 ? e.padding : [0, 0, 0, 0], u = e.nearest !== void 0 ? e.nearest : !1;
    let h;
    e.minResolution !== void 0 ? h = e.minResolution : e.maxZoom !== void 0 ? h = this.getResolutionForZoom(e.maxZoom) : h = 0;
    const f = this.rotatedExtentForGeometry(t);
    let g = this.getResolutionForExtentInternal(f, [
      r[0] - s[1] - s[3],
      r[1] - s[0] - s[2]
    ]);
    g = isNaN(g) ? h : Math.max(g, h), g = this.getConstrainedResolution(g, u ? 0 : 1);
    const y = this.getRotation(), p = Math.sin(y), m = Math.cos(y), _ = Ri(f);
    _[0] += (s[1] - s[3]) / 2 * g, _[1] += (s[0] - s[2]) / 2 * g;
    const x = _[0] * m - _[1] * p, I = _[1] * m + _[0] * p, k = this.getConstrainedCenter([x, I], g), C = e.callback ? e.callback : as;
    e.duration !== void 0 ? this.animateInternal(
      {
        resolution: g,
        center: k,
        duration: e.duration,
        easing: e.easing
      },
      C
    ) : (this.targetResolution_ = g, this.targetCenter_ = k, this.applyTargetState_(!1, !0), js(C, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(t, e, r) {
    this.centerOnInternal(
      Pn(t, this.getProjection()),
      e,
      r
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(t, e, r) {
    this.setCenterInternal(
      Pa(
        t,
        e,
        r,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(t, e, r, s) {
    let u;
    const h = this.padding_;
    if (h && t) {
      const f = this.getViewportSizeMinusPadding_(-r), g = Pa(
        t,
        s,
        [f[0] / 2 + h[3], f[1] / 2 + h[0]],
        e,
        r
      );
      u = [
        t[0] - g[0],
        t[1] - g[1]
      ];
    }
    return u;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(t) {
    const e = zh(this.targetCenter_, this.getProjection());
    this.setCenter([
      e[0] + t[0],
      e[1] + t[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(t) {
    const e = this.targetCenter_;
    this.setCenterInternal([
      e[0] + t[0],
      e[1] + t[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(t, e) {
    e = e && Pn(e, this.getProjection()), this.adjustResolutionInternal(t, e);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(t, e) {
    const r = this.getAnimating() || this.getInteracting(), s = this.getViewportSize_(this.getRotation()), u = this.constraints_.resolution(
      this.targetResolution_ * t,
      0,
      s,
      r
    );
    e && (this.targetCenter_ = this.calculateCenterZoom(u, e)), this.targetResolution_ *= t, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(t, e) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(t, e) {
    e && (e = Pn(e, this.getProjection())), this.adjustRotationInternal(t, e);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(t, e) {
    const r = this.getAnimating() || this.getInteracting(), s = this.constraints_.rotation(
      this.targetRotation_ + t,
      r
    );
    e && (this.targetCenter_ = this.calculateCenterRotate(s, e)), this.targetRotation_ += t, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(t) {
    this.setCenterInternal(
      t && Pn(t, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(t) {
    this.targetCenter_ = t, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(t, e) {
    return this.hints_[t] += e, this.changed(), this.hints_[t];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(t) {
    this.targetResolution_ = t, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(t) {
    this.targetRotation_ = t, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(t) {
    this.setResolution(this.getResolutionForZoom(t));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(t, e) {
    const r = this.getAnimating() || this.getInteracting() || e, s = this.constraints_.rotation(
      this.targetRotation_,
      r
    ), u = this.getViewportSize_(s), h = this.constraints_.resolution(
      this.targetResolution_,
      0,
      u,
      r
    ), f = this.constraints_.center(
      this.targetCenter_,
      h,
      u,
      r,
      this.calculateCenterShift(
        this.targetCenter_,
        h,
        s,
        u
      )
    );
    this.get($e.ROTATION) !== s && this.set($e.ROTATION, s), this.get($e.RESOLUTION) !== h && (this.set($e.RESOLUTION, h), this.set("zoom", this.getZoom(), !0)), (!f || !this.get($e.CENTER) || !_o(this.get($e.CENTER), f)) && this.set($e.CENTER, f), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(t, e, r) {
    t = t !== void 0 ? t : 200;
    const s = e || 0, u = this.constraints_.rotation(this.targetRotation_), h = this.getViewportSize_(u), f = this.constraints_.resolution(
      this.targetResolution_,
      s,
      h
    ), g = this.constraints_.center(
      this.targetCenter_,
      f,
      h,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        f,
        u,
        h
      )
    );
    if (t === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = f, this.targetRotation_ = u, this.targetCenter_ = g, this.applyTargetState_();
      return;
    }
    r = r || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== f || this.getRotation() !== u || !this.getCenterInternal() || !_o(this.getCenterInternal(), g)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: u,
      center: g,
      resolution: f,
      duration: t,
      easing: dv,
      anchor: r
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(Oe.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(t, e, r) {
    r = r && Pn(r, this.getProjection()), this.endInteractionInternal(t, e, r);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(t, e, r) {
    this.getInteracting() && (this.setHint(Oe.INTERACTING, -1), this.resolveConstraints(t, e, r));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(t, e) {
    const r = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      t,
      e || this.getResolution(),
      r
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(t, e) {
    const r = this.getResolutionForZoom(t);
    return this.getZoomForResolution(
      this.getConstrainedResolution(r, e)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(t, e) {
    e = e || 0;
    const r = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(t, e, r);
  }
}
function js(i, t) {
  setTimeout(function() {
    i(t);
  }, 0);
}
function pv(i) {
  if (i.extent !== void 0) {
    const e = i.smoothExtentConstraint !== void 0 ? i.smoothExtentConstraint : !0;
    return jh(i.extent, i.constrainOnlyCenter, e);
  }
  const t = ll(i.projection, "EPSG:3857");
  if (i.multiWorld !== !0 && t.isGlobal()) {
    const e = t.getExtent().slice();
    return e[0] = -1 / 0, e[2] = 1 / 0, jh(e, !1, !1);
  }
  return av;
}
function mv(i) {
  let t, e, r, h = i.minZoom !== void 0 ? i.minZoom : Aa, f = i.maxZoom !== void 0 ? i.maxZoom : 28;
  const g = i.zoomFactor !== void 0 ? i.zoomFactor : 2, y = i.multiWorld !== void 0 ? i.multiWorld : !1, p = i.smoothResolutionConstraint !== void 0 ? i.smoothResolutionConstraint : !0, m = i.showFullExtent !== void 0 ? i.showFullExtent : !1, _ = ll(i.projection, "EPSG:3857"), x = _.getExtent();
  let I = i.constrainOnlyCenter, k = i.extent;
  if (!y && !k && _.isGlobal() && (I = !1, k = x), i.resolutions !== void 0) {
    const C = i.resolutions;
    e = C[h], r = C[f] !== void 0 ? C[f] : C[C.length - 1], i.constrainResolution ? t = uv(
      C,
      p,
      !I && k,
      m
    ) : t = Vh(
      e,
      r,
      p,
      !I && k,
      m
    );
  } else {
    const R = (x ? Math.max(he(x), Cn(x)) : (
      // use an extent that can fit the whole world if need be
      360 * Pg.degrees / _.getMetersPerUnit()
    )) / ov / Math.pow(2, Aa), b = R / Math.pow(2, 28 - Aa);
    e = i.maxResolution, e !== void 0 ? h = 0 : e = R / Math.pow(g, h), r = i.minResolution, r === void 0 && (i.maxZoom !== void 0 ? i.maxResolution !== void 0 ? r = e / Math.pow(g, f) : r = R / Math.pow(g, f) : r = b), f = h + Math.floor(
      Math.log(e / r) / Math.log(g)
    ), r = e / Math.pow(g, f - h), i.constrainResolution ? t = lv(
      g,
      e,
      r,
      p,
      !I && k,
      m
    ) : t = Vh(
      e,
      r,
      p,
      !I && k,
      m
    );
  }
  return {
    constraint: t,
    maxResolution: e,
    minResolution: r,
    minZoom: h,
    zoomFactor: g
  };
}
function vv(i) {
  if (i.enableRotation !== void 0 ? i.enableRotation : !0) {
    const e = i.constrainRotation;
    return e === void 0 || e === !0 ? fv() : e === !1 ? Zh : typeof e == "number" ? cv(e) : Zh;
  }
  return hv;
}
function _v(i) {
  return !(i.sourceCenter && i.targetCenter && !_o(i.sourceCenter, i.targetCenter) || i.sourceResolution !== i.targetResolution || i.sourceRotation !== i.targetRotation);
}
function Pa(i, t, e, r, s) {
  const u = Math.cos(-s);
  let h = Math.sin(-s), f = i[0] * u - i[1] * h, g = i[1] * u + i[0] * h;
  f += (t[0] / 2 - e[0]) * r, g += (e[1] - t[1] / 2) * r, h = -h;
  const y = f * u - g * h, p = g * u + f * h;
  return [y, p];
}
class xv extends sv {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(t) {
    const e = Object.assign({}, t);
    delete e.source, super(e), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(
      Ct.SOURCE,
      this.handleSourcePropertyChange_
    );
    const r = t.source ? (
      /** @type {SourceType} */
      t.source
    ) : null;
    this.setSource(r);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return t = t || [], t.push(this), t;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return t = t || [], t.push(this.getLayerState()), t;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Ct.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const t = this.getSource();
    return t ? t.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (Hn(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const t = this.getSource();
    t && (this.sourceChangeKey_ = En(
      t,
      Ue.CHANGE,
      this.handleSourceChange_,
      this
    ), t.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(t) {
    let e;
    const r = this.getMapInternal();
    !t && r && (t = r.getView()), t instanceof Hh ? e = {
      viewState: t.getState(),
      extent: t.calculateExtent()
    } : e = t, !e.layerStatesArray && r && (e.layerStatesArray = r.getLayerGroup().getLayerStatesArray());
    let s;
    e.layerStatesArray ? s = e.layerStatesArray.find(
      (h) => h.layer === this
    ) : s = this.getLayerState();
    const u = this.getExtent();
    return Ev(s, e.viewState) && (!u || qe(u, e.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(t) {
    if (!this.isVisible(t))
      return [];
    let e;
    const r = this.getSource();
    if (r && (e = r.getAttributions()), !e)
      return [];
    const s = t instanceof Hh ? t.getViewStateAndExtent() : t;
    let u = e(s);
    return Array.isArray(u) || (u = [u]), u;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(t, e) {
    const r = this.getRenderer();
    return r.prepareFrame(t) ? (this.rendered = !0, r.renderFrame(t, e)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(t, e) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(t) {
    const e = this.getRenderer();
    e && e.renderDeferred(t);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(t) {
    t || this.unrender(), this.set(Ct.MAP, t);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Ct.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.mapPrecomposeKey_ && (Hn(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (Hn(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = En(
      t,
      vi.PRECOMPOSE,
      function(e) {
        const s = /** @type {import("../render/Event.js").default} */ e.frameState.layerStatesArray, u = this.getLayerState(!1);
        te(
          !s.some(function(h) {
            return h.layer === u.layer;
          }),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        ), s.push(u);
      },
      this
    ), this.mapRenderKey_ = En(this, Ue.CHANGE, t.render, t), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(t) {
    this.set(Ct.SOURCE, t);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function Ev(i, t) {
  if (!i.visible)
    return !1;
  const e = t.resolution;
  if (e < i.minResolution || e >= i.maxResolution)
    return !1;
  const r = t.zoom;
  return r > i.minZoom && r <= i.maxZoom;
}
function Sv(i, t, e, r, s) {
  Kg(i, t, e || 0, r || i.length - 1, s || Iv);
}
function Kg(i, t, e, r, s) {
  for (; r > e; ) {
    if (r - e > 600) {
      var u = r - e + 1, h = t - e + 1, f = Math.log(u), g = 0.5 * Math.exp(2 * f / 3), y = 0.5 * Math.sqrt(f * g * (u - g) / u) * (h - u / 2 < 0 ? -1 : 1), p = Math.max(e, Math.floor(t - h * g / u + y)), m = Math.min(r, Math.floor(t + (u - h) * g / u + y));
      Kg(i, t, p, m, s);
    }
    var _ = i[t], x = e, I = r;
    for (zr(i, e, t), s(i[r], _) > 0 && zr(i, e, r); x < I; ) {
      for (zr(i, x, I), x++, I--; s(i[x], _) < 0; ) x++;
      for (; s(i[I], _) > 0; ) I--;
    }
    s(i[e], _) === 0 ? zr(i, e, I) : (I++, zr(i, I, r)), I <= t && (e = I + 1), t <= I && (r = I - 1);
  }
}
function zr(i, t, e) {
  var r = i[t];
  i[t] = i[e], i[e] = r;
}
function Iv(i, t) {
  return i < t ? -1 : i > t ? 1 : 0;
}
let Qg = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let e = this.data;
    const r = [];
    if (!Zs(t, e)) return r;
    const s = this.toBBox, u = [];
    for (; e; ) {
      for (let h = 0; h < e.children.length; h++) {
        const f = e.children[h], g = e.leaf ? s(f) : f;
        Zs(t, g) && (e.leaf ? r.push(f) : Fa(t, g) ? this._all(f, r) : u.push(f));
      }
      e = u.pop();
    }
    return r;
  }
  collides(t) {
    let e = this.data;
    if (!Zs(t, e)) return !1;
    const r = [];
    for (; e; ) {
      for (let s = 0; s < e.children.length; s++) {
        const u = e.children[s], h = e.leaf ? this.toBBox(u) : u;
        if (Zs(t, h)) {
          if (e.leaf || Fa(t, h)) return !0;
          r.push(u);
        }
      }
      e = r.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let r = 0; r < t.length; r++)
        this.insert(t[r]);
      return this;
    }
    let e = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = e;
    else if (this.data.height === e.height)
      this._splitRoot(this.data, e);
    else {
      if (this.data.height < e.height) {
        const r = this.data;
        this.data = e, e = r;
      }
      this._insert(e, this.data.height - e.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = tr([]), this;
  }
  remove(t, e) {
    if (!t) return this;
    let r = this.data;
    const s = this.toBBox(t), u = [], h = [];
    let f, g, y;
    for (; r || u.length; ) {
      if (r || (r = u.pop(), g = u[u.length - 1], f = h.pop(), y = !0), r.leaf) {
        const p = wv(t, r.children, e);
        if (p !== -1)
          return r.children.splice(p, 1), u.push(r), this._condense(u), this;
      }
      !y && !r.leaf && Fa(r, s) ? (u.push(r), h.push(f), f = 0, g = r, r = r.children[0]) : g ? (f++, r = g.children[f], y = !1) : r = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, e) {
    return t.minX - e.minX;
  }
  compareMinY(t, e) {
    return t.minY - e.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, e) {
    const r = [];
    for (; t; )
      t.leaf ? e.push(...t.children) : r.push(...t.children), t = r.pop();
    return e;
  }
  _build(t, e, r, s) {
    const u = r - e + 1;
    let h = this._maxEntries, f;
    if (u <= h)
      return f = tr(t.slice(e, r + 1)), Zi(f, this.toBBox), f;
    s || (s = Math.ceil(Math.log(u) / Math.log(h)), h = Math.ceil(u / Math.pow(h, s - 1))), f = tr([]), f.leaf = !1, f.height = s;
    const g = Math.ceil(u / h), y = g * Math.ceil(Math.sqrt(h));
    Jh(t, e, r, y, this.compareMinX);
    for (let p = e; p <= r; p += y) {
      const m = Math.min(p + y - 1, r);
      Jh(t, p, m, g, this.compareMinY);
      for (let _ = p; _ <= m; _ += g) {
        const x = Math.min(_ + g - 1, m);
        f.children.push(this._build(t, _, x, s - 1));
      }
    }
    return Zi(f, this.toBBox), f;
  }
  _chooseSubtree(t, e, r, s) {
    for (; s.push(e), !(e.leaf || s.length - 1 === r); ) {
      let u = 1 / 0, h = 1 / 0, f;
      for (let g = 0; g < e.children.length; g++) {
        const y = e.children[g], p = Da(y), m = Rv(t, y) - p;
        m < h ? (h = m, u = p < u ? p : u, f = y) : m === h && p < u && (u = p, f = y);
      }
      e = f || e.children[0];
    }
    return e;
  }
  _insert(t, e, r) {
    const s = r ? t : this.toBBox(t), u = [], h = this._chooseSubtree(s, this.data, e, u);
    for (h.children.push(t), Jr(h, s); e >= 0 && u[e].children.length > this._maxEntries; )
      this._split(u, e), e--;
    this._adjustParentBBoxes(s, u, e);
  }
  // split overflowed node into two
  _split(t, e) {
    const r = t[e], s = r.children.length, u = this._minEntries;
    this._chooseSplitAxis(r, u, s);
    const h = this._chooseSplitIndex(r, u, s), f = tr(r.children.splice(h, r.children.length - h));
    f.height = r.height, f.leaf = r.leaf, Zi(r, this.toBBox), Zi(f, this.toBBox), e ? t[e - 1].children.push(f) : this._splitRoot(r, f);
  }
  _splitRoot(t, e) {
    this.data = tr([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Zi(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, e, r) {
    let s, u = 1 / 0, h = 1 / 0;
    for (let f = e; f <= r - e; f++) {
      const g = Hr(t, 0, f, this.toBBox), y = Hr(t, f, r, this.toBBox), p = bv(g, y), m = Da(g) + Da(y);
      p < u ? (u = p, s = f, h = m < h ? m : h) : p === u && m < h && (h = m, s = f);
    }
    return s || r - e;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, e, r) {
    const s = t.leaf ? this.compareMinX : kv, u = t.leaf ? this.compareMinY : Cv, h = this._allDistMargin(t, e, r, s), f = this._allDistMargin(t, e, r, u);
    h < f && t.children.sort(s);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, e, r, s) {
    t.children.sort(s);
    const u = this.toBBox, h = Hr(t, 0, e, u), f = Hr(t, r - e, r, u);
    let g = Vs(h) + Vs(f);
    for (let y = e; y < r - e; y++) {
      const p = t.children[y];
      Jr(h, t.leaf ? u(p) : p), g += Vs(h);
    }
    for (let y = r - e - 1; y >= e; y--) {
      const p = t.children[y];
      Jr(f, t.leaf ? u(p) : p), g += Vs(f);
    }
    return g;
  }
  _adjustParentBBoxes(t, e, r) {
    for (let s = r; s >= 0; s--)
      Jr(e[s], t);
  }
  _condense(t) {
    for (let e = t.length - 1, r; e >= 0; e--)
      t[e].children.length === 0 ? e > 0 ? (r = t[e - 1].children, r.splice(r.indexOf(t[e]), 1)) : this.clear() : Zi(t[e], this.toBBox);
  }
};
function wv(i, t, e) {
  if (!e) return t.indexOf(i);
  for (let r = 0; r < t.length; r++)
    if (e(i, t[r])) return r;
  return -1;
}
function Zi(i, t) {
  Hr(i, 0, i.children.length, t, i);
}
function Hr(i, t, e, r, s) {
  s || (s = tr(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
  for (let u = t; u < e; u++) {
    const h = i.children[u];
    Jr(s, i.leaf ? r(h) : h);
  }
  return s;
}
function Jr(i, t) {
  return i.minX = Math.min(i.minX, t.minX), i.minY = Math.min(i.minY, t.minY), i.maxX = Math.max(i.maxX, t.maxX), i.maxY = Math.max(i.maxY, t.maxY), i;
}
function kv(i, t) {
  return i.minX - t.minX;
}
function Cv(i, t) {
  return i.minY - t.minY;
}
function Da(i) {
  return (i.maxX - i.minX) * (i.maxY - i.minY);
}
function Vs(i) {
  return i.maxX - i.minX + (i.maxY - i.minY);
}
function Rv(i, t) {
  return (Math.max(t.maxX, i.maxX) - Math.min(t.minX, i.minX)) * (Math.max(t.maxY, i.maxY) - Math.min(t.minY, i.minY));
}
function bv(i, t) {
  const e = Math.max(i.minX, t.minX), r = Math.max(i.minY, t.minY), s = Math.min(i.maxX, t.maxX), u = Math.min(i.maxY, t.maxY);
  return Math.max(0, s - e) * Math.max(0, u - r);
}
function Fa(i, t) {
  return i.minX <= t.minX && i.minY <= t.minY && t.maxX <= i.maxX && t.maxY <= i.maxY;
}
function Zs(i, t) {
  return t.minX <= i.maxX && t.minY <= i.maxY && t.maxX >= i.minX && t.maxY >= i.minY;
}
function tr(i) {
  return {
    children: i,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Jh(i, t, e, r, s) {
  const u = [t, e];
  for (; u.length; ) {
    if (e = u.pop(), t = u.pop(), e - t <= r) continue;
    const h = t + Math.ceil((e - t) / r / 2) * r;
    Sv(i, h, t, e, s), u.push(t, h, h, e);
  }
}
const yt = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
function fs(i, t) {
  return Array.isArray(i) ? i : (t === void 0 ? t = [i, i] : (t[0] = i, t[1] = i), t);
}
class ea {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = fs(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new ea({
      opacity: this.getOpacity(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return Tt();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(t) {
    return Tt();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return Tt();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return Tt();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return Tt();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return Tt();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return Tt();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(t) {
    this.displacement_ = t;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(t) {
    this.opacity_ = t;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = fs(t);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    Tt();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    Tt();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    Tt();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
const gs = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
};
var Vt = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"]
};
Vt.whitepoint = {
  //1931 2°
  2: {
    //incadescent
    A: [109.85, 100, 35.585],
    // B:[],
    C: [98.074, 100, 118.232],
    D50: [96.422, 100, 82.521],
    D55: [95.682, 100, 92.149],
    //daylight
    D65: [95.045592705167, 100, 108.9057750759878],
    D75: [94.972, 100, 122.638],
    //flourescent
    // F1: [],
    F2: [99.187, 100, 67.395],
    // F3: [],
    // F4: [],
    // F5: [],
    // F6:[],
    F7: [95.044, 100, 108.755],
    // F8: [],
    // F9: [],
    // F10: [],
    F11: [100.966, 100, 64.37],
    // F12: [],
    E: [100, 100, 100]
  },
  //1964  10°
  10: {
    //incadescent
    A: [111.144, 100, 35.2],
    C: [97.285, 100, 116.145],
    D50: [96.72, 100, 81.427],
    D55: [95.799, 100, 90.926],
    //daylight
    D65: [94.811, 100, 107.304],
    D75: [94.416, 100, 120.641],
    //flourescent
    F2: [103.28, 100, 69.026],
    F7: [95.792, 100, 107.687],
    F11: [103.866, 100, 65.627],
    E: [100, 100, 100]
  }
};
Vt.max = Vt.whitepoint[2].D65;
Vt.rgb = function(i, t) {
  t = t || Vt.whitepoint[2].E;
  var e = i[0] / t[0], r = i[1] / t[1], s = i[2] / t[2], u, h, f;
  return u = e * 3.240969941904521 + r * -1.537383177570093 + s * -0.498610760293, h = e * -0.96924363628087 + r * 1.87596750150772 + s * 0.041555057407175, f = e * 0.055630079696993 + r * -0.20397695888897 + s * 1.056971514242878, u = u > 31308e-7 ? 1.055 * Math.pow(u, 1 / 2.4) - 0.055 : u = u * 12.92, h = h > 31308e-7 ? 1.055 * Math.pow(h, 1 / 2.4) - 0.055 : h = h * 12.92, f = f > 31308e-7 ? 1.055 * Math.pow(f, 1 / 2.4) - 0.055 : f = f * 12.92, u = Math.min(Math.max(0, u), 1), h = Math.min(Math.max(0, h), 1), f = Math.min(Math.max(0, f), 1), [u * 255, h * 255, f * 255];
};
gs.xyz = function(i, t) {
  var e = i[0] / 255, r = i[1] / 255, s = i[2] / 255;
  e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, s = s > 0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
  var u = e * 0.41239079926595 + r * 0.35758433938387 + s * 0.18048078840183, h = e * 0.21263900587151 + r * 0.71516867876775 + s * 0.072192315360733, f = e * 0.019330818715591 + r * 0.11919477979462 + s * 0.95053215224966;
  return t = t || Vt.whitepoint[2].E, [u * t[0], h * t[1], f * t[2]];
};
const Sl = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(i, t, e) {
    var r, s, u, h, f, g, y, p, m, _, x, I, k;
    if (u = i[0], h = i[1], f = i[2], u === 0) return [0, 0, 0];
    var C = 0.0011070564598794539;
    return t = t || "D65", e = e || 2, m = Vt.whitepoint[e][t][0], _ = Vt.whitepoint[e][t][1], x = Vt.whitepoint[e][t][2], I = 4 * m / (m + 15 * _ + 3 * x), k = 9 * _ / (m + 15 * _ + 3 * x), r = h / (13 * u) + I || 0, s = f / (13 * u) + k || 0, y = u > 8 ? _ * Math.pow((u + 16) / 116, 3) : _ * u * C, g = y * 9 * r / (4 * s) || 0, p = y * (12 - 3 * r - 20 * s) / (4 * s) || 0, [g, y, p];
  }
};
Vt.luv = function(i, t, e) {
  var r, s, u, h, f, g, y, p, m, _, x, I, k, C = 0.008856451679035631, R = 903.2962962962961;
  t = t || "D65", e = e || 2, m = Vt.whitepoint[e][t][0], _ = Vt.whitepoint[e][t][1], x = Vt.whitepoint[e][t][2], I = 4 * m / (m + 15 * _ + 3 * x), k = 9 * _ / (m + 15 * _ + 3 * x), g = i[0], y = i[1], p = i[2], r = 4 * g / (g + 15 * y + 3 * p) || 0, s = 9 * y / (g + 15 * y + 3 * p) || 0;
  var b = y / _;
  return u = b <= C ? R * b : 116 * Math.pow(b, 1 / 3) - 16, h = 13 * u * (r - I), f = 13 * u * (s - k), [u, h, f];
};
var td = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(i) {
    var t = i[0], e = i[1], r = i[2], s, u, h;
    return h = r / 360 * 2 * Math.PI, s = e * Math.cos(h), u = e * Math.sin(h), [t, s, u];
  },
  xyz: function(i) {
    return Sl.xyz(td.luv(i));
  }
};
Sl.lchuv = function(i) {
  var t = i[0], e = i[1], r = i[2], s = Math.sqrt(e * e + r * r), u = Math.atan2(r, e), h = u * 360 / 2 / Math.PI;
  return h < 0 && (h += 360), [t, s, h];
};
Vt.lchuv = function(i) {
  return Sl.lchuv(Vt.luv(i));
};
const Kh = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var Qh = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function Tv(i) {
  var p, m;
  var t, e = [], r = 1, s;
  if (typeof i == "number")
    return { space: "rgb", values: [i >>> 16, (i & 65280) >>> 8, i & 255], alpha: 1 };
  if (typeof i == "number") return { space: "rgb", values: [i >>> 16, (i & 65280) >>> 8, i & 255], alpha: 1 };
  if (i = String(i).toLowerCase(), Kh[i])
    e = Kh[i].slice(), s = "rgb";
  else if (i === "transparent")
    r = 0, s = "rgb", e = [0, 0, 0];
  else if (i[0] === "#") {
    var u = i.slice(1), h = u.length, f = h <= 4;
    r = 1, f ? (e = [
      parseInt(u[0] + u[0], 16),
      parseInt(u[1] + u[1], 16),
      parseInt(u[2] + u[2], 16)
    ], h === 4 && (r = parseInt(u[3] + u[3], 16) / 255)) : (e = [
      parseInt(u[0] + u[1], 16),
      parseInt(u[2] + u[3], 16),
      parseInt(u[4] + u[5], 16)
    ], h === 8 && (r = parseInt(u[6] + u[7], 16) / 255)), e[0] || (e[0] = 0), e[1] || (e[1] = 0), e[2] || (e[2] = 0), s = "rgb";
  } else if (t = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(i)) {
    var g = t[1];
    s = g.replace(/a$/, "");
    var y = s === "cmyk" ? 4 : s === "gray" ? 1 : 3;
    e = t[2].trim().split(/\s*[,\/]\s*|\s+/), s === "color" && (s = e.shift()), e = e.map(function(_, x) {
      if (_[_.length - 1] === "%")
        return _ = parseFloat(_) / 100, x === 3 ? _ : s === "rgb" ? _ * 255 : s[0] === "h" || s[0] === "l" && !x ? _ * 100 : s === "lab" ? _ * 125 : s === "lch" ? x < 2 ? _ * 150 : _ * 360 : s[0] === "o" && !x ? _ : s === "oklab" ? _ * 0.4 : s === "oklch" ? x < 2 ? _ * 0.4 : _ * 360 : _;
      if (s[x] === "h" || x === 2 && s[s.length - 1] === "h") {
        if (Qh[_] !== void 0) return Qh[_];
        if (_.endsWith("deg")) return parseFloat(_);
        if (_.endsWith("turn")) return parseFloat(_) * 360;
        if (_.endsWith("grad")) return parseFloat(_) * 360 / 400;
        if (_.endsWith("rad")) return parseFloat(_) * 180 / Math.PI;
      }
      return _ === "none" ? 0 : parseFloat(_);
    }), r = e.length > y ? e.pop() : 1;
  } else /[0-9](?:\s|\/|,)/.test(i) && (e = i.match(/([0-9]+)/g).map(function(_) {
    return parseFloat(_);
  }), s = ((m = (p = i.match(/([a-z])/ig)) == null ? void 0 : p.join("")) == null ? void 0 : m.toLowerCase()) || "rgb");
  return {
    space: s,
    values: e,
    alpha: r
  };
}
const Ga = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(i) {
    var t = i[0] / 360, e = i[1] / 100, r = i[2] / 100, s, u, h, f, g, y = 0;
    if (e === 0) return g = r * 255, [g, g, g];
    for (u = r < 0.5 ? r * (1 + e) : r + e - r * e, s = 2 * r - u, f = [0, 0, 0]; y < 3; )
      h = t + 1 / 3 * -(y - 1), h < 0 ? h++ : h > 1 && h--, g = 6 * h < 1 ? s + (u - s) * 6 * h : 2 * h < 1 ? u : 3 * h < 2 ? s + (u - s) * (2 / 3 - h) * 6 : s, f[y++] = g * 255;
    return f;
  }
};
gs.hsl = function(i) {
  var t = i[0] / 255, e = i[1] / 255, r = i[2] / 255, s = Math.min(t, e, r), u = Math.max(t, e, r), h = u - s, f, g, y;
  return u === s ? f = 0 : t === u ? f = (e - r) / h : e === u ? f = 2 + (r - t) / h : r === u && (f = 4 + (t - e) / h), f = Math.min(f * 60, 360), f < 0 && (f += 360), y = (s + u) / 2, u === s ? g = 0 : y <= 0.5 ? g = h / (u + s) : g = h / (2 - u - s), [f, g * 100, y * 100];
};
function Nv(i) {
  Array.isArray(i) && i.raw && (i = String.raw(...arguments)), i instanceof Number && (i = +i);
  var t, e = Tv(i);
  if (!e.space) return [];
  const r = e.space[0] === "h" ? Ga.min : gs.min, s = e.space[0] === "h" ? Ga.max : gs.max;
  return t = Array(3), t[0] = Math.min(Math.max(e.values[0], r[0]), s[0]), t[1] = Math.min(Math.max(e.values[1], r[1]), s[1]), t[2] = Math.min(Math.max(e.values[2], r[2]), s[2]), e.space[0] === "h" && (t = Ga.rgb(t)), t.push(Math.min(Math.max(e.alpha, 0), 1)), t;
}
function Mv(i) {
  return typeof i == "string" ? i : wl(i);
}
const Ov = 1024, $r = {};
let Ba = 0;
function Lv(i) {
  if (i.length === 4)
    return i;
  const t = i.slice();
  return t[3] = 1, t;
}
function tc(i) {
  const t = Vt.lchuv(gs.xyz(i));
  return t[3] = i[3], t;
}
function Av(i) {
  const t = Vt.rgb(td.xyz(i));
  return t[3] = i[3], t;
}
function Il(i) {
  if ($r.hasOwnProperty(i))
    return $r[i];
  if (Ba >= Ov) {
    let e = 0;
    for (const r in $r)
      e++ & 3 || (delete $r[r], --Ba);
  }
  const t = Nv(i);
  if (t.length !== 4)
    throw new Error('Failed to parse "' + i + '" as color');
  for (const e of t)
    if (isNaN(e))
      throw new Error('Failed to parse "' + i + '" as color');
  return ed(t), $r[i] = t, ++Ba, t;
}
function ds(i) {
  return Array.isArray(i) ? i : Il(i);
}
function ed(i) {
  return i[0] = ee(i[0] + 0.5 | 0, 0, 255), i[1] = ee(i[1] + 0.5 | 0, 0, 255), i[2] = ee(i[2] + 0.5 | 0, 0, 255), i[3] = ee(i[3], 0, 1), i;
}
function wl(i) {
  let t = i[0];
  t != (t | 0) && (t = t + 0.5 | 0);
  let e = i[1];
  e != (e | 0) && (e = e + 0.5 | 0);
  let r = i[2];
  r != (r | 0) && (r = r + 0.5 | 0);
  const s = i[3] === void 0 ? 1 : Math.round(i[3] * 1e3) / 1e3;
  return "rgba(" + t + "," + e + "," + r + "," + s + ")";
}
function Pv(i) {
  try {
    return Il(i), !0;
  } catch {
    return !1;
  }
}
const ni = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "";
ni.includes("firefox");
const Dv = ni.includes("safari") && !ni.includes("chrom");
Dv && (ni.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ni));
ni.includes("webkit") && ni.includes("edge");
ni.includes("macintosh");
const nd = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Fv = typeof Image < "u" && Image.prototype.decode;
(function() {
  let i = !1;
  try {
    const t = Object.defineProperty({}, "passive", {
      get: function() {
        i = !0;
      }
    });
    window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
  } catch {
  }
  return i;
})();
function Se(i, t, e, r) {
  let s;
  return e && e.length ? s = /** @type {HTMLCanvasElement} */
  e.shift() : nd ? s = new OffscreenCanvas(i || 300, t || 300) : s = document.createElement("canvas"), i && (s.width = i), t && (s.height = t), /** @type {CanvasRenderingContext2D} */
  s.getContext("2d", r);
}
let Ya;
function Su() {
  return Ya || (Ya = Se(1, 1)), Ya;
}
function Gv(i) {
  const t = i.canvas;
  t.width = 1, t.height = 1, i.clearRect(0, 0, 1, 1);
}
function Bv(i, t) {
  return new Promise((e, r) => {
    function s() {
      h(), e(i);
    }
    function u() {
      h(), r(new Error("Image load error"));
    }
    function h() {
      i.removeEventListener("load", s), i.removeEventListener("error", u);
    }
    i.addEventListener("load", s), i.addEventListener("error", u);
  });
}
function Yv(i, t) {
  return t && (i.src = t), i.src && Fv ? new Promise(
    (e, r) => i.decode().then(() => e(i)).catch(
      (s) => i.complete && i.width ? e(i) : r(s)
    )
  ) : Bv(i);
}
class zv {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let t = 0;
      for (const e in this.cache_) {
        const r = this.cache_[e];
        !(t++ & 3) && !r.hasListener() && (delete this.cache_[e], delete this.patternCache_[e], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(t, e, r) {
    const s = za(t, e, r);
    return s in this.cache_ ? this.cache_[s] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(t, e, r) {
    const s = za(t, e, r);
    return s in this.patternCache_ ? this.patternCache_[s] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(t, e, r, s, u) {
    const h = za(t, e, r), f = h in this.cache_;
    this.cache_[h] = s, u && (s.getImageState() === yt.IDLE && s.load(), s.getImageState() === yt.LOADING ? s.ready().then(() => {
      this.patternCache_[h] = Su().createPattern(
        s.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[h] = Su().createPattern(
      s.getImage(1),
      "repeat"
    )), f || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(t) {
    this.maxCacheSize_ = t, this.expire();
  }
}
function za(i, t, e) {
  const r = e ? ds(e) : "null";
  return t + ":" + i + ":" + r;
}
const Wn = new zv();
let Xr = null;
class $v extends Cg {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(t, e, r, s, u) {
    super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = r, this.canvas_ = {}, this.color_ = u, this.imageState_ = s === void 0 ? yt.IDLE : s, this.size_ = t && t.width && t.height ? [t.width, t.height] : null, this.src_ = e, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === yt.LOADED) {
      Xr || (Xr = Se(1, 1, void 0, {
        willReadFrequently: !0
      })), Xr.drawImage(this.image_, 0, 0);
      try {
        Xr.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        Xr = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(Ue.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = yt.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = yt.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(t) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(t) {
    return this.replaceColor_(t), this.canvas_[t] ? t : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const t = this.size_[0], e = this.size_[1], r = Se(t, e);
        r.fillRect(0, 0, t, e), this.hitDetectionImage_ = r.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === yt.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = yt.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && Yv(this.image_, this.src_).then((t) => {
        this.image_ = t, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(t) {
    if (!this.color_ || this.canvas_[t] || this.imageState_ !== yt.LOADED)
      return;
    const e = this.image_, r = document.createElement("canvas");
    r.width = Math.ceil(e.width * t), r.height = Math.ceil(e.height * t);
    const s = r.getContext("2d");
    s.scale(t, t), s.drawImage(e, 0, 0), s.globalCompositeOperation = "multiply", s.fillStyle = Mv(this.color_), s.fillRect(0, 0, r.width / t, r.height / t), s.globalCompositeOperation = "destination-in", s.drawImage(e, 0, 0), this.canvas_[t] = r;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((t) => {
      this.imageState_ === yt.LOADED || this.imageState_ === yt.ERROR ? t() : this.addEventListener(Ue.CHANGE, function e() {
        (this.imageState_ === yt.LOADED || this.imageState_ === yt.ERROR) && (this.removeEventListener(Ue.CHANGE, e), t());
      });
    })), this.ready_;
  }
}
function kl(i, t, e, r, s, u) {
  let h = t === void 0 ? void 0 : Wn.get(t, e, s);
  return h || (h = new $v(
    i,
    i instanceof HTMLImageElement ? i.src || void 0 : t,
    e,
    r,
    s
  ), Wn.set(t, e, s, h, u)), u && h && !Wn.getPattern(t, e, s) && Wn.set(t, e, s, h, u), h;
}
function rn(i) {
  return i ? Array.isArray(i) ? wl(i) : typeof i == "object" && "src" in i ? Xv(i) : i : null;
}
function Xv(i) {
  if (!i.offset || !i.size)
    return Wn.getPattern(i.src, "anonymous", i.color);
  const t = i.src + ":" + i.offset, e = Wn.getPattern(
    t,
    void 0,
    i.color
  );
  if (e)
    return e;
  const r = Wn.get(i.src, "anonymous", null);
  if (r.getImageState() !== yt.LOADED)
    return null;
  const s = Se(
    i.size[0],
    i.size[1]
  );
  return s.drawImage(
    r.getImage(1),
    i.offset[0],
    i.offset[1],
    i.size[0],
    i.size[1],
    0,
    0,
    i.size[0],
    i.size[1]
  ), kl(
    s.canvas,
    t,
    void 0,
    yt.LOADED,
    i.color,
    !0
  ), Wn.getPattern(t, void 0, i.color);
}
const qv = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), ec = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], id = function(i) {
  const t = i.match(qv);
  if (!t)
    return null;
  const e = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let r = 0, s = ec.length; r < s; ++r) {
    const u = t[r + 1];
    u !== void 0 && (e[ec[r]] = u);
  }
  return e.families = e.family.split(/,\s?/), e;
}, rd = "10px sans-serif", ce = "#000", cr = "round", In = [], wn = 0, fr = "round", ys = 10, ps = "#000", ms = "center", Io = "middle", _i = [0, 0, 0, 0], vs = 1, Dn = new Er();
let er = null, Iu;
const wu = {}, Wv = function() {
  const t = "32px ", e = ["monospace", "serif"], r = e.length, s = "wmytzilWMYTZIL@#/&?$%10";
  let u, h;
  function f(y, p, m) {
    let _ = !0;
    for (let x = 0; x < r; ++x) {
      const I = e[x];
      if (h = wo(
        y + " " + p + " " + t + I,
        s
      ), m != I) {
        const k = wo(
          y + " " + p + " " + t + m + "," + I,
          s
        );
        _ = _ && k != h;
      }
    }
    return !!_;
  }
  function g() {
    let y = !0;
    const p = Dn.getKeys();
    for (let m = 0, _ = p.length; m < _; ++m) {
      const x = p[m];
      Dn.get(x) < 100 && (f.apply(this, x.split(`
`)) ? (rl(wu), er = null, Iu = void 0, Dn.set(x, 100)) : (Dn.set(x, Dn.get(x) + 1, !0), y = !1));
    }
    y && (clearInterval(u), u = void 0);
  }
  return function(y) {
    const p = id(y);
    if (!p)
      return;
    const m = p.families;
    for (let _ = 0, x = m.length; _ < x; ++_) {
      const I = m[_], k = p.style + `
` + p.weight + `
` + I;
      Dn.get(k) === void 0 && (Dn.set(k, 100, !0), f(p.style, p.weight, I) || (Dn.set(k, 0, !0), u === void 0 && (u = setInterval(g, 32))));
    }
  };
}(), Uv = /* @__PURE__ */ function() {
  let i;
  return function(t) {
    let e = wu[t];
    if (e == null) {
      if (nd) {
        const r = id(t), s = sd(t, "Žg");
        e = (isNaN(Number(r.lineHeight)) ? 1.2 : Number(r.lineHeight)) * (s.actualBoundingBoxAscent + s.actualBoundingBoxDescent);
      } else
        i || (i = document.createElement("div"), i.innerHTML = "M", i.style.minHeight = "0", i.style.maxHeight = "none", i.style.height = "auto", i.style.padding = "0", i.style.border = "none", i.style.position = "absolute", i.style.display = "block", i.style.left = "-99999px"), i.style.font = t, document.body.appendChild(i), e = i.offsetHeight, document.body.removeChild(i);
      wu[t] = e;
    }
    return e;
  };
}();
function sd(i, t) {
  return er || (er = Se(1, 1)), i != Iu && (er.font = i, Iu = er.font), er.measureText(t);
}
function wo(i, t) {
  return sd(i, t).width;
}
function nc(i, t, e) {
  if (t in e)
    return e[t];
  const r = t.split(`
`).reduce((s, u) => Math.max(s, wo(i, u)), 0);
  return e[t] = r, r;
}
function jv(i, t) {
  const e = [], r = [], s = [];
  let u = 0, h = 0, f = 0, g = 0;
  for (let y = 0, p = t.length; y <= p; y += 2) {
    const m = t[y];
    if (m === `
` || y === p) {
      u = Math.max(u, h), s.push(h), h = 0, f += g;
      continue;
    }
    const _ = t[y + 1] || i.font, x = wo(_, m);
    e.push(x), h += x;
    const I = Uv(_);
    r.push(I), g = Math.max(g, I);
  }
  return { width: u, height: f, widths: e, heights: r, lineWidths: s };
}
function Vv(i, t, e, r, s, u, h, f, g, y, p) {
  i.save(), e !== 1 && (i.globalAlpha === void 0 ? i.globalAlpha = (m) => m.globalAlpha *= e : i.globalAlpha *= e), t && i.transform.apply(i, t), /** @type {*} */
  r.contextInstructions ? (i.translate(g, y), i.scale(p[0], p[1]), Zv(
    /** @type {Label} */
    r,
    i
  )) : p[0] < 0 || p[1] < 0 ? (i.translate(g, y), i.scale(p[0], p[1]), i.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    r,
    s,
    u,
    h,
    f,
    0,
    0,
    h,
    f
  )) : i.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    r,
    s,
    u,
    h,
    f,
    g,
    y,
    h * p[0],
    f * p[1]
  ), i.restore();
}
function Zv(i, t) {
  const e = i.contextInstructions;
  for (let r = 0, s = e.length; r < s; r += 2)
    Array.isArray(e[r + 1]) ? t[e[r]].apply(
      t,
      e[r + 1]
    ) : t[e[r]] = e[r + 1];
}
class na extends ea {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    super({
      opacity: 1,
      rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      scale: t.scale !== void 0 ? t.scale : 1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    }), this.canvases_, this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius_ = t.radius, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? yt.LOADING : yt.LOADED, this.imageState_ === yt.LOADING && this.ready().then(() => this.imageState_ = yt.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale(), e = new na({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return e.setOpacity(this.getOpacity()), e;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const t = this.size_, e = this.getDisplacement(), r = this.getScaleArray();
    return [
      t[0] / 2 - e[0] / r[0],
      t[1] / 2 + e[1] / r[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(t) {
    let e = this.canvases_[t];
    if (!e) {
      const r = this.renderOptions_, s = Se(
        r.size * t,
        r.size * t
      );
      this.draw_(r, s, t), e = s.canvas, this.canvases_[t] = e;
    }
    return e;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return t;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(t, e, r) {
    if (e === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter")
      return e;
    let s = this.radius_, u = this.radius2_ === void 0 ? s : this.radius2_;
    if (s < u) {
      const D = s;
      s = u, u = D;
    }
    const h = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, f = 2 * Math.PI / h, g = u * Math.sin(f), y = Math.sqrt(u * u - g * g), p = s - y, m = Math.sqrt(g * g + p * p), _ = m / g;
    if (t === "miter" && _ <= r)
      return _ * e;
    const x = e / 2 / _, I = e / 2 * (p / m), C = Math.sqrt((s + x) * (s + x) + I * I) - s;
    if (this.radius2_ === void 0 || t === "bevel")
      return C * 2;
    const R = s * Math.sin(f), b = Math.sqrt(s * s - R * R), O = u - b, L = Math.sqrt(R * R + O * O) / R;
    if (L <= r) {
      const D = L * e / 2 - u - s;
      return 2 * Math.max(C, D);
    }
    return C * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let t = cr, e = fr, r = 0, s = null, u = 0, h, f = 0;
    this.stroke_ && (h = rn(this.stroke_.getColor() ?? ps), f = this.stroke_.getWidth() ?? vs, s = this.stroke_.getLineDash(), u = this.stroke_.getLineDashOffset() ?? 0, e = this.stroke_.getLineJoin() ?? fr, t = this.stroke_.getLineCap() ?? cr, r = this.stroke_.getMiterLimit() ?? ys);
    const g = this.calculateLineJoinSize_(e, f, r), y = Math.max(this.radius_, this.radius2_ || 0), p = Math.ceil(2 * y + g);
    return {
      strokeStyle: h,
      strokeWidth: f,
      size: p,
      lineCap: t,
      lineDash: s,
      lineDashOffset: u,
      lineJoin: e,
      miterLimit: r
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const t = this.renderOptions_.size;
    this.canvases_ = {}, this.hitDetectionCanvas_ = null, this.size_ = [t, t];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(t, e, r) {
    if (e.scale(r, r), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) {
      let s = this.fill_.getColor();
      s === null && (s = ce), e.fillStyle = rn(s), e.fill();
    }
    t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(t) {
    let e;
    if (this.fill_) {
      let r = this.fill_.getColor(), s = 0;
      typeof r == "string" && (r = ds(r)), r === null ? s = 1 : Array.isArray(r) && (s = r.length === 4 ? r[3] : 1), s === 0 && (e = Se(t.size, t.size), this.drawHitDetectionCanvas_(t, e));
    }
    return e ? e.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(t) {
    let e = this.points_;
    const r = this.radius_;
    if (e === 1 / 0)
      t.arc(0, 0, r, 0, 2 * Math.PI);
    else {
      const s = this.radius2_ === void 0 ? r : this.radius2_;
      this.radius2_ !== void 0 && (e *= 2);
      const u = this.angle_ - Math.PI / 2, h = 2 * Math.PI / e;
      for (let f = 0; f < e; f++) {
        const g = u + f * h, y = f % 2 === 0 ? r : s;
        t.lineTo(y * Math.cos(g), y * Math.sin(g));
      }
      t.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(t, e) {
    e.translate(t.size / 2, t.size / 2), this.createPath_(e), e.fillStyle = ce, e.fill(), t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
  }
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
class ia extends na {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || { radius: 5 }, super({
      points: 1 / 0,
      fill: t.fill,
      radius: t.radius,
      stroke: t.stroke,
      scale: t.scale !== void 0 ? t.scale : 1,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale(), e = new ia({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return e.setOpacity(this.getOpacity()), e;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(t) {
    this.radius_ = t, this.render();
  }
}
class Ni {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.patternImage_ = null, this.color_ = null, t.color !== void 0 && this.setColor(t.color);
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new Ni({
      color: Array.isArray(t) ? t.slice() : t || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(t) {
    if (t !== null && typeof t == "object" && "src" in t) {
      const e = kl(
        null,
        t.src,
        "anonymous",
        void 0,
        t.offset ? null : t.color ? t.color : null,
        !(t.offset && t.size)
      );
      e.ready().then(() => {
        this.patternImage_ = null;
      }), e.getImageState() === yt.IDLE && e.load(), e.getImageState() === yt.LOADING && (this.patternImage_ = e);
    }
    this.color_ = t;
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
class gr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new gr({
      color: Array.isArray(t) ? t.slice() : t || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(t) {
    this.color_ = t;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(t) {
    this.lineCap_ = t;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(t) {
    this.lineDash_ = t;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(t) {
    this.lineDashOffset_ = t;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(t) {
    this.lineJoin_ = t;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(t) {
    this.miterLimit_ = t;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(t) {
    this.width_ = t;
  }
}
class Qn {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(t) {
    t = t || {}, this.geometry_ = null, this.geometryFunction_ = ic, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let t = this.getGeometry();
    return t && typeof t == "object" && (t = /** @type {import("../geom/Geometry.js").default} */
    t.clone()), new Qn({
      geometry: t ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(t) {
    this.renderer_ = t;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(t) {
    this.hitDetectionRenderer_ = t;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(t) {
    this.image_ = t;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(t) {
    typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(e) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e.get(t)
      );
    } : t ? t !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t
      );
    }) : this.geometryFunction_ = ic, this.geometry_ = t;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(t) {
    this.zIndex_ = t;
  }
}
function Hv(i) {
  let t;
  if (typeof i == "function")
    t = i;
  else {
    let e;
    Array.isArray(i) ? e = i : (te(
      typeof /** @type {?} */
      i.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), e = [
      /** @type {Style} */
      i
    ]), t = function() {
      return e;
    };
  }
  return t;
}
let $a = null;
function Jv(i, t) {
  if (!$a) {
    const e = new Ni({
      color: "rgba(255,255,255,0.4)"
    }), r = new gr({
      color: "#3399CC",
      width: 1.25
    });
    $a = [
      new Qn({
        image: new ia({
          fill: e,
          stroke: r,
          radius: 5
        }),
        fill: e,
        stroke: r
      })
    ];
  }
  return $a;
}
function ic(i) {
  return i.getGeometry();
}
function rc(i, t, e, r) {
  return e !== void 0 && r !== void 0 ? [e / i, r / t] : e !== void 0 ? e / i : r !== void 0 ? r / t : 1;
}
class bs extends ea {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = t.opacity !== void 0 ? t.opacity : 1, r = t.rotation !== void 0 ? t.rotation : 0, s = t.scale !== void 0 ? t.scale : 1, u = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
    super({
      opacity: e,
      rotation: r,
      scale: s,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      rotateWithView: u,
      declutterMode: t.declutterMode
    }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
    const h = t.img !== void 0 ? t.img : null;
    let f = t.src;
    te(
      !(f !== void 0 && h),
      "`image` and `src` cannot be provided at the same time"
    ), (f === void 0 || f.length === 0) && h && (f = /** @type {HTMLImageElement} */
    h.src || jt(h)), te(
      f !== void 0 && f.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), te(
      !((t.width !== void 0 || t.height !== void 0) && t.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let g;
    if (t.src !== void 0 ? g = yt.IDLE : h !== void 0 && (h instanceof HTMLImageElement ? h.complete ? g = h.src ? yt.LOADED : yt.IDLE : g = yt.LOADING : g = yt.LOADED), this.color_ = t.color !== void 0 ? ds(t.color) : null, this.iconImage_ = kl(
      h,
      /** @type {string} */
      f,
      this.crossOrigin_,
      g,
      this.color_
    ), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null, t.width !== void 0 || t.height !== void 0) {
      let y, p;
      if (t.size)
        [y, p] = t.size;
      else {
        const m = this.getImage(1);
        if (m.width && m.height)
          y = m.width, p = m.height;
        else if (m instanceof HTMLImageElement) {
          this.initialOptions_ = t;
          const _ = () => {
            if (this.unlistenImageChange(_), !this.initialOptions_)
              return;
            const x = this.iconImage_.getSize();
            this.setScale(
              rc(
                x[0],
                x[1],
                t.width,
                t.height
              )
            );
          };
          this.listenImageChange(_);
          return;
        }
      }
      y !== void 0 && this.setScale(
        rc(y, p, t.width, t.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let t, e, r;
    return this.initialOptions_ ? (e = this.initialOptions_.width, r = this.initialOptions_.height) : (t = this.getScale(), t = Array.isArray(t) ? t.slice() : t), new bs({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: t,
      width: e,
      height: r,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let t = this.normalizedAnchor_;
    if (!t) {
      t = this.anchor_;
      const s = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!s)
          return null;
        t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= s[0]), this.anchorYUnits_ == "fraction" && (t[1] *= s[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!s)
          return null;
        t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + s[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + s[1]);
      }
      this.normalizedAnchor_ = t;
    }
    const e = this.getDisplacement(), r = this.getScaleArray();
    return [
      t[0] - e[0] / r[0],
      t[1] + e[1] / r[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(t) {
    this.anchor_ = t, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */
  getImage(t) {
    return this.iconImage_.getImage(t);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(t) {
    return this.iconImage_.getPixelRatio(t);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let t = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const e = this.getSize(), r = this.iconImage_.getSize();
      if (!e || !r)
        return null;
      t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = r[0] - e[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = r[1] - e[1] - t[1]);
    }
    return this.origin_ = t, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const t = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * t[0];
    if (this.iconImage_.getImageState() == yt.LOADED)
      return this.iconImage_.getSize()[0] * t[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const t = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * t[1];
    if (this.iconImage_.getImageState() == yt.LOADED)
      return this.iconImage_.getSize()[1] * t[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(t) {
    delete this.initialOptions_, super.setScale(t);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    this.iconImage_.addEventListener(Ue.CHANGE, t);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    this.iconImage_.removeEventListener(Ue.CHANGE, t);
  }
  ready() {
    return this.iconImage_.ready();
  }
}
const Kv = "#333";
class ra {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.scale_ = t.scale, this.scaleArray_ = fs(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.repeat_ = t.repeat, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new Ni({ color: Kv }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding, this.declutterMode_ = t.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new ra({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(t) {
    this.overflow_ = t;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(t) {
    this.font_ = t;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(t) {
    this.maxAngle_ = t;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(t) {
    this.offsetX_ = t;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(t) {
    this.offsetY_ = t;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(t) {
    this.placement_ = t;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(t) {
    this.repeat_ = t;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = fs(t !== void 0 ? t : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(t) {
    this.textAlign_ = t;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(t) {
    this.justify_ = t;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(t) {
    this.textBaseline_ = t;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(t) {
    this.backgroundFill_ = t;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(t) {
    this.backgroundStroke_ = t;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(t) {
    this.padding_ = t;
  }
}
let Sr = 0;
const Ir = 0, Gt = 1 << Sr++, nt = 1 << Sr++, Ee = 1 << Sr++, qt = 1 << Sr++, Rn = 1 << Sr++, Qt = Math.pow(2, Sr) - 1, od = {
  [Gt]: "boolean",
  [nt]: "number",
  [Ee]: "string",
  [qt]: "color",
  [Rn]: "number[]"
}, Qv = Object.keys(od).map(Number).sort(Ei);
function ne(i) {
  const t = [];
  for (const e of Qv)
    t_(i, e) && t.push(od[e]);
  return t.length === 0 ? "untyped" : t.length < 3 ? t.join(" or ") : t.slice(0, -1).join(", ") + ", or " + t[t.length - 1];
}
function t_(i, t) {
  return (i & t) === t;
}
function an(i, t) {
  return !!(i & t);
}
function sa(i, t) {
  return i === t;
}
class Un {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
}
class e_ {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(t, e, ...r) {
    this.type = t, this.operator = e, this.args = r;
  }
}
function ad() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    style: {}
  };
}
function n_(i) {
  switch (i) {
    case "string":
      return Ee;
    case "color":
      return qt;
    case "number":
      return nt;
    case "boolean":
      return Gt;
    case "number[]":
      return Rn;
    default:
      throw new Error(`Unrecognized type hint: ${i}`);
  }
}
function wt(i, t, e) {
  switch (typeof i) {
    case "boolean":
      return new Un(Gt, i);
    case "number":
      return new Un(nt, i);
    case "string": {
      let s = Ee;
      return Pv(i) && (s |= qt), sa(s & e, Ir) || (s &= e), new Un(s, i);
    }
  }
  if (!Array.isArray(i))
    throw new Error("Expression must be an array or a primitive value");
  if (i.length === 0)
    throw new Error("Empty expression");
  if (typeof i[0] == "string")
    return d_(i, t, e);
  for (const s of i)
    if (typeof s != "number")
      throw new Error("Expected an array of numbers");
  let r = Rn;
  return (i.length === 3 || i.length === 4) && (r |= qt), e && (r &= e), new Un(r, i);
}
const $ = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string"
}, i_ = {
  [$.Get]: gt(
    ([i, t]) => t !== void 0 ? n_(
      /** @type {string} */
      /** @type {LiteralExpression} */
      t.value
    ) : Qt,
    dt(1, 2),
    r_
  ),
  [$.Var]: gt(
    ([i]) => i.type,
    dt(1, 1),
    s_
  ),
  [$.Id]: gt(nt | Ee, qr, o_),
  [$.Concat]: gt(
    Ee,
    dt(2, 1 / 0),
    xt(Qt)
  ),
  [$.GeometryType]: gt(Ee, qr, a_),
  [$.Resolution]: gt(nt, qr),
  [$.Zoom]: gt(nt, qr),
  [$.Time]: gt(nt, qr),
  [$.Any]: gt(
    Gt,
    dt(2, 1 / 0),
    xt(Gt)
  ),
  [$.All]: gt(
    Gt,
    dt(2, 1 / 0),
    xt(Gt)
  ),
  [$.Not]: gt(
    Gt,
    dt(1, 1),
    xt(Gt)
  ),
  [$.Equal]: gt(
    Gt,
    dt(2, 2),
    xt(Qt),
    Fn
  ),
  [$.NotEqual]: gt(
    Gt,
    dt(2, 2),
    xt(Qt),
    Fn
  ),
  [$.GreaterThan]: gt(
    Gt,
    dt(2, 2),
    xt(Qt),
    Fn
  ),
  [$.GreaterThanOrEqualTo]: gt(
    Gt,
    dt(2, 2),
    xt(Qt),
    Fn
  ),
  [$.LessThan]: gt(
    Gt,
    dt(2, 2),
    xt(Qt),
    Fn
  ),
  [$.LessThanOrEqualTo]: gt(
    Gt,
    dt(2, 2),
    xt(Qt),
    Fn
  ),
  [$.Multiply]: gt(
    (i) => {
      let t = nt | qt;
      for (let e = 0; e < i.length; e++)
        t &= i[e].type;
      return t;
    },
    dt(2, 1 / 0),
    xt(nt | qt),
    Fn
  ),
  [$.Coalesce]: gt(
    (i) => {
      let t = Qt;
      for (let e = 1; e < i.length; e += 2)
        t &= i[e].type;
      return t &= i[i.length - 1].type, t;
    },
    dt(2, 1 / 0),
    xt(Qt),
    Fn
  ),
  [$.Divide]: gt(
    nt,
    dt(2, 2),
    xt(nt)
  ),
  [$.Add]: gt(
    nt,
    dt(2, 1 / 0),
    xt(nt)
  ),
  [$.Subtract]: gt(
    nt,
    dt(2, 2),
    xt(nt)
  ),
  [$.Clamp]: gt(
    nt,
    dt(3, 3),
    xt(nt)
  ),
  [$.Mod]: gt(
    nt,
    dt(2, 2),
    xt(nt)
  ),
  [$.Pow]: gt(
    nt,
    dt(2, 2),
    xt(nt)
  ),
  [$.Abs]: gt(
    nt,
    dt(1, 1),
    xt(nt)
  ),
  [$.Floor]: gt(
    nt,
    dt(1, 1),
    xt(nt)
  ),
  [$.Ceil]: gt(
    nt,
    dt(1, 1),
    xt(nt)
  ),
  [$.Round]: gt(
    nt,
    dt(1, 1),
    xt(nt)
  ),
  [$.Sin]: gt(
    nt,
    dt(1, 1),
    xt(nt)
  ),
  [$.Cos]: gt(
    nt,
    dt(1, 1),
    xt(nt)
  ),
  [$.Atan]: gt(
    nt,
    dt(1, 2),
    xt(nt)
  ),
  [$.Sqrt]: gt(
    nt,
    dt(1, 1),
    xt(nt)
  ),
  [$.Match]: gt(
    (i) => {
      let t = Qt;
      for (let e = 2; e < i.length; e += 2)
        t &= i[e].type;
      return t &= i[i.length - 1].type, t;
    },
    dt(4, 1 / 0),
    sc,
    l_
  ),
  [$.Between]: gt(
    Gt,
    dt(3, 3),
    xt(nt)
  ),
  [$.Interpolate]: gt(
    (i) => {
      let t = qt | nt;
      for (let e = 3; e < i.length; e += 2)
        t &= i[e].type;
      return t;
    },
    dt(6, 1 / 0),
    sc,
    h_
  ),
  [$.Case]: gt(
    (i) => {
      let t = Qt;
      for (let e = 1; e < i.length; e += 2)
        t &= i[e].type;
      return t &= i[i.length - 1].type, t;
    },
    dt(3, 1 / 0),
    u_,
    c_
  ),
  [$.In]: gt(Gt, dt(2, 2), f_),
  [$.Number]: gt(
    nt,
    dt(1, 1 / 0),
    xt(Qt)
  ),
  [$.String]: gt(
    Ee,
    dt(1, 1 / 0),
    xt(Qt)
  ),
  [$.Array]: gt(
    (i) => i.length === 3 || i.length === 4 ? Rn | qt : Rn,
    dt(1, 1 / 0),
    xt(nt)
  ),
  [$.Color]: gt(
    qt,
    dt(1, 4),
    xt(nt)
  ),
  [$.Band]: gt(
    nt,
    dt(1, 3),
    xt(nt)
  ),
  [$.Palette]: gt(qt, dt(2, 2), g_),
  [$.ToString]: gt(
    Ee,
    dt(1, 1),
    xt(Gt | nt | Ee | qt)
  )
};
function r_(i, t) {
  const e = wt(i[1], t);
  if (!(e instanceof Un))
    throw new Error("Expected a literal argument for get operation");
  if (typeof e.value != "string")
    throw new Error("Expected a string argument for get operation");
  if (t.properties.add(e.value), i.length === 3) {
    const r = wt(i[2], t);
    return [e, r];
  }
  return [e];
}
function s_(i, t, e, r) {
  const s = i[1];
  if (typeof s != "string")
    throw new Error("Expected a string argument for var operation");
  if (t.variables.add(s), !("variables" in t.style) || t.style.variables[s] === void 0)
    return [new Un(Qt, s)];
  const u = t.style.variables[s], h = (
    /** @type {LiteralExpression} */
    wt(u, t)
  );
  if (h.value = s, r && !an(r, h.type))
    throw new Error(
      `The variable ${s} has type ${ne(
        h.type
      )} but the following type was expected: ${ne(r)}`
    );
  return [h];
}
function o_(i, t) {
  t.featureId = !0;
}
function a_(i, t) {
  t.geometryType = !0;
}
function qr(i, t) {
  const e = i[0];
  if (i.length !== 1)
    throw new Error(`Expected no arguments for ${e} operation`);
  return [];
}
function dt(i, t) {
  return function(e, r) {
    const s = e[0], u = e.length - 1;
    if (i === t) {
      if (u !== i) {
        const h = i === 1 ? "" : "s";
        throw new Error(
          `Expected ${i} argument${h} for ${s}, got ${u}`
        );
      }
    } else if (u < i || u > t) {
      const h = t === 1 / 0 ? `${i} or more` : `${i} to ${t}`;
      throw new Error(
        `Expected ${h} arguments for ${s}, got ${u}`
      );
    }
  };
}
function xt(i) {
  return function(t, e) {
    const r = t[0], s = t.length - 1, u = new Array(s);
    for (let h = 0; h < s; ++h) {
      const f = wt(t[h + 1], e);
      if (!an(i, f.type)) {
        const g = ne(i), y = ne(f.type);
        throw new Error(
          `Unexpected type for argument ${h} of ${r} operation, got ${g} but expected ${y}`
        );
      }
      f.type &= i, u[h] = f;
    }
    return u;
  };
}
function Fn(i, t, e) {
  const r = i[0], s = i.length - 1;
  let u = Qt;
  for (let f = 0; f < e.length; ++f)
    u &= e[f].type;
  if (u === Ir)
    throw new Error(
      `No common type could be found for arguments of ${r} operation`
    );
  const h = new Array(s);
  for (let f = 0; f < s; ++f)
    h[f] = wt(i[f + 1], t, u);
  return h;
}
function u_(i, t) {
  const e = i[0], r = i.length - 1;
  if (r % 2 === 0)
    throw new Error(
      `An odd amount of arguments was expected for operation ${e}, got ${JSON.stringify(
        r
      )} instead`
    );
}
function sc(i, t) {
  const e = i[0], r = i.length - 1;
  if (r % 2 === 1)
    throw new Error(
      `An even amount of arguments was expected for operation ${e}, got ${JSON.stringify(
        r
      )} instead`
    );
}
function l_(i, t, e, r) {
  const s = i.length - 1;
  let h = wt(i[1], t).type;
  const f = wt(i[i.length - 1], t);
  let g = r !== void 0 ? r & f.type : f.type;
  const y = new Array(s - 2);
  for (let m = 0; m < s - 2; m += 2) {
    const _ = wt(i[m + 2], t), x = wt(i[m + 3], t);
    h &= _.type, g &= x.type, y[m] = _, y[m + 1] = x;
  }
  const p = Ee | nt | Gt;
  if (!an(p, h))
    throw new Error(
      `Expected an input of type ${ne(
        p
      )} for the interpolate operation, got ${ne(h)} instead`
    );
  if (sa(g, Ir))
    throw new Error(
      "Could not find a common output type for the following match operation: " + JSON.stringify(i)
    );
  for (let m = 0; m < s - 2; m += 2) {
    const _ = wt(i[m + 2], t, h), x = wt(i[m + 3], t, g);
    y[m] = _, y[m + 1] = x;
  }
  return [
    wt(i[1], t, h),
    ...y,
    wt(i[i.length - 1], t, g)
  ];
}
function h_(i, t, e, r) {
  const s = i[1];
  let u;
  switch (s[0]) {
    case "linear":
      u = 1;
      break;
    case "exponential":
      if (u = s[1], typeof u != "number")
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(u)} instead`
        );
      break;
    default:
      u = null;
  }
  if (!u)
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(s)}`
    );
  u = wt(u, t);
  let h = wt(i[2], t);
  if (!an(nt, h.type))
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${ne(h.type)} instead`
    );
  h = wt(i[2], t, nt);
  const f = new Array(i.length - 3);
  for (let g = 0; g < f.length; g += 2) {
    let y = wt(i[g + 3], t);
    if (!an(nt, y.type))
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${ne(y.type)} at position ${g + 2} instead`
      );
    let p = wt(i[g + 4], t);
    if (!an(nt | qt, p.type))
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${ne(p.type)} at position ${g + 3} instead`
      );
    y = wt(i[g + 3], t, nt), p = wt(i[g + 4], t, nt | qt), f[g] = y, f[g + 1] = p;
  }
  return [u, h, ...f];
}
function c_(i, t, e, r) {
  const s = wt(i[i.length - 1], t);
  let u = r !== void 0 ? r & s.type : s.type;
  const h = new Array(i.length - 1);
  for (let f = 0; f < h.length - 1; f += 2) {
    const g = wt(i[f + 1], t), y = wt(i[f + 2], t);
    if (!an(Gt, g.type))
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${ne(g.type)} at position ${f} instead`
      );
    u &= y.type, h[f] = g, h[f + 1] = y;
  }
  if (sa(u, Ir))
    throw new Error(
      "Could not find a common output type for the following case operation: " + JSON.stringify(i)
    );
  for (let f = 0; f < h.length - 1; f += 2)
    h[f + 1] = wt(i[f + 2], t, u);
  return h[h.length - 1] = wt(
    i[i.length - 1],
    t,
    u
  ), h;
}
function f_(i, t) {
  let e = (
    /** @type {any} */
    i[2]
  );
  if (!Array.isArray(e))
    throw new Error(
      'The "in" operator was provided a literal value which was not an array as second argument.'
    );
  if (typeof e[0] == "string") {
    if (e[0] !== "literal")
      throw new Error(
        'For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.'
      );
    if (!Array.isArray(e[1]))
      throw new Error(
        'The "in" operator was provided a literal value which was not an array as second argument.'
      );
    e = e[1];
  }
  let r = Ee | nt;
  const s = new Array(e.length);
  for (let h = 0; h < s.length; h++) {
    const f = wt(e[h], t);
    r &= f.type, s[h] = f;
  }
  if (sa(r, Ir))
    throw new Error(
      "Could not find a common type for the following in operation: " + JSON.stringify(i)
    );
  return [wt(i[1], t, r), ...s];
}
function g_(i, t) {
  const e = wt(i[1], t, nt);
  if (e.type !== nt)
    throw new Error(
      `The first argument of palette must be an number, got ${ne(
        e.type
      )} instead`
    );
  const r = i[2];
  if (!Array.isArray(r))
    throw new Error("The second argument of palette must be an array");
  const s = new Array(r.length);
  for (let u = 0; u < s.length; u++) {
    const h = wt(r[u], t, qt);
    if (!(h instanceof Un))
      throw new Error(
        `The palette color at index ${u} must be a literal value`
      );
    if (!an(h.type, qt))
      throw new Error(
        `The palette color at index ${u} should be of type color, got ${ne(
          h.type
        )} instead`
      );
    s[u] = h;
  }
  return [e, ...s];
}
function gt(i, ...t) {
  return function(e, r, s) {
    const u = e[0];
    let h = [];
    for (let g = 0; g < t.length; g++)
      h = t[g](e, r, h, s) || h;
    let f = typeof i == "function" ? i(h) : i;
    if (s !== void 0) {
      if (!an(f, s))
        throw new Error(
          `The following expression was expected to return ${ne(
            s
          )}, but returns ${ne(f)} instead: ${JSON.stringify(
            e
          )}`
        );
      f &= s;
    }
    if (f === Ir)
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          e
        )}`
      );
    return new e_(f, u, ...h);
  };
}
function d_(i, t, e) {
  const r = i[0], s = i_[r];
  if (!s)
    throw new Error(`Unknown operator: ${r}`);
  return s(i, t, e);
}
function ud(i) {
  if (!i)
    return "";
  const t = i.getType();
  switch (t) {
    case "Point":
    case "LineString":
    case "Polygon":
      return t;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        t.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return ud(
        /** @type {import("../geom/GeometryCollection.js").default} */
        i.getGeometries()[0]
      );
    default:
      return "";
  }
}
function ld() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function Tn(i, t, e) {
  const r = wt(i, e);
  if (!an(t, r.type)) {
    const s = ne(t), u = ne(r.type);
    throw new Error(
      `Expected expression to be of type ${s}, got ${u}`
    );
  }
  return Ve(r);
}
function Ve(i, t) {
  if (i instanceof Un) {
    if (i.type === qt && typeof i.value == "string") {
      const r = Il(i.value);
      return function() {
        return r;
      };
    }
    return function() {
      return i.value;
    };
  }
  const e = i.operator;
  switch (e) {
    case $.Number:
    case $.String:
    case $.Coalesce:
      return y_(i);
    case $.Get:
    case $.Var:
      return p_(i);
    case $.Id:
      return (r) => r.featureId;
    case $.GeometryType:
      return (r) => r.geometryType;
    case $.Concat: {
      const r = i.args.map((s) => Ve(s));
      return (s) => "".concat(...r.map((u) => u(s).toString()));
    }
    case $.Resolution:
      return (r) => r.resolution;
    case $.Any:
    case $.All:
    case $.Between:
    case $.In:
    case $.Not:
      return v_(i);
    case $.Equal:
    case $.NotEqual:
    case $.LessThan:
    case $.LessThanOrEqualTo:
    case $.GreaterThan:
    case $.GreaterThanOrEqualTo:
      return m_(i);
    case $.Multiply:
    case $.Divide:
    case $.Add:
    case $.Subtract:
    case $.Clamp:
    case $.Mod:
    case $.Pow:
    case $.Abs:
    case $.Floor:
    case $.Ceil:
    case $.Round:
    case $.Sin:
    case $.Cos:
    case $.Atan:
    case $.Sqrt:
      return __(i);
    case $.Case:
      return x_(i);
    case $.Match:
      return E_(i);
    case $.Interpolate:
      return S_(i);
    case $.ToString:
      return I_(i);
    default:
      throw new Error(`Unsupported operator ${e}`);
  }
}
function y_(i, t) {
  const e = i.operator, r = i.args.length, s = new Array(r);
  for (let u = 0; u < r; ++u)
    s[u] = Ve(i.args[u]);
  switch (e) {
    case $.Coalesce:
      return (u) => {
        for (let h = 0; h < r; ++h) {
          const f = s[h](u);
          if (typeof f < "u" && f !== null)
            return f;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case $.Number:
    case $.String:
      return (u) => {
        for (let h = 0; h < r; ++h) {
          const f = s[h](u);
          if (typeof f === e)
            return f;
        }
        throw new Error(`Expected one of the values to be a ${e}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${e}`);
  }
}
function p_(i, t) {
  const r = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    i.args[0].value
  );
  switch (i.operator) {
    case $.Get:
      return (s) => s.properties[r];
    case $.Var:
      return (s) => s.variables[r];
    default:
      throw new Error(`Unsupported accessor operator ${i.operator}`);
  }
}
function m_(i, t) {
  const e = i.operator, r = Ve(i.args[0]), s = Ve(i.args[1]);
  switch (e) {
    case $.Equal:
      return (u) => r(u) === s(u);
    case $.NotEqual:
      return (u) => r(u) !== s(u);
    case $.LessThan:
      return (u) => r(u) < s(u);
    case $.LessThanOrEqualTo:
      return (u) => r(u) <= s(u);
    case $.GreaterThan:
      return (u) => r(u) > s(u);
    case $.GreaterThanOrEqualTo:
      return (u) => r(u) >= s(u);
    default:
      throw new Error(`Unsupported comparison operator ${e}`);
  }
}
function v_(i, t) {
  const e = i.operator, r = i.args.length, s = new Array(r);
  for (let u = 0; u < r; ++u)
    s[u] = Ve(i.args[u]);
  switch (e) {
    case $.Any:
      return (u) => {
        for (let h = 0; h < r; ++h)
          if (s[h](u))
            return !0;
        return !1;
      };
    case $.All:
      return (u) => {
        for (let h = 0; h < r; ++h)
          if (!s[h](u))
            return !1;
        return !0;
      };
    case $.Between:
      return (u) => {
        const h = s[0](u), f = s[1](u), g = s[2](u);
        return h >= f && h <= g;
      };
    case $.In:
      return (u) => {
        const h = s[0](u);
        for (let f = 1; f < r; ++f)
          if (h === s[f](u))
            return !0;
        return !1;
      };
    case $.Not:
      return (u) => !s[0](u);
    default:
      throw new Error(`Unsupported logical operator ${e}`);
  }
}
function __(i, t) {
  const e = i.operator, r = i.args.length, s = new Array(r);
  for (let u = 0; u < r; ++u)
    s[u] = Ve(i.args[u]);
  switch (e) {
    case $.Multiply:
      return (u) => {
        let h = 1;
        for (let f = 0; f < r; ++f)
          h *= s[f](u);
        return h;
      };
    case $.Divide:
      return (u) => s[0](u) / s[1](u);
    case $.Add:
      return (u) => {
        let h = 0;
        for (let f = 0; f < r; ++f)
          h += s[f](u);
        return h;
      };
    case $.Subtract:
      return (u) => s[0](u) - s[1](u);
    case $.Clamp:
      return (u) => {
        const h = s[0](u), f = s[1](u);
        if (h < f)
          return f;
        const g = s[2](u);
        return h > g ? g : h;
      };
    case $.Mod:
      return (u) => s[0](u) % s[1](u);
    case $.Pow:
      return (u) => Math.pow(s[0](u), s[1](u));
    case $.Abs:
      return (u) => Math.abs(s[0](u));
    case $.Floor:
      return (u) => Math.floor(s[0](u));
    case $.Ceil:
      return (u) => Math.ceil(s[0](u));
    case $.Round:
      return (u) => Math.round(s[0](u));
    case $.Sin:
      return (u) => Math.sin(s[0](u));
    case $.Cos:
      return (u) => Math.cos(s[0](u));
    case $.Atan:
      return r === 2 ? (u) => Math.atan2(s[0](u), s[1](u)) : (u) => Math.atan(s[0](u));
    case $.Sqrt:
      return (u) => Math.sqrt(s[0](u));
    default:
      throw new Error(`Unsupported numeric operator ${e}`);
  }
}
function x_(i, t) {
  const e = i.args.length, r = new Array(e);
  for (let s = 0; s < e; ++s)
    r[s] = Ve(i.args[s]);
  return (s) => {
    for (let u = 0; u < e - 1; u += 2)
      if (r[u](s))
        return r[u + 1](s);
    return r[e - 1](s);
  };
}
function E_(i, t) {
  const e = i.args.length, r = new Array(e);
  for (let s = 0; s < e; ++s)
    r[s] = Ve(i.args[s]);
  return (s) => {
    const u = r[0](s);
    for (let h = 1; h < e; h += 2)
      if (u === r[h](s))
        return r[h + 1](s);
    return r[e - 1](s);
  };
}
function S_(i, t) {
  const e = i.args.length, r = new Array(e);
  for (let s = 0; s < e; ++s)
    r[s] = Ve(i.args[s]);
  return (s) => {
    const u = r[0](s), h = r[1](s);
    let f, g;
    for (let y = 2; y < e; y += 2) {
      const p = r[y](s);
      let m = r[y + 1](s);
      const _ = Array.isArray(m);
      if (_ && (m = Lv(m)), p >= h)
        return y === 2 ? m : _ ? w_(
          u,
          h,
          f,
          g,
          p,
          m
        ) : Kr(
          u,
          h,
          f,
          g,
          p,
          m
        );
      f = p, g = m;
    }
    return g;
  };
}
function I_(i, t) {
  const e = i.operator, r = i.args.length, s = new Array(r);
  for (let u = 0; u < r; ++u)
    s[u] = Ve(i.args[u]);
  switch (e) {
    case $.ToString:
      return (u) => {
        const h = s[0](u);
        return i.args[0].type === qt ? wl(h) : h.toString();
      };
    default:
      throw new Error(`Unsupported convert operator ${e}`);
  }
}
function Kr(i, t, e, r, s, u) {
  const h = s - e;
  if (h === 0)
    return r;
  const f = t - e, g = i === 1 ? f / h : (Math.pow(i, f) - 1) / (Math.pow(i, h) - 1);
  return r + g * (u - r);
}
function w_(i, t, e, r, s, u) {
  if (s - e === 0)
    return r;
  const f = tc(r), g = tc(u);
  let y = g[2] - f[2];
  y > 180 ? y -= 360 : y < -180 && (y += 360);
  const p = [
    Kr(i, t, e, f[0], s, g[0]),
    Kr(i, t, e, f[1], s, g[1]),
    f[2] + Kr(i, t, e, 0, s, y),
    Kr(i, t, e, r[3], s, u[3])
  ];
  return ed(Av(p));
}
function k_(i) {
  return !0;
}
function C_(i) {
  const t = ad(), e = R_(i, t), r = ld();
  return function(s, u) {
    if (r.properties = s.getPropertiesInternal(), r.resolution = u, t.featureId) {
      const h = s.getId();
      h !== void 0 ? r.featureId = h : r.featureId = null;
    }
    return t.geometryType && (r.geometryType = ud(
      s.getGeometry()
    )), e(r);
  };
}
function oc(i) {
  const t = ad(), e = i.length, r = new Array(e);
  for (let h = 0; h < e; ++h)
    r[h] = ku(i[h], t);
  const s = ld(), u = new Array(e);
  return function(h, f) {
    if (s.properties = h.getPropertiesInternal(), s.resolution = f, t.featureId) {
      const y = h.getId();
      y !== void 0 ? s.featureId = y : s.featureId = null;
    }
    let g = 0;
    for (let y = 0; y < e; ++y) {
      const p = r[y](s);
      p && (u[g] = p, g += 1);
    }
    return u.length = g, u;
  };
}
function R_(i, t) {
  const e = i.length, r = new Array(e);
  for (let s = 0; s < e; ++s) {
    const u = i[s], h = "filter" in u ? Tn(u.filter, Gt, t) : k_;
    let f;
    if (Array.isArray(u.style)) {
      const g = u.style.length;
      f = new Array(g);
      for (let y = 0; y < g; ++y)
        f[y] = ku(u.style[y], t);
    } else
      f = [ku(u.style, t)];
    r[s] = { filter: h, styles: f };
  }
  return function(s) {
    const u = [];
    let h = !1;
    for (let f = 0; f < e; ++f) {
      const g = r[f].filter;
      if (g(s) && !(i[f].else && h)) {
        h = !0;
        for (const y of r[f].styles) {
          const p = y(s);
          p && u.push(p);
        }
      }
    }
    return u;
  };
}
function ku(i, t) {
  const e = _s(i, "", t), r = xs(i, "", t), s = b_(i, t), u = T_(i, t), h = fe(i, "z-index", t);
  if (!e && !r && !s && !u && !hr(i))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(i)
    );
  const f = new Qn();
  return function(g) {
    let y = !0;
    if (e) {
      const p = e(g);
      p && (y = !1), f.setFill(p);
    }
    if (r) {
      const p = r(g);
      p && (y = !1), f.setStroke(p);
    }
    if (s) {
      const p = s(g);
      p && (y = !1), f.setText(p);
    }
    if (u) {
      const p = u(g);
      p && (y = !1), f.setImage(p);
    }
    return h && f.setZIndex(h(g)), y ? null : f;
  };
}
function _s(i, t, e) {
  let r;
  if (t + "fill-pattern-src" in i ? r = L_(i, t + "fill-", e) : r = Cl(
    i,
    t + "fill-color",
    e
  ), !r)
    return null;
  const s = new Ni();
  return function(u) {
    const h = r(u);
    return h === "none" ? null : (s.setColor(h), s);
  };
}
function xs(i, t, e) {
  const r = fe(
    i,
    t + "stroke-width",
    e
  ), s = Cl(
    i,
    t + "stroke-color",
    e
  );
  if (!r && !s)
    return null;
  const u = _n(
    i,
    t + "stroke-line-cap",
    e
  ), h = _n(
    i,
    t + "stroke-line-join",
    e
  ), f = hd(
    i,
    t + "stroke-line-dash",
    e
  ), g = fe(
    i,
    t + "stroke-line-dash-offset",
    e
  ), y = fe(
    i,
    t + "stroke-miter-limit",
    e
  ), p = new gr();
  return function(m) {
    if (s) {
      const _ = s(m);
      if (_ === "none")
        return null;
      p.setColor(_);
    }
    if (r && p.setWidth(r(m)), u) {
      const _ = u(m);
      if (_ !== "butt" && _ !== "round" && _ !== "square")
        throw new Error("Expected butt, round, or square line cap");
      p.setLineCap(_);
    }
    if (h) {
      const _ = h(m);
      if (_ !== "bevel" && _ !== "round" && _ !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      p.setLineJoin(_);
    }
    return f && p.setLineDash(f(m)), g && p.setLineDashOffset(g(m)), y && p.setMiterLimit(y(m)), p;
  };
}
function b_(i, t) {
  const e = "text-", r = _n(i, e + "value", t);
  if (!r)
    return null;
  const s = _s(i, e, t), u = _s(
    i,
    e + "background-",
    t
  ), h = xs(i, e, t), f = xs(
    i,
    e + "background-",
    t
  ), g = _n(i, e + "font", t), y = fe(
    i,
    e + "max-angle",
    t
  ), p = fe(
    i,
    e + "offset-x",
    t
  ), m = fe(
    i,
    e + "offset-y",
    t
  ), _ = Es(
    i,
    e + "overflow",
    t
  ), x = _n(
    i,
    e + "placement",
    t
  ), I = fe(i, e + "repeat", t), k = oa(i, e + "scale", t), C = Es(
    i,
    e + "rotate-with-view",
    t
  ), R = fe(
    i,
    e + "rotation",
    t
  ), b = _n(i, e + "align", t), O = _n(
    i,
    e + "justify",
    t
  ), A = _n(
    i,
    e + "baseline",
    t
  ), L = hd(
    i,
    e + "padding",
    t
  ), D = aa(
    i,
    e + "declutter-mode"
  ), F = new ra({ declutterMode: D });
  return function(G) {
    if (F.setText(r(G)), s && F.setFill(s(G)), u && F.setBackgroundFill(u(G)), h && F.setStroke(h(G)), f && F.setBackgroundStroke(f(G)), g && F.setFont(g(G)), y && F.setMaxAngle(y(G)), p && F.setOffsetX(p(G)), m && F.setOffsetY(m(G)), _ && F.setOverflow(_(G)), x) {
      const B = x(G);
      if (B !== "point" && B !== "line")
        throw new Error("Expected point or line for text-placement");
      F.setPlacement(B);
    }
    if (I && F.setRepeat(I(G)), k && F.setScale(k(G)), C && F.setRotateWithView(C(G)), R && F.setRotation(R(G)), b) {
      const B = b(G);
      if (B !== "left" && B !== "center" && B !== "right" && B !== "end" && B !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      F.setTextAlign(B);
    }
    if (O) {
      const B = O(G);
      if (B !== "left" && B !== "right" && B !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      F.setJustify(B);
    }
    if (A) {
      const B = A(G);
      if (B !== "bottom" && B !== "top" && B !== "middle" && B !== "alphabetic" && B !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      F.setTextBaseline(B);
    }
    return L && F.setPadding(L(G)), F;
  };
}
function T_(i, t) {
  return "icon-src" in i ? N_(i, t) : "shape-points" in i ? M_(i, t) : "circle-radius" in i ? O_(i, t) : null;
}
function N_(i, t) {
  const e = "icon-", r = e + "src", s = cd(i[r], r), u = ko(
    i,
    e + "anchor",
    t
  ), h = oa(i, e + "scale", t), f = fe(
    i,
    e + "opacity",
    t
  ), g = ko(
    i,
    e + "displacement",
    t
  ), y = fe(
    i,
    e + "rotation",
    t
  ), p = Es(
    i,
    e + "rotate-with-view",
    t
  ), m = uc(i, e + "anchor-origin"), _ = lc(
    i,
    e + "anchor-x-units"
  ), x = lc(
    i,
    e + "anchor-y-units"
  ), I = F_(i, e + "color"), k = P_(i, e + "cross-origin"), C = D_(i, e + "offset"), R = uc(i, e + "offset-origin"), b = Co(i, e + "width"), O = Co(i, e + "height"), A = A_(i, e + "size"), L = aa(
    i,
    e + "declutter-mode"
  ), D = new bs({
    src: s,
    anchorOrigin: m,
    anchorXUnits: _,
    anchorYUnits: x,
    color: I,
    crossOrigin: k,
    offset: C,
    offsetOrigin: R,
    height: O,
    width: b,
    size: A,
    declutterMode: L
  });
  return function(F) {
    return f && D.setOpacity(f(F)), g && D.setDisplacement(g(F)), y && D.setRotation(y(F)), p && D.setRotateWithView(p(F)), h && D.setScale(h(F)), u && D.setAnchor(u(F)), D;
  };
}
function M_(i, t) {
  const e = "shape-", r = e + "points", s = e + "radius", u = Cu(i[r], r), h = Cu(i[s], s), f = _s(i, e, t), g = xs(i, e, t), y = oa(i, e + "scale", t), p = ko(
    i,
    e + "displacement",
    t
  ), m = fe(
    i,
    e + "rotation",
    t
  ), _ = Es(
    i,
    e + "rotate-with-view",
    t
  ), x = Co(i, e + "radius2"), I = Co(i, e + "angle"), k = aa(
    i,
    e + "declutter-mode"
  ), C = new na({
    points: u,
    radius: h,
    radius2: x,
    angle: I,
    declutterMode: k
  });
  return function(R) {
    return f && C.setFill(f(R)), g && C.setStroke(g(R)), p && C.setDisplacement(p(R)), m && C.setRotation(m(R)), _ && C.setRotateWithView(_(R)), y && C.setScale(y(R)), C;
  };
}
function O_(i, t) {
  const e = "circle-", r = _s(i, e, t), s = xs(i, e, t), u = fe(i, e + "radius", t), h = oa(i, e + "scale", t), f = ko(
    i,
    e + "displacement",
    t
  ), g = fe(
    i,
    e + "rotation",
    t
  ), y = Es(
    i,
    e + "rotate-with-view",
    t
  ), p = aa(
    i,
    e + "declutter-mode"
  ), m = new ia({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: p
  });
  return function(_) {
    return u && m.setRadius(u(_)), r && m.setFill(r(_)), s && m.setStroke(s(_)), f && m.setDisplacement(f(_)), g && m.setRotation(g(_)), y && m.setRotateWithView(y(_)), h && m.setScale(h(_)), m;
  };
}
function fe(i, t, e) {
  if (!(t in i))
    return;
  const r = Tn(i[t], nt, e);
  return function(s) {
    return Cu(r(s), t);
  };
}
function _n(i, t, e) {
  if (!(t in i))
    return null;
  const r = Tn(i[t], Ee, e);
  return function(s) {
    return cd(r(s), t);
  };
}
function L_(i, t, e) {
  const r = _n(
    i,
    t + "pattern-src",
    e
  ), s = ac(
    i,
    t + "pattern-offset",
    e
  ), u = ac(
    i,
    t + "pattern-size",
    e
  ), h = Cl(
    i,
    t + "color",
    e
  );
  return function(f) {
    return {
      src: r(f),
      offset: s && s(f),
      size: u && u(f),
      color: h && h(f)
    };
  };
}
function Es(i, t, e) {
  if (!(t in i))
    return null;
  const r = Tn(i[t], Gt, e);
  return function(s) {
    const u = r(s);
    if (typeof u != "boolean")
      throw new Error(`Expected a boolean for ${t}`);
    return u;
  };
}
function Cl(i, t, e) {
  if (!(t in i))
    return null;
  const r = Tn(
    i[t],
    qt | Ee,
    e
  );
  return function(s) {
    return fd(r(s), t);
  };
}
function hd(i, t, e) {
  if (!(t in i))
    return null;
  const r = Tn(i[t], Rn, e);
  return function(s) {
    return Ts(r(s), t);
  };
}
function ko(i, t, e) {
  if (!(t in i))
    return null;
  const r = Tn(i[t], Rn, e);
  return function(s) {
    const u = Ts(r(s), t);
    if (u.length !== 2)
      throw new Error(`Expected two numbers for ${t}`);
    return u;
  };
}
function ac(i, t, e) {
  if (!(t in i))
    return null;
  const r = Tn(i[t], Rn, e);
  return function(s) {
    return gd(r(s), t);
  };
}
function oa(i, t, e) {
  if (!(t in i))
    return null;
  const r = Tn(
    i[t],
    Rn | nt,
    e
  );
  return function(s) {
    return G_(r(s), t);
  };
}
function Co(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (typeof e != "number")
      throw new Error(`Expected a number for ${t}`);
    return e;
  }
}
function A_(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (typeof e == "number")
      return fs(e);
    if (!Array.isArray(e))
      throw new Error(`Expected a number or size array for ${t}`);
    if (e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number")
      throw new Error(`Expected a number or size array for ${t}`);
    return e;
  }
}
function P_(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (typeof e != "string")
      throw new Error(`Expected a string for ${t}`);
    return e;
  }
}
function uc(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (e !== "bottom-left" && e !== "bottom-right" && e !== "top-left" && e !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${t}`
      );
    return e;
  }
}
function lc(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (e !== "pixels" && e !== "fraction")
      throw new Error(`Expected pixels or fraction for ${t}`);
    return e;
  }
}
function D_(i, t) {
  const e = i[t];
  if (e !== void 0)
    return Ts(e, t);
}
function aa(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (typeof e != "string")
      throw new Error(`Expected a string for ${t}`);
    if (e !== "declutter" && e !== "obstacle" && e !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${t}`);
    return e;
  }
}
function F_(i, t) {
  const e = i[t];
  if (e !== void 0)
    return fd(e, t);
}
function Ts(i, t) {
  if (!Array.isArray(i))
    throw new Error(`Expected an array for ${t}`);
  const e = i.length;
  for (let r = 0; r < e; ++r)
    if (typeof i[r] != "number")
      throw new Error(`Expected an array of numbers for ${t}`);
  return i;
}
function cd(i, t) {
  if (typeof i != "string")
    throw new Error(`Expected a string for ${t}`);
  return i;
}
function Cu(i, t) {
  if (typeof i != "number")
    throw new Error(`Expected a number for ${t}`);
  return i;
}
function fd(i, t) {
  if (typeof i == "string")
    return i;
  const e = Ts(i, t), r = e.length;
  if (r < 3 || r > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${t}`);
  return e;
}
function gd(i, t) {
  const e = Ts(i, t);
  if (e.length !== 2)
    throw new Error(`Expected an array of two numbers for ${t}`);
  return e;
}
function G_(i, t) {
  return typeof i == "number" ? i : gd(i, t);
}
const hc = {
  RENDER_ORDER: "renderOrder"
};
class B_ extends xv {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = Object.assign({}, t);
    delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, super(e), this.declutter_ = t.declutter ? String(t.declutter) : void 0, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : !1, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(t) {
    return super.getFeatures(t);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(hc.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(t, e) {
    const r = this.getDeclutter();
    r in t.declutter || (t.declutter[r] = new Qg(9)), this.getRenderer().renderDeclutter(t, e);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(t) {
    this.set(hc.RENDER_ORDER, t);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(t) {
    this.style_ = Y_(t), this.styleFunction_ = t === null ? void 0 : Hv(this.style_), this.changed();
  }
}
function Y_(i) {
  if (i === void 0)
    return Jv;
  if (!i)
    return null;
  if (typeof i == "function" || i instanceof Qn)
    return i;
  if (!Array.isArray(i))
    return oc([i]);
  if (i.length === 0)
    return [];
  const t = i.length, e = i[0];
  if (e instanceof Qn) {
    const s = new Array(t);
    for (let u = 0; u < t; ++u) {
      const h = i[u];
      if (!(h instanceof Qn))
        throw new Error("Expected a list of style instances");
      s[u] = h;
    }
    return s;
  }
  if ("style" in e) {
    const s = new Array(t);
    for (let u = 0; u < t; ++u) {
      const h = i[u];
      if (!("style" in h))
        throw new Error("Expected a list of rules with a style property");
      s[u] = h;
    }
    return C_(s);
  }
  return oc(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    i
  );
}
const st = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, Hs = [st.FILL], jn = [st.STROKE], xi = [st.BEGIN_PATH], cc = [st.CLOSE_PATH];
class dd {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(t, e, r, s, u) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(t) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(t) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(t, e, r) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(t, e, r) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(t, e, r) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(t, e, r) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(t, e, r) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(t, e, r) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(t, e, r) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(t, e, r) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(t, e, r) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(t, e, r) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, e) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(t, e) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(t, e) {
  }
}
class Ns extends dd {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, r, s) {
    super(), this.tolerance = t, this.maxExtent = e, this.pixelRatio = s, this.maxLineWidth = 0, this.resolution = r, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(t) {
    const e = this.pixelRatio;
    return e == 1 ? t : t.map(function(r) {
      return r * e;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(t, e) {
    const r = this.getBufferedMaxExtent(), s = this.tmpCoordinate_, u = this.coordinates;
    let h = u.length;
    for (let f = 0, g = t.length; f < g; f += e)
      s[0] = t[f], s[1] = t[f + 1], du(r, s) && (u[h++] = s[0], u[h++] = s[1]);
    return h;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(t, e, r, s, u, h) {
    const f = this.coordinates;
    let g = f.length;
    const y = this.getBufferedMaxExtent();
    h && (e += s);
    let p = t[e], m = t[e + 1];
    const _ = this.tmpCoordinate_;
    let x = !0, I, k, C;
    for (I = e + s; I < r; I += s)
      _[0] = t[I], _[1] = t[I + 1], C = yu(y, _), C !== k ? (x && (f[g++] = p, f[g++] = m, x = !1), f[g++] = _[0], f[g++] = _[1]) : C === Xt.INTERSECTING ? (f[g++] = _[0], f[g++] = _[1], x = !1) : x = !0, p = _[0], m = _[1], k = C;
    return (u && x || I === e + s) && (f[g++] = p, f[g++] = m), g;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(t, e, r, s, u) {
    for (let h = 0, f = r.length; h < f; ++h) {
      const g = r[h], y = this.appendFlatLineCoordinates(
        t,
        e,
        g,
        s,
        !1,
        !1
      );
      u.push(y), e = g;
    }
    return e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(t, e, r, s, u) {
    this.beginGeometry(t, e, u);
    const h = t.getType(), f = t.getStride(), g = this.coordinates.length;
    let y, p, m, _, x;
    switch (h) {
      case "MultiPolygon":
        y = /** @type {import("../../geom/MultiPolygon.js").default} */
        t.getOrientedFlatCoordinates(), _ = [];
        const I = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        x = 0;
        for (let k = 0, C = I.length; k < C; ++k) {
          const R = [];
          x = this.drawCustomCoordinates_(
            y,
            x,
            I[k],
            f,
            R
          ), _.push(R);
        }
        this.instructions.push([
          st.CUSTOM,
          g,
          _,
          t,
          r,
          _u,
          u
        ]), this.hitDetectionInstructions.push([
          st.CUSTOM,
          g,
          _,
          t,
          s || r,
          _u,
          u
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        m = [], y = h == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          t.getOrientedFlatCoordinates()
        ) : t.getFlatCoordinates(), x = this.drawCustomCoordinates_(
          y,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          t.getEnds(),
          f,
          m
        ), this.instructions.push([
          st.CUSTOM,
          g,
          m,
          t,
          r,
          us,
          u
        ]), this.hitDetectionInstructions.push([
          st.CUSTOM,
          g,
          m,
          t,
          s || r,
          us,
          u
        ]);
        break;
      case "LineString":
      case "Circle":
        y = t.getFlatCoordinates(), p = this.appendFlatLineCoordinates(
          y,
          0,
          y.length,
          f,
          !1,
          !1
        ), this.instructions.push([
          st.CUSTOM,
          g,
          p,
          t,
          r,
          qn,
          u
        ]), this.hitDetectionInstructions.push([
          st.CUSTOM,
          g,
          p,
          t,
          s || r,
          qn,
          u
        ]);
        break;
      case "MultiPoint":
        y = t.getFlatCoordinates(), p = this.appendFlatPointCoordinates(y, f), p > g && (this.instructions.push([
          st.CUSTOM,
          g,
          p,
          t,
          r,
          qn,
          u
        ]), this.hitDetectionInstructions.push([
          st.CUSTOM,
          g,
          p,
          t,
          s || r,
          qn,
          u
        ]));
        break;
      case "Point":
        y = t.getFlatCoordinates(), this.coordinates.push(y[0], y[1]), p = this.coordinates.length, this.instructions.push([
          st.CUSTOM,
          g,
          p,
          t,
          r,
          void 0,
          u
        ]), this.hitDetectionInstructions.push([
          st.CUSTOM,
          g,
          p,
          t,
          s || r,
          void 0,
          u
        ]);
        break;
    }
    this.endGeometry(e);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(t, e, r) {
    this.beginGeometryInstruction1_ = [
      st.BEGIN_GEOMETRY,
      e,
      0,
      t,
      r
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      st.BEGIN_GEOMETRY,
      e,
      0,
      t,
      r
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const t = this.hitDetectionInstructions;
    t.reverse();
    let e;
    const r = t.length;
    let s, u, h = -1;
    for (e = 0; e < r; ++e)
      s = t[e], u = /** @type {import("./Instruction.js").default} */
      s[0], u == st.END_GEOMETRY ? h = e : u == st.BEGIN_GEOMETRY && (s[2] = e, Zp(this.hitDetectionInstructions, h, e), h = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, e) {
    const r = this.state;
    if (t) {
      const s = t.getColor();
      r.fillPatternScale = s && typeof s == "object" && "src" in s ? this.pixelRatio : 1, r.fillStyle = rn(
        s || ce
      );
    } else
      r.fillStyle = void 0;
    if (e) {
      const s = e.getColor();
      r.strokeStyle = rn(
        s || ps
      );
      const u = e.getLineCap();
      r.lineCap = u !== void 0 ? u : cr;
      const h = e.getLineDash();
      r.lineDash = h ? h.slice() : In;
      const f = e.getLineDashOffset();
      r.lineDashOffset = f || wn;
      const g = e.getLineJoin();
      r.lineJoin = g !== void 0 ? g : fr;
      const y = e.getWidth();
      r.lineWidth = y !== void 0 ? y : vs;
      const p = e.getMiterLimit();
      r.miterLimit = p !== void 0 ? p : ys, r.lineWidth > this.maxLineWidth && (this.maxLineWidth = r.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      r.strokeStyle = void 0, r.lineCap = void 0, r.lineDash = null, r.lineDashOffset = void 0, r.lineJoin = void 0, r.lineWidth = void 0, r.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(t) {
    const e = t.fillStyle, r = [st.SET_FILL_STYLE, e];
    return typeof e != "string" && r.push(t.fillPatternScale), r;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    this.instructions.push(this.createStroke(t));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(t) {
    return [
      st.SET_STROKE_STYLE,
      t.strokeStyle,
      t.lineWidth * this.pixelRatio,
      t.lineCap,
      t.lineJoin,
      t.miterLimit,
      this.applyPixelRatio(t.lineDash),
      t.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(t, e) {
    const r = t.fillStyle;
    (typeof r != "string" || t.currentFillStyle != r) && (r !== void 0 && this.instructions.push(e.call(this, t)), t.currentFillStyle = r);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(t, e) {
    const r = t.strokeStyle, s = t.lineCap, u = t.lineDash, h = t.lineDashOffset, f = t.lineJoin, g = t.lineWidth, y = t.miterLimit;
    (t.currentStrokeStyle != r || t.currentLineCap != s || u != t.currentLineDash && !xr(t.currentLineDash, u) || t.currentLineDashOffset != h || t.currentLineJoin != f || t.currentLineWidth != g || t.currentMiterLimit != y) && (r !== void 0 && e.call(this, t), t.currentStrokeStyle = r, t.currentLineCap = s, t.currentLineDash = u, t.currentLineDashOffset = h, t.currentLineJoin = f, t.currentLineWidth = g, t.currentMiterLimit = y);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(t) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const e = [st.END_GEOMETRY, t];
    this.instructions.push(e), this.hitDetectionInstructions.push(e);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = rm(this.maxExtent), this.maxLineWidth > 0)) {
      const t = this.resolution * (this.maxLineWidth + 1) / 2;
      sl(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
class z_ extends Ns {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, r, s) {
    super(t, e, r, s), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(t, e, r) {
    if (!this.image_ || this.maxExtent && !du(this.maxExtent, t.getFlatCoordinates()))
      return;
    this.beginGeometry(t, e, r);
    const s = t.getFlatCoordinates(), u = t.getStride(), h = this.coordinates.length, f = this.appendFlatPointCoordinates(s, u);
    this.instructions.push([
      st.DRAW_IMAGE,
      h,
      f,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      st.DRAW_IMAGE,
      h,
      f,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(t, e, r) {
    if (!this.image_)
      return;
    this.beginGeometry(t, e, r);
    const s = t.getFlatCoordinates(), u = [];
    for (let g = 0, y = s.length; g < y; g += t.getStride())
      (!this.maxExtent || du(this.maxExtent, s.slice(g, g + 2))) && u.push(
        s[g],
        s[g + 1]
      );
    const h = this.coordinates.length, f = this.appendFlatPointCoordinates(u, 2);
    this.instructions.push([
      st.DRAW_IMAGE,
      h,
      f,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      st.DRAW_IMAGE,
      h,
      f,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(t, e) {
    const r = t.getAnchor(), s = t.getSize(), u = t.getOrigin();
    this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = r[0], this.anchorY_ = r[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = s[1], this.opacity_ = t.getOpacity(), this.originX_ = u[0], this.originY_ = u[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = s[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
  }
}
class $_ extends Ns {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, r, s) {
    super(t, e, r, s);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(t, e, r, s) {
    const u = this.coordinates.length, h = this.appendFlatLineCoordinates(
      t,
      e,
      r,
      s,
      !1,
      !1
    ), f = [
      st.MOVE_TO_LINE_TO,
      u,
      h
    ];
    return this.instructions.push(f), this.hitDetectionInstructions.push(f), r;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(t, e, r) {
    const s = this.state, u = s.strokeStyle, h = s.lineWidth;
    if (u === void 0 || h === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, r), this.hitDetectionInstructions.push(
      [
        st.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        In,
        wn
      ],
      xi
    );
    const f = t.getFlatCoordinates(), g = t.getStride();
    this.drawFlatCoordinates_(
      f,
      0,
      f.length,
      g
    ), this.hitDetectionInstructions.push(jn), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(t, e, r) {
    const s = this.state, u = s.strokeStyle, h = s.lineWidth;
    if (u === void 0 || h === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, r), this.hitDetectionInstructions.push(
      [
        st.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        In,
        wn
      ],
      xi
    );
    const f = t.getEnds(), g = t.getFlatCoordinates(), y = t.getStride();
    let p = 0;
    for (let m = 0, _ = f.length; m < _; ++m)
      p = this.drawFlatCoordinates_(
        g,
        p,
        /** @type {number} */
        f[m],
        y
      );
    this.hitDetectionInstructions.push(jn), this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const t = this.state;
    return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(jn), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(jn), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(xi);
  }
}
class fc extends Ns {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, r, s) {
    super(t, e, r, s);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(t, e, r, s) {
    const u = this.state, h = u.fillStyle !== void 0, f = u.strokeStyle !== void 0, g = r.length;
    this.instructions.push(xi), this.hitDetectionInstructions.push(xi);
    for (let y = 0; y < g; ++y) {
      const p = r[y], m = this.coordinates.length, _ = this.appendFlatLineCoordinates(
        t,
        e,
        p,
        s,
        !0,
        !f
      ), x = [
        st.MOVE_TO_LINE_TO,
        m,
        _
      ];
      this.instructions.push(x), this.hitDetectionInstructions.push(x), f && (this.instructions.push(cc), this.hitDetectionInstructions.push(cc)), e = p;
    }
    return h && (this.instructions.push(Hs), this.hitDetectionInstructions.push(Hs)), f && (this.instructions.push(jn), this.hitDetectionInstructions.push(jn)), e;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(t, e, r) {
    const s = this.state, u = s.fillStyle, h = s.strokeStyle;
    if (u === void 0 && h === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, r), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      st.SET_FILL_STYLE,
      ce
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      st.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      In,
      wn
    ]);
    const f = t.getFlatCoordinates(), g = t.getStride(), y = this.coordinates.length;
    this.appendFlatLineCoordinates(
      f,
      0,
      f.length,
      g,
      !1,
      !1
    );
    const p = [st.CIRCLE, y];
    this.instructions.push(xi, p), this.hitDetectionInstructions.push(xi, p), s.fillStyle !== void 0 && (this.instructions.push(Hs), this.hitDetectionInstructions.push(Hs)), s.strokeStyle !== void 0 && (this.instructions.push(jn), this.hitDetectionInstructions.push(jn)), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(t, e, r) {
    const s = this.state, u = s.fillStyle, h = s.strokeStyle;
    if (u === void 0 && h === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, r), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      st.SET_FILL_STYLE,
      ce
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      st.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      In,
      wn
    ]);
    const f = t.getEnds(), g = t.getOrientedFlatCoordinates(), y = t.getStride();
    this.drawFlatCoordinatess_(
      g,
      0,
      /** @type {Array<number>} */
      f,
      y
    ), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(t, e, r) {
    const s = this.state, u = s.fillStyle, h = s.strokeStyle;
    if (u === void 0 && h === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, r), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      st.SET_FILL_STYLE,
      ce
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      st.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      In,
      wn
    ]);
    const f = t.getEndss(), g = t.getOrientedFlatCoordinates(), y = t.getStride();
    let p = 0;
    for (let m = 0, _ = f.length; m < _; ++m)
      p = this.drawFlatCoordinatess_(
        g,
        p,
        f[m],
        y
      );
    this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const t = this.tolerance;
    if (t !== 0) {
      const e = this.coordinates;
      for (let r = 0, s = e.length; r < s; ++r)
        e[r] = pi(e[r], t);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const t = this.state;
    t.fillStyle !== void 0 && this.updateFillStyle(t, this.createFill), t.strokeStyle !== void 0 && this.updateStrokeStyle(t, this.applyStroke);
  }
}
function X_(i, t, e, r, s) {
  const u = [];
  let h = e, f = 0, g = t.slice(e, 2);
  for (; f < i && h + s < r; ) {
    const [y, p] = g.slice(-2), m = t[h + s], _ = t[h + s + 1], x = Math.sqrt(
      (m - y) * (m - y) + (_ - p) * (_ - p)
    );
    if (f += x, f >= i) {
      const I = (i - f + x) / x, k = xe(y, m, I), C = xe(p, _, I);
      g.push(k, C), u.push(g), g = [k, C], f == i && (h += s), f = 0;
    } else if (f < i)
      g.push(
        t[h + s],
        t[h + s + 1]
      ), h += s;
    else {
      const I = x - f, k = xe(y, m, I / x), C = xe(p, _, I / x);
      g.push(k, C), u.push(g), g = [k, C], f = 0, h += s;
    }
  }
  return f > 0 && u.push(g), u;
}
function q_(i, t, e, r, s) {
  let u = e, h = e, f = 0, g = 0, y = e, p, m, _, x, I, k, C, R, b, O;
  for (m = e; m < r; m += s) {
    const A = t[m], L = t[m + 1];
    I !== void 0 && (b = A - I, O = L - k, x = Math.sqrt(b * b + O * O), C !== void 0 && (g += _, p = Math.acos((C * b + R * O) / (_ * x)), p > i && (g > f && (f = g, u = y, h = m), g = 0, y = m - s)), _ = x, C = b, R = O), I = A, k = L;
  }
  return g += x, g > f ? [y, m] : [u, h];
}
const Ro = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class W_ extends Ns {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, r, s) {
    super(t, e, r, s), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[ce] = { fillStyle: ce }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const t = super.finish();
    return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(t, e, r) {
    const s = this.textFillState_, u = this.textStrokeState_, h = this.textState_;
    if (this.text_ === "" || !h || !s && !u)
      return;
    const f = this.coordinates;
    let g = f.length;
    const y = t.getType();
    let p = null, m = t.getStride();
    if (h.placement === "line" && (y == "LineString" || y == "MultiLineString" || y == "Polygon" || y == "MultiPolygon")) {
      if (!qe(this.maxExtent, t.getExtent()))
        return;
      let _;
      if (p = t.getFlatCoordinates(), y == "LineString")
        _ = [p.length];
      else if (y == "MultiLineString")
        _ = /** @type {import("../../geom/MultiLineString.js").default} */
        t.getEnds();
      else if (y == "Polygon")
        _ = /** @type {import("../../geom/Polygon.js").default} */
        t.getEnds().slice(0, 1);
      else if (y == "MultiPolygon") {
        const C = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        _ = [];
        for (let R = 0, b = C.length; R < b; ++R)
          _.push(C[R][0]);
      }
      this.beginGeometry(t, e, r);
      const x = h.repeat, I = x ? void 0 : h.textAlign;
      let k = 0;
      for (let C = 0, R = _.length; C < R; ++C) {
        let b;
        x ? b = X_(
          x * this.resolution,
          p,
          k,
          _[C],
          m
        ) : b = [p.slice(k, _[C])];
        for (let O = 0, A = b.length; O < A; ++O) {
          const L = b[O];
          let D = 0, F = L.length;
          if (I == null) {
            const B = q_(
              h.maxAngle,
              L,
              0,
              L.length,
              2
            );
            D = B[0], F = B[1];
          }
          for (let B = D; B < F; B += m)
            f.push(L[B], L[B + 1]);
          const G = f.length;
          k = _[C], this.drawChars_(g, G), g = G;
        }
      }
      this.endGeometry(e);
    } else {
      let _ = h.overflow ? null : [];
      switch (y) {
        case "Point":
        case "MultiPoint":
          p = /** @type {import("../../geom/MultiPoint.js").default} */
          t.getFlatCoordinates();
          break;
        case "LineString":
          p = /** @type {import("../../geom/LineString.js").default} */
          t.getFlatMidpoint();
          break;
        case "Circle":
          p = /** @type {import("../../geom/Circle.js").default} */
          t.getCenter();
          break;
        case "MultiLineString":
          p = /** @type {import("../../geom/MultiLineString.js").default} */
          t.getFlatMidpoints(), m = 2;
          break;
        case "Polygon":
          p = /** @type {import("../../geom/Polygon.js").default} */
          t.getFlatInteriorPoint(), h.overflow || _.push(p[2] / this.resolution), m = 3;
          break;
        case "MultiPolygon":
          const b = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getFlatInteriorPoints()
          );
          p = [];
          for (let O = 0, A = b.length; O < A; O += 3)
            h.overflow || _.push(b[O + 2] / this.resolution), p.push(b[O], b[O + 1]);
          if (p.length === 0)
            return;
          m = 2;
          break;
      }
      const x = this.appendFlatPointCoordinates(p, m);
      if (x === g)
        return;
      if (_ && (x - g) / 2 !== p.length / m) {
        let b = g / 2;
        _ = _.filter((O, A) => {
          const L = f[(b + A) * 2] === p[A * m] && f[(b + A) * 2 + 1] === p[A * m + 1];
          return L || --b, L;
        });
      }
      this.saveTextStates_(), (h.backgroundFill || h.backgroundStroke) && (this.setFillStrokeStyle(
        h.backgroundFill,
        h.backgroundStroke
      ), h.backgroundFill && this.updateFillStyle(this.state, this.createFill), h.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, e, r);
      let I = h.padding;
      if (I != _i && (h.scale[0] < 0 || h.scale[1] < 0)) {
        let b = h.padding[0], O = h.padding[1], A = h.padding[2], L = h.padding[3];
        h.scale[0] < 0 && (O = -O, L = -L), h.scale[1] < 0 && (b = -b, A = -A), I = [b, O, A, L];
      }
      const k = this.pixelRatio;
      this.instructions.push([
        st.DRAW_IMAGE,
        g,
        x,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        I == _i ? _i : I.map(function(b) {
          return b * k;
        }),
        !!h.backgroundFill,
        !!h.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        _
      ]);
      const C = 1 / k, R = this.state.fillStyle;
      h.backgroundFill && (this.state.fillStyle = ce, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([
        st.DRAW_IMAGE,
        g,
        x,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [C, C],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        I,
        !!h.backgroundFill,
        !!h.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? ce : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        _
      ]), h.backgroundFill && (this.state.fillStyle = R, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(e);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const t = this.textStrokeState_, e = this.textState_, r = this.textFillState_, s = this.strokeKey_;
    t && (s in this.strokeStates || (this.strokeStates[s] = {
      strokeStyle: t.strokeStyle,
      lineCap: t.lineCap,
      lineDashOffset: t.lineDashOffset,
      lineWidth: t.lineWidth,
      lineJoin: t.lineJoin,
      miterLimit: t.miterLimit,
      lineDash: t.lineDash
    }));
    const u = this.textKey_;
    u in this.textStates || (this.textStates[u] = {
      font: e.font,
      textAlign: e.textAlign || ms,
      justify: e.justify,
      textBaseline: e.textBaseline || Io,
      scale: e.scale
    });
    const h = this.fillKey_;
    r && (h in this.fillStates || (this.fillStates[h] = {
      fillStyle: r.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(t, e) {
    const r = this.textStrokeState_, s = this.textState_, u = this.strokeKey_, h = this.textKey_, f = this.fillKey_;
    this.saveTextStates_();
    const g = this.pixelRatio, y = Ro[s.textBaseline], p = this.textOffsetY_ * g, m = this.text_, _ = r ? r.lineWidth * Math.abs(s.scale[0]) / 2 : 0;
    this.instructions.push([
      st.DRAW_CHARS,
      t,
      e,
      y,
      s.overflow,
      f,
      s.maxAngle,
      g,
      p,
      u,
      _ * g,
      m,
      h,
      1,
      this.declutterMode_
    ]), this.hitDetectionInstructions.push([
      st.DRAW_CHARS,
      t,
      e,
      y,
      s.overflow,
      f && ce,
      s.maxAngle,
      g,
      p,
      u,
      _ * g,
      m,
      h,
      1 / g,
      this.declutterMode_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(t, e) {
    let r, s, u;
    if (!t)
      this.text_ = "";
    else {
      const h = t.getFill();
      h ? (s = this.textFillState_, s || (s = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = s), s.fillStyle = rn(
        h.getColor() || ce
      )) : (s = null, this.textFillState_ = s);
      const f = t.getStroke();
      if (!f)
        u = null, this.textStrokeState_ = u;
      else {
        u = this.textStrokeState_, u || (u = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = u);
        const I = f.getLineDash(), k = f.getLineDashOffset(), C = f.getWidth(), R = f.getMiterLimit();
        u.lineCap = f.getLineCap() || cr, u.lineDash = I ? I.slice() : In, u.lineDashOffset = k === void 0 ? wn : k, u.lineJoin = f.getLineJoin() || fr, u.lineWidth = C === void 0 ? vs : C, u.miterLimit = R === void 0 ? ys : R, u.strokeStyle = rn(
          f.getColor() || ps
        );
      }
      r = this.textState_;
      const g = t.getFont() || rd;
      Wv(g);
      const y = t.getScaleArray();
      r.overflow = t.getOverflow(), r.font = g, r.maxAngle = t.getMaxAngle(), r.placement = t.getPlacement(), r.textAlign = t.getTextAlign(), r.repeat = t.getRepeat(), r.justify = t.getJustify(), r.textBaseline = t.getTextBaseline() || Io, r.backgroundFill = t.getBackgroundFill(), r.backgroundStroke = t.getBackgroundStroke(), r.padding = t.getPadding() || _i, r.scale = y === void 0 ? [1, 1] : y;
      const p = t.getOffsetX(), m = t.getOffsetY(), _ = t.getRotateWithView(), x = t.getRotation();
      this.text_ = t.getText() || "", this.textOffsetX_ = p === void 0 ? 0 : p, this.textOffsetY_ = m === void 0 ? 0 : m, this.textRotateWithView_ = _ === void 0 ? !1 : _, this.textRotation_ = x === void 0 ? 0 : x, this.strokeKey_ = u ? (typeof u.strokeStyle == "string" ? u.strokeStyle : jt(u.strokeStyle)) + u.lineCap + u.lineDashOffset + "|" + u.lineWidth + u.lineJoin + u.miterLimit + "[" + u.lineDash.join() + "]" : "", this.textKey_ = r.font + r.scale + (r.textAlign || "?") + (r.repeat || "?") + (r.justify || "?") + (r.textBaseline || "?"), this.fillKey_ = s && s.fillStyle ? typeof s.fillStyle == "string" ? s.fillStyle : "|" + jt(s.fillStyle) : "";
    }
    this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
  }
}
const U_ = {
  Circle: fc,
  Default: Ns,
  Image: z_,
  LineString: $_,
  Polygon: fc,
  Text: W_
};
class j_ {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, r, s) {
    this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = s, this.resolution_ = r, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const t = {};
    for (const e in this.buildersByZIndex_) {
      t[e] = t[e] || {};
      const r = this.buildersByZIndex_[e];
      for (const s in r) {
        const u = r[s].finish();
        t[e][s] = u;
      }
    }
    return t;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(t, e) {
    const r = t !== void 0 ? t.toString() : "0";
    let s = this.buildersByZIndex_[r];
    s === void 0 && (s = {}, this.buildersByZIndex_[r] = s);
    let u = s[e];
    if (u === void 0) {
      const h = U_[e];
      u = new h(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), s[e] = u;
    }
    return u;
  }
}
class V_ extends Cs {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.declutterExecutorGroup = null;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return Tt();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    return Tt();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(t, e) {
    return Tt();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(t, e, r) {
    t[e] || (t[e] = {}), t[e][r.tileCoord.toString()] = r;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(t, e, r) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (s, u) => {
        const h = this.loadedTileCallback.bind(this, r, s);
        return t.forEachLoadedTile(e, s, u, h);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, e, r, s, u) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(t) {
    const e = (
      /** @type {import("../Image.js").default} */
      t.target
    );
    (e.getState() === yt.LOADED || e.getState() === yt.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(t) {
    let e = t.getState();
    return e != yt.LOADED && e != yt.ERROR && t.addEventListener(Ue.CHANGE, this.boundHandleImageChange_), e == yt.IDLE && (t.load(), e = t.getState()), e == yt.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const t = this.getLayer();
    t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(t) {
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
class Z_ extends ks {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(t, e, r, s) {
    super(t), this.inversePixelTransform = e, this.frameState = r, this.context = s;
  }
}
class yd {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    Oh(this, "pushMethodArgs_", (...t) => (this.instructions_[this.zIndex + this.offset_].push(t), this));
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(CanvasRenderingContext2D.prototype, {
      get: (t, e) => {
        if (typeof /** @type {*} */
        Su()[e] == "function")
          return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e), this.pushMethodArgs_;
      },
      set: (t, e, r) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e, r), !0)
    });
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(t) {
    this.instructions_.forEach((e) => {
      for (let r = 0, s = e.length; r < s; r += 2) {
        const u = e[r], h = e[r + 1];
        if (typeof /** @type {*} */
        t[u] == "function")
          t[u](...h);
        else {
          if (typeof h == "function") {
            t[u] = h(t);
            continue;
          }
          t[u] = h;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const gc = [];
let nr = null;
function H_() {
  nr = Se(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class J_ extends V_ {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(t), this.container = null, this.renderedResolution, this.tempTransform = Sn(), this.pixelTransform = Sn(), this.inversePixelTransform = Sn(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(t, e, r) {
    nr || H_(), nr.clearRect(0, 0, 1, 1);
    let s;
    try {
      nr.drawImage(t, e, r, 1, 1, 0, 0, 1, 1), s = nr.getImageData(0, 0, 1, 1).data;
    } catch {
      return nr = null, null;
    }
    return s;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(t) {
    let r = this.getLayer().getBackground();
    return typeof r == "function" && (r = r(t.viewState.resolution)), r || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(t, e, r) {
    const s = this.getLayer().getClassName();
    let u, h;
    if (t && t.className === s && (!r || t && t.style.backgroundColor && xr(
      ds(t.style.backgroundColor),
      ds(r)
    ))) {
      const f = t.firstElementChild;
      f instanceof HTMLCanvasElement && (h = f.getContext("2d"));
    }
    if (h && h.canvas.style.transform === e ? (this.container = t, this.context = h, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      u = document.createElement("div"), u.className = s;
      let f = u.style;
      f.position = "absolute", f.width = "100%", f.height = "100%", h = Se();
      const g = h.canvas;
      u.appendChild(g), f = g.style, f.position = "absolute", f.left = "0", f.transformOrigin = "top left", this.container = u, this.context = h;
    }
    !this.containerReused && r && !this.container.style.backgroundColor && (this.container.style.backgroundColor = r);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(t, e, r) {
    const s = Og(r), u = Lg(r), h = Mg(r), f = Ng(r);
    le(e.coordinateToPixelTransform, s), le(e.coordinateToPixelTransform, u), le(e.coordinateToPixelTransform, h), le(e.coordinateToPixelTransform, f);
    const g = this.inversePixelTransform;
    le(g, s), le(g, u), le(g, h), le(g, f), t.save(), t.beginPath(), t.moveTo(Math.round(s[0]), Math.round(s[1])), t.lineTo(Math.round(u[0]), Math.round(u[1])), t.lineTo(Math.round(h[0]), Math.round(h[1])), t.lineTo(Math.round(f[0]), Math.round(f[1])), t.clip();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(t, e, r) {
    const s = this.getLayer();
    if (s.hasListener(t)) {
      const u = new Z_(
        t,
        this.inversePixelTransform,
        r,
        e
      );
      s.dispatchEvent(u);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(t, e) {
    this.frameState = e, !e.declutter && this.dispatchRenderEvent_(vi.PRERENDER, t, e);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(t, e) {
    e.declutter || this.dispatchRenderEvent_(vi.POSTRENDER, t, e);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(t) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(t) {
    return t.declutter && !this.deferredContext_ && (this.deferredContext_ = new yd()), t.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(t) {
    t.declutter && (this.dispatchRenderEvent_(
      vi.PRERENDER,
      this.context,
      t
    ), t.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(t), this.dispatchRenderEvent_(
      vi.POSTRENDER,
      this.context,
      t
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(t, e, r, s, u, h, f) {
    const g = u / 2, y = h / 2, p = s / e, m = -p, _ = -t[0] + f, x = -t[1];
    return Oi(
      this.tempTransform,
      g,
      y,
      p,
      m,
      -r,
      _,
      x
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
function K_(i, t, e, r, s, u, h, f, g, y, p, m) {
  let _ = i[t], x = i[t + 1], I = 0, k = 0, C = 0, R = 0;
  function b() {
    I = _, k = x, t += r, _ = i[t], x = i[t + 1], R += C, C = Math.sqrt((_ - I) * (_ - I) + (x - k) * (x - k));
  }
  do
    b();
  while (t < e - r && R + C < u);
  let O = C === 0 ? 0 : (u - R) / C;
  const A = xe(I, _, O), L = xe(k, x, O), D = t - r, F = R, G = u + f * g(y, s, p);
  for (; t < e - r && R + C < G; )
    b();
  O = C === 0 ? 0 : (G - R) / C;
  const B = xe(I, _, O), tt = xe(k, x, O);
  let J;
  if (m) {
    const V = [A, L, B, tt];
    zg(V, 0, 4, 2, m, V, V), J = V[0] > V[2];
  } else
    J = A > B;
  const H = Math.PI, Q = [], X = D + r === t;
  t = D, C = 0, R = F, _ = i[t], x = i[t + 1];
  let K;
  if (X) {
    b(), K = Math.atan2(x - k, _ - I), J && (K += K > 0 ? -H : H);
    const V = (B + A) / 2, lt = (tt + L) / 2;
    return Q[0] = [V, lt, (G - u) / 2, K, s], Q;
  }
  s = s.replace(/\n/g, " ");
  for (let V = 0, lt = s.length; V < lt; ) {
    b();
    let ct = Math.atan2(x - k, _ - I);
    if (J && (ct += ct > 0 ? -H : H), K !== void 0) {
      let z = ct - K;
      if (z += z > H ? -2 * H : z < -H ? 2 * H : 0, Math.abs(z) > h)
        return null;
    }
    K = ct;
    const Et = V;
    let Z = 0;
    for (; V < lt; ++V) {
      const z = J ? lt - V - 1 : V, ge = f * g(y, s[z], p);
      if (t + r < e && R + C < u + Z + ge / 2)
        break;
      Z += ge;
    }
    if (V === Et)
      continue;
    const pt = J ? s.substring(lt - Et, lt - V) : s.substring(Et, V);
    O = C === 0 ? 0 : (u + Z / 2 - R) / C;
    const mt = xe(I, _, O), Lt = xe(k, x, O);
    Q.push([mt, Lt, Z / 2, ct, pt]), u += Z;
  }
  return Q;
}
const Hi = ki(), Gn = [], pn = [], mn = [], Bn = [];
function dc(i) {
  return i[3].declutterBox;
}
const yc = new RegExp(
  /* eslint-disable prettier/prettier */
  "[֑-ࣿיִ-﷿ﹰ-ﻼࠀ-࿿-]"
  /* eslint-enable prettier/prettier */
);
function Xa(i, t) {
  return t === "start" ? t = yc.test(i) ? "right" : "left" : t === "end" && (t = yc.test(i) ? "left" : "right"), Ro[t];
}
function Q_(i, t, e) {
  return e > 0 && i.push(`
`, ""), i.push(t, ""), i;
}
class t0 {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(t, e, r, s, u) {
    this.overlaps = r, this.pixelRatio = e, this.resolution = t, this.alignAndScaleFill_, this.instructions = s.instructions, this.coordinates = s.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = Sn(), this.hitDetectionInstructions = s.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = s.fillStates || {}, this.strokeStates = s.strokeStates || {}, this.textStates = s.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = u ? new yd() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(t, e, r, s) {
    const u = t + e + r + s;
    if (this.labels_[u])
      return this.labels_[u];
    const h = s ? this.strokeStates[s] : null, f = r ? this.fillStates[r] : null, g = this.textStates[e], y = this.pixelRatio, p = [
      g.scale[0] * y,
      g.scale[1] * y
    ], m = Array.isArray(t), _ = g.justify ? Ro[g.justify] : Xa(
      Array.isArray(t) ? t[0] : t,
      g.textAlign || ms
    ), x = s && h.lineWidth ? h.lineWidth : 0, I = m ? t : t.split(`
`).reduce(Q_, []), { width: k, height: C, widths: R, heights: b, lineWidths: O } = jv(
      g,
      I
    ), A = k + x, L = [], D = (A + 2) * p[0], F = (C + x) * p[1], G = {
      width: D < 0 ? Math.floor(D) : Math.ceil(D),
      height: F < 0 ? Math.floor(F) : Math.ceil(F),
      contextInstructions: L
    };
    (p[0] != 1 || p[1] != 1) && L.push("scale", p), s && (L.push("strokeStyle", h.strokeStyle), L.push("lineWidth", x), L.push("lineCap", h.lineCap), L.push("lineJoin", h.lineJoin), L.push("miterLimit", h.miterLimit), L.push("setLineDash", [h.lineDash]), L.push("lineDashOffset", h.lineDashOffset)), r && L.push("fillStyle", f.fillStyle), L.push("textBaseline", "middle"), L.push("textAlign", "center");
    const B = 0.5 - _;
    let tt = _ * A + B * x;
    const J = [], H = [];
    let Q = 0, X = 0, K = 0, V = 0, lt;
    for (let ct = 0, Et = I.length; ct < Et; ct += 2) {
      const Z = I[ct];
      if (Z === `
`) {
        X += Q, Q = 0, tt = _ * A + B * x, ++V;
        continue;
      }
      const pt = I[ct + 1] || g.font;
      pt !== lt && (s && J.push("font", pt), r && H.push("font", pt), lt = pt), Q = Math.max(Q, b[K]);
      const mt = [
        Z,
        tt + B * R[K] + _ * (R[K] - O[V]),
        0.5 * (x + Q) + X
      ];
      tt += R[K], s && J.push("strokeText", mt), r && H.push("fillText", mt), ++K;
    }
    return Array.prototype.push.apply(L, J), Array.prototype.push.apply(L, H), this.labels_[u] = G, G;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(t, e, r, s, u, h, f) {
    t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, r), t.lineTo.apply(t, s), t.lineTo.apply(t, u), t.lineTo.apply(t, e), h && (this.alignAndScaleFill_ = /** @type {number} */
    h[2], this.fill_(t)), f && (this.setStrokeStyle_(
      t,
      /** @type {Array<*>} */
      f
    ), t.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(t, e, r, s, u, h, f, g, y, p, m, _, x, I, k, C) {
    f *= _[0], g *= _[1];
    let R = r - f, b = s - g;
    const O = u + y > t ? t - y : u, A = h + p > e ? e - p : h, L = I[3] + O * _[0] + I[1], D = I[0] + A * _[1] + I[2], F = R - I[3], G = b - I[0];
    (k || m !== 0) && (Gn[0] = F, Bn[0] = F, Gn[1] = G, pn[1] = G, pn[0] = F + L, mn[0] = pn[0], mn[1] = G + D, Bn[1] = mn[1]);
    let B;
    return m !== 0 ? (B = Oi(
      Sn(),
      r,
      s,
      1,
      1,
      m,
      -r,
      -s
    ), le(B, Gn), le(B, pn), le(B, mn), le(B, Bn), Ci(
      Math.min(Gn[0], pn[0], mn[0], Bn[0]),
      Math.min(Gn[1], pn[1], mn[1], Bn[1]),
      Math.max(Gn[0], pn[0], mn[0], Bn[0]),
      Math.max(Gn[1], pn[1], mn[1], Bn[1]),
      Hi
    )) : Ci(
      Math.min(F, F + L),
      Math.min(G, G + D),
      Math.max(F, F + L),
      Math.max(G, G + D),
      Hi
    ), x && (R = Math.round(R), b = Math.round(b)), {
      drawImageX: R,
      drawImageY: b,
      drawImageW: O,
      drawImageH: A,
      originX: y,
      originY: p,
      declutterBox: {
        minX: Hi[0],
        minY: Hi[1],
        maxX: Hi[2],
        maxY: Hi[3],
        value: C
      },
      canvasTransform: B,
      scale: _
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(t, e, r, s, u, h, f) {
    const g = !!(h || f), y = s.declutterBox, p = f ? f[2] * s.scale[0] / 2 : 0;
    return y.minX - p <= e[0] && y.maxX + p >= 0 && y.minY - p <= e[1] && y.maxY + p >= 0 && (g && this.replayTextBackground_(
      t,
      Gn,
      pn,
      mn,
      Bn,
      /** @type {Array<*>} */
      h,
      /** @type {Array<*>} */
      f
    ), Vv(
      t,
      s.canvasTransform,
      u,
      r,
      s.originX,
      s.originY,
      s.drawImageW,
      s.drawImageH,
      s.drawImageX,
      s.drawImageY,
      s.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(t) {
    const e = this.alignAndScaleFill_;
    if (e) {
      const r = le(this.renderedTransform_, [0, 0]), s = 512 * this.pixelRatio;
      t.save(), t.translate(r[0] % s, r[1] % s), e !== 1 && t.scale(e, e), t.rotate(this.viewRotation_);
    }
    t.fill(), e && t.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(t, e) {
    t.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    e[1], t.lineWidth = /** @type {number} */
    e[2], t.lineCap = /** @type {CanvasLineCap} */
    e[3], t.lineJoin = /** @type {CanvasLineJoin} */
    e[4], t.miterLimit = /** @type {number} */
    e[5], t.lineDashOffset = /** @type {number} */
    e[7], t.setLineDash(
      /** @type {Array<number>} */
      e[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(t, e, r, s) {
    const u = this.textStates[e], h = this.createLabel(t, e, s, r), f = this.strokeStates[r], g = this.pixelRatio, y = Xa(
      Array.isArray(t) ? t[0] : t,
      u.textAlign || ms
    ), p = Ro[u.textBaseline || Io], m = f && f.lineWidth ? f.lineWidth : 0, _ = h.width / g - 2 * u.scale[0], x = y * _ + 2 * (0.5 - y) * m, I = p * h.height / g + 2 * (0.5 - p) * m;
    return {
      label: h,
      anchorX: x,
      anchorY: I
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(t, e, r, s, u, h, f, g) {
    const y = this.zIndexContext_;
    let p;
    this.pixelCoordinates_ && xr(r, this.renderedTransform_) ? p = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), p = Jn(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      r,
      this.pixelCoordinates_
    ), Qp(this.renderedTransform_, r));
    let m = 0;
    const _ = s.length;
    let x = 0, I, k, C, R, b, O, A, L, D, F, G, B, tt, J = 0, H = 0, Q = null, X = null;
    const K = this.coordinateCache_, V = this.viewRotation_, lt = Math.round(Math.atan2(-r[1], r[0]) * 1e12) / 1e12, ct = (
      /** @type {import("../../render.js").State} */
      {
        context: t,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: V
      }
    ), Et = this.instructions != s || this.overlaps ? 0 : 200;
    let Z, pt, mt, Lt;
    for (; m < _; ) {
      const z = s[m];
      switch (
        /** @type {import("./Instruction.js").default} */
        z[0]
      ) {
        case st.BEGIN_GEOMETRY:
          Z = /** @type {import("../../Feature.js").FeatureLike} */
          z[1], Lt = z[3], Z.getGeometry() ? f !== void 0 && !qe(f, Lt.getExtent()) ? m = /** @type {number} */
          z[2] + 1 : ++m : m = /** @type {number} */
          z[2], y && (y.zIndex = z[4]);
          break;
        case st.BEGIN_PATH:
          J > Et && (this.fill_(t), J = 0), H > Et && (t.stroke(), H = 0), !J && !H && (t.beginPath(), b = NaN, O = NaN), ++m;
          break;
        case st.CIRCLE:
          x = /** @type {number} */
          z[1];
          const Nr = p[x], Fi = p[x + 1], P = p[x + 2], ga = p[x + 3], bt = P - Nr, et = ga - Fi, T = Math.sqrt(bt * bt + et * et);
          t.moveTo(Nr + T, Fi), t.arc(Nr, Fi, T, 0, 2 * Math.PI, !0), ++m;
          break;
        case st.CLOSE_PATH:
          t.closePath(), ++m;
          break;
        case st.CUSTOM:
          x = /** @type {number} */
          z[1], I = z[2];
          const Ie = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            z[3]
          ), Gi = z[4], De = z[5];
          ct.geometry = Ie, ct.feature = Z, m in K || (K[m] = []);
          const Nn = K[m];
          De ? De(p, x, I, 2, Nn) : (Nn[0] = p[x], Nn[1] = p[x + 1], Nn.length = 2), y && (y.zIndex = z[6]), Gi(Nn, ct), ++m;
          break;
        case st.DRAW_IMAGE:
          x = /** @type {number} */
          z[1], I = /** @type {number} */
          z[2], D = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          z[3], k = /** @type {number} */
          z[4], C = /** @type {number} */
          z[5];
          let ai = (
            /** @type {number} */
            z[6]
          );
          const da = (
            /** @type {number} */
            z[7]
          ), U = (
            /** @type {number} */
            z[8]
          ), As = (
            /** @type {number} */
            z[9]
          ), Mr = (
            /** @type {boolean} */
            z[10]
          );
          let Fe = (
            /** @type {number} */
            z[11]
          );
          const ya = (
            /** @type {import("../../size.js").Size} */
            z[12]
          );
          let ht = (
            /** @type {number} */
            z[13]
          );
          R = z[14] || "declutter";
          const Ge = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            z[15]
          );
          if (!D && z.length >= 20) {
            F = /** @type {string} */
            z[19], G = /** @type {string} */
            z[20], B = /** @type {string} */
            z[21], tt = /** @type {string} */
            z[22];
            const Bt = this.drawLabelWithPointPlacement_(
              F,
              G,
              B,
              tt
            );
            D = Bt.label, z[3] = D;
            const j = (
              /** @type {number} */
              z[23]
            );
            k = (Bt.anchorX - j) * this.pixelRatio, z[4] = k;
            const Ut = (
              /** @type {number} */
              z[24]
            );
            C = (Bt.anchorY - Ut) * this.pixelRatio, z[5] = C, ai = D.height, z[6] = ai, ht = D.width, z[13] = ht;
          }
          let Mn;
          z.length > 25 && (Mn = /** @type {number} */
          z[25]);
          let ui, rt, On;
          z.length > 17 ? (ui = /** @type {Array<number>} */
          z[16], rt = /** @type {boolean} */
          z[17], On = /** @type {boolean} */
          z[18]) : (ui = _i, rt = !1, On = !1), Mr && lt ? Fe += V : !Mr && !lt && (Fe -= V);
          let vt = 0;
          for (; x < I; x += 2) {
            if (Mn && Mn[vt++] < ht / this.pixelRatio)
              continue;
            const Bt = this.calculateImageOrLabelDimensions_(
              D.width,
              D.height,
              p[x],
              p[x + 1],
              ht,
              ai,
              k,
              C,
              U,
              As,
              Fe,
              ya,
              u,
              ui,
              rt || On,
              Z
            ), j = [
              t,
              e,
              D,
              Bt,
              da,
              rt ? (
                /** @type {Array<*>} */
                Q
              ) : null,
              On ? (
                /** @type {Array<*>} */
                X
              ) : null
            ];
            if (g) {
              let Ut, se, zt;
              if (Ge) {
                const Mt = I - x;
                if (!Ge[Mt]) {
                  Ge[Mt] = { args: j, declutterMode: R };
                  continue;
                }
                const At = Ge[Mt];
                Ut = At.args, se = At.declutterMode, delete Ge[Mt], zt = dc(Ut);
              }
              let we, ye;
              if (Ut && (se !== "declutter" || !g.collides(zt)) && (we = !0), (R !== "declutter" || !g.collides(Bt.declutterBox)) && (ye = !0), se === "declutter" && R === "declutter") {
                const Mt = we && ye;
                we = Mt, ye = Mt;
              }
              we && (se !== "none" && g.insert(zt), this.replayImageOrLabel_.apply(this, Ut)), ye && (R !== "none" && g.insert(Bt.declutterBox), this.replayImageOrLabel_.apply(this, j));
            } else
              this.replayImageOrLabel_.apply(this, j);
          }
          ++m;
          break;
        case st.DRAW_CHARS:
          const ut = (
            /** @type {number} */
            z[1]
          ), Ps = (
            /** @type {number} */
            z[2]
          ), de = (
            /** @type {number} */
            z[3]
          ), pa = (
            /** @type {number} */
            z[4]
          );
          tt = /** @type {string} */
          z[5];
          const ot = (
            /** @type {number} */
            z[6]
          ), Ds = (
            /** @type {number} */
            z[7]
          ), Fs = (
            /** @type {number} */
            z[8]
          );
          B = /** @type {string} */
          z[9];
          const li = (
            /** @type {number} */
            z[10]
          );
          F = /** @type {string} */
          z[11], G = /** @type {string} */
          z[12];
          const re = [
            /** @type {number} */
            z[13],
            /** @type {number} */
            z[13]
          ];
          R = z[14] || "declutter";
          const cn = this.textStates[G], Ht = cn.font, Ln = [
            cn.scale[0] * Ds,
            cn.scale[1] * Ds
          ];
          let He;
          Ht in this.widths_ ? He = this.widths_[Ht] : (He = {}, this.widths_[Ht] = He);
          const Gs = Vg(p, ut, Ps, 2), Or = Math.abs(Ln[0]) * nc(Ht, F, He);
          if (pa || Or <= Gs) {
            const Bt = this.textStates[G].textAlign, j = (Gs - Or) * Xa(F, Bt), Ut = K_(
              p,
              ut,
              Ps,
              2,
              F,
              j,
              ot,
              Math.abs(Ln[0]),
              nc,
              Ht,
              He,
              lt ? 0 : this.viewRotation_
            );
            t: if (Ut) {
              const se = [];
              let zt, we, ye, Mt, At;
              if (B)
                for (zt = 0, we = Ut.length; zt < we; ++zt) {
                  At = Ut[zt], ye = /** @type {string} */
                  At[4], Mt = this.createLabel(ye, G, "", B), k = /** @type {number} */
                  At[2] + (Ln[0] < 0 ? -li : li), C = de * Mt.height + (0.5 - de) * 2 * li * Ln[1] / Ln[0] - Fs;
                  const ke = this.calculateImageOrLabelDimensions_(
                    Mt.width,
                    Mt.height,
                    At[0],
                    At[1],
                    Mt.width,
                    Mt.height,
                    k,
                    C,
                    0,
                    0,
                    At[3],
                    re,
                    !1,
                    _i,
                    !1,
                    Z
                  );
                  if (g && R === "declutter" && g.collides(ke.declutterBox))
                    break t;
                  se.push([
                    t,
                    e,
                    Mt,
                    ke,
                    1,
                    null,
                    null
                  ]);
                }
              if (tt)
                for (zt = 0, we = Ut.length; zt < we; ++zt) {
                  At = Ut[zt], ye = /** @type {string} */
                  At[4], Mt = this.createLabel(ye, G, tt, ""), k = /** @type {number} */
                  At[2], C = de * Mt.height - Fs;
                  const ke = this.calculateImageOrLabelDimensions_(
                    Mt.width,
                    Mt.height,
                    At[0],
                    At[1],
                    Mt.width,
                    Mt.height,
                    k,
                    C,
                    0,
                    0,
                    At[3],
                    re,
                    !1,
                    _i,
                    !1,
                    Z
                  );
                  if (g && R === "declutter" && g.collides(ke.declutterBox))
                    break t;
                  se.push([
                    t,
                    e,
                    Mt,
                    ke,
                    1,
                    null,
                    null
                  ]);
                }
              g && R !== "none" && g.load(se.map(dc));
              for (let ke = 0, Bi = se.length; ke < Bi; ++ke)
                this.replayImageOrLabel_.apply(this, se[ke]);
            }
          }
          ++m;
          break;
        case st.END_GEOMETRY:
          if (h !== void 0) {
            Z = /** @type {import("../../Feature.js").FeatureLike} */
            z[1];
            const Bt = h(Z, Lt);
            if (Bt)
              return Bt;
          }
          ++m;
          break;
        case st.FILL:
          Et ? J++ : this.fill_(t), ++m;
          break;
        case st.MOVE_TO_LINE_TO:
          for (x = /** @type {number} */
          z[1], I = /** @type {number} */
          z[2], pt = p[x], mt = p[x + 1], A = pt + 0.5 | 0, L = mt + 0.5 | 0, (A !== b || L !== O) && (t.moveTo(pt, mt), b = A, O = L), x += 2; x < I; x += 2)
            pt = p[x], mt = p[x + 1], A = pt + 0.5 | 0, L = mt + 0.5 | 0, (x == I - 2 || A !== b || L !== O) && (t.lineTo(pt, mt), b = A, O = L);
          ++m;
          break;
        case st.SET_FILL_STYLE:
          Q = z, this.alignAndScaleFill_ = z[2], J && (this.fill_(t), J = 0, H && (t.stroke(), H = 0)), t.fillStyle = z[1], ++m;
          break;
        case st.SET_STROKE_STYLE:
          X = z, H && (t.stroke(), H = 0), this.setStrokeStyle_(
            t,
            /** @type {Array<*>} */
            z
          ), ++m;
          break;
        case st.STROKE:
          Et ? H++ : t.stroke(), ++m;
          break;
        default:
          ++m;
          break;
      }
    }
    J && this.fill_(t), H && t.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(t, e, r, s, u, h) {
    this.viewRotation_ = s, this.execute_(
      t,
      e,
      r,
      this.instructions,
      u,
      void 0,
      void 0,
      h
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(t, e, r, s, u) {
    return this.viewRotation_ = r, this.execute_(
      t,
      [t.canvas.width, t.canvas.height],
      e,
      this.hitDetectionInstructions,
      !0,
      s,
      u
    );
  }
}
const ns = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], pd = ["Image", "Text"], e0 = ns.filter(
  (i) => !pd.includes(i)
);
class n0 {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(t, e, r, s, u, h, f) {
    this.maxExtent_ = t, this.overlaps_ = s, this.pixelRatio_ = r, this.resolution_ = e, this.renderBuffer_ = h, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = Sn(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(u, f);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(t, e) {
    const r = this.getClipCoords(e);
    t.beginPath(), t.moveTo(r[0], r[1]), t.lineTo(r[2], r[3]), t.lineTo(r[4], r[5]), t.lineTo(r[6], r[7]), t.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(t, e) {
    for (const r in t) {
      let s = this.executorsByZIndex_[r];
      s === void 0 && (s = {}, this.executorsByZIndex_[r] = s);
      const u = t[r];
      for (const h in u) {
        const f = u[h];
        s[h] = new t0(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          f,
          e
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(t) {
    for (const e in this.executorsByZIndex_) {
      const r = this.executorsByZIndex_[e];
      for (let s = 0, u = t.length; s < u; ++s)
        if (t[s] in r)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, e, r, s, u, h) {
    s = Math.round(s);
    const f = s * 2 + 1, g = Oi(
      this.hitDetectionTransform_,
      s + 0.5,
      s + 0.5,
      1 / e,
      -1 / e,
      -r,
      -t[0],
      -t[1]
    ), y = !this.hitDetectionContext_;
    y && (this.hitDetectionContext_ = Se(
      f,
      f,
      void 0,
      { willReadFrequently: !0 }
    ));
    const p = this.hitDetectionContext_;
    p.canvas.width !== f || p.canvas.height !== f ? (p.canvas.width = f, p.canvas.height = f) : y || p.clearRect(0, 0, f, f);
    let m;
    this.renderBuffer_ !== void 0 && (m = ki(), om(m, t), sl(
      m,
      e * (this.renderBuffer_ + s),
      m
    ));
    const _ = i0(s);
    let x;
    function I(L, D) {
      const F = p.getImageData(
        0,
        0,
        f,
        f
      ).data;
      for (let G = 0, B = _.length; G < B; G++)
        if (F[_[G]] > 0) {
          if (!h || x !== "Image" && x !== "Text" || h.includes(L)) {
            const tt = (_[G] - 3) / 4, J = s - tt % f, H = s - (tt / f | 0), Q = u(L, D, J * J + H * H);
            if (Q)
              return Q;
          }
          p.clearRect(0, 0, f, f);
          break;
        }
    }
    const k = Object.keys(this.executorsByZIndex_).map(Number);
    k.sort(Ei);
    let C, R, b, O, A;
    for (C = k.length - 1; C >= 0; --C) {
      const L = k[C].toString();
      for (b = this.executorsByZIndex_[L], R = ns.length - 1; R >= 0; --R)
        if (x = ns[R], O = b[x], O !== void 0 && (A = O.executeHitDetection(
          p,
          g,
          r,
          I,
          m
        ), A))
          return A;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(t) {
    const e = this.maxExtent_;
    if (!e)
      return null;
    const r = e[0], s = e[1], u = e[2], h = e[3], f = [r, s, r, h, u, h, u, s];
    return Jn(f, 0, 8, 2, t, f), f;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return hr(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(t, e, r, s, u, h, f) {
    const g = Object.keys(this.executorsByZIndex_).map(Number);
    g.sort(Ei), h = h || ns;
    let y, p, m, _, x, I;
    for (f && g.reverse(), y = 0, p = g.length; y < p; ++y) {
      const k = g[y].toString();
      for (x = this.executorsByZIndex_[k], m = 0, _ = h.length; m < _; ++m) {
        const C = h[m];
        if (I = x[C], I !== void 0) {
          const R = f === null ? void 0 : I.getZIndexContext(), b = R ? R.getContext() : t, O = this.maxExtent_ && C !== "Image" && C !== "Text";
          if (O && (b.save(), this.clip(b, r)), I.execute(
            b,
            e,
            r,
            s,
            u,
            f
          ), O && b.restore(), R) {
            R.offset();
            const A = g[y];
            this.deferredZIndexContexts_[A] || (this.deferredZIndexContexts_[A] = []), this.deferredZIndexContexts_[A].push(R);
          }
        }
      }
    }
    this.renderedContext_ = t;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const t = this.deferredZIndexContexts_, e = Object.keys(t).map(Number).sort(Ei);
    for (let r = 0, s = e.length; r < s; ++r)
      t[e[r]].forEach((u) => {
        u.draw(this.renderedContext_), u.clear();
      });
  }
}
const qa = {};
function i0(i) {
  if (qa[i] !== void 0)
    return qa[i];
  const t = i * 2 + 1, e = i * i, r = new Array(e + 1);
  for (let u = 0; u <= i; ++u)
    for (let h = 0; h <= i; ++h) {
      const f = u * u + h * h;
      if (f > e)
        break;
      let g = r[f];
      g || (g = [], r[f] = g), g.push(((i + u) * t + (i + h)) * 4 + 3), u > 0 && g.push(((i - u) * t + (i + h)) * 4 + 3), h > 0 && (g.push(((i + u) * t + (i - h)) * 4 + 3), u > 0 && g.push(((i - u) * t + (i - h)) * 4 + 3));
    }
  const s = [];
  for (let u = 0, h = r.length; u < h; ++u)
    r[u] && s.push(...r[u]);
  return qa[i] = s, s;
}
class r0 extends dd {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(t, e, r, s, u, h, f) {
    super(), this.context_ = t, this.pixelRatio_ = e, this.extent_ = r, this.transform_ = s, this.transformRotation_ = s ? Cm(Math.atan2(s[1], s[0]), 10) : 0, this.viewRotation_ = u, this.squaredTolerance_ = h, this.userTransform_ = f, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = Sn();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(t, e, r, s) {
    if (!this.image_)
      return;
    const u = Jn(
      t,
      e,
      r,
      s,
      this.transform_,
      this.pixelCoordinates_
    ), h = this.context_, f = this.tmpLocalTransform_, g = h.globalAlpha;
    this.imageOpacity_ != 1 && (h.globalAlpha = g * this.imageOpacity_);
    let y = this.imageRotation_;
    this.transformRotation_ === 0 && (y -= this.viewRotation_), this.imageRotateWithView_ && (y += this.viewRotation_);
    for (let p = 0, m = u.length; p < m; p += 2) {
      const _ = u[p] - this.imageAnchorX_, x = u[p + 1] - this.imageAnchorY_;
      if (y !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const I = _ + this.imageAnchorX_, k = x + this.imageAnchorY_;
        Oi(
          f,
          I,
          k,
          1,
          1,
          y,
          -I,
          -k
        ), h.save(), h.transform.apply(h, f), h.translate(I, k), h.scale(this.imageScale_[0], this.imageScale_[1]), h.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), h.restore();
      } else
        h.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          _,
          x,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (h.globalAlpha = g);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(t, e, r, s) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const u = Jn(
      t,
      e,
      r,
      s,
      this.transform_,
      this.pixelCoordinates_
    ), h = this.context_;
    let f = this.textRotation_;
    for (this.transformRotation_ === 0 && (f -= this.viewRotation_), this.textRotateWithView_ && (f += this.viewRotation_); e < r; e += s) {
      const g = u[e] + this.textOffsetX_, y = u[e + 1] + this.textOffsetY_;
      f !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (h.save(), h.translate(g - this.textOffsetX_, y - this.textOffsetY_), h.rotate(f), h.translate(this.textOffsetX_, this.textOffsetY_), h.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && h.strokeText(this.text_, 0, 0), this.textFillState_ && h.fillText(this.text_, 0, 0), h.restore()) : (this.textStrokeState_ && h.strokeText(this.text_, g, y), this.textFillState_ && h.fillText(this.text_, g, y));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(t, e, r, s, u) {
    const h = this.context_, f = Jn(
      t,
      e,
      r,
      s,
      this.transform_,
      this.pixelCoordinates_
    );
    h.moveTo(f[0], f[1]);
    let g = f.length;
    u && (g -= 2);
    for (let y = 2; y < g; y += 2)
      h.lineTo(f[y], f[y + 1]);
    return u && h.closePath(), r;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(t, e, r, s) {
    for (let u = 0, h = r.length; u < h; ++u)
      e = this.moveToLineTo_(
        t,
        e,
        r[u],
        s,
        !0
      );
    return e;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Circle.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!qe(this.extent_, t.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = $m(
          t,
          this.transform_,
          this.pixelCoordinates_
        ), r = e[2] - e[0], s = e[3] - e[1], u = Math.sqrt(r * r + s * s), h = this.context_;
        h.beginPath(), h.arc(
          e[0],
          e[1],
          u,
          0,
          2 * Math.PI
        ), this.fillState_ && h.fill(), this.strokeState_ && h.stroke();
      }
      this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(t) {
    this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(t) {
    this.transform_ = t;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(t) {
    switch (t.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          t
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          t
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          t
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          t
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          t
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          t
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          t
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(t, e) {
    const r = e.getGeometryFunction()(t);
    r && (this.setStyle(e), this.drawGeometry(r));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(t) {
    const e = t.getGeometriesArray();
    for (let r = 0, s = e.length; r < s; ++r)
      this.drawGeometry(e[r]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/Point.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getFlatCoordinates(), r = t.getStride();
    this.image_ && this.drawImages_(e, 0, e.length, r), this.text_ !== "" && this.drawText_(e, 0, e.length, r);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPoint.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getFlatCoordinates(), r = t.getStride();
    this.image_ && this.drawImages_(e, 0, e.length, r), this.text_ !== "" && this.drawText_(e, 0, e.length, r);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/LineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!qe(this.extent_, t.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const e = this.context_, r = t.getFlatCoordinates();
        e.beginPath(), this.moveToLineTo_(
          r,
          0,
          r.length,
          t.getStride(),
          !1
        ), e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatMidpoint();
        this.drawText_(e, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiLineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getExtent();
    if (qe(this.extent_, e)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const r = this.context_, s = t.getFlatCoordinates();
        let u = 0;
        const h = (
          /** @type {Array<number>} */
          t.getEnds()
        ), f = t.getStride();
        r.beginPath();
        for (let g = 0, y = h.length; g < y; ++g)
          u = this.moveToLineTo_(
            s,
            u,
            h[g],
            f,
            !1
          );
        r.stroke();
      }
      if (this.text_ !== "") {
        const r = t.getFlatMidpoints();
        this.drawText_(r, 0, r.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Polygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!qe(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = this.context_;
        e.beginPath(), this.drawRings_(
          t.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          t.getEnds(),
          t.getStride()
        ), this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatInteriorPoint();
        this.drawText_(e, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPolygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!qe(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = this.context_, r = t.getOrientedFlatCoordinates();
        let s = 0;
        const u = t.getEndss(), h = t.getStride();
        e.beginPath();
        for (let f = 0, g = u.length; f < g; ++f) {
          const y = u[f];
          s = this.drawRings_(r, s, y, h);
        }
        this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatInteriorPoints();
        this.drawText_(e, 0, e.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(t) {
    const e = this.context_, r = this.contextFillState_;
    r ? r.fillStyle != t.fillStyle && (r.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = {
      fillStyle: t.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(t) {
    const e = this.context_, r = this.contextStrokeState_;
    r ? (r.lineCap != t.lineCap && (r.lineCap = t.lineCap, e.lineCap = t.lineCap), xr(r.lineDash, t.lineDash) || e.setLineDash(
      r.lineDash = t.lineDash
    ), r.lineDashOffset != t.lineDashOffset && (r.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset), r.lineJoin != t.lineJoin && (r.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), r.lineWidth != t.lineWidth && (r.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), r.miterLimit != t.miterLimit && (r.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), r.strokeStyle != t.strokeStyle && (r.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
      lineCap: t.lineCap,
      lineDash: t.lineDash,
      lineDashOffset: t.lineDashOffset,
      lineJoin: t.lineJoin,
      lineWidth: t.lineWidth,
      miterLimit: t.miterLimit,
      strokeStyle: t.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(t) {
    const e = this.context_, r = this.contextTextState_, s = t.textAlign ? t.textAlign : ms;
    r ? (r.font != t.font && (r.font = t.font, e.font = t.font), r.textAlign != s && (r.textAlign = s, e.textAlign = s), r.textBaseline != t.textBaseline && (r.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = s, e.textBaseline = t.textBaseline, this.contextTextState_ = {
      font: t.font,
      textAlign: s,
      textBaseline: t.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, e) {
    if (!t)
      this.fillState_ = null;
    else {
      const r = t.getColor();
      this.fillState_ = {
        fillStyle: rn(
          r || ce
        )
      };
    }
    if (!e)
      this.strokeState_ = null;
    else {
      const r = e.getColor(), s = e.getLineCap(), u = e.getLineDash(), h = e.getLineDashOffset(), f = e.getLineJoin(), g = e.getWidth(), y = e.getMiterLimit(), p = u || In;
      this.strokeState_ = {
        lineCap: s !== void 0 ? s : cr,
        lineDash: this.pixelRatio_ === 1 ? p : p.map((m) => m * this.pixelRatio_),
        lineDashOffset: (h || wn) * this.pixelRatio_,
        lineJoin: f !== void 0 ? f : fr,
        lineWidth: (g !== void 0 ? g : vs) * this.pixelRatio_,
        miterLimit: y !== void 0 ? y : ys,
        strokeStyle: rn(
          r || ps
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(t) {
    let e;
    if (!t || !(e = t.getSize())) {
      this.image_ = null;
      return;
    }
    const r = t.getPixelRatio(this.pixelRatio_), s = t.getAnchor(), u = t.getOrigin();
    this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = s[0] * r, this.imageAnchorY_ = s[1] * r, this.imageHeight_ = e[1] * r, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = u[0], this.imageOriginY_ = u[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
    const h = t.getScaleArray();
    this.imageScale_ = [
      h[0] * this.pixelRatio_ / r,
      h[1] * this.pixelRatio_ / r
    ], this.imageWidth_ = e[0] * r;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(t) {
    if (!t)
      this.text_ = "";
    else {
      const e = t.getFill();
      if (!e)
        this.textFillState_ = null;
      else {
        const x = e.getColor();
        this.textFillState_ = {
          fillStyle: rn(
            x || ce
          )
        };
      }
      const r = t.getStroke();
      if (!r)
        this.textStrokeState_ = null;
      else {
        const x = r.getColor(), I = r.getLineCap(), k = r.getLineDash(), C = r.getLineDashOffset(), R = r.getLineJoin(), b = r.getWidth(), O = r.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: I !== void 0 ? I : cr,
          lineDash: k || In,
          lineDashOffset: C || wn,
          lineJoin: R !== void 0 ? R : fr,
          lineWidth: b !== void 0 ? b : vs,
          miterLimit: O !== void 0 ? O : ys,
          strokeStyle: rn(
            x || ps
          )
        };
      }
      const s = t.getFont(), u = t.getOffsetX(), h = t.getOffsetY(), f = t.getRotateWithView(), g = t.getRotation(), y = t.getScaleArray(), p = t.getText(), m = t.getTextAlign(), _ = t.getTextBaseline();
      this.textState_ = {
        font: s !== void 0 ? s : rd,
        textAlign: m !== void 0 ? m : ms,
        textBaseline: _ !== void 0 ? _ : Io
      }, this.text_ = p !== void 0 ? Array.isArray(p) ? p.reduce((x, I, k) => x += k % 2 ? " " : I, "") : p : "", this.textOffsetX_ = u !== void 0 ? this.pixelRatio_ * u : 0, this.textOffsetY_ = h !== void 0 ? this.pixelRatio_ * h : 0, this.textRotateWithView_ = f !== void 0 ? f : !1, this.textRotation_ = g !== void 0 ? g : 0, this.textScale_ = [
        this.pixelRatio_ * y[0],
        this.pixelRatio_ * y[1]
      ];
    }
  }
}
const nn = 0.5;
function s0(i, t, e, r, s, u, h, f, g) {
  const y = s, p = i[0] * nn, m = i[1] * nn, _ = Se(p, m);
  _.imageSmoothingEnabled = !1;
  const x = _.canvas, I = new r0(
    _,
    nn,
    s,
    null,
    h,
    f,
    null
  ), k = e.length, C = Math.floor((256 * 256 * 256 - 1) / k), R = {};
  for (let O = 1; O <= k; ++O) {
    const A = e[O - 1], L = A.getStyleFunction() || r;
    if (!L)
      continue;
    let D = L(A, u);
    if (!D)
      continue;
    Array.isArray(D) || (D = [D]);
    const G = (O * C).toString(16).padStart(7, "#00000");
    for (let B = 0, tt = D.length; B < tt; ++B) {
      const J = D[B], H = J.getGeometryFunction()(A);
      if (!H || !qe(y, H.getExtent()))
        continue;
      const Q = J.clone(), X = Q.getFill();
      X && X.setColor(G);
      const K = Q.getStroke();
      K && (K.setColor(G), K.setLineDash(null)), Q.setText(void 0);
      const V = J.getImage();
      if (V) {
        const Z = V.getImageSize();
        if (!Z)
          continue;
        const pt = Se(
          Z[0],
          Z[1],
          void 0,
          { alpha: !1 }
        ), mt = pt.canvas;
        pt.fillStyle = G, pt.fillRect(0, 0, mt.width, mt.height), Q.setImage(
          new bs({
            img: mt,
            anchor: V.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: V.getOrigin(),
            opacity: 1,
            size: V.getSize(),
            scale: V.getScale(),
            rotation: V.getRotation(),
            rotateWithView: V.getRotateWithView()
          })
        );
      }
      const lt = Q.getZIndex() || 0;
      let ct = R[lt];
      ct || (ct = {}, R[lt] = ct, ct.Polygon = [], ct.Circle = [], ct.LineString = [], ct.Point = []);
      const Et = H.getType();
      if (Et === "GeometryCollection") {
        const Z = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          H.getGeometriesArrayRecursive()
        );
        for (let pt = 0, mt = Z.length; pt < mt; ++pt) {
          const Lt = Z[pt];
          ct[Lt.getType().replace("Multi", "")].push(
            Lt,
            Q
          );
        }
      } else
        ct[Et.replace("Multi", "")].push(H, Q);
    }
  }
  const b = Object.keys(R).map(Number).sort(Ei);
  for (let O = 0, A = b.length; O < A; ++O) {
    const L = R[b[O]];
    for (const D in L) {
      const F = L[D];
      for (let G = 0, B = F.length; G < B; G += 2) {
        I.setStyle(F[G + 1]);
        for (let tt = 0, J = t.length; tt < J; ++tt)
          I.setTransform(t[tt]), I.drawGeometry(F[G]);
      }
    }
  }
  return _.getImageData(0, 0, x.width, x.height);
}
function o0(i, t, e) {
  const r = [];
  if (e) {
    const s = Math.floor(Math.round(i[0]) * nn), u = Math.floor(Math.round(i[1]) * nn), h = (ee(s, 0, e.width - 1) + ee(u, 0, e.height - 1) * e.width) * 4, f = e.data[h], g = e.data[h + 1], p = e.data[h + 2] + 256 * (g + 256 * f), m = Math.floor((256 * 256 * 256 - 1) / t.length);
    p && p % m === 0 && r.push(t[p / m - 1]);
  }
  return r;
}
const a0 = 0.5, md = {
  Point: y0,
  LineString: f0,
  Polygon: m0,
  MultiPoint: p0,
  MultiLineString: g0,
  MultiPolygon: d0,
  GeometryCollection: c0,
  Circle: l0
};
function u0(i, t) {
  return parseInt(jt(i), 10) - parseInt(jt(t), 10);
}
function pc(i, t) {
  const e = vd(i, t);
  return e * e;
}
function vd(i, t) {
  return a0 * i / t;
}
function l0(i, t, e, r, s) {
  const u = e.getFill(), h = e.getStroke();
  if (u || h) {
    const g = i.getBuilder(e.getZIndex(), "Circle");
    g.setFillStrokeStyle(u, h), g.drawCircle(t, r, s);
  }
  const f = e.getText();
  if (f && f.getText()) {
    const g = i.getBuilder(e.getZIndex(), "Text");
    g.setTextStyle(f), g.drawText(t, r);
  }
}
function mc(i, t, e, r, s, u, h, f) {
  const g = [], y = e.getImage();
  if (y) {
    let _ = !0;
    const x = y.getImageState();
    x == yt.LOADED || x == yt.ERROR ? _ = !1 : x == yt.IDLE && y.load(), _ && g.push(y.ready());
  }
  const p = e.getFill();
  p && p.loading() && g.push(p.ready());
  const m = g.length > 0;
  return m && Promise.all(g).then(() => s(null)), h0(
    i,
    t,
    e,
    r,
    u,
    h,
    f
  ), m;
}
function h0(i, t, e, r, s, u, h) {
  const f = e.getGeometryFunction()(t);
  if (!f)
    return;
  const g = f.simplifyTransformed(
    r,
    s
  );
  if (e.getRenderer())
    _d(i, g, e, t, h);
  else {
    const p = md[g.getType()];
    p(
      i,
      g,
      e,
      t,
      h,
      u
    );
  }
}
function _d(i, t, e, r, s) {
  if (t.getType() == "GeometryCollection") {
    const h = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      t.getGeometries()
    );
    for (let f = 0, g = h.length; f < g; ++f)
      _d(i, h[f], e, r, s);
    return;
  }
  i.getBuilder(e.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    t,
    r,
    e.getRenderer(),
    e.getHitDetectionRenderer(),
    s
  );
}
function c0(i, t, e, r, s, u) {
  const h = t.getGeometriesArray();
  let f, g;
  for (f = 0, g = h.length; f < g; ++f) {
    const y = md[h[f].getType()];
    y(
      i,
      h[f],
      e,
      r,
      s,
      u
    );
  }
}
function f0(i, t, e, r, s) {
  const u = e.getStroke();
  if (u) {
    const f = i.getBuilder(
      e.getZIndex(),
      "LineString"
    );
    f.setFillStrokeStyle(null, u), f.drawLineString(t, r, s);
  }
  const h = e.getText();
  if (h && h.getText()) {
    const f = i.getBuilder(e.getZIndex(), "Text");
    f.setTextStyle(h), f.drawText(t, r, s);
  }
}
function g0(i, t, e, r, s) {
  const u = e.getStroke();
  if (u) {
    const f = i.getBuilder(
      e.getZIndex(),
      "LineString"
    );
    f.setFillStrokeStyle(null, u), f.drawMultiLineString(t, r, s);
  }
  const h = e.getText();
  if (h && h.getText()) {
    const f = i.getBuilder(e.getZIndex(), "Text");
    f.setTextStyle(h), f.drawText(t, r, s);
  }
}
function d0(i, t, e, r, s) {
  const u = e.getFill(), h = e.getStroke();
  if (h || u) {
    const g = i.getBuilder(e.getZIndex(), "Polygon");
    g.setFillStrokeStyle(u, h), g.drawMultiPolygon(t, r, s);
  }
  const f = e.getText();
  if (f && f.getText()) {
    const g = i.getBuilder(e.getZIndex(), "Text");
    g.setTextStyle(f), g.drawText(t, r, s);
  }
}
function y0(i, t, e, r, s, u) {
  const h = e.getImage(), f = e.getText(), g = f && f.getText(), y = u && h && g ? {} : void 0;
  if (h) {
    if (h.getImageState() != yt.LOADED)
      return;
    const p = i.getBuilder(e.getZIndex(), "Image");
    p.setImageStyle(h, y), p.drawPoint(t, r, s);
  }
  if (g) {
    const p = i.getBuilder(e.getZIndex(), "Text");
    p.setTextStyle(f, y), p.drawText(t, r, s);
  }
}
function p0(i, t, e, r, s, u) {
  const h = e.getImage(), f = h && h.getOpacity() !== 0, g = e.getText(), y = g && g.getText(), p = u && f && y ? {} : void 0;
  if (f) {
    if (h.getImageState() != yt.LOADED)
      return;
    const m = i.getBuilder(e.getZIndex(), "Image");
    m.setImageStyle(h, p), m.drawMultiPoint(t, r, s);
  }
  if (y) {
    const m = i.getBuilder(e.getZIndex(), "Text");
    m.setTextStyle(g, p), m.drawText(t, r, s);
  }
}
function m0(i, t, e, r, s) {
  const u = e.getFill(), h = e.getStroke();
  if (u || h) {
    const g = i.getBuilder(e.getZIndex(), "Polygon");
    g.setFillStrokeStyle(u, h), g.drawPolygon(t, r, s);
  }
  const f = e.getText();
  if (f && f.getText()) {
    const g = i.getBuilder(e.getZIndex(), "Text");
    g.setTextStyle(f), g.drawText(t, r, s);
  }
}
class v0 extends J_ {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(t) {
    super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = ki(), this.wrappedRenderedExtent_ = ki(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(t, e, r) {
    const s = e.extent, u = e.viewState, h = u.center, f = u.resolution, g = u.projection, y = u.rotation, p = g.getExtent(), m = this.getLayer().getSource(), _ = this.getLayer().getDeclutter(), x = e.pixelRatio, I = e.viewHints, k = !(I[Oe.ANIMATING] || I[Oe.INTERACTING]), C = this.context, R = Math.round(he(s) / f * x), b = Math.round(Cn(s) / f * x), O = m.getWrapX() && g.canWrapX(), A = O ? he(p) : null, L = O ? Math.ceil((s[2] - p[2]) / A) + 1 : 1;
    let D = O ? Math.floor((s[0] - p[0]) / A) : 0;
    do {
      const F = this.getRenderTransform(
        h,
        f,
        y,
        x,
        R,
        b,
        D * A
      );
      t.execute(
        C,
        [C.canvas.width, C.canvas.height],
        F,
        y,
        k,
        r === void 0 ? ns : r ? pd : e0,
        r ? _ && e.declutter[_] : void 0
      );
    } while (++D < L);
  }
  /**
   * @private
   */
  setDrawContext_() {
    this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = Se(
      this.context.canvas.width,
      this.context.canvas.height,
      gc
    ));
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1) {
      const t = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = t, Gv(this.context), gc.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, t, !0);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(t) {
    this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.resetDrawContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(t, e) {
    const r = t.pixelRatio, s = t.layerStatesArray[t.layerIndex];
    this.opacity_ = s.opacity;
    const u = t.extent, h = t.viewState.resolution, f = Math.round(he(u) / h * r), g = Math.round(Cn(u) / h * r);
    Oi(
      this.pixelTransform,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / r,
      1 / r,
      0,
      -f / 2,
      -g / 2
    ), tm(this.inversePixelTransform, this.pixelTransform);
    const y = nm(this.pixelTransform);
    this.useContainer(e, y, this.getBackground(t));
    const p = this.context, m = p.canvas, _ = this.replayGroup_;
    let x = _ && !_.isEmpty();
    if (!x && !(this.getLayer().hasListener(vi.PRERENDER) || this.getLayer().hasListener(vi.POSTRENDER)))
      return null;
    m.width != f || m.height != g ? (m.width = f, m.height = g, m.style.transform !== y && (m.style.transform = y)) : this.containerReused || p.clearRect(0, 0, f, g), this.setDrawContext_(), this.preRender(p, t);
    const I = t.viewState;
    I.projection;
    let k = !1;
    if (x && s.extent && this.clipping) {
      const C = Zr(s.extent);
      x = qe(C, t.extent), k = x && !rr(C, t.extent), k && this.clipUnrotated(p, t, C);
    }
    return x && this.renderWorlds(
      _,
      t,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), k && p.restore(), this.postRender(p, t), this.renderedRotation_ !== I.rotation && (this.renderedRotation_ = I.rotation, this.hitDetectionImageData_ = null), t.declutter || this.resetDrawContext_(), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(t) {
    return new Promise((e) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const r = [this.context.canvas.width, this.context.canvas.height];
        le(this.pixelTransform, r);
        const s = this.renderedCenter_, u = this.renderedResolution_, h = this.renderedRotation_, f = this.renderedProjection_, g = this.wrappedRenderedExtent_, y = this.getLayer(), p = [], m = r[0] * nn, _ = r[1] * nn;
        p.push(
          this.getRenderTransform(
            s,
            u,
            h,
            nn,
            m,
            _,
            0
          ).slice()
        );
        const x = y.getSource(), I = f.getExtent();
        if (x.getWrapX() && f.canWrapX() && !rr(I, g)) {
          let k = g[0];
          const C = he(I);
          let R = 0, b;
          for (; k < I[0]; )
            --R, b = C * R, p.push(
              this.getRenderTransform(
                s,
                u,
                h,
                nn,
                m,
                _,
                b
              ).slice()
            ), k += C;
          for (R = 0, k = g[2]; k > I[2]; )
            ++R, b = C * R, p.push(
              this.getRenderTransform(
                s,
                u,
                h,
                nn,
                m,
                _,
                b
              ).slice()
            ), k -= C;
        }
        this.hitDetectionImageData_ = s0(
          r,
          p,
          this.renderedFeatures_,
          y.getStyleFunction(),
          g,
          u,
          h,
          pc(u, this.renderedPixelRatio_)
        );
      }
      e(
        o0(t, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, e, r, s, u) {
    if (!this.replayGroup_)
      return;
    const h = e.viewState.resolution, f = e.viewState.rotation, g = this.getLayer(), y = {}, p = function(I, k, C) {
      const R = jt(I), b = y[R];
      if (b) {
        if (b !== !0 && C < b.distanceSq) {
          if (C === 0)
            return y[R] = !0, u.splice(u.lastIndexOf(b), 1), s(I, g, k);
          b.geometry = k, b.distanceSq = C;
        }
      } else {
        if (C === 0)
          return y[R] = !0, s(I, g, k);
        u.push(
          y[R] = {
            feature: I,
            layer: g,
            geometry: k,
            distanceSq: C,
            callback: s
          }
        );
      }
    };
    let m;
    const _ = [this.replayGroup_], x = this.getLayer().getDeclutter();
    return _.some((I) => m = I.forEachFeatureAtCoordinate(
      t,
      h,
      f,
      r,
      p,
      x && e.declutter[x] ? e.declutter[x].all().map((k) => k.value) : null
    )), m;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const t = this.getLayer();
    t.getVisible() && this.replayGroup_ && t.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(t) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    const e = this.getLayer(), r = e.getSource();
    if (!r)
      return !1;
    const s = t.viewHints[Oe.ANIMATING], u = t.viewHints[Oe.INTERACTING], h = e.getUpdateWhileAnimating(), f = e.getUpdateWhileInteracting();
    if (this.ready && !h && s || !f && u)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const g = t.extent, y = t.viewState, p = y.projection, m = y.resolution, _ = t.pixelRatio, x = e.getRevision(), I = e.getRenderBuffer();
    let k = e.getRenderOrder();
    k === void 0 && (k = u0);
    const C = y.center.slice(), R = sl(
      g,
      I * m
    ), b = R.slice(), O = [R.slice()], A = p.getExtent();
    if (r.getWrapX() && p.canWrapX() && !rr(A, t.extent)) {
      const X = he(A), K = Math.max(he(R) / 2, X);
      R[0] = A[0] - K, R[2] = A[2] + K, Tm(C, p);
      const V = Ag(O[0], p);
      V[0] < A[0] && V[2] < A[2] ? O.push([
        V[0] + X,
        V[1],
        V[2] + X,
        V[3]
      ]) : V[0] > A[0] && V[2] > A[2] && O.push([
        V[0] - X,
        V[1],
        V[2] - X,
        V[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == m && this.renderedRevision_ == x && this.renderedRenderOrder_ == k && rr(this.wrappedRenderedExtent_, R))
      return xr(this.renderedExtent_, b) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = b), this.renderedCenter_ = C, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const L = new j_(
      vd(m, _),
      R,
      m,
      _
    );
    let D;
    for (let X = 0, K = O.length; X < K; ++X)
      r.loadFeatures(O[X], m, p);
    const F = pc(m, _);
    let G = !0;
    const B = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (X, K) => {
        let V;
        const lt = X.getStyleFunction() || e.getStyleFunction();
        if (lt && (V = lt(X, m)), V) {
          const ct = this.renderFeature(
            X,
            F,
            V,
            L,
            D,
            this.getLayer().getDeclutter(),
            K
          );
          G = G && !ct;
        }
      }
    ), tt = Yg(R), J = r.getFeaturesInExtent(tt);
    k && J.sort(k);
    for (let X = 0, K = J.length; X < K; ++X)
      B(J[X], X);
    this.renderedFeatures_ = J, this.ready = G;
    const H = L.finish(), Q = new n0(
      R,
      m,
      _,
      r.getOverlaps(),
      H,
      e.getRenderBuffer(),
      !!t.declutter
    );
    return this.renderedResolution_ = m, this.renderedRevision_ = x, this.renderedRenderOrder_ = k, this.renderedExtent_ = b, this.wrappedRenderedExtent_ = R, this.renderedCenter_ = C, this.renderedProjection_ = p, this.renderedPixelRatio_ = _, this.replayGroup_ = Q, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(t, e, r, s, u, h, f) {
    if (!r)
      return !1;
    let g = !1;
    if (Array.isArray(r))
      for (let y = 0, p = r.length; y < p; ++y)
        g = mc(
          s,
          t,
          r[y],
          e,
          this.boundHandleStyleImageChange_,
          u,
          h,
          f
        ) || g;
    else
      g = mc(
        s,
        t,
        r,
        e,
        this.boundHandleStyleImageChange_,
        u,
        h,
        f
      );
    return g;
  }
}
class _0 extends B_ {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(t) {
    super(t);
  }
  createRenderer() {
    return new v0(this);
  }
}
const or = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, vc = {
  LENGTH: "length"
};
class Js extends ks {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(t, e, r) {
    super(t), this.element = e, this.index = r;
  }
}
class x0 extends Er {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(t, e) {
    if (super(), this.on, this.once, this.un, e = e || {}, this.unique_ = !!e.unique, this.array_ = t || [], this.unique_)
      for (let r = 0, s = this.array_.length; r < s; ++r)
        this.assertUnique_(this.array_[r], r);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(t) {
    for (let e = 0, r = t.length; e < r; ++e)
      this.push(t[e]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(t) {
    const e = this.array_;
    for (let r = 0, s = e.length; r < s; ++r)
      t(e[r], r, e);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(t) {
    return this.array_[t];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(vc.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(t, e) {
    if (t < 0 || t > this.getLength())
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(
      new Js(or.ADD, e, t)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(t) {
    this.unique_ && this.assertUnique_(t);
    const e = this.getLength();
    return this.insertAt(e, t), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(t) {
    const e = this.array_;
    for (let r = 0, s = e.length; r < s; ++r)
      if (e[r] === t)
        return this.removeAt(r);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(t) {
    if (t < 0 || t >= this.getLength())
      return;
    const e = this.array_[t];
    return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Js(or.REMOVE, e, t)
    ), e;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(t, e) {
    const r = this.getLength();
    if (t >= r) {
      this.insertAt(t, e);
      return;
    }
    if (t < 0)
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(e, t);
    const s = this.array_[t];
    this.array_[t] = e, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Js(or.REMOVE, s, t)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Js(or.ADD, e, t)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(vc.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(t, e) {
    for (let r = 0, s = this.array_.length; r < s; ++r)
      if (this.array_[r] === t && r !== e)
        throw new Error("Duplicate item added to a unique collection");
  }
}
class _c {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(t) {
    this.rbush_ = new Qg(t), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(t, e) {
    const r = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3],
      value: e
    };
    this.rbush_.insert(r), this.items_[jt(e)] = r;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(t, e) {
    const r = new Array(e.length);
    for (let s = 0, u = e.length; s < u; s++) {
      const h = t[s], f = e[s], g = {
        minX: h[0],
        minY: h[1],
        maxX: h[2],
        maxY: h[3],
        value: f
      };
      r[s] = g, this.items_[jt(f)] = g;
    }
    this.rbush_.load(r);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(t) {
    const e = jt(t), r = this.items_[e];
    return delete this.items_[e], this.rbush_.remove(r) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(t, e) {
    const r = this.items_[jt(e)], s = [r.minX, r.minY, r.maxX, r.maxY];
    bg(s, t) || (this.remove(e), this.insert(t, e));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(e) {
      return e.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(t) {
    const e = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3]
    };
    return this.rbush_.search(e).map(function(s) {
      return s.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(t) {
    return this.forEach_(this.getAll(), t);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(t, e) {
    return this.forEach_(this.getInExtent(t), e);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(t, e) {
    let r;
    for (let s = 0, u = t.length; s < u; s++)
      if (r = e(t[s]), r)
        return r;
    return r;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return hr(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(t) {
    const e = this.rbush_.toJSON();
    return Ci(e.minX, e.minY, e.maxX, e.maxY, t);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(t) {
    this.rbush_.load(t.rbush_.all());
    for (const e in t.items_)
      this.items_[e] = t.items_[e];
  }
}
const xc = Sn();
class Le {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(t, e, r, s, u, h) {
    this.styleFunction, this.extent_, this.id_ = h, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = r || null, this.properties_ = u, this.squaredTolerance_, this.stride_ = s, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(t) {
    return this.properties_[t];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? Rg(this.flatCoordinates_) : al(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const t = Ri(this.getExtent());
      this.flatInteriorPoints_ = vl(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        t,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const t = rv(this.flatCoordinates_, this.ends_), e = Jg(this.flatCoordinates_, 0, t, 2);
      this.flatInteriorPoints_ = Zg(
        this.flatCoordinates_,
        0,
        t,
        2,
        e
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = So(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const t = this.flatCoordinates_;
      let e = 0;
      const r = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let s = 0, u = r.length; s < u; ++s) {
        const h = r[s], f = So(t, e, h, 2, 0.5);
        on(this.flatMidpoints_, f), e = h;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(t, e) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(t) {
    t = bi(t);
    const e = t.getExtent(), r = t.getWorldExtent();
    if (e && r) {
      const s = Cn(r) / Cn(e);
      Oi(
        xc,
        r[0],
        r[3],
        s,
        -s,
        0,
        0,
        0
      ), Jn(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        xc,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(t) {
    t(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    var t;
    return new Le(
      this.type_,
      this.flatCoordinates_.slice(),
      (t = this.ends_) == null ? void 0 : t.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = kg((t, e) => {
      if (t === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), e && this.simplifiedGeometry_.applyTransform(e);
      const r = this.simplifiedGeometry_.getFlatCoordinates();
      let s;
      switch (this.type_) {
        case "LineString":
          r.length = Qo(
            r,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            t,
            r,
            0
          ), s = [r.length];
          break;
        case "MultiLineString":
          s = [], r.length = Xg(
            r,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            t,
            r,
            0,
            s
          );
          break;
        case "Polygon":
          s = [], r.length = yl(
            r,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(t),
            r,
            0,
            s
          );
          break;
      }
      return s && (this.simplifiedGeometry_ = new Le(
        this.type_,
        r,
        s,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = t, this.simplifiedGeometry_;
    }), this;
  }
}
Le.prototype.getFlatCoordinates = Le.prototype.getOrientedFlatCoordinates;
class E0 extends Er {
  /**
   * @param {Options} options Source options.
   */
  constructor(t) {
    super(), this.projection = bi(t.projection), this.attributions_ = Ec(t.attributions), this.attributionsCollapsible_ = t.attributionsCollapsible !== void 0 ? t.attributionsCollapsible : !0, this.loading = !1, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : !1, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
    const e = this;
    this.viewPromise_ = new Promise(function(r, s) {
      e.viewResolver = r, e.viewRejector = s;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(t) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(t) {
    this.attributions_ = Ec(t), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(t) {
    this.state_ = t, this.changed();
  }
}
function Ec(i) {
  return i ? Array.isArray(i) ? function(t) {
    return i;
  } : typeof i == "function" ? i : function(t) {
    return [i];
  } : null;
}
const Ne = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function S0(i, t) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
let I0 = !1;
function w0(i, t, e, r, s, u, h) {
  const f = new XMLHttpRequest();
  f.open(
    "GET",
    typeof i == "function" ? i(e, r, s) : i,
    !0
  ), t.getType() == "arraybuffer" && (f.responseType = "arraybuffer"), f.withCredentials = I0, f.onload = function(g) {
    if (!f.status || f.status >= 200 && f.status < 300) {
      const y = t.getType();
      let p;
      y == "json" ? p = JSON.parse(f.responseText) : y == "text" ? p = f.responseText : y == "xml" ? (p = f.responseXML, p || (p = new DOMParser().parseFromString(
        f.responseText,
        "application/xml"
      ))) : y == "arraybuffer" && (p = /** @type {ArrayBuffer} */
      f.response), p ? u(
        /** @type {Array<import("./Feature.js").default>} */
        t.readFeatures(p, {
          extent: e,
          featureProjection: s
        }),
        t.readProjection(p)
      ) : h();
    } else
      h();
  }, f.onerror = h, f.send();
}
function Sc(i, t) {
  return function(e, r, s, u, h) {
    const f = (
      /** @type {import("./source/Vector").default} */
      this
    );
    w0(
      i,
      t,
      e,
      r,
      s,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(g, y) {
        f.addFeatures(g), u !== void 0 && u(g);
      },
      /* FIXME handle error */
      h || as
    );
  };
}
class Yn extends ks {
  /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */
  constructor(t, e, r) {
    super(t), this.feature = e, this.features = r;
  }
}
class k0 extends E0 {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(t) {
    t = t || {}, super({
      attributions: t.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = as, this.format_ = t.format, this.overlaps_ = t.overlaps === void 0 ? !0 : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (te(this.format_, "`format` must be set when `url` is set"), this.loader_ = Sc(
      this.url_,
      /** @type {import("../format/Feature.js").default} */
      this.format_
    )), this.strategy_ = t.strategy !== void 0 ? t.strategy : S0;
    const e = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : !0;
    this.featuresRtree_ = e ? new _c() : null, this.loadedExtentsRtree_ = new _c(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let r, s;
    Array.isArray(t.features) ? s = t.features : t.features && (r = t.features, s = r.getArray()), !e && r === void 0 && (r = new x0(s)), s !== void 0 && this.addFeaturesInternal(s), r !== void 0 && this.bindFeaturesCollection_(r);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(t) {
    this.addFeatureInternal(t), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(t) {
    const e = jt(t);
    if (!this.addToIndex_(e, t)) {
      this.featuresCollection_ && this.featuresCollection_.remove(t);
      return;
    }
    this.setupChangeEvents_(e, t);
    const r = t.getGeometry();
    if (r) {
      const s = r.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(s, t);
    } else
      this.nullGeometryFeatures_[e] = t;
    this.dispatchEvent(
      new Yn(Ne.ADDFEATURE, t)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(t, e) {
    e instanceof Le || (this.featureChangeKeys_[t] = [
      En(e, Ue.CHANGE, this.handleFeatureChange_, this),
      En(
        e,
        Ig.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(t, e) {
    let r = !0;
    if (e.getId() !== void 0) {
      const s = String(e.getId());
      if (!(s in this.idIndex_))
        this.idIndex_[s] = e;
      else if (e instanceof Le) {
        const u = this.idIndex_[s];
        u instanceof Le ? Array.isArray(u) ? u.push(e) : this.idIndex_[s] = [u, e] : r = !1;
      } else
        r = !1;
    }
    return r && (te(
      !(t in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[t] = e), r;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(t) {
    this.addFeaturesInternal(t), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(t) {
    const e = [], r = [], s = [];
    for (let u = 0, h = t.length; u < h; u++) {
      const f = t[u], g = jt(f);
      this.addToIndex_(g, f) && r.push(f);
    }
    for (let u = 0, h = r.length; u < h; u++) {
      const f = r[u], g = jt(f);
      this.setupChangeEvents_(g, f);
      const y = f.getGeometry();
      if (y) {
        const p = y.getExtent();
        e.push(p), s.push(f);
      } else
        this.nullGeometryFeatures_[g] = f;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(e, s), this.hasListener(Ne.ADDFEATURE))
      for (let u = 0, h = r.length; u < h; u++)
        this.dispatchEvent(
          new Yn(Ne.ADDFEATURE, r[u])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(t) {
    let e = !1;
    this.addEventListener(
      Ne.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(r) {
        e || (e = !0, t.push(r.feature), e = !1);
      }
    ), this.addEventListener(
      Ne.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(r) {
        e || (e = !0, t.remove(r.feature), e = !1);
      }
    ), t.addEventListener(
      or.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (r) => {
        e || (e = !0, this.addFeature(r.element), e = !1);
      }
    ), t.addEventListener(
      or.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (r) => {
        e || (e = !0, this.removeFeature(r.element), e = !1);
      }
    ), this.featuresCollection_ = t;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(t) {
    if (t) {
      for (const r in this.featureChangeKeys_)
        this.featureChangeKeys_[r].forEach(Hn);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const r = (s) => {
        this.removeFeatureInternal(s);
      };
      this.featuresRtree_.forEach(r);
      for (const s in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[s]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const e = new Yn(Ne.CLEAR);
    this.dispatchEvent(e), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(t, e) {
    const r = [t[0], t[1], t[0], t[1]];
    return this.forEachFeatureInExtent(r, function(s) {
      const u = s.getGeometry();
      if (u instanceof Le || u.intersectsCoordinate(t))
        return e(s);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(t, e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(t, e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(t, e) {
    return this.forEachFeatureInExtent(
      t,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(r) {
        const s = r.getGeometry();
        if (s instanceof Le || s.intersectsExtent(t)) {
          const u = e(r);
          if (u)
            return u;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let t;
    return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), hr(this.nullGeometryFeatures_) || on(t, Object.values(this.nullGeometryFeatures_))), t;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  getFeaturesAtCoordinate(t) {
    const e = [];
    return this.forEachFeatureAtCoordinateDirect(t, function(r) {
      e.push(r);
    }), e;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(t, e) {
    if (this.featuresRtree_) {
      if (!(e && e.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(t);
      const s = dm(t, e);
      return [].concat(
        ...s.map((u) => this.featuresRtree_.getInExtent(u))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(t, e) {
    const r = t[0], s = t[1];
    let u = null;
    const h = [NaN, NaN];
    let f = 1 / 0;
    const g = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return e = e || Hp, this.featuresRtree_.forEachInExtent(
      g,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(y) {
        if (e(y)) {
          const p = y.getGeometry(), m = f;
          if (f = p instanceof Le ? 0 : p.closestPointXY(r, s, h, f), f < m) {
            u = y;
            const _ = Math.sqrt(f);
            g[0] = r - _, g[1] = s - _, g[2] = r + _, g[3] = s + _;
          }
        }
      }
    ), u;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(t) {
    return this.featuresRtree_.getExtent(t);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(t) {
    const e = this.idIndex_[t.toString()];
    return e !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      e
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(t) {
    const e = this.uidIndex_[t];
    return e !== void 0 ? e : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<import('../format/Feature.js').FeatureToFeatureClass<FeatureType>>|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(t) {
    const e = (
      /** @type {FeatureType} */
      t.target
    ), r = jt(e), s = e.getGeometry();
    if (!s)
      r in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[r] = e);
    else {
      const h = s.getExtent();
      r in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[r], this.featuresRtree_ && this.featuresRtree_.insert(h, e)) : this.featuresRtree_ && this.featuresRtree_.update(h, e);
    }
    const u = e.getId();
    if (u !== void 0) {
      const h = u.toString();
      this.idIndex_[h] !== e && (this.removeFromIdIndex_(e), this.idIndex_[h] = e);
    } else
      this.removeFromIdIndex_(e), this.uidIndex_[r] = e;
    this.changed(), this.dispatchEvent(
      new Yn(Ne.CHANGEFEATURE, e)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(t) {
    const e = t.getId();
    return e !== void 0 ? e in this.idIndex_ : jt(t) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && hr(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(t, e, r) {
    const s = this.loadedExtentsRtree_, u = this.strategy_(t, e, r);
    for (let h = 0, f = u.length; h < f; ++h) {
      const g = u[h];
      s.forEachInExtent(
        g,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(p) {
          return rr(p.extent, g);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new Yn(Ne.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        g,
        e,
        r,
        (p) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new Yn(
              Ne.FEATURESLOADEND,
              void 0,
              p
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new Yn(Ne.FEATURESLOADERROR)
          );
        }
      ), s.insert(g, { extent: g.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(t) {
    const e = this.loadedExtentsRtree_;
    let r;
    e.forEachInExtent(t, function(s) {
      if (bg(s.extent, t))
        return r = s, !0;
    }), r && e.remove(r);
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   */
  removeFeatures(t) {
    const e = [];
    for (let r = 0, s = t.length; r < s; ++r) {
      const u = t[r], h = this.removeFeatureInternal(u);
      h && e.push(h);
    }
    e.length > 0 && this.changed();
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(t) {
    if (!t)
      return;
    this.removeFeatureInternal(t) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {FeatureType|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(t) {
    const e = jt(t);
    e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t);
    const r = this.featureChangeKeys_[e];
    if (!r)
      return;
    r.forEach(Hn), delete this.featureChangeKeys_[e];
    const s = t.getId();
    return s !== void 0 && delete this.idIndex_[s.toString()], delete this.uidIndex_[e], this.hasListener(Ne.REMOVEFEATURE) && this.dispatchEvent(
      new Yn(Ne.REMOVEFEATURE, t)
    ), t;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(t) {
    let e = !1;
    for (const r in this.idIndex_) {
      const s = this.idIndex_[r];
      if (t instanceof Le && Array.isArray(s) && s.includes(t))
        s.splice(s.indexOf(t), 1);
      else if (this.idIndex_[r] === t) {
        delete this.idIndex_[r], e = !0;
        break;
      }
    }
    return e;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(t) {
    this.loader_ = t;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(t) {
    te(this.format_, "`format` must be set when `url` is set"), this.url_ = t, this.setLoader(Sc(t, this.format_));
  }
}
var ua = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xd(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function C0(i) {
  if (i.__esModule) return i;
  var t = i.default;
  if (typeof t == "function") {
    var e = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(i).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(i, r);
    Object.defineProperty(e, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return i[r];
      }
    });
  }), e;
}
var Ic = Object.prototype.toString, Ed = function(t) {
  var e = Ic.call(t), r = e === "[object Arguments]";
  return r || (r = e !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Ic.call(t.callee) === "[object Function]"), r;
}, Wa, wc;
function R0() {
  if (wc) return Wa;
  wc = 1;
  var i;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, e = Object.prototype.toString, r = Ed, s = Object.prototype.propertyIsEnumerable, u = !s.call({ toString: null }, "toString"), h = s.call(function() {
    }, "prototype"), f = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], g = function(_) {
      var x = _.constructor;
      return x && x.prototype === _;
    }, y = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, p = function() {
      if (typeof window > "u")
        return !1;
      for (var _ in window)
        try {
          if (!y["$" + _] && t.call(window, _) && window[_] !== null && typeof window[_] == "object")
            try {
              g(window[_]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), m = function(_) {
      if (typeof window > "u" || !p)
        return g(_);
      try {
        return g(_);
      } catch {
        return !1;
      }
    };
    i = function(x) {
      var I = x !== null && typeof x == "object", k = e.call(x) === "[object Function]", C = r(x), R = I && e.call(x) === "[object String]", b = [];
      if (!I && !k && !C)
        throw new TypeError("Object.keys called on a non-object");
      var O = h && k;
      if (R && x.length > 0 && !t.call(x, 0))
        for (var A = 0; A < x.length; ++A)
          b.push(String(A));
      if (C && x.length > 0)
        for (var L = 0; L < x.length; ++L)
          b.push(String(L));
      else
        for (var D in x)
          !(O && D === "prototype") && t.call(x, D) && b.push(String(D));
      if (u)
        for (var F = m(x), G = 0; G < f.length; ++G)
          !(F && f[G] === "constructor") && t.call(x, f[G]) && b.push(f[G]);
      return b;
    };
  }
  return Wa = i, Wa;
}
var b0 = Array.prototype.slice, T0 = Ed, kc = Object.keys, oo = kc ? function(t) {
  return kc(t);
} : R0(), Cc = Object.keys;
oo.shim = function() {
  if (Object.keys) {
    var t = function() {
      var e = Object.keys(arguments);
      return e && e.length === arguments.length;
    }(1, 2);
    t || (Object.keys = function(r) {
      return T0(r) ? Cc(b0.call(r)) : Cc(r);
    });
  } else
    Object.keys = oo;
  return Object.keys || oo;
};
var Rl = oo, N0 = Error, M0 = EvalError, O0 = RangeError, L0 = ReferenceError, Sd = SyntaxError, ri = TypeError, A0 = URIError, la = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, e = Symbol("test"), r = Object(e);
  if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
    return !1;
  var s = 42;
  t[e] = s;
  for (e in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var u = Object.getOwnPropertySymbols(t);
  if (u.length !== 1 || u[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var h = Object.getOwnPropertyDescriptor(t, e);
    if (h.value !== s || h.enumerable !== !0)
      return !1;
  }
  return !0;
}, Rc = typeof Symbol < "u" && Symbol, P0 = la, bl = function() {
  return typeof Rc != "function" || typeof Symbol != "function" || typeof Rc("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : P0();
}, Ua = {
  __proto__: null,
  foo: {}
}, D0 = Object, F0 = function() {
  return { __proto__: Ua }.foo === Ua.foo && !(Ua instanceof D0);
}, G0 = "Function.prototype.bind called on incompatible ", B0 = Object.prototype.toString, Y0 = Math.max, z0 = "[object Function]", bc = function(t, e) {
  for (var r = [], s = 0; s < t.length; s += 1)
    r[s] = t[s];
  for (var u = 0; u < e.length; u += 1)
    r[u + t.length] = e[u];
  return r;
}, $0 = function(t, e) {
  for (var r = [], s = e, u = 0; s < t.length; s += 1, u += 1)
    r[u] = t[s];
  return r;
}, X0 = function(i, t) {
  for (var e = "", r = 0; r < i.length; r += 1)
    e += i[r], r + 1 < i.length && (e += t);
  return e;
}, q0 = function(t) {
  var e = this;
  if (typeof e != "function" || B0.apply(e) !== z0)
    throw new TypeError(G0 + e);
  for (var r = $0(arguments, 1), s, u = function() {
    if (this instanceof s) {
      var p = e.apply(
        this,
        bc(r, arguments)
      );
      return Object(p) === p ? p : this;
    }
    return e.apply(
      t,
      bc(r, arguments)
    );
  }, h = Y0(0, e.length - r.length), f = [], g = 0; g < h; g++)
    f[g] = "$" + g;
  if (s = Function("binder", "return function (" + X0(f, ",") + "){ return binder.apply(this,arguments); }")(u), e.prototype) {
    var y = function() {
    };
    y.prototype = e.prototype, s.prototype = new y(), y.prototype = null;
  }
  return s;
}, W0 = q0, Tl = Function.prototype.bind || W0, U0 = Function.prototype.call, j0 = Object.prototype.hasOwnProperty, V0 = Tl, Id = V0.call(U0, j0), _t, Z0 = N0, H0 = M0, J0 = O0, K0 = L0, dr = Sd, lr = ri, Q0 = A0, wd = Function, ja = function(i) {
  try {
    return wd('"use strict"; return (' + i + ").constructor;")();
  } catch {
  }
}, Ii = Object.getOwnPropertyDescriptor;
if (Ii)
  try {
    Ii({}, "");
  } catch {
    Ii = null;
  }
var Va = function() {
  throw new lr();
}, t1 = Ii ? function() {
  try {
    return arguments.callee, Va;
  } catch {
    try {
      return Ii(arguments, "callee").get;
    } catch {
      return Va;
    }
  }
}() : Va, Ji = bl(), e1 = F0(), $t = Object.getPrototypeOf || (e1 ? function(i) {
  return i.__proto__;
} : null), ir = {}, n1 = typeof Uint8Array > "u" || !$t ? _t : $t(Uint8Array), wi = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? _t : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? _t : ArrayBuffer,
  "%ArrayIteratorPrototype%": Ji && $t ? $t([][Symbol.iterator]()) : _t,
  "%AsyncFromSyncIteratorPrototype%": _t,
  "%AsyncFunction%": ir,
  "%AsyncGenerator%": ir,
  "%AsyncGeneratorFunction%": ir,
  "%AsyncIteratorPrototype%": ir,
  "%Atomics%": typeof Atomics > "u" ? _t : Atomics,
  "%BigInt%": typeof BigInt > "u" ? _t : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? _t : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? _t : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? _t : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Z0,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": H0,
  "%Float32Array%": typeof Float32Array > "u" ? _t : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? _t : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? _t : FinalizationRegistry,
  "%Function%": wd,
  "%GeneratorFunction%": ir,
  "%Int8Array%": typeof Int8Array > "u" ? _t : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? _t : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? _t : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Ji && $t ? $t($t([][Symbol.iterator]())) : _t,
  "%JSON%": typeof JSON == "object" ? JSON : _t,
  "%Map%": typeof Map > "u" ? _t : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Ji || !$t ? _t : $t((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? _t : Promise,
  "%Proxy%": typeof Proxy > "u" ? _t : Proxy,
  "%RangeError%": J0,
  "%ReferenceError%": K0,
  "%Reflect%": typeof Reflect > "u" ? _t : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? _t : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Ji || !$t ? _t : $t((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? _t : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Ji && $t ? $t(""[Symbol.iterator]()) : _t,
  "%Symbol%": Ji ? Symbol : _t,
  "%SyntaxError%": dr,
  "%ThrowTypeError%": t1,
  "%TypedArray%": n1,
  "%TypeError%": lr,
  "%Uint8Array%": typeof Uint8Array > "u" ? _t : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? _t : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? _t : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? _t : Uint32Array,
  "%URIError%": Q0,
  "%WeakMap%": typeof WeakMap > "u" ? _t : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? _t : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? _t : WeakSet
};
if ($t)
  try {
    null.error;
  } catch (i) {
    var i1 = $t($t(i));
    wi["%Error.prototype%"] = i1;
  }
var r1 = function i(t) {
  var e;
  if (t === "%AsyncFunction%")
    e = ja("async function () {}");
  else if (t === "%GeneratorFunction%")
    e = ja("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    e = ja("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = i("%AsyncGeneratorFunction%");
    r && (e = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var s = i("%AsyncGenerator%");
    s && $t && (e = $t(s.prototype));
  }
  return wi[t] = e, e;
}, Tc = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Ms = Tl, bo = Id, s1 = Ms.call(Function.call, Array.prototype.concat), o1 = Ms.call(Function.apply, Array.prototype.splice), Nc = Ms.call(Function.call, String.prototype.replace), To = Ms.call(Function.call, String.prototype.slice), a1 = Ms.call(Function.call, RegExp.prototype.exec), u1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, l1 = /\\(\\)?/g, h1 = function(t) {
  var e = To(t, 0, 1), r = To(t, -1);
  if (e === "%" && r !== "%")
    throw new dr("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && e !== "%")
    throw new dr("invalid intrinsic syntax, expected opening `%`");
  var s = [];
  return Nc(t, u1, function(u, h, f, g) {
    s[s.length] = f ? Nc(g, l1, "$1") : h || u;
  }), s;
}, c1 = function(t, e) {
  var r = t, s;
  if (bo(Tc, r) && (s = Tc[r], r = "%" + s[0] + "%"), bo(wi, r)) {
    var u = wi[r];
    if (u === ir && (u = r1(r)), typeof u > "u" && !e)
      throw new lr("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: s,
      name: r,
      value: u
    };
  }
  throw new dr("intrinsic " + t + " does not exist!");
}, ln = function(t, e) {
  if (typeof t != "string" || t.length === 0)
    throw new lr("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof e != "boolean")
    throw new lr('"allowMissing" argument must be a boolean');
  if (a1(/^%?[^%]*%?$/, t) === null)
    throw new dr("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = h1(t), s = r.length > 0 ? r[0] : "", u = c1("%" + s + "%", e), h = u.name, f = u.value, g = !1, y = u.alias;
  y && (s = y[0], o1(r, s1([0, 1], y)));
  for (var p = 1, m = !0; p < r.length; p += 1) {
    var _ = r[p], x = To(_, 0, 1), I = To(_, -1);
    if ((x === '"' || x === "'" || x === "`" || I === '"' || I === "'" || I === "`") && x !== I)
      throw new dr("property names with quotes must have matching quotes");
    if ((_ === "constructor" || !m) && (g = !0), s += "." + _, h = "%" + s + "%", bo(wi, h))
      f = wi[h];
    else if (f != null) {
      if (!(_ in f)) {
        if (!e)
          throw new lr("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Ii && p + 1 >= r.length) {
        var k = Ii(f, _);
        m = !!k, m && "get" in k && !("originalValue" in k.get) ? f = k.get : f = f[_];
      } else
        m = bo(f, _), f = f[_];
      m && !g && (wi[h] = f);
    }
  }
  return f;
}, f1 = ln, ao = f1("%Object.defineProperty%", !0) || !1;
if (ao)
  try {
    ao({}, "a", { value: 1 });
  } catch {
    ao = !1;
  }
var Nl = ao, g1 = ln, uo = g1("%Object.getOwnPropertyDescriptor%", !0);
if (uo)
  try {
    uo([], "length");
  } catch {
    uo = null;
  }
var Ml = uo, Mc = Nl, d1 = Sd, Ki = ri, Oc = Ml, Ol = function(t, e, r) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new Ki("`obj` must be an object or a function`");
  if (typeof e != "string" && typeof e != "symbol")
    throw new Ki("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Ki("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Ki("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Ki("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Ki("`loose`, if provided, must be a boolean");
  var s = arguments.length > 3 ? arguments[3] : null, u = arguments.length > 4 ? arguments[4] : null, h = arguments.length > 5 ? arguments[5] : null, f = arguments.length > 6 ? arguments[6] : !1, g = !!Oc && Oc(t, e);
  if (Mc)
    Mc(t, e, {
      configurable: h === null && g ? g.configurable : !h,
      enumerable: s === null && g ? g.enumerable : !s,
      value: r,
      writable: u === null && g ? g.writable : !u
    });
  else if (f || !s && !u && !h)
    t[e] = r;
  else
    throw new d1("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, Ru = Nl, kd = function() {
  return !!Ru;
};
kd.hasArrayLengthDefineBug = function() {
  if (!Ru)
    return null;
  try {
    return Ru([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var Ll = kd, y1 = Rl, p1 = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", m1 = Object.prototype.toString, v1 = Array.prototype.concat, Lc = Ol, _1 = function(i) {
  return typeof i == "function" && m1.call(i) === "[object Function]";
}, Cd = Ll(), x1 = function(i, t, e, r) {
  if (t in i) {
    if (r === !0) {
      if (i[t] === e)
        return;
    } else if (!_1(r) || !r())
      return;
  }
  Cd ? Lc(i, t, e, !0) : Lc(i, t, e);
}, Rd = function(i, t) {
  var e = arguments.length > 2 ? arguments[2] : {}, r = y1(t);
  p1 && (r = v1.call(r, Object.getOwnPropertySymbols(t)));
  for (var s = 0; s < r.length; s += 1)
    x1(i, r[s], t[r[s]], e[r[s]]);
};
Rd.supportsDescriptors = !!Cd;
var Pi = Rd, bd = { exports: {} }, E1 = ln, Ac = Ol, S1 = Ll(), Pc = Ml, Dc = ri, I1 = E1("%Math.floor%"), w1 = function(t, e) {
  if (typeof t != "function")
    throw new Dc("`fn` is not a function");
  if (typeof e != "number" || e < 0 || e > 4294967295 || I1(e) !== e)
    throw new Dc("`length` must be a positive 32-bit integer");
  var r = arguments.length > 2 && !!arguments[2], s = !0, u = !0;
  if ("length" in t && Pc) {
    var h = Pc(t, "length");
    h && !h.configurable && (s = !1), h && !h.writable && (u = !1);
  }
  return (s || u || !r) && (S1 ? Ac(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    e,
    !0,
    !0
  ) : Ac(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    e
  )), t;
};
(function(i) {
  var t = Tl, e = ln, r = w1, s = ri, u = e("%Function.prototype.apply%"), h = e("%Function.prototype.call%"), f = e("%Reflect.apply%", !0) || t.call(h, u), g = Nl, y = e("%Math.max%");
  i.exports = function(_) {
    if (typeof _ != "function")
      throw new s("a function is required");
    var x = f(t, h, arguments);
    return r(
      x,
      1 + y(0, _.length - (arguments.length - 1)),
      !0
    );
  };
  var p = function() {
    return f(t, u, arguments);
  };
  g ? g(i.exports, "apply", { value: p }) : i.exports.apply = p;
})(bd);
var wr = bd.exports, Td = ln, Nd = wr, k1 = Nd(Td("String.prototype.indexOf")), Pe = function(t, e) {
  var r = Td(t, !!e);
  return typeof r == "function" && k1(t, ".prototype.") > -1 ? Nd(r) : r;
}, C1 = Rl, Md = la(), Od = Pe, Fc = Object, R1 = Od("Array.prototype.push"), Gc = Od("Object.prototype.propertyIsEnumerable"), b1 = Md ? Object.getOwnPropertySymbols : null, Ld = function(t, e) {
  if (t == null)
    throw new TypeError("target must be an object");
  var r = Fc(t);
  if (arguments.length === 1)
    return r;
  for (var s = 1; s < arguments.length; ++s) {
    var u = Fc(arguments[s]), h = C1(u), f = Md && (Object.getOwnPropertySymbols || b1);
    if (f)
      for (var g = f(u), y = 0; y < g.length; ++y) {
        var p = g[y];
        Gc(u, p) && R1(h, p);
      }
    for (var m = 0; m < h.length; ++m) {
      var _ = h[m];
      if (Gc(u, _)) {
        var x = u[_];
        r[_] = x;
      }
    }
  }
  return r;
}, Za = Ld, T1 = function() {
  if (!Object.assign)
    return !1;
  for (var i = "abcdefghijklmnopqrst", t = i.split(""), e = {}, r = 0; r < t.length; ++r)
    e[t[r]] = t[r];
  var s = Object.assign({}, e), u = "";
  for (var h in s)
    u += h;
  return i !== u;
}, N1 = function() {
  if (!Object.assign || !Object.preventExtensions)
    return !1;
  var i = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(i, "xy");
  } catch {
    return i[1] === "y";
  }
  return !1;
}, Ad = function() {
  return !Object.assign || T1() || N1() ? Za : Object.assign;
}, M1 = Pi, O1 = Ad, L1 = function() {
  var t = O1();
  return M1(
    Object,
    { assign: t },
    { assign: function() {
      return Object.assign !== t;
    } }
  ), t;
}, A1 = Pi, P1 = wr, D1 = Ld, Pd = Ad, F1 = L1, G1 = P1.apply(Pd()), Dd = function(t, e) {
  return G1(Object, arguments);
};
A1(Dd, {
  getPolyfill: Pd,
  implementation: D1,
  shim: F1
});
var B1 = Dd, Ss = function() {
  return typeof (function() {
  }).name == "string";
}, is = Object.getOwnPropertyDescriptor;
if (is)
  try {
    is([], "length");
  } catch {
    is = null;
  }
Ss.functionsHaveConfigurableNames = function() {
  if (!Ss() || !is)
    return !1;
  var t = is(function() {
  }, "name");
  return !!t && !!t.configurable;
};
var Y1 = Function.prototype.bind;
Ss.boundFunctionsHaveNames = function() {
  return Ss() && typeof Y1 == "function" && (function() {
  }).bind().name !== "";
};
var z1 = Ss, Bc = Ol, $1 = Ll(), X1 = z1.functionsHaveConfigurableNames(), q1 = ri, W1 = function(t, e) {
  if (typeof t != "function")
    throw new q1("`fn` is not a function");
  var r = arguments.length > 2 && !!arguments[2];
  return (!r || X1) && ($1 ? Bc(
    /** @type {Parameters<define>[0]} */
    t,
    "name",
    e,
    !0,
    !0
  ) : Bc(
    /** @type {Parameters<define>[0]} */
    t,
    "name",
    e
  )), t;
}, U1 = W1, j1 = ri, V1 = Object, Fd = U1(function() {
  if (this == null || this !== V1(this))
    throw new j1("RegExp.prototype.flags getter called on non-object");
  var t = "";
  return this.hasIndices && (t += "d"), this.global && (t += "g"), this.ignoreCase && (t += "i"), this.multiline && (t += "m"), this.dotAll && (t += "s"), this.unicode && (t += "u"), this.unicodeSets && (t += "v"), this.sticky && (t += "y"), t;
}, "get flags", !0), Z1 = Fd, H1 = Pi.supportsDescriptors, J1 = Object.getOwnPropertyDescriptor, Gd = function() {
  if (H1 && /a/mig.flags === "gim") {
    var t = J1(RegExp.prototype, "flags");
    if (t && typeof t.get == "function" && typeof RegExp.prototype.dotAll == "boolean" && typeof RegExp.prototype.hasIndices == "boolean") {
      var e = "", r = {};
      if (Object.defineProperty(r, "hasIndices", {
        get: function() {
          e += "d";
        }
      }), Object.defineProperty(r, "sticky", {
        get: function() {
          e += "y";
        }
      }), e === "dy")
        return t.get;
    }
  }
  return Z1;
}, K1 = Pi.supportsDescriptors, Q1 = Gd, tx = Object.getOwnPropertyDescriptor, ex = Object.defineProperty, nx = TypeError, Yc = Object.getPrototypeOf, ix = /a/, rx = function() {
  if (!K1 || !Yc)
    throw new nx("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  var t = Q1(), e = Yc(ix), r = tx(e, "flags");
  return (!r || r.get !== t) && ex(e, "flags", {
    configurable: !0,
    enumerable: !1,
    get: t
  }), t;
}, sx = Pi, ox = wr, ax = Fd, Bd = Gd, ux = rx, Yd = ox(Bd());
sx(Yd, {
  getPolyfill: Bd,
  implementation: ax,
  shim: ux
});
var lx = Yd, lo = { exports: {} }, hx = la, Di = function() {
  return hx() && !!Symbol.toStringTag;
}, cx = Di(), fx = Pe, bu = fx("Object.prototype.toString"), ha = function(t) {
  return cx && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : bu(t) === "[object Arguments]";
}, zd = function(t) {
  return ha(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && bu(t) !== "[object Array]" && bu(t.callee) === "[object Function]";
}, gx = function() {
  return ha(arguments);
}();
ha.isLegacyArguments = zd;
var $d = gx ? ha : zd;
const dx = {}, yx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: dx
}, Symbol.toStringTag, { value: "Module" })), px = /* @__PURE__ */ C0(yx);
var Al = typeof Map == "function" && Map.prototype, Ha = Object.getOwnPropertyDescriptor && Al ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, No = Al && Ha && typeof Ha.get == "function" ? Ha.get : null, zc = Al && Map.prototype.forEach, Pl = typeof Set == "function" && Set.prototype, Ja = Object.getOwnPropertyDescriptor && Pl ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Mo = Pl && Ja && typeof Ja.get == "function" ? Ja.get : null, $c = Pl && Set.prototype.forEach, mx = typeof WeakMap == "function" && WeakMap.prototype, rs = mx ? WeakMap.prototype.has : null, vx = typeof WeakSet == "function" && WeakSet.prototype, ss = vx ? WeakSet.prototype.has : null, _x = typeof WeakRef == "function" && WeakRef.prototype, Xc = _x ? WeakRef.prototype.deref : null, xx = Boolean.prototype.valueOf, Ex = Object.prototype.toString, Sx = Function.prototype.toString, Ix = String.prototype.match, Dl = String.prototype.slice, Vn = String.prototype.replace, wx = String.prototype.toUpperCase, qc = String.prototype.toLowerCase, Xd = RegExp.prototype.test, Wc = Array.prototype.concat, tn = Array.prototype.join, kx = Array.prototype.slice, Uc = Math.floor, Tu = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, Ka = Object.getOwnPropertySymbols, Nu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, yr = typeof Symbol == "function" && typeof Symbol.iterator == "object", ie = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === yr || !0) ? Symbol.toStringTag : null, qd = Object.prototype.propertyIsEnumerable, jc = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(i) {
  return i.__proto__;
} : null);
function Vc(i, t) {
  if (i === 1 / 0 || i === -1 / 0 || i !== i || i && i > -1e3 && i < 1e3 || Xd.call(/e/, t))
    return t;
  var e = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof i == "number") {
    var r = i < 0 ? -Uc(-i) : Uc(i);
    if (r !== i) {
      var s = String(r), u = Dl.call(t, s.length + 1);
      return Vn.call(s, e, "$&_") + "." + Vn.call(Vn.call(u, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return Vn.call(t, e, "$&_");
}
var Mu = px, Zc = Mu.custom, Hc = Ud(Zc) ? Zc : null, Cx = function i(t, e, r, s) {
  var u = e || {};
  if ($n(u, "quoteStyle") && u.quoteStyle !== "single" && u.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if ($n(u, "maxStringLength") && (typeof u.maxStringLength == "number" ? u.maxStringLength < 0 && u.maxStringLength !== 1 / 0 : u.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var h = $n(u, "customInspect") ? u.customInspect : !0;
  if (typeof h != "boolean" && h !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if ($n(u, "indent") && u.indent !== null && u.indent !== "	" && !(parseInt(u.indent, 10) === u.indent && u.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if ($n(u, "numericSeparator") && typeof u.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var f = u.numericSeparator;
  if (typeof t > "u")
    return "undefined";
  if (t === null)
    return "null";
  if (typeof t == "boolean")
    return t ? "true" : "false";
  if (typeof t == "string")
    return Vd(t, u);
  if (typeof t == "number") {
    if (t === 0)
      return 1 / 0 / t > 0 ? "0" : "-0";
    var g = String(t);
    return f ? Vc(t, g) : g;
  }
  if (typeof t == "bigint") {
    var y = String(t) + "n";
    return f ? Vc(t, y) : y;
  }
  var p = typeof u.depth > "u" ? 5 : u.depth;
  if (typeof r > "u" && (r = 0), r >= p && p > 0 && typeof t == "object")
    return Ou(t) ? "[Array]" : "[Object]";
  var m = qx(u, r);
  if (typeof s > "u")
    s = [];
  else if (jd(s, t) >= 0)
    return "[Circular]";
  function _(Q, X, K) {
    if (X && (s = kx.call(s), s.push(X)), K) {
      var V = {
        depth: u.depth
      };
      return $n(u, "quoteStyle") && (V.quoteStyle = u.quoteStyle), i(Q, V, r + 1, s);
    }
    return i(Q, u, r + 1, s);
  }
  if (typeof t == "function" && !Jc(t)) {
    var x = Px(t), I = Ks(t, _);
    return "[Function" + (x ? ": " + x : " (anonymous)") + "]" + (I.length > 0 ? " { " + tn.call(I, ", ") + " }" : "");
  }
  if (Ud(t)) {
    var k = yr ? Vn.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : Nu.call(t);
    return typeof t == "object" && !yr ? Wr(k) : k;
  }
  if (zx(t)) {
    for (var C = "<" + qc.call(String(t.nodeName)), R = t.attributes || [], b = 0; b < R.length; b++)
      C += " " + R[b].name + "=" + Wd(Rx(R[b].value), "double", u);
    return C += ">", t.childNodes && t.childNodes.length && (C += "..."), C += "</" + qc.call(String(t.nodeName)) + ">", C;
  }
  if (Ou(t)) {
    if (t.length === 0)
      return "[]";
    var O = Ks(t, _);
    return m && !Xx(O) ? "[" + Lu(O, m) + "]" : "[ " + tn.call(O, ", ") + " ]";
  }
  if (Tx(t)) {
    var A = Ks(t, _);
    return !("cause" in Error.prototype) && "cause" in t && !qd.call(t, "cause") ? "{ [" + String(t) + "] " + tn.call(Wc.call("[cause]: " + _(t.cause), A), ", ") + " }" : A.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + tn.call(A, ", ") + " }";
  }
  if (typeof t == "object" && h) {
    if (Hc && typeof t[Hc] == "function" && Mu)
      return Mu(t, { depth: p - r });
    if (h !== "symbol" && typeof t.inspect == "function")
      return t.inspect();
  }
  if (Dx(t)) {
    var L = [];
    return zc && zc.call(t, function(Q, X) {
      L.push(_(X, t, !0) + " => " + _(Q, t));
    }), Kc("Map", No.call(t), L, m);
  }
  if (Bx(t)) {
    var D = [];
    return $c && $c.call(t, function(Q) {
      D.push(_(Q, t));
    }), Kc("Set", Mo.call(t), D, m);
  }
  if (Fx(t))
    return Qa("WeakMap");
  if (Yx(t))
    return Qa("WeakSet");
  if (Gx(t))
    return Qa("WeakRef");
  if (Mx(t))
    return Wr(_(Number(t)));
  if (Lx(t))
    return Wr(_(Tu.call(t)));
  if (Ox(t))
    return Wr(xx.call(t));
  if (Nx(t))
    return Wr(_(String(t)));
  if (typeof window < "u" && t === window)
    return "{ [object Window] }";
  if (t === ua)
    return "{ [object globalThis] }";
  if (!bx(t) && !Jc(t)) {
    var F = Ks(t, _), G = jc ? jc(t) === Object.prototype : t instanceof Object || t.constructor === Object, B = t instanceof Object ? "" : "null prototype", tt = !G && ie && Object(t) === t && ie in t ? Dl.call(si(t), 8, -1) : B ? "Object" : "", J = G || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", H = J + (tt || B ? "[" + tn.call(Wc.call([], tt || [], B || []), ": ") + "] " : "");
    return F.length === 0 ? H + "{}" : m ? H + "{" + Lu(F, m) + "}" : H + "{ " + tn.call(F, ", ") + " }";
  }
  return String(t);
};
function Wd(i, t, e) {
  var r = (e.quoteStyle || t) === "double" ? '"' : "'";
  return r + i + r;
}
function Rx(i) {
  return Vn.call(String(i), /"/g, "&quot;");
}
function Ou(i) {
  return si(i) === "[object Array]" && (!ie || !(typeof i == "object" && ie in i));
}
function bx(i) {
  return si(i) === "[object Date]" && (!ie || !(typeof i == "object" && ie in i));
}
function Jc(i) {
  return si(i) === "[object RegExp]" && (!ie || !(typeof i == "object" && ie in i));
}
function Tx(i) {
  return si(i) === "[object Error]" && (!ie || !(typeof i == "object" && ie in i));
}
function Nx(i) {
  return si(i) === "[object String]" && (!ie || !(typeof i == "object" && ie in i));
}
function Mx(i) {
  return si(i) === "[object Number]" && (!ie || !(typeof i == "object" && ie in i));
}
function Ox(i) {
  return si(i) === "[object Boolean]" && (!ie || !(typeof i == "object" && ie in i));
}
function Ud(i) {
  if (yr)
    return i && typeof i == "object" && i instanceof Symbol;
  if (typeof i == "symbol")
    return !0;
  if (!i || typeof i != "object" || !Nu)
    return !1;
  try {
    return Nu.call(i), !0;
  } catch {
  }
  return !1;
}
function Lx(i) {
  if (!i || typeof i != "object" || !Tu)
    return !1;
  try {
    return Tu.call(i), !0;
  } catch {
  }
  return !1;
}
var Ax = Object.prototype.hasOwnProperty || function(i) {
  return i in this;
};
function $n(i, t) {
  return Ax.call(i, t);
}
function si(i) {
  return Ex.call(i);
}
function Px(i) {
  if (i.name)
    return i.name;
  var t = Ix.call(Sx.call(i), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function jd(i, t) {
  if (i.indexOf)
    return i.indexOf(t);
  for (var e = 0, r = i.length; e < r; e++)
    if (i[e] === t)
      return e;
  return -1;
}
function Dx(i) {
  if (!No || !i || typeof i != "object")
    return !1;
  try {
    No.call(i);
    try {
      Mo.call(i);
    } catch {
      return !0;
    }
    return i instanceof Map;
  } catch {
  }
  return !1;
}
function Fx(i) {
  if (!rs || !i || typeof i != "object")
    return !1;
  try {
    rs.call(i, rs);
    try {
      ss.call(i, ss);
    } catch {
      return !0;
    }
    return i instanceof WeakMap;
  } catch {
  }
  return !1;
}
function Gx(i) {
  if (!Xc || !i || typeof i != "object")
    return !1;
  try {
    return Xc.call(i), !0;
  } catch {
  }
  return !1;
}
function Bx(i) {
  if (!Mo || !i || typeof i != "object")
    return !1;
  try {
    Mo.call(i);
    try {
      No.call(i);
    } catch {
      return !0;
    }
    return i instanceof Set;
  } catch {
  }
  return !1;
}
function Yx(i) {
  if (!ss || !i || typeof i != "object")
    return !1;
  try {
    ss.call(i, ss);
    try {
      rs.call(i, rs);
    } catch {
      return !0;
    }
    return i instanceof WeakSet;
  } catch {
  }
  return !1;
}
function zx(i) {
  return !i || typeof i != "object" ? !1 : typeof HTMLElement < "u" && i instanceof HTMLElement ? !0 : typeof i.nodeName == "string" && typeof i.getAttribute == "function";
}
function Vd(i, t) {
  if (i.length > t.maxStringLength) {
    var e = i.length - t.maxStringLength, r = "... " + e + " more character" + (e > 1 ? "s" : "");
    return Vd(Dl.call(i, 0, t.maxStringLength), t) + r;
  }
  var s = Vn.call(Vn.call(i, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, $x);
  return Wd(s, "single", t);
}
function $x(i) {
  var t = i.charCodeAt(0), e = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[t];
  return e ? "\\" + e : "\\x" + (t < 16 ? "0" : "") + wx.call(t.toString(16));
}
function Wr(i) {
  return "Object(" + i + ")";
}
function Qa(i) {
  return i + " { ? }";
}
function Kc(i, t, e, r) {
  var s = r ? Lu(e, r) : tn.call(e, ", ");
  return i + " (" + t + ") {" + s + "}";
}
function Xx(i) {
  for (var t = 0; t < i.length; t++)
    if (jd(i[t], `
`) >= 0)
      return !1;
  return !0;
}
function qx(i, t) {
  var e;
  if (i.indent === "	")
    e = "	";
  else if (typeof i.indent == "number" && i.indent > 0)
    e = tn.call(Array(i.indent + 1), " ");
  else
    return null;
  return {
    base: e,
    prev: tn.call(Array(t + 1), e)
  };
}
function Lu(i, t) {
  if (i.length === 0)
    return "";
  var e = `
` + t.prev + t.base;
  return e + tn.call(i, "," + e) + `
` + t.prev;
}
function Ks(i, t) {
  var e = Ou(i), r = [];
  if (e) {
    r.length = i.length;
    for (var s = 0; s < i.length; s++)
      r[s] = $n(i, s) ? t(i[s], i) : "";
  }
  var u = typeof Ka == "function" ? Ka(i) : [], h;
  if (yr) {
    h = {};
    for (var f = 0; f < u.length; f++)
      h["$" + u[f]] = u[f];
  }
  for (var g in i)
    $n(i, g) && (e && String(Number(g)) === g && g < i.length || yr && h["$" + g] instanceof Symbol || (Xd.call(/[^\w$]/, g) ? r.push(t(g, i) + ": " + t(i[g], i)) : r.push(g + ": " + t(i[g], i))));
  if (typeof Ka == "function")
    for (var y = 0; y < u.length; y++)
      qd.call(i, u[y]) && r.push("[" + t(u[y]) + "]: " + t(i[u[y]], i));
  return r;
}
var Zd = ln, kr = Pe, Wx = Cx, Ux = ri, Qs = Zd("%WeakMap%", !0), to = Zd("%Map%", !0), jx = kr("WeakMap.prototype.get", !0), Vx = kr("WeakMap.prototype.set", !0), Zx = kr("WeakMap.prototype.has", !0), Hx = kr("Map.prototype.get", !0), Jx = kr("Map.prototype.set", !0), Kx = kr("Map.prototype.has", !0), Fl = function(i, t) {
  for (var e = i, r; (r = e.next) !== null; e = r)
    if (r.key === t)
      return e.next = r.next, r.next = /** @type {NonNullable<typeof list.next>} */
      i.next, i.next = r, r;
}, Qx = function(i, t) {
  var e = Fl(i, t);
  return e && e.value;
}, tE = function(i, t, e) {
  var r = Fl(i, t);
  r ? r.value = e : i.next = /** @type {import('.').ListNode<typeof value>} */
  {
    // eslint-disable-line no-param-reassign, no-extra-parens
    key: t,
    next: i.next,
    value: e
  };
}, eE = function(i, t) {
  return !!Fl(i, t);
}, Hd = function() {
  var t, e, r, s = {
    assert: function(u) {
      if (!s.has(u))
        throw new Ux("Side channel does not contain " + Wx(u));
    },
    get: function(u) {
      if (Qs && u && (typeof u == "object" || typeof u == "function")) {
        if (t)
          return jx(t, u);
      } else if (to) {
        if (e)
          return Hx(e, u);
      } else if (r)
        return Qx(r, u);
    },
    has: function(u) {
      if (Qs && u && (typeof u == "object" || typeof u == "function")) {
        if (t)
          return Zx(t, u);
      } else if (to) {
        if (e)
          return Kx(e, u);
      } else if (r)
        return eE(r, u);
      return !1;
    },
    set: function(u, h) {
      Qs && u && (typeof u == "object" || typeof u == "function") ? (t || (t = new Qs()), Vx(t, u, h)) : to ? (e || (e = new to()), Jx(e, u, h)) : (r || (r = { key: {}, next: null }), tE(r, u, h));
    }
  };
  return s;
}, nE = Id, Ur = Hd(), vn = ri, Gl = {
  assert: function(i, t) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new vn("`O` is not an object");
    if (typeof t != "string")
      throw new vn("`slot` must be a string");
    if (Ur.assert(i), !Gl.has(i, t))
      throw new vn("`" + t + "` is not present on `O`");
  },
  get: function(i, t) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new vn("`O` is not an object");
    if (typeof t != "string")
      throw new vn("`slot` must be a string");
    var e = Ur.get(i);
    return e && e["$" + t];
  },
  has: function(i, t) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new vn("`O` is not an object");
    if (typeof t != "string")
      throw new vn("`slot` must be a string");
    var e = Ur.get(i);
    return !!e && nE(e, "$" + t);
  },
  set: function(i, t, e) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new vn("`O` is not an object");
    if (typeof t != "string")
      throw new vn("`slot` must be a string");
    var r = Ur.get(i);
    r || (r = {}, Ur.set(i, r)), r["$" + t] = e;
  }
};
Object.freeze && Object.freeze(Gl);
var iE = Gl, jr = iE, rE = SyntaxError, Qc = typeof StopIteration == "object" ? StopIteration : null, sE = function(t) {
  if (!Qc)
    throw new rE("this environment lacks StopIteration");
  jr.set(t, "[[Done]]", !1);
  var e = {
    next: function() {
      var s = jr.get(this, "[[Iterator]]"), u = jr.get(s, "[[Done]]");
      try {
        return {
          done: u,
          value: u ? void 0 : s.next()
        };
      } catch (h) {
        if (jr.set(s, "[[Done]]", !0), h !== Qc)
          throw h;
        return {
          done: !0,
          value: void 0
        };
      }
    }
  };
  return jr.set(e, "[[Iterator]]", t), e;
}, oE = {}.toString, Jd = Array.isArray || function(i) {
  return oE.call(i) == "[object Array]";
}, aE = String.prototype.valueOf, uE = function(t) {
  try {
    return aE.call(t), !0;
  } catch {
    return !1;
  }
}, lE = Object.prototype.toString, hE = "[object String]", cE = Di(), Kd = function(t) {
  return typeof t == "string" ? !0 : typeof t != "object" ? !1 : cE ? uE(t) : lE.call(t) === hE;
}, Bl = typeof Map == "function" && Map.prototype ? Map : null, fE = typeof Set == "function" && Set.prototype ? Set : null, Oo;
Bl || (Oo = function(t) {
  return !1;
});
var Qd = Bl ? Map.prototype.has : null, tf = fE ? Set.prototype.has : null;
!Oo && !Qd && (Oo = function(t) {
  return !1;
});
var ty = Oo || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (Qd.call(t), tf)
      try {
        tf.call(t);
      } catch {
        return !0;
      }
    return t instanceof Bl;
  } catch {
  }
  return !1;
}, gE = typeof Map == "function" && Map.prototype ? Map : null, Yl = typeof Set == "function" && Set.prototype ? Set : null, Lo;
Yl || (Lo = function(t) {
  return !1;
});
var ef = gE ? Map.prototype.has : null, ey = Yl ? Set.prototype.has : null;
!Lo && !ey && (Lo = function(t) {
  return !1;
});
var ny = Lo || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (ey.call(t), ef)
      try {
        ef.call(t);
      } catch {
        return !0;
      }
    return t instanceof Yl;
  } catch {
  }
  return !1;
}, nf = $d, rf = sE;
if (bl() || la()) {
  var tu = Symbol.iterator;
  lo.exports = function(t) {
    if (t != null && typeof t[tu] < "u")
      return t[tu]();
    if (nf(t))
      return Array.prototype[tu].call(t);
  };
} else {
  var dE = Jd, yE = Kd, sf = ln, pE = sf("%Map%", !0), mE = sf("%Set%", !0), Xe = Pe, of = Xe("Array.prototype.push"), af = Xe("String.prototype.charCodeAt"), vE = Xe("String.prototype.slice"), _E = function(t, e) {
    var r = t.length;
    if (e + 1 >= r)
      return e + 1;
    var s = af(t, e);
    if (s < 55296 || s > 56319)
      return e + 1;
    var u = af(t, e + 1);
    return u < 56320 || u > 57343 ? e + 1 : e + 2;
  }, eu = function(t) {
    var e = 0;
    return {
      next: function() {
        var s = e >= t.length, u;
        return s || (u = t[e], e += 1), {
          done: s,
          value: u
        };
      }
    };
  }, uf = function(t, e) {
    if (dE(t) || nf(t))
      return eu(t);
    if (yE(t)) {
      var r = 0;
      return {
        next: function() {
          var u = _E(t, r), h = vE(t, r, u);
          return r = u, {
            done: u > t.length,
            value: h
          };
        }
      };
    }
    if (e && typeof t["_es6-shim iterator_"] < "u")
      return t["_es6-shim iterator_"]();
  };
  if (!pE && !mE)
    lo.exports = function(t) {
      if (t != null)
        return uf(t, !0);
    };
  else {
    var xE = ty, EE = ny, lf = Xe("Map.prototype.forEach", !0), hf = Xe("Set.prototype.forEach", !0);
    if (typeof process > "u" || !process.versions || !process.versions.node)
      var cf = Xe("Map.prototype.iterator", !0), ff = Xe("Set.prototype.iterator", !0);
    var gf = Xe("Map.prototype.@@iterator", !0) || Xe("Map.prototype._es6-shim iterator_", !0), df = Xe("Set.prototype.@@iterator", !0) || Xe("Set.prototype._es6-shim iterator_", !0), SE = function(t) {
      if (xE(t)) {
        if (cf)
          return rf(cf(t));
        if (gf)
          return gf(t);
        if (lf) {
          var e = [];
          return lf(t, function(s, u) {
            of(e, [u, s]);
          }), eu(e);
        }
      }
      if (EE(t)) {
        if (ff)
          return rf(ff(t));
        if (df)
          return df(t);
        if (hf) {
          var r = [];
          return hf(t, function(s) {
            of(r, s);
          }), eu(r);
        }
      }
    };
    lo.exports = function(t) {
      return SE(t) || uf(t);
    };
  }
}
var IE = lo.exports, yf = function(i) {
  return i !== i;
}, iy = function(t, e) {
  return t === 0 && e === 0 ? 1 / t === 1 / e : !!(t === e || yf(t) && yf(e));
}, wE = iy, ry = function() {
  return typeof Object.is == "function" ? Object.is : wE;
}, kE = ry, CE = Pi, RE = function() {
  var t = kE();
  return CE(Object, { is: t }, {
    is: function() {
      return Object.is !== t;
    }
  }), t;
}, bE = Pi, TE = wr, NE = iy, sy = ry, ME = RE, oy = TE(sy(), Object);
bE(oy, {
  getPolyfill: sy,
  implementation: NE,
  shim: ME
});
var OE = oy, LE = wr, ay = Pe, AE = ln, Au = AE("%ArrayBuffer%", !0), ho = ay("ArrayBuffer.prototype.byteLength", !0), PE = ay("Object.prototype.toString"), pf = !!Au && !ho && new Au(0).slice, mf = !!pf && LE(pf), uy = ho || mf ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    return ho ? ho(t) : mf(t, 0), !0;
  } catch {
    return !1;
  }
} : Au ? function(t) {
  return PE(t) === "[object ArrayBuffer]";
} : function(t) {
  return !1;
}, DE = Date.prototype.getDay, FE = function(t) {
  try {
    return DE.call(t), !0;
  } catch {
    return !1;
  }
}, GE = Object.prototype.toString, BE = "[object Date]", YE = Di(), zE = function(t) {
  return typeof t != "object" || t === null ? !1 : YE ? FE(t) : GE.call(t) === BE;
}, Pu = Pe, ly = Di(), hy, cy, Du, Fu;
if (ly) {
  hy = Pu("Object.prototype.hasOwnProperty"), cy = Pu("RegExp.prototype.exec"), Du = {};
  var nu = function() {
    throw Du;
  };
  Fu = {
    toString: nu,
    valueOf: nu
  }, typeof Symbol.toPrimitive == "symbol" && (Fu[Symbol.toPrimitive] = nu);
}
var $E = Pu("Object.prototype.toString"), XE = Object.getOwnPropertyDescriptor, qE = "[object RegExp]", WE = ly ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  var e = XE(t, "lastIndex"), r = e && hy(e, "value");
  if (!r)
    return !1;
  try {
    cy(t, Fu);
  } catch (s) {
    return s === Du;
  }
} : function(t) {
  return !t || typeof t != "object" && typeof t != "function" ? !1 : $E(t) === qE;
}, UE = Pe, vf = UE("SharedArrayBuffer.prototype.byteLength", !0), jE = vf ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    return vf(t), !0;
  } catch {
    return !1;
  }
} : function(t) {
  return !1;
}, VE = Number.prototype.toString, ZE = function(t) {
  try {
    return VE.call(t), !0;
  } catch {
    return !1;
  }
}, HE = Object.prototype.toString, JE = "[object Number]", KE = Di(), QE = function(t) {
  return typeof t == "number" ? !0 : typeof t != "object" ? !1 : KE ? ZE(t) : HE.call(t) === JE;
}, fy = Pe, tS = fy("Boolean.prototype.toString"), eS = fy("Object.prototype.toString"), nS = function(t) {
  try {
    return tS(t), !0;
  } catch {
    return !1;
  }
}, iS = "[object Boolean]", rS = Di(), sS = function(t) {
  return typeof t == "boolean" ? !0 : t === null || typeof t != "object" ? !1 : rS && Symbol.toStringTag in t ? nS(t) : eS(t) === iS;
}, Gu = { exports: {} }, oS = Object.prototype.toString, aS = bl();
if (aS) {
  var uS = Symbol.prototype.toString, lS = /^Symbol\(.*\)$/, hS = function(t) {
    return typeof t.valueOf() != "symbol" ? !1 : lS.test(uS.call(t));
  };
  Gu.exports = function(t) {
    if (typeof t == "symbol")
      return !0;
    if (oS.call(t) !== "[object Symbol]")
      return !1;
    try {
      return hS(t);
    } catch {
      return !1;
    }
  };
} else
  Gu.exports = function(t) {
    return !1;
  };
var cS = Gu.exports, Bu = { exports: {} }, _f = typeof BigInt < "u" && BigInt, fS = function() {
  return typeof _f == "function" && typeof BigInt == "function" && typeof _f(42) == "bigint" && typeof BigInt(42) == "bigint";
}, gS = fS();
if (gS) {
  var dS = BigInt.prototype.valueOf, yS = function(t) {
    try {
      return dS.call(t), !0;
    } catch {
    }
    return !1;
  };
  Bu.exports = function(t) {
    return t === null || typeof t > "u" || typeof t == "boolean" || typeof t == "string" || typeof t == "number" || typeof t == "symbol" || typeof t == "function" ? !1 : typeof t == "bigint" ? !0 : yS(t);
  };
} else
  Bu.exports = function(t) {
    return !1;
  };
var pS = Bu.exports, mS = Kd, vS = QE, _S = sS, xS = cS, ES = pS, SS = function(t) {
  if (t == null || typeof t != "object" && typeof t != "function")
    return null;
  if (mS(t))
    return "String";
  if (vS(t))
    return "Number";
  if (_S(t))
    return "Boolean";
  if (xS(t))
    return "Symbol";
  if (ES(t))
    return "BigInt";
}, Ao = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap : null, xf = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet : null, Po;
Ao || (Po = function(t) {
  return !1;
});
var Yu = Ao ? Ao.prototype.has : null, iu = xf ? xf.prototype.has : null;
!Po && !Yu && (Po = function(t) {
  return !1;
});
var IS = Po || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (Yu.call(t, Yu), iu)
      try {
        iu.call(t, iu);
      } catch {
        return !0;
      }
    return t instanceof Ao;
  } catch {
  }
  return !1;
}, zu = { exports: {} }, wS = ln, gy = Pe, kS = wS("%WeakSet%", !0), ru = gy("WeakSet.prototype.has", !0);
if (ru) {
  var su = gy("WeakMap.prototype.has", !0);
  zu.exports = function(t) {
    if (!t || typeof t != "object")
      return !1;
    try {
      if (ru(t, ru), su)
        try {
          su(t, su);
        } catch {
          return !0;
        }
      return t instanceof kS;
    } catch {
    }
    return !1;
  };
} else
  zu.exports = function(t) {
    return !1;
  };
var CS = zu.exports, RS = ty, bS = ny, TS = IS, NS = CS, MS = function(t) {
  if (t && typeof t == "object") {
    if (RS(t))
      return "Map";
    if (bS(t))
      return "Set";
    if (TS(t))
      return "WeakMap";
    if (NS(t))
      return "WeakSet";
  }
  return !1;
}, dy = Function.prototype.toString, ar = typeof Reflect == "object" && Reflect !== null && Reflect.apply, $u, co;
if (typeof ar == "function" && typeof Object.defineProperty == "function")
  try {
    $u = Object.defineProperty({}, "length", {
      get: function() {
        throw co;
      }
    }), co = {}, ar(function() {
      throw 42;
    }, null, $u);
  } catch (i) {
    i !== co && (ar = null);
  }
else
  ar = null;
var OS = /^\s*class\b/, Xu = function(t) {
  try {
    var e = dy.call(t);
    return OS.test(e);
  } catch {
    return !1;
  }
}, ou = function(t) {
  try {
    return Xu(t) ? !1 : (dy.call(t), !0);
  } catch {
    return !1;
  }
}, fo = Object.prototype.toString, LS = "[object Object]", AS = "[object Function]", PS = "[object GeneratorFunction]", DS = "[object HTMLAllCollection]", FS = "[object HTML document.all class]", GS = "[object HTMLCollection]", BS = typeof Symbol == "function" && !!Symbol.toStringTag, YS = !(0 in [,]), qu = function() {
  return !1;
};
if (typeof document == "object") {
  var zS = document.all;
  fo.call(zS) === fo.call(document.all) && (qu = function(t) {
    if ((YS || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var e = fo.call(t);
        return (e === DS || e === FS || e === GS || e === LS) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var $S = ar ? function(t) {
  if (qu(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    ar(t, null, $u);
  } catch (e) {
    if (e !== co)
      return !1;
  }
  return !Xu(t) && ou(t);
} : function(t) {
  if (qu(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (BS)
    return ou(t);
  if (Xu(t))
    return !1;
  var e = fo.call(t);
  return e !== AS && e !== PS && !/^\[object HTML/.test(e) ? !1 : ou(t);
}, XS = $S, qS = Object.prototype.toString, yy = Object.prototype.hasOwnProperty, WS = function(t, e, r) {
  for (var s = 0, u = t.length; s < u; s++)
    yy.call(t, s) && (r == null ? e(t[s], s, t) : e.call(r, t[s], s, t));
}, US = function(t, e, r) {
  for (var s = 0, u = t.length; s < u; s++)
    r == null ? e(t.charAt(s), s, t) : e.call(r, t.charAt(s), s, t);
}, jS = function(t, e, r) {
  for (var s in t)
    yy.call(t, s) && (r == null ? e(t[s], s, t) : e.call(r, t[s], s, t));
}, VS = function(t, e, r) {
  if (!XS(e))
    throw new TypeError("iterator must be a function");
  var s;
  arguments.length >= 3 && (s = r), qS.call(t) === "[object Array]" ? WS(t, e, s) : typeof t == "string" ? US(t, e, s) : jS(t, e, s);
}, ZS = VS, HS = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], au = HS, JS = typeof globalThis > "u" ? ua : globalThis, KS = function() {
  for (var t = [], e = 0; e < au.length; e++)
    typeof JS[au[e]] == "function" && (t[t.length] = au[e]);
  return t;
}, Do = ZS, QS = KS, Ef = wr, zl = Pe, go = Ml, tI = zl("Object.prototype.toString"), py = Di(), Sf = typeof globalThis > "u" ? ua : globalThis, Wu = QS(), $l = zl("String.prototype.slice"), uu = Object.getPrototypeOf, eI = zl("Array.prototype.indexOf", !0) || function(t, e) {
  for (var r = 0; r < t.length; r += 1)
    if (t[r] === e)
      return r;
  return -1;
}, Fo = { __proto__: null };
py && go && uu ? Do(Wu, function(i) {
  var t = new Sf[i]();
  if (Symbol.toStringTag in t) {
    var e = uu(t), r = go(e, Symbol.toStringTag);
    if (!r) {
      var s = uu(e);
      r = go(s, Symbol.toStringTag);
    }
    Fo["$" + i] = Ef(r.get);
  }
}) : Do(Wu, function(i) {
  var t = new Sf[i](), e = t.slice || t.set;
  e && (Fo["$" + i] = Ef(e));
});
var nI = function(t) {
  var e = !1;
  return Do(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    Fo,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, s) {
      if (!e)
        try {
          "$" + r(t) === s && (e = $l(s, 1));
        } catch {
        }
    }
  ), e;
}, iI = function(t) {
  var e = !1;
  return Do(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    Fo,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, s) {
      if (!e)
        try {
          r(t), e = $l(s, 1);
        } catch {
        }
    }
  ), e;
}, rI = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!py) {
    var e = $l(tI(t), 8, -1);
    return eI(Wu, e) > -1 ? e : e !== "Object" ? !1 : iI(t);
  }
  return go ? nI(t) : null;
}, sI = Pe, If = sI("ArrayBuffer.prototype.byteLength", !0), oI = uy, aI = function(t) {
  return oI(t) ? If ? If(t) : t.byteLength : NaN;
}, my = B1, hn = Pe, wf = lx, uI = ln, pr = IE, lI = Hd, kf = OE, Cf = $d, Rf = Jd, bf = uy, Tf = zE, Nf = WE, Mf = jE, Of = Rl, Lf = SS, Af = MS, Pf = rI, Df = aI, Ff = hn("SharedArrayBuffer.prototype.byteLength", !0), Gf = hn("Date.prototype.getTime"), lu = Object.getPrototypeOf, Bf = hn("Object.prototype.toString"), Go = uI("%Set%", !0), Uu = hn("Map.prototype.has", !0), Bo = hn("Map.prototype.get", !0), Yf = hn("Map.prototype.size", !0), Yo = hn("Set.prototype.add", !0), vy = hn("Set.prototype.delete", !0), zo = hn("Set.prototype.has", !0), yo = hn("Set.prototype.size", !0);
function zf(i, t, e, r) {
  for (var s = pr(i), u; (u = s.next()) && !u.done; )
    if (je(t, u.value, e, r))
      return vy(i, u.value), !0;
  return !1;
}
function _y(i) {
  if (typeof i > "u")
    return null;
  if (typeof i != "object")
    return typeof i == "symbol" ? !1 : typeof i == "string" || typeof i == "number" ? +i == +i : !0;
}
function hI(i, t, e, r, s, u) {
  var h = _y(e);
  if (h != null)
    return h;
  var f = Bo(t, h), g = my({}, s, { strict: !1 });
  return typeof f > "u" && !Uu(t, h) || !je(r, f, g, u) ? !1 : !Uu(i, h) && je(r, f, g, u);
}
function cI(i, t, e) {
  var r = _y(e);
  return r ?? (zo(t, r) && !zo(i, r));
}
function $f(i, t, e, r, s, u) {
  for (var h = pr(i), f, g; (f = h.next()) && !f.done; )
    if (g = f.value, // eslint-disable-next-line no-use-before-define
    je(e, g, s, u) && je(r, Bo(t, g), s, u))
      return vy(i, g), !0;
  return !1;
}
function je(i, t, e, r) {
  var s = e || {};
  if (s.strict ? kf(i, t) : i === t)
    return !0;
  var u = Lf(i), h = Lf(t);
  if (u !== h)
    return !1;
  if (!i || !t || typeof i != "object" && typeof t != "object")
    return s.strict ? kf(i, t) : i == t;
  var f = r.has(i), g = r.has(t), y;
  if (f && g) {
    if (r.get(i) === r.get(t))
      return !0;
  } else
    y = {};
  return f || r.set(i, y), g || r.set(t, y), dI(i, t, s, r);
}
function Xf(i) {
  return !i || typeof i != "object" || typeof i.length != "number" || typeof i.copy != "function" || typeof i.slice != "function" || i.length > 0 && typeof i[0] != "number" ? !1 : !!(i.constructor && i.constructor.isBuffer && i.constructor.isBuffer(i));
}
function fI(i, t, e, r) {
  if (yo(i) !== yo(t))
    return !1;
  for (var s = pr(i), u = pr(t), h, f, g; (h = s.next()) && !h.done; )
    if (h.value && typeof h.value == "object")
      g || (g = new Go()), Yo(g, h.value);
    else if (!zo(t, h.value)) {
      if (e.strict || !cI(i, t, h.value))
        return !1;
      g || (g = new Go()), Yo(g, h.value);
    }
  if (g) {
    for (; (f = u.next()) && !f.done; )
      if (f.value && typeof f.value == "object") {
        if (!zf(g, f.value, e.strict, r))
          return !1;
      } else if (!e.strict && !zo(i, f.value) && !zf(g, f.value, e.strict, r))
        return !1;
    return yo(g) === 0;
  }
  return !0;
}
function gI(i, t, e, r) {
  if (Yf(i) !== Yf(t))
    return !1;
  for (var s = pr(i), u = pr(t), h, f, g, y, p, m; (h = s.next()) && !h.done; )
    if (y = h.value[0], p = h.value[1], y && typeof y == "object")
      g || (g = new Go()), Yo(g, y);
    else if (m = Bo(t, y), typeof m > "u" && !Uu(t, y) || !je(p, m, e, r)) {
      if (e.strict || !hI(i, t, y, p, e, r))
        return !1;
      g || (g = new Go()), Yo(g, y);
    }
  if (g) {
    for (; (f = u.next()) && !f.done; )
      if (y = f.value[0], m = f.value[1], y && typeof y == "object") {
        if (!$f(g, i, y, m, e, r))
          return !1;
      } else if (!e.strict && (!i.has(y) || !je(Bo(i, y), m, e, r)) && !$f(g, i, y, m, my({}, e, { strict: !1 }), r))
        return !1;
    return yo(g) === 0;
  }
  return !0;
}
function dI(i, t, e, r) {
  var s, u;
  if (typeof i != typeof t || i == null || t == null || Bf(i) !== Bf(t) || Cf(i) !== Cf(t))
    return !1;
  var h = Rf(i), f = Rf(t);
  if (h !== f)
    return !1;
  var g = i instanceof Error, y = t instanceof Error;
  if (g !== y || (g || y) && (i.name !== t.name || i.message !== t.message))
    return !1;
  var p = Nf(i), m = Nf(t);
  if (p !== m || (p || m) && (i.source !== t.source || wf(i) !== wf(t)))
    return !1;
  var _ = Tf(i), x = Tf(t);
  if (_ !== x || (_ || x) && Gf(i) !== Gf(t) || e.strict && lu && lu(i) !== lu(t))
    return !1;
  var I = Pf(i), k = Pf(t);
  if (I !== k)
    return !1;
  if (I || k) {
    if (i.length !== t.length)
      return !1;
    for (s = 0; s < i.length; s++)
      if (i[s] !== t[s])
        return !1;
    return !0;
  }
  var C = Xf(i), R = Xf(t);
  if (C !== R)
    return !1;
  if (C || R) {
    if (i.length !== t.length)
      return !1;
    for (s = 0; s < i.length; s++)
      if (i[s] !== t[s])
        return !1;
    return !0;
  }
  var b = bf(i), O = bf(t);
  if (b !== O)
    return !1;
  if (b || O)
    return Df(i) !== Df(t) ? !1 : typeof Uint8Array == "function" && je(new Uint8Array(i), new Uint8Array(t), e, r);
  var A = Mf(i), L = Mf(t);
  if (A !== L)
    return !1;
  if (A || L)
    return Ff(i) !== Ff(t) ? !1 : typeof Uint8Array == "function" && je(new Uint8Array(i), new Uint8Array(t), e, r);
  if (typeof i != typeof t)
    return !1;
  var D = Of(i), F = Of(t);
  if (D.length !== F.length)
    return !1;
  for (D.sort(), F.sort(), s = D.length - 1; s >= 0; s--)
    if (D[s] != F[s])
      return !1;
  for (s = D.length - 1; s >= 0; s--)
    if (u = D[s], !je(i[u], t[u], e, r))
      return !1;
  var G = Af(i), B = Af(t);
  return G !== B ? !1 : G === "Set" || B === "Set" ? fI(i, t, e, r) : G === "Map" ? gI(i, t, e, r) : !0;
}
var yI = function(t, e, r) {
  return je(t, e, r, lI());
};
const pI = /* @__PURE__ */ xd(yI);
var mI = Object.defineProperty, Rt = (i, t) => mI(i, "name", { value: t, configurable: !0 }), vI = class {
  constructor(t) {
    this.direction = !1, this.compareProperties = !0;
    var e, r, s;
    this.precision = 10 ** -((e = t == null ? void 0 : t.precision) != null ? e : 17), this.direction = (r = t == null ? void 0 : t.direction) != null ? r : !1, this.compareProperties = (s = t == null ? void 0 : t.compareProperties) != null ? s : !0;
  }
  compare(t, e) {
    if (t.type !== e.type || !Qr(t, e))
      return !1;
    switch (t.type) {
      case "Point":
        return this.compareCoord(t.coordinates, e.coordinates);
      case "LineString":
        return this.compareLine(t.coordinates, e.coordinates);
      case "Polygon":
        return this.comparePolygon(t, e);
      case "GeometryCollection":
        return this.compareGeometryCollection(t, e);
      case "Feature":
        return this.compareFeature(t, e);
      case "FeatureCollection":
        return this.compareFeatureCollection(t, e);
      default:
        if (t.type.startsWith("Multi")) {
          const r = ju(t), s = ju(
            e
          );
          return r.every(
            (u) => s.some((h) => this.compare(u, h))
          );
        }
    }
    return !1;
  }
  compareCoord(t, e) {
    return t.length === e.length && t.every((r, s) => Math.abs(r - e[s]) < this.precision);
  }
  compareLine(t, e, r = 0, s = !1) {
    if (!Qr(t, e))
      return !1;
    const u = t;
    let h = e;
    if (s && !this.compareCoord(u[0], h[0])) {
      const g = this.fixStartIndex(h, u);
      if (g)
        h = g;
      else
        return !1;
    }
    const f = this.compareCoord(u[r], h[r]);
    return this.direction || f ? this.comparePath(u, h) : this.compareCoord(u[r], h[h.length - (1 + r)]) ? this.comparePath(u.slice().reverse(), h) : !1;
  }
  fixStartIndex(t, e) {
    let r, s = -1;
    for (let u = 0; u < t.length; u++)
      if (this.compareCoord(t[u], e[0])) {
        s = u;
        break;
      }
    return s >= 0 && (r = [].concat(
      t.slice(s, t.length),
      t.slice(1, s + 1)
    )), r;
  }
  comparePath(t, e) {
    return t.every((r, s) => this.compareCoord(r, e[s]));
  }
  comparePolygon(t, e) {
    if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) {
      const r = t.coordinates.slice(1, t.coordinates.length), s = e.coordinates.slice(1, e.coordinates.length);
      return r.every(
        (u) => s.some((h) => this.compareLine(u, h, 1, !0))
      );
    }
    return !1;
  }
  compareGeometryCollection(t, e) {
    return Qr(t.geometries, e.geometries) && this.compareBBox(t, e) && t.geometries.every((r, s) => this.compare(r, e.geometries[s]));
  }
  compareFeature(t, e) {
    return t.id === e.id && (this.compareProperties ? pI(t.properties, e.properties) : !0) && this.compareBBox(t, e) && this.compare(t.geometry, e.geometry);
  }
  compareFeatureCollection(t, e) {
    return Qr(t.features, e.features) && this.compareBBox(t, e) && t.features.every((r, s) => this.compare(r, e.features[s]));
  }
  compareBBox(t, e) {
    return !t.bbox && !e.bbox || (t.bbox && e.bbox ? this.compareCoord(t.bbox, e.bbox) : !1);
  }
};
Rt(vI, "GeojsonEquality");
function Qr(i, t) {
  return i.coordinates ? i.coordinates.length === t.coordinates.length : i.length === t.length;
}
Rt(Qr, "sameLength");
function ju(i) {
  return i.coordinates.map((t) => ({
    type: i.type.replace("Multi", ""),
    coordinates: t
  }));
}
Rt(ju, "explode");
var ue = 63710088e-1, xy = {
  centimeters: ue * 100,
  centimetres: ue * 100,
  degrees: 360 / (2 * Math.PI),
  feet: ue * 3.28084,
  inches: ue * 39.37,
  kilometers: ue / 1e3,
  kilometres: ue / 1e3,
  meters: ue,
  metres: ue,
  miles: ue / 1609.344,
  millimeters: ue * 1e3,
  millimetres: ue * 1e3,
  nauticalmiles: ue / 1852,
  radians: 1,
  yards: ue * 1.0936
}, qf = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  nauticalmiles: 29155334959812285e-23,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function Ze(i, t, e = {}) {
  const r = { type: "Feature" };
  return (e.id === 0 || e.id) && (r.id = e.id), e.bbox && (r.bbox = e.bbox), r.properties = t || {}, r.geometry = i, r;
}
Rt(Ze, "feature");
function _I(i, t, e = {}) {
  switch (i) {
    case "Point":
      return en(t).geometry;
    case "LineString":
      return xn(t).geometry;
    case "Polygon":
      return Os(t).geometry;
    case "MultiPoint":
      return Sy(t).geometry;
    case "MultiLineString":
      return Ey(t).geometry;
    case "MultiPolygon":
      return Xl(t).geometry;
    default:
      throw new Error(i + " is invalid");
  }
}
Rt(_I, "geometry");
function en(i, t, e = {}) {
  if (!i)
    throw new Error("coordinates is required");
  if (!Array.isArray(i))
    throw new Error("coordinates must be an Array");
  if (i.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!$o(i[0]) || !$o(i[1]))
    throw new Error("coordinates must contain numbers");
  return Ze({
    type: "Point",
    coordinates: i
  }, t, e);
}
Rt(en, "point");
function xI(i, t, e = {}) {
  return bn(
    i.map((r) => en(r, t)),
    e
  );
}
Rt(xI, "points");
function Os(i, t, e = {}) {
  for (const s of i) {
    if (s.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (s[s.length - 1].length !== s[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let u = 0; u < s[s.length - 1].length; u++)
      if (s[s.length - 1][u] !== s[0][u])
        throw new Error("First and last Position are not equivalent.");
  }
  return Ze({
    type: "Polygon",
    coordinates: i
  }, t, e);
}
Rt(Os, "polygon");
function EI(i, t, e = {}) {
  return bn(
    i.map((r) => Os(r, t)),
    e
  );
}
Rt(EI, "polygons");
function xn(i, t, e = {}) {
  if (i.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return Ze({
    type: "LineString",
    coordinates: i
  }, t, e);
}
Rt(xn, "lineString");
function SI(i, t, e = {}) {
  return bn(
    i.map((r) => xn(r, t)),
    e
  );
}
Rt(SI, "lineStrings");
function bn(i, t = {}) {
  const e = { type: "FeatureCollection" };
  return t.id && (e.id = t.id), t.bbox && (e.bbox = t.bbox), e.features = i, e;
}
Rt(bn, "featureCollection");
function Ey(i, t, e = {}) {
  return Ze({
    type: "MultiLineString",
    coordinates: i
  }, t, e);
}
Rt(Ey, "multiLineString");
function Sy(i, t, e = {}) {
  return Ze({
    type: "MultiPoint",
    coordinates: i
  }, t, e);
}
Rt(Sy, "multiPoint");
function Xl(i, t, e = {}) {
  return Ze({
    type: "MultiPolygon",
    coordinates: i
  }, t, e);
}
Rt(Xl, "multiPolygon");
function II(i, t, e = {}) {
  return Ze({
    type: "GeometryCollection",
    geometries: i
  }, t, e);
}
Rt(II, "geometryCollection");
function wI(i, t = 0) {
  if (t && !(t >= 0))
    throw new Error("precision must be a positive number");
  const e = Math.pow(10, t || 0);
  return Math.round(i * e) / e;
}
Rt(wI, "round");
function ql(i, t = "kilometers") {
  const e = xy[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return i * e;
}
Rt(ql, "radiansToLength");
function ca(i, t = "kilometers") {
  const e = xy[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return i / e;
}
Rt(ca, "lengthToRadians");
function kI(i, t) {
  return Iy(ca(i, t));
}
Rt(kI, "lengthToDegrees");
function CI(i) {
  let t = i % 360;
  return t < 0 && (t += 360), t;
}
Rt(CI, "bearingToAzimuth");
function Iy(i) {
  return i % (2 * Math.PI) * 180 / Math.PI;
}
Rt(Iy, "radiansToDegrees");
function RI(i) {
  return i % 360 * Math.PI / 180;
}
Rt(RI, "degreesToRadians");
function bI(i, t = "kilometers", e = "kilometers") {
  if (!(i >= 0))
    throw new Error("length must be a positive number");
  return ql(ca(i, t), e);
}
Rt(bI, "convertLength");
function TI(i, t = "meters", e = "kilometers") {
  if (!(i >= 0))
    throw new Error("area must be a positive number");
  const r = qf[t];
  if (!r)
    throw new Error("invalid original units");
  const s = qf[e];
  if (!s)
    throw new Error("invalid final units");
  return i / r * s;
}
Rt(TI, "convertArea");
function $o(i) {
  return !isNaN(i) && i !== null && !Array.isArray(i);
}
Rt($o, "isNumber");
function Wl(i) {
  return i !== null && typeof i == "object" && !Array.isArray(i);
}
Rt(Wl, "isObject");
function NI(i) {
  if (!i)
    throw new Error("bbox is required");
  if (!Array.isArray(i))
    throw new Error("bbox must be an Array");
  if (i.length !== 4 && i.length !== 6)
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  i.forEach((t) => {
    if (!$o(t))
      throw new Error("bbox must only contain numbers");
  });
}
Rt(NI, "validateBBox");
function MI(i) {
  if (!i)
    throw new Error("id is required");
  if (["string", "number"].indexOf(typeof i) === -1)
    throw new Error("id must be a number or a string");
}
Rt(MI, "validateId");
var OI = Object.defineProperty, Zt = (i, t) => OI(i, "name", { value: t, configurable: !0 });
function Cr(i, t, e) {
  if (i !== null)
    for (var r, s, u, h, f, g, y, p = 0, m = 0, _, x = i.type, I = x === "FeatureCollection", k = x === "Feature", C = I ? i.features.length : 1, R = 0; R < C; R++) {
      y = I ? i.features[R].geometry : k ? i.geometry : i, _ = y ? y.type === "GeometryCollection" : !1, f = _ ? y.geometries.length : 1;
      for (var b = 0; b < f; b++) {
        var O = 0, A = 0;
        if (h = _ ? y.geometries[b] : y, h !== null) {
          g = h.coordinates;
          var L = h.type;
          switch (p = e && (L === "Polygon" || L === "MultiPolygon") ? 1 : 0, L) {
            case null:
              break;
            case "Point":
              if (t(
                g,
                m,
                R,
                O,
                A
              ) === !1)
                return !1;
              m++, O++;
              break;
            case "LineString":
            case "MultiPoint":
              for (r = 0; r < g.length; r++) {
                if (t(
                  g[r],
                  m,
                  R,
                  O,
                  A
                ) === !1)
                  return !1;
                m++, L === "MultiPoint" && O++;
              }
              L === "LineString" && O++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (r = 0; r < g.length; r++) {
                for (s = 0; s < g[r].length - p; s++) {
                  if (t(
                    g[r][s],
                    m,
                    R,
                    O,
                    A
                  ) === !1)
                    return !1;
                  m++;
                }
                L === "MultiLineString" && O++, L === "Polygon" && A++;
              }
              L === "Polygon" && O++;
              break;
            case "MultiPolygon":
              for (r = 0; r < g.length; r++) {
                for (A = 0, s = 0; s < g[r].length; s++) {
                  for (u = 0; u < g[r][s].length - p; u++) {
                    if (t(
                      g[r][s][u],
                      m,
                      R,
                      O,
                      A
                    ) === !1)
                      return !1;
                    m++;
                  }
                  A++;
                }
                O++;
              }
              break;
            case "GeometryCollection":
              for (r = 0; r < h.geometries.length; r++)
                if (Cr(h.geometries[r], t, e) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
Zt(Cr, "coordEach");
function LI(i, t, e, r) {
  var s = e;
  return Cr(
    i,
    function(u, h, f, g, y) {
      h === 0 && e === void 0 ? s = u : s = t(
        s,
        u,
        h,
        f,
        g,
        y
      );
    },
    r
  ), s;
}
Zt(LI, "coordReduce");
function wy(i, t) {
  var e;
  switch (i.type) {
    case "FeatureCollection":
      for (e = 0; e < i.features.length && t(i.features[e].properties, e) !== !1; e++)
        ;
      break;
    case "Feature":
      t(i.properties, 0);
      break;
  }
}
Zt(wy, "propEach");
function AI(i, t, e) {
  var r = e;
  return wy(i, function(s, u) {
    u === 0 && e === void 0 ? r = s : r = t(r, s, u);
  }), r;
}
Zt(AI, "propReduce");
function Xo(i, t) {
  if (i.type === "Feature")
    t(i, 0);
  else if (i.type === "FeatureCollection")
    for (var e = 0; e < i.features.length && t(i.features[e], e) !== !1; e++)
      ;
}
Zt(Xo, "featureEach");
function PI(i, t, e) {
  var r = e;
  return Xo(i, function(s, u) {
    u === 0 && e === void 0 ? r = s : r = t(r, s, u);
  }), r;
}
Zt(PI, "featureReduce");
function DI(i) {
  var t = [];
  return Cr(i, function(e) {
    t.push(e);
  }), t;
}
Zt(DI, "coordAll");
function Rr(i, t) {
  var e, r, s, u, h, f, g, y, p, m, _ = 0, x = i.type === "FeatureCollection", I = i.type === "Feature", k = x ? i.features.length : 1;
  for (e = 0; e < k; e++) {
    for (f = x ? i.features[e].geometry : I ? i.geometry : i, y = x ? i.features[e].properties : I ? i.properties : {}, p = x ? i.features[e].bbox : I ? i.bbox : void 0, m = x ? i.features[e].id : I ? i.id : void 0, g = f ? f.type === "GeometryCollection" : !1, h = g ? f.geometries.length : 1, s = 0; s < h; s++) {
      if (u = g ? f.geometries[s] : f, u === null) {
        if (t(
          null,
          _,
          y,
          p,
          m
        ) === !1)
          return !1;
        continue;
      }
      switch (u.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            u,
            _,
            y,
            p,
            m
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (r = 0; r < u.geometries.length; r++)
            if (t(
              u.geometries[r],
              _,
              y,
              p,
              m
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    _++;
  }
}
Zt(Rr, "geomEach");
function FI(i, t, e) {
  var r = e;
  return Rr(
    i,
    function(s, u, h, f, g) {
      u === 0 && e === void 0 ? r = s : r = t(
        r,
        s,
        u,
        h,
        f,
        g
      );
    }
  ), r;
}
Zt(FI, "geomReduce");
function fa(i, t) {
  Rr(i, function(e, r, s, u, h) {
    var f = e === null ? null : e.type;
    switch (f) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return t(
          Ze(e, s, { bbox: u, id: h }),
          r,
          0
        ) === !1 ? !1 : void 0;
    }
    var g;
    switch (f) {
      case "MultiPoint":
        g = "Point";
        break;
      case "MultiLineString":
        g = "LineString";
        break;
      case "MultiPolygon":
        g = "Polygon";
        break;
    }
    for (var y = 0; y < e.coordinates.length; y++) {
      var p = e.coordinates[y], m = {
        type: g,
        coordinates: p
      };
      if (t(Ze(m, s), r, y) === !1)
        return !1;
    }
  });
}
Zt(fa, "flattenEach");
function GI(i, t, e) {
  var r = e;
  return fa(
    i,
    function(s, u, h) {
      u === 0 && h === 0 && e === void 0 ? r = s : r = t(
        r,
        s,
        u,
        h
      );
    }
  ), r;
}
Zt(GI, "flattenReduce");
function ky(i, t) {
  fa(i, function(e, r, s) {
    var u = 0;
    if (e.geometry) {
      var h = e.geometry.type;
      if (!(h === "Point" || h === "MultiPoint")) {
        var f, g = 0, y = 0, p = 0;
        if (Cr(
          e,
          function(m, _, x, I, k) {
            if (f === void 0 || r > g || I > y || k > p) {
              f = m, g = r, y = I, p = k, u = 0;
              return;
            }
            var C = xn(
              [f, m],
              e.properties
            );
            if (t(
              C,
              r,
              s,
              k,
              u
            ) === !1)
              return !1;
            u++, f = m;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
Zt(ky, "segmentEach");
function BI(i, t, e) {
  var r = e, s = !1;
  return ky(
    i,
    function(u, h, f, g, y) {
      s === !1 && e === void 0 ? r = u : r = t(
        r,
        u,
        h,
        f,
        g,
        y
      ), s = !0;
    }
  ), r;
}
Zt(BI, "segmentReduce");
function Cy(i, t) {
  if (!i)
    throw new Error("geojson is required");
  fa(i, function(e, r, s) {
    if (e.geometry !== null) {
      var u = e.geometry.type, h = e.geometry.coordinates;
      switch (u) {
        case "LineString":
          if (t(e, r, s, 0, 0) === !1)
            return !1;
          break;
        case "Polygon":
          for (var f = 0; f < h.length; f++)
            if (t(
              xn(h[f], e.properties),
              r,
              s,
              f
            ) === !1)
              return !1;
          break;
      }
    }
  });
}
Zt(Cy, "lineEach");
function YI(i, t, e) {
  var r = e;
  return Cy(
    i,
    function(s, u, h, f) {
      u === 0 && e === void 0 ? r = s : r = t(
        r,
        s,
        u,
        h,
        f
      );
    }
  ), r;
}
Zt(YI, "lineReduce");
function zI(i, t) {
  if (t = t || {}, !Wl(t))
    throw new Error("options is invalid");
  var e = t.featureIndex || 0, r = t.multiFeatureIndex || 0, s = t.geometryIndex || 0, u = t.segmentIndex || 0, h = t.properties, f;
  switch (i.type) {
    case "FeatureCollection":
      e < 0 && (e = i.features.length + e), h = h || i.features[e].properties, f = i.features[e].geometry;
      break;
    case "Feature":
      h = h || i.properties, f = i.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      f = i;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (f === null)
    return null;
  var g = f.coordinates;
  switch (f.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      return u < 0 && (u = g.length + u - 1), xn(
        [g[u], g[u + 1]],
        h,
        t
      );
    case "Polygon":
      return s < 0 && (s = g.length + s), u < 0 && (u = g[s].length + u - 1), xn(
        [
          g[s][u],
          g[s][u + 1]
        ],
        h,
        t
      );
    case "MultiLineString":
      return r < 0 && (r = g.length + r), u < 0 && (u = g[r].length + u - 1), xn(
        [
          g[r][u],
          g[r][u + 1]
        ],
        h,
        t
      );
    case "MultiPolygon":
      return r < 0 && (r = g.length + r), s < 0 && (s = g[r].length + s), u < 0 && (u = g[r][s].length - u - 1), xn(
        [
          g[r][s][u],
          g[r][s][u + 1]
        ],
        h,
        t
      );
  }
  throw new Error("geojson is invalid");
}
Zt(zI, "findSegment");
function $I(i, t) {
  if (t = t || {}, !Wl(t))
    throw new Error("options is invalid");
  var e = t.featureIndex || 0, r = t.multiFeatureIndex || 0, s = t.geometryIndex || 0, u = t.coordIndex || 0, h = t.properties, f;
  switch (i.type) {
    case "FeatureCollection":
      e < 0 && (e = i.features.length + e), h = h || i.features[e].properties, f = i.features[e].geometry;
      break;
    case "Feature":
      h = h || i.properties, f = i.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      f = i;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (f === null)
    return null;
  var g = f.coordinates;
  switch (f.type) {
    case "Point":
      return en(g, h, t);
    case "MultiPoint":
      return r < 0 && (r = g.length + r), en(g[r], h, t);
    case "LineString":
      return u < 0 && (u = g.length + u), en(g[u], h, t);
    case "Polygon":
      return s < 0 && (s = g.length + s), u < 0 && (u = g[s].length + u), en(g[s][u], h, t);
    case "MultiLineString":
      return r < 0 && (r = g.length + r), u < 0 && (u = g[r].length + u), en(g[r][u], h, t);
    case "MultiPolygon":
      return r < 0 && (r = g.length + r), s < 0 && (s = g[r].length + s), u < 0 && (u = g[r][s].length - u), en(
        g[r][s][u],
        h,
        t
      );
  }
  throw new Error("geojson is invalid");
}
Zt($I, "findPoint");
var XI = Object.defineProperty, qI = (i, t) => XI(i, "name", { value: t, configurable: !0 });
function Ry(i, t = {}) {
  if (i.bbox != null && t.recompute !== !0)
    return i.bbox;
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return Cr(i, (r) => {
    e[0] > r[0] && (e[0] = r[0]), e[1] > r[1] && (e[1] = r[1]), e[2] < r[0] && (e[2] = r[0]), e[3] < r[1] && (e[3] = r[1]);
  }), e;
}
qI(Ry, "bbox");
var WI = Object.defineProperty, UI = (i, t) => WI(i, "name", { value: t, configurable: !0 });
function by(i, t = {}) {
  const e = Ry(i), r = (e[0] + e[2]) / 2, s = (e[1] + e[3]) / 2;
  return en([r, s], t.properties, t);
}
UI(by, "center");
var Ty = { exports: {} };
(function(i, t) {
  (function(e, r) {
    i.exports = r();
  })(ua, function() {
    function e(c, n) {
      if (!(c instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function r(c, n) {
      for (var o = 0; o < n.length; o++) {
        var a = n[o];
        a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(c, a.key, a);
      }
    }
    function s(c, n, o) {
      return n && r(c.prototype, n), o && r(c, o), c;
    }
    function u(c, n) {
      if (typeof n != "function" && n !== null) throw new TypeError("Super expression must either be null or a function");
      c.prototype = Object.create(n && n.prototype, { constructor: { value: c, writable: !0, configurable: !0 } }), n && f(c, n);
    }
    function h(c) {
      return h = Object.setPrototypeOf ? Object.getPrototypeOf : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n);
      }, h(c);
    }
    function f(c, n) {
      return f = Object.setPrototypeOf || function(o, a) {
        return o.__proto__ = a, o;
      }, f(c, n);
    }
    function g() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
      if (typeof Proxy == "function") return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function y(c, n, o) {
      return y = g() ? Reflect.construct : function(a, l, d) {
        var v = [null];
        v.push.apply(v, l);
        var E = new (Function.bind.apply(a, v))();
        return d && f(E, d.prototype), E;
      }, y.apply(null, arguments);
    }
    function p(c) {
      var n = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return p = function(o) {
        if (o === null || (a = o, Function.toString.call(a).indexOf("[native code]") === -1)) return o;
        var a;
        if (typeof o != "function") throw new TypeError("Super expression must either be null or a function");
        if (n !== void 0) {
          if (n.has(o)) return n.get(o);
          n.set(o, l);
        }
        function l() {
          return y(o, arguments, h(this).constructor);
        }
        return l.prototype = Object.create(o.prototype, { constructor: { value: l, enumerable: !1, writable: !0, configurable: !0 } }), f(l, o);
      }, p(c);
    }
    function m(c) {
      if (c === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return c;
    }
    function _(c, n) {
      if (n && (typeof n == "object" || typeof n == "function")) return n;
      if (n !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
      return m(c);
    }
    function x(c) {
      var n = g();
      return function() {
        var o, a = h(c);
        if (n) {
          var l = h(this).constructor;
          o = Reflect.construct(a, arguments, l);
        } else o = a.apply(this, arguments);
        return _(this, o);
      };
    }
    function I(c, n, o) {
      return I = typeof Reflect < "u" && Reflect.get ? Reflect.get : function(a, l, d) {
        var v = function(S, w) {
          for (; !Object.prototype.hasOwnProperty.call(S, w) && (S = h(S)) !== null; ) ;
          return S;
        }(a, l);
        if (v) {
          var E = Object.getOwnPropertyDescriptor(v, l);
          return E.get ? E.get.call(d) : E.value;
        }
      }, I(c, n, o || c);
    }
    function k(c) {
      return function(n) {
        if (Array.isArray(n)) return R(n);
      }(c) || function(n) {
        if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n);
      }(c) || C(c) || function() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }();
    }
    function C(c, n) {
      if (c) {
        if (typeof c == "string") return R(c, n);
        var o = Object.prototype.toString.call(c).slice(8, -1);
        return o === "Object" && c.constructor && (o = c.constructor.name), o === "Map" || o === "Set" ? Array.from(c) : o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? R(c, n) : void 0;
      }
    }
    function R(c, n) {
      (n == null || n > c.length) && (n = c.length);
      for (var o = 0, a = new Array(n); o < n; o++) a[o] = c[o];
      return a;
    }
    function b(c, n) {
      var o = typeof Symbol < "u" && c[Symbol.iterator] || c["@@iterator"];
      if (!o) {
        if (Array.isArray(c) || (o = C(c)) || n) {
          o && (c = o);
          var a = 0, l = function() {
          };
          return { s: l, n: function() {
            return a >= c.length ? { done: !0 } : { done: !1, value: c[a++] };
          }, e: function(S) {
            throw S;
          }, f: l };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var d, v = !0, E = !1;
      return { s: function() {
        o = o.call(c);
      }, n: function() {
        var S = o.next();
        return v = S.done, S;
      }, e: function(S) {
        E = !0, d = S;
      }, f: function() {
        try {
          v || o.return == null || o.return();
        } finally {
          if (E) throw d;
        }
      } };
    }
    var O = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getEndCapStyle", value: function() {
        return this._endCapStyle;
      } }, { key: "isSingleSided", value: function() {
        return this._isSingleSided;
      } }, { key: "setQuadrantSegments", value: function(n) {
        this._quadrantSegments = n, this._quadrantSegments === 0 && (this._joinStyle = c.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = c.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), n <= 0 && (this._quadrantSegments = 1), this._joinStyle !== c.JOIN_ROUND && (this._quadrantSegments = c.DEFAULT_QUADRANT_SEGMENTS);
      } }, { key: "getJoinStyle", value: function() {
        return this._joinStyle;
      } }, { key: "setJoinStyle", value: function(n) {
        this._joinStyle = n;
      } }, { key: "setSimplifyFactor", value: function(n) {
        this._simplifyFactor = n < 0 ? 0 : n;
      } }, { key: "getSimplifyFactor", value: function() {
        return this._simplifyFactor;
      } }, { key: "getQuadrantSegments", value: function() {
        return this._quadrantSegments;
      } }, { key: "setEndCapStyle", value: function(n) {
        this._endCapStyle = n;
      } }, { key: "getMitreLimit", value: function() {
        return this._mitreLimit;
      } }, { key: "setMitreLimit", value: function(n) {
        this._mitreLimit = n;
      } }, { key: "setSingleSided", value: function(n) {
        this._isSingleSided = n;
      } }], [{ key: "constructor_", value: function() {
        if (this._quadrantSegments = c.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = c.CAP_ROUND, this._joinStyle = c.JOIN_ROUND, this._mitreLimit = c.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = c.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
          if (arguments.length === 1) {
            var n = arguments[0];
            this.setQuadrantSegments(n);
          } else if (arguments.length === 2) {
            var o = arguments[0], a = arguments[1];
            this.setQuadrantSegments(o), this.setEndCapStyle(a);
          } else if (arguments.length === 4) {
            var l = arguments[0], d = arguments[1], v = arguments[2], E = arguments[3];
            this.setQuadrantSegments(l), this.setEndCapStyle(d), this.setJoinStyle(v), this.setMitreLimit(E);
          }
        }
      } }, { key: "bufferDistanceError", value: function(n) {
        var o = Math.PI / 2 / n;
        return 1 - Math.cos(o / 2);
      } }]), c;
    }();
    O.CAP_ROUND = 1, O.CAP_FLAT = 2, O.CAP_SQUARE = 3, O.JOIN_ROUND = 1, O.JOIN_MITRE = 2, O.JOIN_BEVEL = 3, O.DEFAULT_QUADRANT_SEGMENTS = 8, O.DEFAULT_MITRE_LIMIT = 5, O.DEFAULT_SIMPLIFY_FACTOR = 0.01;
    var A = function(c) {
      u(o, c);
      var n = x(o);
      function o(a) {
        var l;
        return e(this, o), (l = n.call(this, a)).name = Object.keys({ Exception: o })[0], l;
      }
      return s(o, [{ key: "toString", value: function() {
        return this.message;
      } }]), o;
    }(p(Error)), L = function(c) {
      u(o, c);
      var n = x(o);
      function o(a) {
        var l;
        return e(this, o), (l = n.call(this, a)).name = Object.keys({ IllegalArgumentException: o })[0], l;
      }
      return o;
    }(A), D = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "filter", value: function(n) {
      } }]), c;
    }();
    function F() {
    }
    function G() {
    }
    function B() {
    }
    var tt, J, H, Q, X, K, V, lt, ct = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "equalsWithTolerance", value: function(n, o, a) {
        return Math.abs(n - o) <= a;
      } }]), c;
    }(), Et = function() {
      function c(n, o) {
        e(this, c), this.low = o || 0, this.high = n || 0;
      }
      return s(c, null, [{ key: "toBinaryString", value: function(n) {
        var o, a = "";
        for (o = 2147483648; o > 0; o >>>= 1) a += (n.high & o) === o ? "1" : "0";
        for (o = 2147483648; o > 0; o >>>= 1) a += (n.low & o) === o ? "1" : "0";
        return a;
      } }]), c;
    }();
    function Z() {
    }
    function pt() {
    }
    Z.NaN = NaN, Z.isNaN = function(c) {
      return Number.isNaN(c);
    }, Z.isInfinite = function(c) {
      return !Number.isFinite(c);
    }, Z.MAX_VALUE = Number.MAX_VALUE, Z.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, Z.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, typeof Float64Array == "function" && typeof Int32Array == "function" ? (K = 2146435072, V = new Float64Array(1), lt = new Int32Array(V.buffer), Z.doubleToLongBits = function(c) {
      V[0] = c;
      var n = 0 | lt[0], o = 0 | lt[1];
      return (o & K) === K && 1048575 & o && n !== 0 && (n = 0, o = 2146959360), new Et(o, n);
    }, Z.longBitsToDouble = function(c) {
      return lt[0] = c.low, lt[1] = c.high, V[0];
    }) : (tt = 1023, J = Math.log2, H = Math.floor, Q = Math.pow, X = function() {
      for (var c = 53; c > 0; c--) {
        var n = Q(2, c) - 1;
        if (H(J(n)) + 1 === c) return n;
      }
      return 0;
    }(), Z.doubleToLongBits = function(c) {
      var n, o, a, l, d, v, E, S, w;
      if (c < 0 || 1 / c === Number.NEGATIVE_INFINITY ? (v = 1 << 31, c = -c) : v = 0, c === 0) return new Et(S = v, w = 0);
      if (c === 1 / 0) return new Et(S = 2146435072 | v, w = 0);
      if (c != c) return new Et(S = 2146959360, w = 0);
      if (l = 0, w = 0, (n = H(c)) > 1) if (n <= X) (l = H(J(n))) <= 20 ? (w = 0, S = n << 20 - l & 1048575) : (w = n % (o = Q(2, a = l - 20)) << 32 - a, S = n / o & 1048575);
      else for (a = n, w = 0; (a = H(o = a / 2)) !== 0; ) l++, w >>>= 1, w |= (1 & S) << 31, S >>>= 1, o !== a && (S |= 524288);
      if (E = l + tt, d = n === 0, n = c - n, l < 52 && n !== 0) for (a = 0; ; ) {
        if ((o = 2 * n) >= 1 ? (n = o - 1, d ? (E--, d = !1) : (a <<= 1, a |= 1, l++)) : (n = o, d ? --E == 0 && (l++, d = !1) : (a <<= 1, l++)), l === 20) S |= a, a = 0;
        else if (l === 52) {
          w |= a;
          break;
        }
        if (o === 1) {
          l < 20 ? S |= a << 20 - l : l < 52 && (w |= a << 52 - l);
          break;
        }
      }
      return S |= E << 20, new Et(S |= v, w);
    }, Z.longBitsToDouble = function(c) {
      var n, o, a, l, d = c.high, v = c.low, E = d & 1 << 31 ? -1 : 1;
      for (a = ((2146435072 & d) >> 20) - tt, l = 0, o = 1 << 19, n = 1; n <= 20; n++) d & o && (l += Q(2, -n)), o >>>= 1;
      for (o = 1 << 31, n = 21; n <= 52; n++) v & o && (l += Q(2, -n)), o >>>= 1;
      if (a === -1023) {
        if (l === 0) return 0 * E;
        a = -1022;
      } else {
        if (a === 1024) return l === 0 ? E / 0 : NaN;
        l += 1;
      }
      return E * l * Q(2, a);
    });
    var mt = function(c) {
      u(o, c);
      var n = x(o);
      function o(a) {
        var l;
        return e(this, o), (l = n.call(this, a)).name = Object.keys({ RuntimeException: o })[0], l;
      }
      return o;
    }(A), Lt = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, null, [{ key: "constructor_", value: function() {
        if (arguments.length === 0) mt.constructor_.call(this);
        else if (arguments.length === 1) {
          var a = arguments[0];
          mt.constructor_.call(this, a);
        }
      } }]), o;
    }(mt), z = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "shouldNeverReachHere", value: function() {
        if (arguments.length === 0) c.shouldNeverReachHere(null);
        else if (arguments.length === 1) {
          var n = arguments[0];
          throw new Lt("Should never reach here" + (n !== null ? ": " + n : ""));
        }
      } }, { key: "isTrue", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          c.isTrue(n, null);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          if (!o) throw a === null ? new Lt() : new Lt(a);
        }
      } }, { key: "equals", value: function() {
        if (arguments.length === 2) {
          var n = arguments[0], o = arguments[1];
          c.equals(n, o, null);
        } else if (arguments.length === 3) {
          var a = arguments[0], l = arguments[1], d = arguments[2];
          if (!l.equals(a)) throw new Lt("Expected " + a + " but encountered " + l + (d !== null ? ": " + d : ""));
        }
      } }]), c;
    }(), ge = new ArrayBuffer(8), Nr = new Float64Array(ge), Fi = new Int32Array(ge), P = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getM", value: function() {
        return Z.NaN;
      } }, { key: "setOrdinate", value: function(n, o) {
        switch (n) {
          case c.X:
            this.x = o;
            break;
          case c.Y:
            this.y = o;
            break;
          case c.Z:
            this.setZ(o);
            break;
          default:
            throw new L("Invalid ordinate index: " + n);
        }
      } }, { key: "equals2D", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return this.x === n.x && this.y === n.y;
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          return !!ct.equalsWithTolerance(this.x, o.x, a) && !!ct.equalsWithTolerance(this.y, o.y, a);
        }
      } }, { key: "setM", value: function(n) {
        throw new L("Invalid ordinate index: " + c.M);
      } }, { key: "getZ", value: function() {
        return this.z;
      } }, { key: "getOrdinate", value: function(n) {
        switch (n) {
          case c.X:
            return this.x;
          case c.Y:
            return this.y;
          case c.Z:
            return this.getZ();
        }
        throw new L("Invalid ordinate index: " + n);
      } }, { key: "equals3D", value: function(n) {
        return this.x === n.x && this.y === n.y && (this.getZ() === n.getZ() || Z.isNaN(this.getZ()) && Z.isNaN(n.getZ()));
      } }, { key: "equals", value: function(n) {
        return n instanceof c && this.equals2D(n);
      } }, { key: "equalInZ", value: function(n, o) {
        return ct.equalsWithTolerance(this.getZ(), n.getZ(), o);
      } }, { key: "setX", value: function(n) {
        this.x = n;
      } }, { key: "compareTo", value: function(n) {
        var o = n;
        return this.x < o.x ? -1 : this.x > o.x ? 1 : this.y < o.y ? -1 : this.y > o.y ? 1 : 0;
      } }, { key: "getX", value: function() {
        return this.x;
      } }, { key: "setZ", value: function(n) {
        this.z = n;
      } }, { key: "clone", value: function() {
        try {
          return null;
        } catch (n) {
          if (n instanceof CloneNotSupportedException) return z.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
          throw n;
        }
      } }, { key: "copy", value: function() {
        return new c(this);
      } }, { key: "toString", value: function() {
        return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
      } }, { key: "distance3D", value: function(n) {
        var o = this.x - n.x, a = this.y - n.y, l = this.getZ() - n.getZ();
        return Math.sqrt(o * o + a * a + l * l);
      } }, { key: "getY", value: function() {
        return this.y;
      } }, { key: "setY", value: function(n) {
        this.y = n;
      } }, { key: "distance", value: function(n) {
        var o = this.x - n.x, a = this.y - n.y;
        return Math.sqrt(o * o + a * a);
      } }, { key: "hashCode", value: function() {
        var n = 17;
        return n = 37 * (n = 37 * n + c.hashCode(this.x)) + c.hashCode(this.y);
      } }, { key: "setCoordinate", value: function(n) {
        this.x = n.x, this.y = n.y, this.z = n.getZ();
      } }, { key: "interfaces_", get: function() {
        return [F, G, B];
      } }], [{ key: "constructor_", value: function() {
        if (this.x = null, this.y = null, this.z = null, arguments.length === 0) c.constructor_.call(this, 0, 0);
        else if (arguments.length === 1) {
          var n = arguments[0];
          c.constructor_.call(this, n.x, n.y, n.getZ());
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          c.constructor_.call(this, o, a, c.NULL_ORDINATE);
        } else if (arguments.length === 3) {
          var l = arguments[0], d = arguments[1], v = arguments[2];
          this.x = l, this.y = d, this.z = v;
        }
      } }, { key: "hashCode", value: function(n) {
        return Nr[0] = n, Fi[0] ^ Fi[1];
      } }]), c;
    }(), ga = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "compare", value: function(n, o) {
        var a = c.compare(n.x, o.x);
        if (a !== 0) return a;
        var l = c.compare(n.y, o.y);
        return l !== 0 ? l : this._dimensionsToTest <= 2 ? 0 : c.compare(n.getZ(), o.getZ());
      } }, { key: "interfaces_", get: function() {
        return [pt];
      } }], [{ key: "constructor_", value: function() {
        if (this._dimensionsToTest = 2, arguments.length === 0) c.constructor_.call(this, 2);
        else if (arguments.length === 1) {
          var n = arguments[0];
          if (n !== 2 && n !== 3) throw new L("only 2 or 3 dimensions may be specified");
          this._dimensionsToTest = n;
        }
      } }, { key: "compare", value: function(n, o) {
        return n < o ? -1 : n > o ? 1 : Z.isNaN(n) ? Z.isNaN(o) ? 0 : -1 : Z.isNaN(o) ? 1 : 0;
      } }]), c;
    }();
    P.DimensionalComparator = ga, P.NULL_ORDINATE = Z.NaN, P.X = 0, P.Y = 1, P.Z = 2, P.M = 3;
    var bt = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getArea", value: function() {
        return this.getWidth() * this.getHeight();
      } }, { key: "equals", value: function(n) {
        if (!(n instanceof c)) return !1;
        var o = n;
        return this.isNull() ? o.isNull() : this._maxx === o.getMaxX() && this._maxy === o.getMaxY() && this._minx === o.getMinX() && this._miny === o.getMinY();
      } }, { key: "intersection", value: function(n) {
        if (this.isNull() || n.isNull() || !this.intersects(n)) return new c();
        var o = this._minx > n._minx ? this._minx : n._minx, a = this._miny > n._miny ? this._miny : n._miny;
        return new c(o, this._maxx < n._maxx ? this._maxx : n._maxx, a, this._maxy < n._maxy ? this._maxy : n._maxy);
      } }, { key: "isNull", value: function() {
        return this._maxx < this._minx;
      } }, { key: "getMaxX", value: function() {
        return this._maxx;
      } }, { key: "covers", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof P) {
            var n = arguments[0];
            return this.covers(n.x, n.y);
          }
          if (arguments[0] instanceof c) {
            var o = arguments[0];
            return !this.isNull() && !o.isNull() && o.getMinX() >= this._minx && o.getMaxX() <= this._maxx && o.getMinY() >= this._miny && o.getMaxY() <= this._maxy;
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          return !this.isNull() && a >= this._minx && a <= this._maxx && l >= this._miny && l <= this._maxy;
        }
      } }, { key: "intersects", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof c) {
            var n = arguments[0];
            return !this.isNull() && !n.isNull() && !(n._minx > this._maxx || n._maxx < this._minx || n._miny > this._maxy || n._maxy < this._miny);
          }
          if (arguments[0] instanceof P) {
            var o = arguments[0];
            return this.intersects(o.x, o.y);
          }
        } else if (arguments.length === 2) {
          if (arguments[0] instanceof P && arguments[1] instanceof P) {
            var a = arguments[0], l = arguments[1];
            if (this.isNull()) return !1;
            var d = a.x < l.x ? a.x : l.x;
            if (d > this._maxx) return !1;
            var v = a.x > l.x ? a.x : l.x;
            if (v < this._minx) return !1;
            var E = a.y < l.y ? a.y : l.y;
            if (E > this._maxy) return !1;
            var S = a.y > l.y ? a.y : l.y;
            return !(S < this._miny);
          }
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var w = arguments[0], N = arguments[1];
            return !this.isNull() && !(w > this._maxx || w < this._minx || N > this._maxy || N < this._miny);
          }
        }
      } }, { key: "getMinY", value: function() {
        return this._miny;
      } }, { key: "getDiameter", value: function() {
        if (this.isNull()) return 0;
        var n = this.getWidth(), o = this.getHeight();
        return Math.sqrt(n * n + o * o);
      } }, { key: "getMinX", value: function() {
        return this._minx;
      } }, { key: "expandToInclude", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof P) {
            var n = arguments[0];
            this.expandToInclude(n.x, n.y);
          } else if (arguments[0] instanceof c) {
            var o = arguments[0];
            if (o.isNull()) return null;
            this.isNull() ? (this._minx = o.getMinX(), this._maxx = o.getMaxX(), this._miny = o.getMinY(), this._maxy = o.getMaxY()) : (o._minx < this._minx && (this._minx = o._minx), o._maxx > this._maxx && (this._maxx = o._maxx), o._miny < this._miny && (this._miny = o._miny), o._maxy > this._maxy && (this._maxy = o._maxy));
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this.isNull() ? (this._minx = a, this._maxx = a, this._miny = l, this._maxy = l) : (a < this._minx && (this._minx = a), a > this._maxx && (this._maxx = a), l < this._miny && (this._miny = l), l > this._maxy && (this._maxy = l));
        }
      } }, { key: "minExtent", value: function() {
        if (this.isNull()) return 0;
        var n = this.getWidth(), o = this.getHeight();
        return n < o ? n : o;
      } }, { key: "getWidth", value: function() {
        return this.isNull() ? 0 : this._maxx - this._minx;
      } }, { key: "compareTo", value: function(n) {
        var o = n;
        return this.isNull() ? o.isNull() ? 0 : -1 : o.isNull() ? 1 : this._minx < o._minx ? -1 : this._minx > o._minx ? 1 : this._miny < o._miny ? -1 : this._miny > o._miny ? 1 : this._maxx < o._maxx ? -1 : this._maxx > o._maxx ? 1 : this._maxy < o._maxy ? -1 : this._maxy > o._maxy ? 1 : 0;
      } }, { key: "translate", value: function(n, o) {
        if (this.isNull()) return null;
        this.init(this.getMinX() + n, this.getMaxX() + n, this.getMinY() + o, this.getMaxY() + o);
      } }, { key: "copy", value: function() {
        return new c(this);
      } }, { key: "toString", value: function() {
        return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
      } }, { key: "setToNull", value: function() {
        this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
      } }, { key: "disjoint", value: function(n) {
        return !(!this.isNull() && !n.isNull()) || n._minx > this._maxx || n._maxx < this._minx || n._miny > this._maxy || n._maxy < this._miny;
      } }, { key: "getHeight", value: function() {
        return this.isNull() ? 0 : this._maxy - this._miny;
      } }, { key: "maxExtent", value: function() {
        if (this.isNull()) return 0;
        var n = this.getWidth(), o = this.getHeight();
        return n > o ? n : o;
      } }, { key: "expandBy", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          this.expandBy(n, n);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          if (this.isNull()) return null;
          this._minx -= o, this._maxx += o, this._miny -= a, this._maxy += a, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
        }
      } }, { key: "contains", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof c) {
            var n = arguments[0];
            return this.covers(n);
          }
          if (arguments[0] instanceof P) {
            var o = arguments[0];
            return this.covers(o);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          return this.covers(a, l);
        }
      } }, { key: "centre", value: function() {
        return this.isNull() ? null : new P((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
      } }, { key: "init", value: function() {
        if (arguments.length === 0) this.setToNull();
        else if (arguments.length === 1) {
          if (arguments[0] instanceof P) {
            var n = arguments[0];
            this.init(n.x, n.x, n.y, n.y);
          } else if (arguments[0] instanceof c) {
            var o = arguments[0];
            this._minx = o._minx, this._maxx = o._maxx, this._miny = o._miny, this._maxy = o._maxy;
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this.init(a.x, l.x, a.y, l.y);
        } else if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], E = arguments[2], S = arguments[3];
          d < v ? (this._minx = d, this._maxx = v) : (this._minx = v, this._maxx = d), E < S ? (this._miny = E, this._maxy = S) : (this._miny = S, this._maxy = E);
        }
      } }, { key: "getMaxY", value: function() {
        return this._maxy;
      } }, { key: "distance", value: function(n) {
        if (this.intersects(n)) return 0;
        var o = 0;
        this._maxx < n._minx ? o = n._minx - this._maxx : this._minx > n._maxx && (o = this._minx - n._maxx);
        var a = 0;
        return this._maxy < n._miny ? a = n._miny - this._maxy : this._miny > n._maxy && (a = this._miny - n._maxy), o === 0 ? a : a === 0 ? o : Math.sqrt(o * o + a * a);
      } }, { key: "hashCode", value: function() {
        var n = 17;
        return n = 37 * (n = 37 * (n = 37 * (n = 37 * n + P.hashCode(this._minx)) + P.hashCode(this._maxx)) + P.hashCode(this._miny)) + P.hashCode(this._maxy);
      } }, { key: "interfaces_", get: function() {
        return [F, B];
      } }], [{ key: "constructor_", value: function() {
        if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init();
        else if (arguments.length === 1) {
          if (arguments[0] instanceof P) {
            var n = arguments[0];
            this.init(n.x, n.x, n.y, n.y);
          } else if (arguments[0] instanceof c) {
            var o = arguments[0];
            this.init(o);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this.init(a.x, l.x, a.y, l.y);
        } else if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], E = arguments[2], S = arguments[3];
          this.init(d, v, E, S);
        }
      } }, { key: "intersects", value: function() {
        if (arguments.length === 3) {
          var n = arguments[0], o = arguments[1], a = arguments[2];
          return a.x >= (n.x < o.x ? n.x : o.x) && a.x <= (n.x > o.x ? n.x : o.x) && a.y >= (n.y < o.y ? n.y : o.y) && a.y <= (n.y > o.y ? n.y : o.y);
        }
        if (arguments.length === 4) {
          var l = arguments[0], d = arguments[1], v = arguments[2], E = arguments[3], S = Math.min(v.x, E.x), w = Math.max(v.x, E.x), N = Math.min(l.x, d.x), M = Math.max(l.x, d.x);
          return !(N > w) && !(M < S) && (S = Math.min(v.y, E.y), w = Math.max(v.y, E.y), N = Math.min(l.y, d.y), M = Math.max(l.y, d.y), !(N > w) && !(M < S));
        }
      } }]), c;
    }(), et = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "isGeometryCollection", value: function() {
        return this.getTypeCode() === c.TYPECODE_GEOMETRYCOLLECTION;
      } }, { key: "getFactory", value: function() {
        return this._factory;
      } }, { key: "getGeometryN", value: function(n) {
        return this;
      } }, { key: "getArea", value: function() {
        return 0;
      } }, { key: "isRectangle", value: function() {
        return !1;
      } }, { key: "equalsExact", value: function(n) {
        return this === n || this.equalsExact(n, 0);
      } }, { key: "geometryChanged", value: function() {
        this.apply(c.geometryChangedFilter);
      } }, { key: "geometryChangedAction", value: function() {
        this._envelope = null;
      } }, { key: "equalsNorm", value: function(n) {
        return n !== null && this.norm().equalsExact(n.norm());
      } }, { key: "getLength", value: function() {
        return 0;
      } }, { key: "getNumGeometries", value: function() {
        return 1;
      } }, { key: "compareTo", value: function() {
        var n;
        if (arguments.length === 1) {
          var o = arguments[0];
          return n = o, this.getTypeCode() !== n.getTypeCode() ? this.getTypeCode() - n.getTypeCode() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(o);
        }
        if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          return n = a, this.getTypeCode() !== n.getTypeCode() ? this.getTypeCode() - n.getTypeCode() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(a, l);
        }
      } }, { key: "getUserData", value: function() {
        return this._userData;
      } }, { key: "getSRID", value: function() {
        return this._SRID;
      } }, { key: "getEnvelope", value: function() {
        return this.getFactory().toGeometry(this.getEnvelopeInternal());
      } }, { key: "checkNotGeometryCollection", value: function(n) {
        if (n.getTypeCode() === c.TYPECODE_GEOMETRYCOLLECTION) throw new L("This method does not support GeometryCollection arguments");
      } }, { key: "equal", value: function(n, o, a) {
        return a === 0 ? n.equals(o) : n.distance(o) <= a;
      } }, { key: "norm", value: function() {
        var n = this.copy();
        return n.normalize(), n;
      } }, { key: "reverse", value: function() {
        var n = this.reverseInternal();
        return this.envelope != null && (n.envelope = this.envelope.copy()), n.setSRID(this.getSRID()), n;
      } }, { key: "copy", value: function() {
        var n = this.copyInternal();
        return n.envelope = this._envelope == null ? null : this._envelope.copy(), n._SRID = this._SRID, n._userData = this._userData, n;
      } }, { key: "getPrecisionModel", value: function() {
        return this._factory.getPrecisionModel();
      } }, { key: "getEnvelopeInternal", value: function() {
        return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new bt(this._envelope);
      } }, { key: "setSRID", value: function(n) {
        this._SRID = n;
      } }, { key: "setUserData", value: function(n) {
        this._userData = n;
      } }, { key: "compare", value: function(n, o) {
        for (var a = n.iterator(), l = o.iterator(); a.hasNext() && l.hasNext(); ) {
          var d = a.next(), v = l.next(), E = d.compareTo(v);
          if (E !== 0) return E;
        }
        return a.hasNext() ? 1 : l.hasNext() ? -1 : 0;
      } }, { key: "hashCode", value: function() {
        return this.getEnvelopeInternal().hashCode();
      } }, { key: "isEquivalentClass", value: function(n) {
        return this.getClass() === n.getClass();
      } }, { key: "isGeometryCollectionOrDerived", value: function() {
        return this.getTypeCode() === c.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === c.TYPECODE_MULTIPOINT || this.getTypeCode() === c.TYPECODE_MULTILINESTRING || this.getTypeCode() === c.TYPECODE_MULTIPOLYGON;
      } }, { key: "interfaces_", get: function() {
        return [G, F, B];
      } }, { key: "getClass", value: function() {
        return c;
      } }], [{ key: "hasNonEmptyElements", value: function(n) {
        for (var o = 0; o < n.length; o++) if (!n[o].isEmpty()) return !0;
        return !1;
      } }, { key: "hasNullElements", value: function(n) {
        for (var o = 0; o < n.length; o++) if (n[o] === null) return !0;
        return !1;
      } }]), c;
    }();
    et.constructor_ = function(c) {
      c && (this._envelope = null, this._userData = null, this._factory = c, this._SRID = c.getSRID());
    }, et.TYPECODE_POINT = 0, et.TYPECODE_MULTIPOINT = 1, et.TYPECODE_LINESTRING = 2, et.TYPECODE_LINEARRING = 3, et.TYPECODE_MULTILINESTRING = 4, et.TYPECODE_POLYGON = 5, et.TYPECODE_MULTIPOLYGON = 6, et.TYPECODE_GEOMETRYCOLLECTION = 7, et.TYPENAME_POINT = "Point", et.TYPENAME_MULTIPOINT = "MultiPoint", et.TYPENAME_LINESTRING = "LineString", et.TYPENAME_LINEARRING = "LinearRing", et.TYPENAME_MULTILINESTRING = "MultiLineString", et.TYPENAME_POLYGON = "Polygon", et.TYPENAME_MULTIPOLYGON = "MultiPolygon", et.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", et.geometryChangedFilter = { get interfaces_() {
      return [D];
    }, filter: function(c) {
      c.geometryChangedAction();
    } };
    var T = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "toLocationSymbol", value: function(n) {
        switch (n) {
          case c.EXTERIOR:
            return "e";
          case c.BOUNDARY:
            return "b";
          case c.INTERIOR:
            return "i";
          case c.NONE:
            return "-";
        }
        throw new L("Unknown location value: " + n);
      } }]), c;
    }();
    T.INTERIOR = 0, T.BOUNDARY = 1, T.EXTERIOR = 2, T.NONE = -1;
    var Ie = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "add", value: function() {
      } }, { key: "addAll", value: function() {
      } }, { key: "isEmpty", value: function() {
      } }, { key: "iterator", value: function() {
      } }, { key: "size", value: function() {
      } }, { key: "toArray", value: function() {
      } }, { key: "remove", value: function() {
      } }]), c;
    }(), Gi = function(c) {
      u(o, c);
      var n = x(o);
      function o(a) {
        var l;
        return e(this, o), (l = n.call(this, a)).name = Object.keys({ NoSuchElementException: o })[0], l;
      }
      return o;
    }(A), De = function(c) {
      u(o, c);
      var n = x(o);
      function o(a) {
        var l;
        return e(this, o), (l = n.call(this, a)).name = Object.keys({ UnsupportedOperationException: o })[0], l;
      }
      return o;
    }(A), Nn = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        return e(this, o), n.apply(this, arguments);
      }
      return s(o, [{ key: "contains", value: function() {
      } }]), o;
    }(Ie), ai = function(c, n) {
      u(a, c);
      var o = x(a);
      function a(l) {
        var d;
        return e(this, a), (d = o.call(this)).map = /* @__PURE__ */ new Map(), l instanceof Ie && d.addAll(l), d;
      }
      return s(a, [{ key: "contains", value: function(l) {
        var d = l.hashCode ? l.hashCode() : l;
        return !!this.map.has(d);
      } }, { key: "add", value: function(l) {
        var d = l.hashCode ? l.hashCode() : l;
        return !this.map.has(d) && !!this.map.set(d, l);
      } }, { key: "addAll", value: function(l) {
        var d, v = b(l);
        try {
          for (v.s(); !(d = v.n()).done; ) {
            var E = d.value;
            this.add(E);
          }
        } catch (S) {
          v.e(S);
        } finally {
          v.f();
        }
        return !0;
      } }, { key: "remove", value: function() {
        throw new De();
      } }, { key: "size", value: function() {
        return this.map.size;
      } }, { key: "isEmpty", value: function() {
        return this.map.size === 0;
      } }, { key: "toArray", value: function() {
        return Array.from(this.map.values());
      } }, { key: "iterator", value: function() {
        return new da(this.map);
      } }, { key: n, value: function() {
        return this.map;
      } }]), a;
    }(Nn, Symbol.iterator), da = function() {
      function c(n) {
        e(this, c), this.iterator = n.values();
        var o = this.iterator.next(), a = o.done, l = o.value;
        this.done = a, this.value = l;
      }
      return s(c, [{ key: "next", value: function() {
        if (this.done) throw new Gi();
        var n = this.value, o = this.iterator.next(), a = o.done, l = o.value;
        return this.done = a, this.value = l, n;
      } }, { key: "hasNext", value: function() {
        return !this.done;
      } }, { key: "remove", value: function() {
        throw new De();
      } }]), c;
    }(), U = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "opposite", value: function(n) {
        return n === c.LEFT ? c.RIGHT : n === c.RIGHT ? c.LEFT : n;
      } }]), c;
    }();
    U.ON = 0, U.LEFT = 1, U.RIGHT = 2;
    var As = function(c) {
      u(o, c);
      var n = x(o);
      function o(a) {
        var l;
        return e(this, o), (l = n.call(this, a)).name = Object.keys({ EmptyStackException: o })[0], l;
      }
      return o;
    }(A), Mr = function(c) {
      u(o, c);
      var n = x(o);
      function o(a) {
        var l;
        return e(this, o), (l = n.call(this, a)).name = Object.keys({ IndexOutOfBoundsException: o })[0], l;
      }
      return o;
    }(A), Fe = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        return e(this, o), n.apply(this, arguments);
      }
      return s(o, [{ key: "get", value: function() {
      } }, { key: "set", value: function() {
      } }, { key: "isEmpty", value: function() {
      } }]), o;
    }(Ie), ya = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), (a = n.call(this)).array = [], a;
      }
      return s(o, [{ key: "add", value: function(a) {
        return this.array.push(a), !0;
      } }, { key: "get", value: function(a) {
        if (a < 0 || a >= this.size()) throw new Mr();
        return this.array[a];
      } }, { key: "push", value: function(a) {
        return this.array.push(a), a;
      } }, { key: "pop", value: function() {
        if (this.array.length === 0) throw new As();
        return this.array.pop();
      } }, { key: "peek", value: function() {
        if (this.array.length === 0) throw new As();
        return this.array[this.array.length - 1];
      } }, { key: "empty", value: function() {
        return this.array.length === 0;
      } }, { key: "isEmpty", value: function() {
        return this.empty();
      } }, { key: "search", value: function(a) {
        return this.array.indexOf(a);
      } }, { key: "size", value: function() {
        return this.array.length;
      } }, { key: "toArray", value: function() {
        return this.array.slice();
      } }]), o;
    }(Fe);
    function ht(c, n) {
      return c.interfaces_ && c.interfaces_.indexOf(n) > -1;
    }
    var Ge = function() {
      function c(n) {
        e(this, c), this.str = n;
      }
      return s(c, [{ key: "append", value: function(n) {
        this.str += n;
      } }, { key: "setCharAt", value: function(n, o) {
        this.str = this.str.substr(0, n) + o + this.str.substr(n + 1);
      } }, { key: "toString", value: function() {
        return this.str;
      } }]), c;
    }(), Mn = function() {
      function c(n) {
        e(this, c), this.value = n;
      }
      return s(c, [{ key: "intValue", value: function() {
        return this.value;
      } }, { key: "compareTo", value: function(n) {
        return this.value < n ? -1 : this.value > n ? 1 : 0;
      } }], [{ key: "compare", value: function(n, o) {
        return n < o ? -1 : n > o ? 1 : 0;
      } }, { key: "isNan", value: function(n) {
        return Number.isNaN(n);
      } }, { key: "valueOf", value: function(n) {
        return new c(n);
      } }]), c;
    }(), ui = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "isWhitespace", value: function(n) {
        return n <= 32 && n >= 0 || n === 127;
      } }, { key: "toUpperCase", value: function(n) {
        return n.toUpperCase();
      } }]), c;
    }(), rt = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "le", value: function(n) {
        return this._hi < n._hi || this._hi === n._hi && this._lo <= n._lo;
      } }, { key: "extractSignificantDigits", value: function(n, o) {
        var a = this.abs(), l = c.magnitude(a._hi), d = c.TEN.pow(l);
        (a = a.divide(d)).gt(c.TEN) ? (a = a.divide(c.TEN), l += 1) : a.lt(c.ONE) && (a = a.multiply(c.TEN), l -= 1);
        for (var v = l + 1, E = new Ge(), S = c.MAX_PRINT_DIGITS - 1, w = 0; w <= S; w++) {
          n && w === v && E.append(".");
          var N = Math.trunc(a._hi);
          if (N < 0) break;
          var M = !1, Y = 0;
          N > 9 ? (M = !0, Y = "9") : Y = "0" + N, E.append(Y), a = a.subtract(c.valueOf(N)).multiply(c.TEN), M && a.selfAdd(c.TEN);
          var W = !0, q = c.magnitude(a._hi);
          if (q < 0 && Math.abs(q) >= S - w && (W = !1), !W) break;
        }
        return o[0] = l, E.toString();
      } }, { key: "sqr", value: function() {
        return this.multiply(this);
      } }, { key: "doubleValue", value: function() {
        return this._hi + this._lo;
      } }, { key: "subtract", value: function() {
        if (arguments[0] instanceof c) {
          var n = arguments[0];
          return this.add(n.negate());
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return this.add(-o);
        }
      } }, { key: "equals", value: function() {
        if (arguments.length === 1 && arguments[0] instanceof c) {
          var n = arguments[0];
          return this._hi === n._hi && this._lo === n._lo;
        }
      } }, { key: "isZero", value: function() {
        return this._hi === 0 && this._lo === 0;
      } }, { key: "selfSubtract", value: function() {
        if (arguments[0] instanceof c) {
          var n = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-n._hi, -n._lo);
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-o, 0);
        }
      } }, { key: "getSpecialNumberString", value: function() {
        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
      } }, { key: "min", value: function(n) {
        return this.le(n) ? this : n;
      } }, { key: "selfDivide", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof c) {
            var n = arguments[0];
            return this.selfDivide(n._hi, n._lo);
          }
          if (typeof arguments[0] == "number") {
            var o = arguments[0];
            return this.selfDivide(o, 0);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1], d = null, v = null, E = null, S = null, w = null, N = null, M = null, Y = null;
          return w = this._hi / a, Y = (d = (N = c.SPLIT * w) - (d = N - w)) * (E = (Y = c.SPLIT * a) - (E = Y - a)) - (M = w * a) + d * (S = a - E) + (v = w - d) * E + v * S, Y = w + (N = (this._hi - M - Y + this._lo - w * l) / a), this._hi = Y, this._lo = w - Y + N, this;
        }
      } }, { key: "dump", value: function() {
        return "DD<" + this._hi + ", " + this._lo + ">";
      } }, { key: "divide", value: function() {
        if (arguments[0] instanceof c) {
          var n = arguments[0], o = null, a = null, l = null, d = null, v = null, E = null, S = null, w = null;
          a = (v = this._hi / n._hi) - (o = (E = c.SPLIT * v) - (o = E - v)), w = o * (l = (w = c.SPLIT * n._hi) - (l = w - n._hi)) - (S = v * n._hi) + o * (d = n._hi - l) + a * l + a * d;
          var N = w = v + (E = (this._hi - S - w + this._lo - v * n._lo) / n._hi), M = v - w + E;
          return new c(N, M);
        }
        if (typeof arguments[0] == "number") {
          var Y = arguments[0];
          return Z.isNaN(Y) ? c.createNaN() : c.copy(this).selfDivide(Y, 0);
        }
      } }, { key: "ge", value: function(n) {
        return this._hi > n._hi || this._hi === n._hi && this._lo >= n._lo;
      } }, { key: "pow", value: function(n) {
        if (n === 0) return c.valueOf(1);
        var o = new c(this), a = c.valueOf(1), l = Math.abs(n);
        if (l > 1) for (; l > 0; ) l % 2 == 1 && a.selfMultiply(o), (l /= 2) > 0 && (o = o.sqr());
        else a = o;
        return n < 0 ? a.reciprocal() : a;
      } }, { key: "ceil", value: function() {
        if (this.isNaN()) return c.NaN;
        var n = Math.ceil(this._hi), o = 0;
        return n === this._hi && (o = Math.ceil(this._lo)), new c(n, o);
      } }, { key: "compareTo", value: function(n) {
        var o = n;
        return this._hi < o._hi ? -1 : this._hi > o._hi ? 1 : this._lo < o._lo ? -1 : this._lo > o._lo ? 1 : 0;
      } }, { key: "rint", value: function() {
        return this.isNaN() ? this : this.add(0.5).floor();
      } }, { key: "setValue", value: function() {
        if (arguments[0] instanceof c) {
          var n = arguments[0];
          return this.init(n), this;
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return this.init(o), this;
        }
      } }, { key: "max", value: function(n) {
        return this.ge(n) ? this : n;
      } }, { key: "sqrt", value: function() {
        if (this.isZero()) return c.valueOf(0);
        if (this.isNegative()) return c.NaN;
        var n = 1 / Math.sqrt(this._hi), o = this._hi * n, a = c.valueOf(o), l = this.subtract(a.sqr())._hi * (0.5 * n);
        return a.add(l);
      } }, { key: "selfAdd", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof c) {
            var n = arguments[0];
            return this.selfAdd(n._hi, n._lo);
          }
          if (typeof arguments[0] == "number") {
            var o = arguments[0], a = null, l = null, d = null, v = null, E = null, S = null;
            return v = (d = this._hi + o) - (E = d - this._hi), l = (S = (v = o - E + (this._hi - v)) + this._lo) + (d - (a = d + S)), this._hi = a + l, this._lo = l + (a - this._hi), this;
          }
        } else if (arguments.length === 2) {
          var w = arguments[0], N = arguments[1], M = null, Y = null, W = null, q = null, it = null, at = null, ft = null;
          q = this._hi + w, Y = this._lo + N, it = q - (at = q - this._hi), W = Y - (ft = Y - this._lo);
          var kt = (M = q + (at = (it = w - at + (this._hi - it)) + Y)) + (at = (W = N - ft + (this._lo - W)) + (at + (q - M))), Pt = at + (M - kt);
          return this._hi = kt, this._lo = Pt, this;
        }
      } }, { key: "selfMultiply", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof c) {
            var n = arguments[0];
            return this.selfMultiply(n._hi, n._lo);
          }
          if (typeof arguments[0] == "number") {
            var o = arguments[0];
            return this.selfMultiply(o, 0);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1], d = null, v = null, E = null, S = null, w = null, N = null;
          d = (w = c.SPLIT * this._hi) - this._hi, N = c.SPLIT * a, d = w - d, v = this._hi - d, E = N - a;
          var M = (w = this._hi * a) + (N = d * (E = N - E) - w + d * (S = a - E) + v * E + v * S + (this._hi * l + this._lo * a)), Y = N + (d = w - M);
          return this._hi = M, this._lo = Y, this;
        }
      } }, { key: "selfSqr", value: function() {
        return this.selfMultiply(this);
      } }, { key: "floor", value: function() {
        if (this.isNaN()) return c.NaN;
        var n = Math.floor(this._hi), o = 0;
        return n === this._hi && (o = Math.floor(this._lo)), new c(n, o);
      } }, { key: "negate", value: function() {
        return this.isNaN() ? this : new c(-this._hi, -this._lo);
      } }, { key: "clone", value: function() {
        try {
          return null;
        } catch (n) {
          if (n instanceof CloneNotSupportedException) return null;
          throw n;
        }
      } }, { key: "multiply", value: function() {
        if (arguments[0] instanceof c) {
          var n = arguments[0];
          return n.isNaN() ? c.createNaN() : c.copy(this).selfMultiply(n);
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return Z.isNaN(o) ? c.createNaN() : c.copy(this).selfMultiply(o, 0);
        }
      } }, { key: "isNaN", value: function() {
        return Z.isNaN(this._hi);
      } }, { key: "intValue", value: function() {
        return Math.trunc(this._hi);
      } }, { key: "toString", value: function() {
        var n = c.magnitude(this._hi);
        return n >= -3 && n <= 20 ? this.toStandardNotation() : this.toSciNotation();
      } }, { key: "toStandardNotation", value: function() {
        var n = this.getSpecialNumberString();
        if (n !== null) return n;
        var o = new Array(1).fill(null), a = this.extractSignificantDigits(!0, o), l = o[0] + 1, d = a;
        if (a.charAt(0) === ".") d = "0" + a;
        else if (l < 0) d = "0." + c.stringOfChar("0", -l) + a;
        else if (a.indexOf(".") === -1) {
          var v = l - a.length;
          d = a + c.stringOfChar("0", v) + ".0";
        }
        return this.isNegative() ? "-" + d : d;
      } }, { key: "reciprocal", value: function() {
        var n, o, a, l, d = null, v = null, E = null, S = null;
        n = (a = 1 / this._hi) - (d = (E = c.SPLIT * a) - (d = E - a)), v = (S = c.SPLIT * this._hi) - this._hi;
        var w = a + (E = (1 - (l = a * this._hi) - (S = d * (v = S - v) - l + d * (o = this._hi - v) + n * v + n * o) - a * this._lo) / this._hi);
        return new c(w, a - w + E);
      } }, { key: "toSciNotation", value: function() {
        if (this.isZero()) return c.SCI_NOT_ZERO;
        var n = this.getSpecialNumberString();
        if (n !== null) return n;
        var o = new Array(1).fill(null), a = this.extractSignificantDigits(!1, o), l = c.SCI_NOT_EXPONENT_CHAR + o[0];
        if (a.charAt(0) === "0") throw new IllegalStateException("Found leading zero: " + a);
        var d = "";
        a.length > 1 && (d = a.substring(1));
        var v = a.charAt(0) + "." + d;
        return this.isNegative() ? "-" + v + l : v + l;
      } }, { key: "abs", value: function() {
        return this.isNaN() ? c.NaN : this.isNegative() ? this.negate() : new c(this);
      } }, { key: "isPositive", value: function() {
        return this._hi > 0 || this._hi === 0 && this._lo > 0;
      } }, { key: "lt", value: function(n) {
        return this._hi < n._hi || this._hi === n._hi && this._lo < n._lo;
      } }, { key: "add", value: function() {
        if (arguments[0] instanceof c) {
          var n = arguments[0];
          return c.copy(this).selfAdd(n);
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return c.copy(this).selfAdd(o);
        }
      } }, { key: "init", value: function() {
        if (arguments.length === 1) {
          if (typeof arguments[0] == "number") {
            var n = arguments[0];
            this._hi = n, this._lo = 0;
          } else if (arguments[0] instanceof c) {
            var o = arguments[0];
            this._hi = o._hi, this._lo = o._lo;
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this._hi = a, this._lo = l;
        }
      } }, { key: "gt", value: function(n) {
        return this._hi > n._hi || this._hi === n._hi && this._lo > n._lo;
      } }, { key: "isNegative", value: function() {
        return this._hi < 0 || this._hi === 0 && this._lo < 0;
      } }, { key: "trunc", value: function() {
        return this.isNaN() ? c.NaN : this.isPositive() ? this.floor() : this.ceil();
      } }, { key: "signum", value: function() {
        return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
      } }, { key: "interfaces_", get: function() {
        return [B, F, G];
      } }], [{ key: "constructor_", value: function() {
        if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0);
        else if (arguments.length === 1) {
          if (typeof arguments[0] == "number") {
            var n = arguments[0];
            this.init(n);
          } else if (arguments[0] instanceof c) {
            var o = arguments[0];
            this.init(o);
          } else if (typeof arguments[0] == "string") {
            var a = arguments[0];
            c.constructor_.call(this, c.parse(a));
          }
        } else if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          this.init(l, d);
        }
      } }, { key: "determinant", value: function() {
        if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var n = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
          return c.determinant(c.valueOf(n), c.valueOf(o), c.valueOf(a), c.valueOf(l));
        }
        if (arguments[3] instanceof c && arguments[2] instanceof c && arguments[0] instanceof c && arguments[1] instanceof c) {
          var d = arguments[0], v = arguments[1], E = arguments[2], S = arguments[3], w = d.multiply(S).selfSubtract(v.multiply(E));
          return w;
        }
      } }, { key: "sqr", value: function(n) {
        return c.valueOf(n).selfMultiply(n);
      } }, { key: "valueOf", value: function() {
        if (typeof arguments[0] == "string") {
          var n = arguments[0];
          return c.parse(n);
        }
        if (typeof arguments[0] == "number") {
          var o = arguments[0];
          return new c(o);
        }
      } }, { key: "sqrt", value: function(n) {
        return c.valueOf(n).sqrt();
      } }, { key: "parse", value: function(n) {
        for (var o = 0, a = n.length; ui.isWhitespace(n.charAt(o)); ) o++;
        var l = !1;
        if (o < a) {
          var d = n.charAt(o);
          d !== "-" && d !== "+" || (o++, d === "-" && (l = !0));
        }
        for (var v = new c(), E = 0, S = 0, w = 0, N = !1; !(o >= a); ) {
          var M = n.charAt(o);
          if (o++, ui.isDigit(M)) {
            var Y = M - "0";
            v.selfMultiply(c.TEN), v.selfAdd(Y), E++;
          } else {
            if (M !== ".") {
              if (M === "e" || M === "E") {
                var W = n.substring(o);
                try {
                  w = Mn.parseInt(W);
                } catch (kt) {
                  throw kt instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + W + " in string " + n) : kt;
                }
                break;
              }
              throw new NumberFormatException("Unexpected character '" + M + "' at position " + o + " in string " + n);
            }
            S = E, N = !0;
          }
        }
        var q = v;
        N || (S = E);
        var it = E - S - w;
        if (it === 0) q = v;
        else if (it > 0) {
          var at = c.TEN.pow(it);
          q = v.divide(at);
        } else if (it < 0) {
          var ft = c.TEN.pow(-it);
          q = v.multiply(ft);
        }
        return l ? q.negate() : q;
      } }, { key: "createNaN", value: function() {
        return new c(Z.NaN, Z.NaN);
      } }, { key: "copy", value: function(n) {
        return new c(n);
      } }, { key: "magnitude", value: function(n) {
        var o = Math.abs(n), a = Math.log(o) / Math.log(10), l = Math.trunc(Math.floor(a));
        return 10 * Math.pow(10, l) <= o && (l += 1), l;
      } }, { key: "stringOfChar", value: function(n, o) {
        for (var a = new Ge(), l = 0; l < o; l++) a.append(n);
        return a.toString();
      } }]), c;
    }();
    rt.PI = new rt(3.141592653589793, 12246467991473532e-32), rt.TWO_PI = new rt(6.283185307179586, 24492935982947064e-32), rt.PI_2 = new rt(1.5707963267948966, 6123233995736766e-32), rt.E = new rt(2.718281828459045, 14456468917292502e-32), rt.NaN = new rt(Z.NaN, Z.NaN), rt.EPS = 123259516440783e-46, rt.SPLIT = 134217729, rt.MAX_PRINT_DIGITS = 32, rt.TEN = rt.valueOf(10), rt.ONE = rt.valueOf(1), rt.SCI_NOT_EXPONENT_CHAR = "E", rt.SCI_NOT_ZERO = "0.0E0";
    var On = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "orientationIndex", value: function(n, o, a) {
        var l = c.orientationIndexFilter(n, o, a);
        if (l <= 1) return l;
        var d = rt.valueOf(o.x).selfAdd(-n.x), v = rt.valueOf(o.y).selfAdd(-n.y), E = rt.valueOf(a.x).selfAdd(-o.x), S = rt.valueOf(a.y).selfAdd(-o.y);
        return d.selfMultiply(S).selfSubtract(v.selfMultiply(E)).signum();
      } }, { key: "signOfDet2x2", value: function() {
        if (arguments[3] instanceof rt && arguments[2] instanceof rt && arguments[0] instanceof rt && arguments[1] instanceof rt) {
          var n = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3], d = n.multiply(l).selfSubtract(o.multiply(a));
          return d.signum();
        }
        if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var v = arguments[0], E = arguments[1], S = arguments[2], w = arguments[3], N = rt.valueOf(v), M = rt.valueOf(E), Y = rt.valueOf(S), W = rt.valueOf(w), q = N.multiply(W).selfSubtract(M.multiply(Y));
          return q.signum();
        }
      } }, { key: "intersection", value: function(n, o, a, l) {
        var d = new rt(n.y).selfSubtract(o.y), v = new rt(o.x).selfSubtract(n.x), E = new rt(n.x).selfMultiply(o.y).selfSubtract(new rt(o.x).selfMultiply(n.y)), S = new rt(a.y).selfSubtract(l.y), w = new rt(l.x).selfSubtract(a.x), N = new rt(a.x).selfMultiply(l.y).selfSubtract(new rt(l.x).selfMultiply(a.y)), M = v.multiply(N).selfSubtract(w.multiply(E)), Y = S.multiply(E).selfSubtract(d.multiply(N)), W = d.multiply(w).selfSubtract(S.multiply(v)), q = M.selfDivide(W).doubleValue(), it = Y.selfDivide(W).doubleValue();
        return Z.isNaN(q) || Z.isInfinite(q) || Z.isNaN(it) || Z.isInfinite(it) ? null : new P(q, it);
      } }, { key: "orientationIndexFilter", value: function(n, o, a) {
        var l = null, d = (n.x - a.x) * (o.y - a.y), v = (n.y - a.y) * (o.x - a.x), E = d - v;
        if (d > 0) {
          if (v <= 0) return c.signum(E);
          l = d + v;
        } else {
          if (!(d < 0) || v >= 0) return c.signum(E);
          l = -d - v;
        }
        var S = c.DP_SAFE_EPSILON * l;
        return E >= S || -E >= S ? c.signum(E) : 2;
      } }, { key: "signum", value: function(n) {
        return n > 0 ? 1 : n < 0 ? -1 : 0;
      } }]), c;
    }();
    On.DP_SAFE_EPSILON = 1e-15;
    var vt = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "getM", value: function(n) {
        if (this.hasM()) {
          var o = this.getDimension() - this.getMeasures();
          return this.getOrdinate(n, o);
        }
        return Z.NaN;
      } }, { key: "setOrdinate", value: function(n, o, a) {
      } }, { key: "getZ", value: function(n) {
        return this.hasZ() ? this.getOrdinate(n, 2) : Z.NaN;
      } }, { key: "size", value: function() {
      } }, { key: "getOrdinate", value: function(n, o) {
      } }, { key: "getCoordinate", value: function() {
      } }, { key: "getCoordinateCopy", value: function(n) {
      } }, { key: "createCoordinate", value: function() {
      } }, { key: "getDimension", value: function() {
      } }, { key: "hasM", value: function() {
        return this.getMeasures() > 0;
      } }, { key: "getX", value: function(n) {
      } }, { key: "hasZ", value: function() {
        return this.getDimension() - this.getMeasures() > 2;
      } }, { key: "getMeasures", value: function() {
        return 0;
      } }, { key: "expandEnvelope", value: function(n) {
      } }, { key: "copy", value: function() {
      } }, { key: "getY", value: function(n) {
      } }, { key: "toCoordinateArray", value: function() {
      } }, { key: "interfaces_", get: function() {
        return [G];
      } }]), c;
    }();
    vt.X = 0, vt.Y = 1, vt.Z = 2, vt.M = 3;
    var ut = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "index", value: function(n, o, a) {
        return On.orientationIndex(n, o, a);
      } }, { key: "isCCW", value: function() {
        if (arguments[0] instanceof Array) {
          var n = arguments[0], o = n.length - 1;
          if (o < 3) throw new L("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var a = n[0], l = 0, d = 1; d <= o; d++) {
            var v = n[d];
            v.y > a.y && (a = v, l = d);
          }
          var E = l;
          do
            (E -= 1) < 0 && (E = o);
          while (n[E].equals2D(a) && E !== l);
          var S = l;
          do
            S = (S + 1) % o;
          while (n[S].equals2D(a) && S !== l);
          var w = n[E], N = n[S];
          if (w.equals2D(a) || N.equals2D(a) || w.equals2D(N)) return !1;
          var M = c.index(w, a, N), Y = null;
          return Y = M === 0 ? w.x > N.x : M > 0, Y;
        }
        if (ht(arguments[0], vt)) {
          var W = arguments[0], q = W.size() - 1;
          if (q < 3) throw new L("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var it = W.getCoordinate(0), at = 0, ft = 1; ft <= q; ft++) {
            var kt = W.getCoordinate(ft);
            kt.y > it.y && (it = kt, at = ft);
          }
          var Pt = null, Jt = at;
          do
            (Jt -= 1) < 0 && (Jt = q), Pt = W.getCoordinate(Jt);
          while (Pt.equals2D(it) && Jt !== at);
          var _e = null, ze = at;
          do
            ze = (ze + 1) % q, _e = W.getCoordinate(ze);
          while (_e.equals2D(it) && ze !== at);
          if (Pt.equals2D(it) || _e.equals2D(it) || Pt.equals2D(_e)) return !1;
          var dn = c.index(Pt, it, _e);
          return dn === 0 ? Pt.x > _e.x : dn > 0;
        }
      } }]), c;
    }();
    ut.CLOCKWISE = -1, ut.RIGHT = ut.CLOCKWISE, ut.COUNTERCLOCKWISE = 1, ut.LEFT = ut.COUNTERCLOCKWISE, ut.COLLINEAR = 0, ut.STRAIGHT = ut.COLLINEAR;
    var Ps = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getCoordinate", value: function() {
        return this._minCoord;
      } }, { key: "getRightmostSide", value: function(n, o) {
        var a = this.getRightmostSideOfSegment(n, o);
        return a < 0 && (a = this.getRightmostSideOfSegment(n, o - 1)), a < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(n)), a;
      } }, { key: "findRightmostEdgeAtVertex", value: function() {
        var n = this._minDe.getEdge().getCoordinates();
        z.isTrue(this._minIndex > 0 && this._minIndex < n.length, "rightmost point expected to be interior vertex of edge");
        var o = n[this._minIndex - 1], a = n[this._minIndex + 1], l = ut.index(this._minCoord, a, o), d = !1;
        (o.y < this._minCoord.y && a.y < this._minCoord.y && l === ut.COUNTERCLOCKWISE || o.y > this._minCoord.y && a.y > this._minCoord.y && l === ut.CLOCKWISE) && (d = !0), d && (this._minIndex = this._minIndex - 1);
      } }, { key: "getRightmostSideOfSegment", value: function(n, o) {
        var a = n.getEdge().getCoordinates();
        if (o < 0 || o + 1 >= a.length || a[o].y === a[o + 1].y) return -1;
        var l = U.LEFT;
        return a[o].y < a[o + 1].y && (l = U.RIGHT), l;
      } }, { key: "getEdge", value: function() {
        return this._orientedDe;
      } }, { key: "checkForRightmostCoordinate", value: function(n) {
        for (var o = n.getEdge().getCoordinates(), a = 0; a < o.length - 1; a++) (this._minCoord === null || o[a].x > this._minCoord.x) && (this._minDe = n, this._minIndex = a, this._minCoord = o[a]);
      } }, { key: "findRightmostEdgeAtNode", value: function() {
        var n = this._minDe.getNode().getEdges();
        this._minDe = n.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
      } }, { key: "findEdge", value: function(n) {
        for (var o = n.iterator(); o.hasNext(); ) {
          var a = o.next();
          a.isForward() && this.checkForRightmostCoordinate(a);
        }
        z.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === U.LEFT && (this._orientedDe = this._minDe.getSym());
      } }], [{ key: "constructor_", value: function() {
        this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
      } }]), c;
    }(), de = function(c) {
      u(o, c);
      var n = x(o);
      function o(a, l) {
        var d;
        return e(this, o), (d = n.call(this, l ? a + " [ " + l + " ]" : a)).pt = l ? new P(l) : void 0, d.name = Object.keys({ TopologyException: o })[0], d;
      }
      return s(o, [{ key: "getCoordinate", value: function() {
        return this.pt;
      } }]), o;
    }(mt), pa = function() {
      function c() {
        e(this, c), this.array = [];
      }
      return s(c, [{ key: "addLast", value: function(n) {
        this.array.push(n);
      } }, { key: "removeFirst", value: function() {
        return this.array.shift();
      } }, { key: "isEmpty", value: function() {
        return this.array.length === 0;
      } }]), c;
    }(), ot = function(c, n) {
      u(a, c);
      var o = x(a);
      function a(l) {
        var d;
        return e(this, a), (d = o.call(this)).array = [], l instanceof Ie && d.addAll(l), d;
      }
      return s(a, [{ key: "interfaces_", get: function() {
        return [Fe, Ie];
      } }, { key: "ensureCapacity", value: function() {
      } }, { key: "add", value: function(l) {
        return arguments.length === 1 ? this.array.push(l) : this.array.splice(arguments[0], 0, arguments[1]), !0;
      } }, { key: "clear", value: function() {
        this.array = [];
      } }, { key: "addAll", value: function(l) {
        var d, v = b(l);
        try {
          for (v.s(); !(d = v.n()).done; ) {
            var E = d.value;
            this.array.push(E);
          }
        } catch (S) {
          v.e(S);
        } finally {
          v.f();
        }
      } }, { key: "set", value: function(l, d) {
        var v = this.array[l];
        return this.array[l] = d, v;
      } }, { key: "iterator", value: function() {
        return new Ds(this);
      } }, { key: "get", value: function(l) {
        if (l < 0 || l >= this.size()) throw new Mr();
        return this.array[l];
      } }, { key: "isEmpty", value: function() {
        return this.array.length === 0;
      } }, { key: "sort", value: function(l) {
        l ? this.array.sort(function(d, v) {
          return l.compare(d, v);
        }) : this.array.sort();
      } }, { key: "size", value: function() {
        return this.array.length;
      } }, { key: "toArray", value: function() {
        return this.array.slice();
      } }, { key: "remove", value: function(l) {
        for (var d = 0, v = this.array.length; d < v; d++) if (this.array[d] === l) return !!this.array.splice(d, 1);
        return !1;
      } }, { key: n, value: function() {
        return this.array.values();
      } }]), a;
    }(Fe, Symbol.iterator), Ds = function() {
      function c(n) {
        e(this, c), this.arrayList = n, this.position = 0;
      }
      return s(c, [{ key: "next", value: function() {
        if (this.position === this.arrayList.size()) throw new Gi();
        return this.arrayList.get(this.position++);
      } }, { key: "hasNext", value: function() {
        return this.position < this.arrayList.size();
      } }, { key: "set", value: function(n) {
        return this.arrayList.set(this.position - 1, n);
      } }, { key: "remove", value: function() {
        this.arrayList.remove(this.arrayList.get(this.position));
      } }]), c;
    }(), Fs = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "clearVisitedEdges", value: function() {
        for (var n = this._dirEdgeList.iterator(); n.hasNext(); )
          n.next().setVisited(!1);
      } }, { key: "getRightmostCoordinate", value: function() {
        return this._rightMostCoord;
      } }, { key: "computeNodeDepth", value: function(n) {
        for (var o = null, a = n.getEdges().iterator(); a.hasNext(); ) {
          var l = a.next();
          if (l.isVisited() || l.getSym().isVisited()) {
            o = l;
            break;
          }
        }
        if (o === null) throw new de("unable to find edge to compute depths at " + n.getCoordinate());
        n.getEdges().computeDepths(o);
        for (var d = n.getEdges().iterator(); d.hasNext(); ) {
          var v = d.next();
          v.setVisited(!0), this.copySymDepths(v);
        }
      } }, { key: "computeDepth", value: function(n) {
        this.clearVisitedEdges();
        var o = this._finder.getEdge();
        o.getNode(), o.getLabel(), o.setEdgeDepths(U.RIGHT, n), this.copySymDepths(o), this.computeDepths(o);
      } }, { key: "create", value: function(n) {
        this.addReachable(n), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
      } }, { key: "findResultEdges", value: function() {
        for (var n = this._dirEdgeList.iterator(); n.hasNext(); ) {
          var o = n.next();
          o.getDepth(U.RIGHT) >= 1 && o.getDepth(U.LEFT) <= 0 && !o.isInteriorAreaEdge() && o.setInResult(!0);
        }
      } }, { key: "computeDepths", value: function(n) {
        var o = new ai(), a = new pa(), l = n.getNode();
        for (a.addLast(l), o.add(l), n.setVisited(!0); !a.isEmpty(); ) {
          var d = a.removeFirst();
          o.add(d), this.computeNodeDepth(d);
          for (var v = d.getEdges().iterator(); v.hasNext(); ) {
            var E = v.next().getSym();
            if (!E.isVisited()) {
              var S = E.getNode();
              o.contains(S) || (a.addLast(S), o.add(S));
            }
          }
        }
      } }, { key: "compareTo", value: function(n) {
        var o = n;
        return this._rightMostCoord.x < o._rightMostCoord.x ? -1 : this._rightMostCoord.x > o._rightMostCoord.x ? 1 : 0;
      } }, { key: "getEnvelope", value: function() {
        if (this._env === null) {
          for (var n = new bt(), o = this._dirEdgeList.iterator(); o.hasNext(); ) for (var a = o.next().getEdge().getCoordinates(), l = 0; l < a.length - 1; l++) n.expandToInclude(a[l]);
          this._env = n;
        }
        return this._env;
      } }, { key: "addReachable", value: function(n) {
        var o = new ya();
        for (o.add(n); !o.empty(); ) {
          var a = o.pop();
          this.add(a, o);
        }
      } }, { key: "copySymDepths", value: function(n) {
        var o = n.getSym();
        o.setDepth(U.LEFT, n.getDepth(U.RIGHT)), o.setDepth(U.RIGHT, n.getDepth(U.LEFT));
      } }, { key: "add", value: function(n, o) {
        n.setVisited(!0), this._nodes.add(n);
        for (var a = n.getEdges().iterator(); a.hasNext(); ) {
          var l = a.next();
          this._dirEdgeList.add(l);
          var d = l.getSym().getNode();
          d.isVisited() || o.push(d);
        }
      } }, { key: "getNodes", value: function() {
        return this._nodes;
      } }, { key: "getDirectedEdges", value: function() {
        return this._dirEdgeList;
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }], [{ key: "constructor_", value: function() {
        this._finder = null, this._dirEdgeList = new ot(), this._nodes = new ot(), this._rightMostCoord = null, this._env = null, this._finder = new Ps();
      } }]), c;
    }(), li = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "intersection", value: function(n, o, a, l) {
        var d = n.x < o.x ? n.x : o.x, v = n.y < o.y ? n.y : o.y, E = n.x > o.x ? n.x : o.x, S = n.y > o.y ? n.y : o.y, w = a.x < l.x ? a.x : l.x, N = a.y < l.y ? a.y : l.y, M = a.x > l.x ? a.x : l.x, Y = a.y > l.y ? a.y : l.y, W = ((d > w ? d : w) + (E < M ? E : M)) / 2, q = ((v > N ? v : N) + (S < Y ? S : Y)) / 2, it = n.x - W, at = n.y - q, ft = o.x - W, kt = o.y - q, Pt = a.x - W, Jt = a.y - q, _e = l.x - W, ze = l.y - q, dn = at - kt, di = ft - it, Br = it * kt - ft * at, Yr = Jt - ze, ji = _e - Pt, Nh = Pt * ze - _e * Jt, Mh = dn * ji - Yr * di, Ma = (di * Nh - ji * Br) / Mh, Oa = (Yr * Br - dn * Nh) / Mh;
        return Z.isNaN(Ma) || Z.isInfinite(Ma) || Z.isNaN(Oa) || Z.isInfinite(Oa) ? null : new P(Ma + W, Oa + q);
      } }]), c;
    }(), re = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "arraycopy", value: function(n, o, a, l, d) {
        for (var v = 0, E = o; E < o + d; E++) a[l + v] = n[E], v++;
      } }, { key: "getProperty", value: function(n) {
        return { "line.separator": `
` }[n];
      } }]), c;
    }(), cn = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "log10", value: function(n) {
        var o = Math.log(n);
        return Z.isInfinite(o) || Z.isNaN(o) ? o : o / c.LOG_10;
      } }, { key: "min", value: function(n, o, a, l) {
        var d = n;
        return o < d && (d = o), a < d && (d = a), l < d && (d = l), d;
      } }, { key: "clamp", value: function() {
        if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var n = arguments[0], o = arguments[1], a = arguments[2];
          return n < o ? o : n > a ? a : n;
        }
        if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
          var l = arguments[0], d = arguments[1], v = arguments[2];
          return l < d ? d : l > v ? v : l;
        }
      } }, { key: "wrap", value: function(n, o) {
        return n < 0 ? o - -n % o : n % o;
      } }, { key: "max", value: function() {
        if (arguments.length === 3) {
          var n = arguments[0], o = arguments[1], a = arguments[2], l = n;
          return o > l && (l = o), a > l && (l = a), l;
        }
        if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], E = arguments[2], S = arguments[3], w = d;
          return v > w && (w = v), E > w && (w = E), S > w && (w = S), w;
        }
      } }, { key: "average", value: function(n, o) {
        return (n + o) / 2;
      } }]), c;
    }();
    cn.LOG_10 = Math.log(10);
    var Ht = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "segmentToSegment", value: function(n, o, a, l) {
        if (n.equals(o)) return c.pointToSegment(n, a, l);
        if (a.equals(l)) return c.pointToSegment(l, n, o);
        var d = !1;
        if (bt.intersects(n, o, a, l)) {
          var v = (o.x - n.x) * (l.y - a.y) - (o.y - n.y) * (l.x - a.x);
          if (v === 0) d = !0;
          else {
            var E = (n.y - a.y) * (l.x - a.x) - (n.x - a.x) * (l.y - a.y), S = ((n.y - a.y) * (o.x - n.x) - (n.x - a.x) * (o.y - n.y)) / v, w = E / v;
            (w < 0 || w > 1 || S < 0 || S > 1) && (d = !0);
          }
        } else d = !0;
        return d ? cn.min(c.pointToSegment(n, a, l), c.pointToSegment(o, a, l), c.pointToSegment(a, n, o), c.pointToSegment(l, n, o)) : 0;
      } }, { key: "pointToSegment", value: function(n, o, a) {
        if (o.x === a.x && o.y === a.y) return n.distance(o);
        var l = (a.x - o.x) * (a.x - o.x) + (a.y - o.y) * (a.y - o.y), d = ((n.x - o.x) * (a.x - o.x) + (n.y - o.y) * (a.y - o.y)) / l;
        if (d <= 0) return n.distance(o);
        if (d >= 1) return n.distance(a);
        var v = ((o.y - n.y) * (a.x - o.x) - (o.x - n.x) * (a.y - o.y)) / l;
        return Math.abs(v) * Math.sqrt(l);
      } }, { key: "pointToLinePerpendicular", value: function(n, o, a) {
        var l = (a.x - o.x) * (a.x - o.x) + (a.y - o.y) * (a.y - o.y), d = ((o.y - n.y) * (a.x - o.x) - (o.x - n.x) * (a.y - o.y)) / l;
        return Math.abs(d) * Math.sqrt(l);
      } }, { key: "pointToSegmentString", value: function(n, o) {
        if (o.length === 0) throw new L("Line array must contain at least one vertex");
        for (var a = n.distance(o[0]), l = 0; l < o.length - 1; l++) {
          var d = c.pointToSegment(n, o[l], o[l + 1]);
          d < a && (a = d);
        }
        return a;
      } }]), c;
    }(), Ln = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "create", value: function() {
        if (arguments.length === 1) arguments[0] instanceof Array || ht(arguments[0], vt);
        else if (arguments.length !== 2) {
          if (arguments.length === 3) {
            var n = arguments[0], o = arguments[1];
            return this.create(n, o);
          }
        }
      } }]), c;
    }(), He = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "filter", value: function(n) {
      } }]), c;
    }(), Gs = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "ofLine", value: function(n) {
        var o = n.size();
        if (o <= 1) return 0;
        var a = 0, l = new P();
        n.getCoordinate(0, l);
        for (var d = l.x, v = l.y, E = 1; E < o; E++) {
          n.getCoordinate(E, l);
          var S = l.x, w = l.y, N = S - d, M = w - v;
          a += Math.sqrt(N * N + M * M), d = S, v = w;
        }
        return a;
      } }]), c;
    }(), Or = function c() {
      e(this, c);
    }, Bt = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "copyCoord", value: function(n, o, a, l) {
        for (var d = Math.min(n.getDimension(), a.getDimension()), v = 0; v < d; v++) a.setOrdinate(l, v, n.getOrdinate(o, v));
      } }, { key: "isRing", value: function(n) {
        var o = n.size();
        return o === 0 || !(o <= 3) && n.getOrdinate(0, vt.X) === n.getOrdinate(o - 1, vt.X) && n.getOrdinate(0, vt.Y) === n.getOrdinate(o - 1, vt.Y);
      } }, { key: "scroll", value: function() {
        if (arguments.length === 2) {
          if (ht(arguments[0], vt) && Number.isInteger(arguments[1])) {
            var n = arguments[0], o = arguments[1];
            c.scroll(n, o, c.isRing(n));
          } else if (ht(arguments[0], vt) && arguments[1] instanceof P) {
            var a = arguments[0], l = arguments[1], d = c.indexOf(l, a);
            if (d <= 0) return null;
            c.scroll(a, d);
          }
        } else if (arguments.length === 3) {
          var v = arguments[0], E = arguments[1], S = arguments[2], w = E;
          if (w <= 0) return null;
          for (var N = v.copy(), M = S ? v.size() - 1 : v.size(), Y = 0; Y < M; Y++) for (var W = 0; W < v.getDimension(); W++) v.setOrdinate(Y, W, N.getOrdinate((E + Y) % M, W));
          if (S) for (var q = 0; q < v.getDimension(); q++) v.setOrdinate(M, q, v.getOrdinate(0, q));
        }
      } }, { key: "isEqual", value: function(n, o) {
        var a = n.size();
        if (a !== o.size()) return !1;
        for (var l = Math.min(n.getDimension(), o.getDimension()), d = 0; d < a; d++) for (var v = 0; v < l; v++) {
          var E = n.getOrdinate(d, v), S = o.getOrdinate(d, v);
          if (n.getOrdinate(d, v) !== o.getOrdinate(d, v) && (!Z.isNaN(E) || !Z.isNaN(S))) return !1;
        }
        return !0;
      } }, { key: "minCoordinateIndex", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return c.minCoordinateIndex(n, 0, n.size() - 1);
        }
        if (arguments.length === 3) {
          for (var o = arguments[0], a = arguments[1], l = arguments[2], d = -1, v = null, E = a; E <= l; E++) {
            var S = o.getCoordinate(E);
            (v === null || v.compareTo(S) > 0) && (v = S, d = E);
          }
          return d;
        }
      } }, { key: "extend", value: function(n, o, a) {
        var l = n.create(a, o.getDimension()), d = o.size();
        if (c.copy(o, 0, l, 0, d), d > 0) for (var v = d; v < a; v++) c.copy(o, d - 1, l, v, 1);
        return l;
      } }, { key: "reverse", value: function(n) {
        for (var o = n.size() - 1, a = Math.trunc(o / 2), l = 0; l <= a; l++) c.swap(n, l, o - l);
      } }, { key: "swap", value: function(n, o, a) {
        if (o === a) return null;
        for (var l = 0; l < n.getDimension(); l++) {
          var d = n.getOrdinate(o, l);
          n.setOrdinate(o, l, n.getOrdinate(a, l)), n.setOrdinate(a, l, d);
        }
      } }, { key: "copy", value: function(n, o, a, l, d) {
        for (var v = 0; v < d; v++) c.copyCoord(n, o + v, a, l + v);
      } }, { key: "ensureValidRing", value: function(n, o) {
        var a = o.size();
        return a === 0 ? o : a <= 3 ? c.createClosedRing(n, o, 4) : o.getOrdinate(0, vt.X) === o.getOrdinate(a - 1, vt.X) && o.getOrdinate(0, vt.Y) === o.getOrdinate(a - 1, vt.Y) ? o : c.createClosedRing(n, o, a + 1);
      } }, { key: "indexOf", value: function(n, o) {
        for (var a = 0; a < o.size(); a++) if (n.x === o.getOrdinate(a, vt.X) && n.y === o.getOrdinate(a, vt.Y)) return a;
        return -1;
      } }, { key: "createClosedRing", value: function(n, o, a) {
        var l = n.create(a, o.getDimension()), d = o.size();
        c.copy(o, 0, l, 0, d);
        for (var v = d; v < a; v++) c.copy(o, 0, l, v, 1);
        return l;
      } }, { key: "minCoordinate", value: function(n) {
        for (var o = null, a = 0; a < n.size(); a++) {
          var l = n.getCoordinate(a);
          (o === null || o.compareTo(l) > 0) && (o = l);
        }
        return o;
      } }]), c;
    }(), j = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "toDimensionSymbol", value: function(n) {
        switch (n) {
          case c.FALSE:
            return c.SYM_FALSE;
          case c.TRUE:
            return c.SYM_TRUE;
          case c.DONTCARE:
            return c.SYM_DONTCARE;
          case c.P:
            return c.SYM_P;
          case c.L:
            return c.SYM_L;
          case c.A:
            return c.SYM_A;
        }
        throw new L("Unknown dimension value: " + n);
      } }, { key: "toDimensionValue", value: function(n) {
        switch (ui.toUpperCase(n)) {
          case c.SYM_FALSE:
            return c.FALSE;
          case c.SYM_TRUE:
            return c.TRUE;
          case c.SYM_DONTCARE:
            return c.DONTCARE;
          case c.SYM_P:
            return c.P;
          case c.SYM_L:
            return c.L;
          case c.SYM_A:
            return c.A;
        }
        throw new L("Unknown dimension symbol: " + n);
      } }]), c;
    }();
    j.P = 0, j.L = 1, j.A = 2, j.FALSE = -1, j.TRUE = -2, j.DONTCARE = -3, j.SYM_FALSE = "F", j.SYM_TRUE = "T", j.SYM_DONTCARE = "*", j.SYM_P = "0", j.SYM_L = "1", j.SYM_A = "2";
    var Ut = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "filter", value: function(n) {
      } }]), c;
    }(), se = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "filter", value: function(n, o) {
      } }, { key: "isDone", value: function() {
      } }, { key: "isGeometryChanged", value: function() {
      } }]), c;
    }(), zt = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "computeEnvelopeInternal", value: function() {
        return this.isEmpty() ? new bt() : this._points.expandEnvelope(new bt());
      } }, { key: "isRing", value: function() {
        return this.isClosed() && this.isSimple();
      } }, { key: "getCoordinates", value: function() {
        return this._points.toCoordinateArray();
      } }, { key: "copyInternal", value: function() {
        return new o(this._points.copy(), this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof et) {
          var a = arguments[0], l = arguments[1];
          if (!this.isEquivalentClass(a)) return !1;
          var d = a;
          if (this._points.size() !== d._points.size()) return !1;
          for (var v = 0; v < this._points.size(); v++) if (!this.equal(this._points.getCoordinate(v), d._points.getCoordinate(v), l)) return !1;
          return !0;
        }
        return I(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "normalize", value: function() {
        for (var a = 0; a < Math.trunc(this._points.size() / 2); a++) {
          var l = this._points.size() - 1 - a;
          if (!this._points.getCoordinate(a).equals(this._points.getCoordinate(l))) {
            if (this._points.getCoordinate(a).compareTo(this._points.getCoordinate(l)) > 0) {
              var d = this._points.copy();
              Bt.reverse(d), this._points = d;
            }
            return null;
          }
        }
      } }, { key: "getCoordinate", value: function() {
        return this.isEmpty() ? null : this._points.getCoordinate(0);
      } }, { key: "getBoundaryDimension", value: function() {
        return this.isClosed() ? j.FALSE : 0;
      } }, { key: "isClosed", value: function() {
        return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
      } }, { key: "reverseInternal", value: function() {
        var a = this._points.copy();
        return Bt.reverse(a), this.getFactory().createLineString(a);
      } }, { key: "getEndPoint", value: function() {
        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
      } }, { key: "getTypeCode", value: function() {
        return et.TYPECODE_LINESTRING;
      } }, { key: "getDimension", value: function() {
        return 1;
      } }, { key: "getLength", value: function() {
        return Gs.ofLine(this._points);
      } }, { key: "getNumPoints", value: function() {
        return this._points.size();
      } }, { key: "compareToSameClass", value: function() {
        if (arguments.length === 1) {
          for (var a = arguments[0], l = a, d = 0, v = 0; d < this._points.size() && v < l._points.size(); ) {
            var E = this._points.getCoordinate(d).compareTo(l._points.getCoordinate(v));
            if (E !== 0) return E;
            d++, v++;
          }
          return d < this._points.size() ? 1 : v < l._points.size() ? -1 : 0;
        }
        if (arguments.length === 2) {
          var S = arguments[0], w = arguments[1], N = S;
          return w.compare(this._points, N._points);
        }
      } }, { key: "apply", value: function() {
        if (ht(arguments[0], He)) for (var a = arguments[0], l = 0; l < this._points.size(); l++) a.filter(this._points.getCoordinate(l));
        else if (ht(arguments[0], se)) {
          var d = arguments[0];
          if (this._points.size() === 0) return null;
          for (var v = 0; v < this._points.size() && (d.filter(this._points, v), !d.isDone()); v++) ;
          d.isGeometryChanged() && this.geometryChanged();
        } else if (ht(arguments[0], Ut)) {
          var E = arguments[0];
          E.filter(this);
        } else if (ht(arguments[0], D)) {
          var S = arguments[0];
          S.filter(this);
        }
      } }, { key: "getBoundary", value: function() {
        throw new De();
      } }, { key: "isEquivalentClass", value: function(a) {
        return a instanceof o;
      } }, { key: "getCoordinateN", value: function(a) {
        return this._points.getCoordinate(a);
      } }, { key: "getGeometryType", value: function() {
        return et.TYPENAME_LINESTRING;
      } }, { key: "getCoordinateSequence", value: function() {
        return this._points;
      } }, { key: "isEmpty", value: function() {
        return this._points.size() === 0;
      } }, { key: "init", value: function(a) {
        if (a === null && (a = this.getFactory().getCoordinateSequenceFactory().create([])), a.size() === 1) throw new L("Invalid number of points in LineString (found " + a.size() + " - must be 0 or >= 2)");
        this._points = a;
      } }, { key: "isCoordinate", value: function(a) {
        for (var l = 0; l < this._points.size(); l++) if (this._points.getCoordinate(l).equals(a)) return !0;
        return !1;
      } }, { key: "getStartPoint", value: function() {
        return this.isEmpty() ? null : this.getPointN(0);
      } }, { key: "getPointN", value: function(a) {
        return this.getFactory().createPoint(this._points.getCoordinate(a));
      } }, { key: "interfaces_", get: function() {
        return [Or];
      } }], [{ key: "constructor_", value: function() {
        if (this._points = null, arguments.length !== 0) {
          if (arguments.length === 2) {
            var a = arguments[0], l = arguments[1];
            et.constructor_.call(this, l), this.init(a);
          }
        }
      } }]), o;
    }(et), we = function c() {
      e(this, c);
    }, ye = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "computeEnvelopeInternal", value: function() {
        if (this.isEmpty()) return new bt();
        var a = new bt();
        return a.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), a;
      } }, { key: "getCoordinates", value: function() {
        return this.isEmpty() ? [] : [this.getCoordinate()];
      } }, { key: "copyInternal", value: function() {
        return new o(this._coordinates.copy(), this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof et) {
          var a = arguments[0], l = arguments[1];
          return !!this.isEquivalentClass(a) && (!(!this.isEmpty() || !a.isEmpty()) || this.isEmpty() === a.isEmpty() && this.equal(a.getCoordinate(), this.getCoordinate(), l));
        }
        return I(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "normalize", value: function() {
      } }, { key: "getCoordinate", value: function() {
        return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
      } }, { key: "getBoundaryDimension", value: function() {
        return j.FALSE;
      } }, { key: "reverseInternal", value: function() {
        return this.getFactory().createPoint(this._coordinates.copy());
      } }, { key: "getTypeCode", value: function() {
        return et.TYPECODE_POINT;
      } }, { key: "getDimension", value: function() {
        return 0;
      } }, { key: "getNumPoints", value: function() {
        return this.isEmpty() ? 0 : 1;
      } }, { key: "getX", value: function() {
        if (this.getCoordinate() === null) throw new IllegalStateException("getX called on empty Point");
        return this.getCoordinate().x;
      } }, { key: "compareToSameClass", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0], l = a;
          return this.getCoordinate().compareTo(l.getCoordinate());
        }
        if (arguments.length === 2) {
          var d = arguments[0], v = arguments[1], E = d;
          return v.compare(this._coordinates, E._coordinates);
        }
      } }, { key: "apply", value: function() {
        if (ht(arguments[0], He)) {
          var a = arguments[0];
          if (this.isEmpty()) return null;
          a.filter(this.getCoordinate());
        } else if (ht(arguments[0], se)) {
          var l = arguments[0];
          if (this.isEmpty()) return null;
          l.filter(this._coordinates, 0), l.isGeometryChanged() && this.geometryChanged();
        } else if (ht(arguments[0], Ut)) {
          var d = arguments[0];
          d.filter(this);
        } else if (ht(arguments[0], D)) {
          var v = arguments[0];
          v.filter(this);
        }
      } }, { key: "getBoundary", value: function() {
        return this.getFactory().createGeometryCollection();
      } }, { key: "getGeometryType", value: function() {
        return et.TYPENAME_POINT;
      } }, { key: "getCoordinateSequence", value: function() {
        return this._coordinates;
      } }, { key: "getY", value: function() {
        if (this.getCoordinate() === null) throw new IllegalStateException("getY called on empty Point");
        return this.getCoordinate().y;
      } }, { key: "isEmpty", value: function() {
        return this._coordinates.size() === 0;
      } }, { key: "init", value: function(a) {
        a === null && (a = this.getFactory().getCoordinateSequenceFactory().create([])), z.isTrue(a.size() <= 1), this._coordinates = a;
      } }, { key: "isSimple", value: function() {
        return !0;
      } }, { key: "interfaces_", get: function() {
        return [we];
      } }], [{ key: "constructor_", value: function() {
        this._coordinates = null;
        var a = arguments[0], l = arguments[1];
        et.constructor_.call(this, l), this.init(a);
      } }]), o;
    }(et), Mt = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "ofRing", value: function() {
        if (arguments[0] instanceof Array) {
          var n = arguments[0];
          return Math.abs(c.ofRingSigned(n));
        }
        if (ht(arguments[0], vt)) {
          var o = arguments[0];
          return Math.abs(c.ofRingSigned(o));
        }
      } }, { key: "ofRingSigned", value: function() {
        if (arguments[0] instanceof Array) {
          var n = arguments[0];
          if (n.length < 3) return 0;
          for (var o = 0, a = n[0].x, l = 1; l < n.length - 1; l++) {
            var d = n[l].x - a, v = n[l + 1].y, E = n[l - 1].y;
            o += d * (E - v);
          }
          return o / 2;
        }
        if (ht(arguments[0], vt)) {
          var S = arguments[0], w = S.size();
          if (w < 3) return 0;
          var N = new P(), M = new P(), Y = new P();
          S.getCoordinate(0, M), S.getCoordinate(1, Y);
          var W = M.x;
          Y.x -= W;
          for (var q = 0, it = 1; it < w - 1; it++) N.y = M.y, M.x = Y.x, M.y = Y.y, S.getCoordinate(it + 1, Y), Y.x -= W, q += M.x * (N.y - Y.y);
          return q / 2;
        }
      } }]), c;
    }(), At = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "sort", value: function() {
        var n = arguments, o = arguments[0];
        if (arguments.length === 1) o.sort(function(W, q) {
          return W.compareTo(q);
        });
        else if (arguments.length === 2) o.sort(function(W, q) {
          return n[1].compare(W, q);
        });
        else if (arguments.length === 3) {
          var a = o.slice(arguments[1], arguments[2]);
          a.sort();
          var l = o.slice(0, arguments[1]).concat(a, o.slice(arguments[2], o.length));
          o.splice(0, o.length);
          var d, v = b(l);
          try {
            for (v.s(); !(d = v.n()).done; ) {
              var E = d.value;
              o.push(E);
            }
          } catch (W) {
            v.e(W);
          } finally {
            v.f();
          }
        } else if (arguments.length === 4) {
          var S = o.slice(arguments[1], arguments[2]);
          S.sort(function(W, q) {
            return n[3].compare(W, q);
          });
          var w = o.slice(0, arguments[1]).concat(S, o.slice(arguments[2], o.length));
          o.splice(0, o.length);
          var N, M = b(w);
          try {
            for (M.s(); !(N = M.n()).done; ) {
              var Y = N.value;
              o.push(Y);
            }
          } catch (W) {
            M.e(W);
          } finally {
            M.f();
          }
        }
      } }, { key: "asList", value: function(n) {
        var o, a = new ot(), l = b(n);
        try {
          for (l.s(); !(o = l.n()).done; ) {
            var d = o.value;
            a.add(d);
          }
        } catch (v) {
          l.e(v);
        } finally {
          l.f();
        }
        return a;
      } }, { key: "copyOf", value: function(n, o) {
        return n.slice(0, o);
      } }]), c;
    }(), ke = function c() {
      e(this, c);
    }, Bi = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "computeEnvelopeInternal", value: function() {
        return this._shell.getEnvelopeInternal();
      } }, { key: "getCoordinates", value: function() {
        if (this.isEmpty()) return [];
        for (var a = new Array(this.getNumPoints()).fill(null), l = -1, d = this._shell.getCoordinates(), v = 0; v < d.length; v++) a[++l] = d[v];
        for (var E = 0; E < this._holes.length; E++) for (var S = this._holes[E].getCoordinates(), w = 0; w < S.length; w++) a[++l] = S[w];
        return a;
      } }, { key: "getArea", value: function() {
        var a = 0;
        a += Mt.ofRing(this._shell.getCoordinateSequence());
        for (var l = 0; l < this._holes.length; l++) a -= Mt.ofRing(this._holes[l].getCoordinateSequence());
        return a;
      } }, { key: "copyInternal", value: function() {
        for (var a = this._shell.copy(), l = new Array(this._holes.length).fill(null), d = 0; d < this._holes.length; d++) l[d] = this._holes[d].copy();
        return new o(a, l, this._factory);
      } }, { key: "isRectangle", value: function() {
        if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5) return !1;
        for (var a = this._shell.getCoordinateSequence(), l = this.getEnvelopeInternal(), d = 0; d < 5; d++) {
          var v = a.getX(d);
          if (v !== l.getMinX() && v !== l.getMaxX()) return !1;
          var E = a.getY(d);
          if (E !== l.getMinY() && E !== l.getMaxY()) return !1;
        }
        for (var S = a.getX(0), w = a.getY(0), N = 1; N <= 4; N++) {
          var M = a.getX(N), Y = a.getY(N);
          if (M !== S == (Y !== w)) return !1;
          S = M, w = Y;
        }
        return !0;
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof et) {
          var a = arguments[0], l = arguments[1];
          if (!this.isEquivalentClass(a)) return !1;
          var d = a, v = this._shell, E = d._shell;
          if (!v.equalsExact(E, l) || this._holes.length !== d._holes.length) return !1;
          for (var S = 0; S < this._holes.length; S++) if (!this._holes[S].equalsExact(d._holes[S], l)) return !1;
          return !0;
        }
        return I(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "normalize", value: function() {
        if (arguments.length === 0) {
          this._shell = this.normalized(this._shell, !0);
          for (var a = 0; a < this._holes.length; a++) this._holes[a] = this.normalized(this._holes[a], !1);
          At.sort(this._holes);
        } else if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          if (l.isEmpty()) return null;
          var v = l.getCoordinateSequence(), E = Bt.minCoordinateIndex(v, 0, v.size() - 2);
          Bt.scroll(v, E, !0), ut.isCCW(v) === d && Bt.reverse(v);
        }
      } }, { key: "getCoordinate", value: function() {
        return this._shell.getCoordinate();
      } }, { key: "getNumInteriorRing", value: function() {
        return this._holes.length;
      } }, { key: "getBoundaryDimension", value: function() {
        return 1;
      } }, { key: "reverseInternal", value: function() {
        for (var a = this.getExteriorRing().reverse(), l = new Array(this.getNumInteriorRing()).fill(null), d = 0; d < l.length; d++) l[d] = this.getInteriorRingN(d).reverse();
        return this.getFactory().createPolygon(a, l);
      } }, { key: "getTypeCode", value: function() {
        return et.TYPECODE_POLYGON;
      } }, { key: "getDimension", value: function() {
        return 2;
      } }, { key: "getLength", value: function() {
        var a = 0;
        a += this._shell.getLength();
        for (var l = 0; l < this._holes.length; l++) a += this._holes[l].getLength();
        return a;
      } }, { key: "getNumPoints", value: function() {
        for (var a = this._shell.getNumPoints(), l = 0; l < this._holes.length; l++) a += this._holes[l].getNumPoints();
        return a;
      } }, { key: "convexHull", value: function() {
        return this.getExteriorRing().convexHull();
      } }, { key: "normalized", value: function(a, l) {
        var d = a.copy();
        return this.normalize(d, l), d;
      } }, { key: "compareToSameClass", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0], l = this._shell, d = a._shell;
          return l.compareToSameClass(d);
        }
        if (arguments.length === 2) {
          var v = arguments[0], E = arguments[1], S = v, w = this._shell, N = S._shell, M = w.compareToSameClass(N, E);
          if (M !== 0) return M;
          for (var Y = this.getNumInteriorRing(), W = S.getNumInteriorRing(), q = 0; q < Y && q < W; ) {
            var it = this.getInteriorRingN(q), at = S.getInteriorRingN(q), ft = it.compareToSameClass(at, E);
            if (ft !== 0) return ft;
            q++;
          }
          return q < Y ? 1 : q < W ? -1 : 0;
        }
      } }, { key: "apply", value: function() {
        if (ht(arguments[0], He)) {
          var a = arguments[0];
          this._shell.apply(a);
          for (var l = 0; l < this._holes.length; l++) this._holes[l].apply(a);
        } else if (ht(arguments[0], se)) {
          var d = arguments[0];
          if (this._shell.apply(d), !d.isDone()) for (var v = 0; v < this._holes.length && (this._holes[v].apply(d), !d.isDone()); v++) ;
          d.isGeometryChanged() && this.geometryChanged();
        } else if (ht(arguments[0], Ut)) {
          var E = arguments[0];
          E.filter(this);
        } else if (ht(arguments[0], D)) {
          var S = arguments[0];
          S.filter(this), this._shell.apply(S);
          for (var w = 0; w < this._holes.length; w++) this._holes[w].apply(S);
        }
      } }, { key: "getBoundary", value: function() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        var a = new Array(this._holes.length + 1).fill(null);
        a[0] = this._shell;
        for (var l = 0; l < this._holes.length; l++) a[l + 1] = this._holes[l];
        return a.length <= 1 ? this.getFactory().createLinearRing(a[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(a);
      } }, { key: "getGeometryType", value: function() {
        return et.TYPENAME_POLYGON;
      } }, { key: "getExteriorRing", value: function() {
        return this._shell;
      } }, { key: "isEmpty", value: function() {
        return this._shell.isEmpty();
      } }, { key: "getInteriorRingN", value: function(a) {
        return this._holes[a];
      } }, { key: "interfaces_", get: function() {
        return [ke];
      } }], [{ key: "constructor_", value: function() {
        this._shell = null, this._holes = null;
        var a = arguments[0], l = arguments[1], d = arguments[2];
        if (et.constructor_.call(this, d), a === null && (a = this.getFactory().createLinearRing()), l === null && (l = []), et.hasNullElements(l)) throw new L("holes must not contain null elements");
        if (a.isEmpty() && et.hasNonEmptyElements(l)) throw new L("shell is empty but holes are not");
        this._shell = a, this._holes = l;
      } }]), o;
    }(et), Uy = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        return e(this, o), n.apply(this, arguments);
      }
      return o;
    }(Nn), Hl = function(c) {
      u(o, c);
      var n = x(o);
      function o(a) {
        var l;
        return e(this, o), (l = n.call(this)).array = [], a instanceof Ie && l.addAll(a), l;
      }
      return s(o, [{ key: "contains", value: function(a) {
        var l, d = b(this.array);
        try {
          for (d.s(); !(l = d.n()).done; )
            if (l.value.compareTo(a) === 0) return !0;
        } catch (v) {
          d.e(v);
        } finally {
          d.f();
        }
        return !1;
      } }, { key: "add", value: function(a) {
        if (this.contains(a)) return !1;
        for (var l = 0, d = this.array.length; l < d; l++)
          if (this.array[l].compareTo(a) === 1) return !!this.array.splice(l, 0, a);
        return this.array.push(a), !0;
      } }, { key: "addAll", value: function(a) {
        var l, d = b(a);
        try {
          for (d.s(); !(l = d.n()).done; ) {
            var v = l.value;
            this.add(v);
          }
        } catch (E) {
          d.e(E);
        } finally {
          d.f();
        }
        return !0;
      } }, { key: "remove", value: function() {
        throw new De();
      } }, { key: "size", value: function() {
        return this.array.length;
      } }, { key: "isEmpty", value: function() {
        return this.array.length === 0;
      } }, { key: "toArray", value: function() {
        return this.array.slice();
      } }, { key: "iterator", value: function() {
        return new jy(this.array);
      } }]), o;
    }(Uy), jy = function() {
      function c(n) {
        e(this, c), this.array = n, this.position = 0;
      }
      return s(c, [{ key: "next", value: function() {
        if (this.position === this.array.length) throw new Gi();
        return this.array[this.position++];
      } }, { key: "hasNext", value: function() {
        return this.position < this.array.length;
      } }, { key: "remove", value: function() {
        throw new De();
      } }]), c;
    }(), pe = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "computeEnvelopeInternal", value: function() {
        for (var a = new bt(), l = 0; l < this._geometries.length; l++) a.expandToInclude(this._geometries[l].getEnvelopeInternal());
        return a;
      } }, { key: "getGeometryN", value: function(a) {
        return this._geometries[a];
      } }, { key: "getCoordinates", value: function() {
        for (var a = new Array(this.getNumPoints()).fill(null), l = -1, d = 0; d < this._geometries.length; d++) for (var v = this._geometries[d].getCoordinates(), E = 0; E < v.length; E++) a[++l] = v[E];
        return a;
      } }, { key: "getArea", value: function() {
        for (var a = 0, l = 0; l < this._geometries.length; l++) a += this._geometries[l].getArea();
        return a;
      } }, { key: "copyInternal", value: function() {
        for (var a = new Array(this._geometries.length).fill(null), l = 0; l < a.length; l++) a[l] = this._geometries[l].copy();
        return new o(a, this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof et) {
          var a = arguments[0], l = arguments[1];
          if (!this.isEquivalentClass(a)) return !1;
          var d = a;
          if (this._geometries.length !== d._geometries.length) return !1;
          for (var v = 0; v < this._geometries.length; v++) if (!this._geometries[v].equalsExact(d._geometries[v], l)) return !1;
          return !0;
        }
        return I(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "normalize", value: function() {
        for (var a = 0; a < this._geometries.length; a++) this._geometries[a].normalize();
        At.sort(this._geometries);
      } }, { key: "getCoordinate", value: function() {
        return this.isEmpty() ? null : this._geometries[0].getCoordinate();
      } }, { key: "getBoundaryDimension", value: function() {
        for (var a = j.FALSE, l = 0; l < this._geometries.length; l++) a = Math.max(a, this._geometries[l].getBoundaryDimension());
        return a;
      } }, { key: "reverseInternal", value: function() {
        for (var a = this._geometries.length, l = new ot(a), d = 0; d < a; d++) l.add(this._geometries[d].reverse());
        return this.getFactory().buildGeometry(l);
      } }, { key: "getTypeCode", value: function() {
        return et.TYPECODE_GEOMETRYCOLLECTION;
      } }, { key: "getDimension", value: function() {
        for (var a = j.FALSE, l = 0; l < this._geometries.length; l++) a = Math.max(a, this._geometries[l].getDimension());
        return a;
      } }, { key: "getLength", value: function() {
        for (var a = 0, l = 0; l < this._geometries.length; l++) a += this._geometries[l].getLength();
        return a;
      } }, { key: "getNumPoints", value: function() {
        for (var a = 0, l = 0; l < this._geometries.length; l++) a += this._geometries[l].getNumPoints();
        return a;
      } }, { key: "getNumGeometries", value: function() {
        return this._geometries.length;
      } }, { key: "compareToSameClass", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0], l = new Hl(At.asList(this._geometries)), d = new Hl(At.asList(a._geometries));
          return this.compare(l, d);
        }
        if (arguments.length === 2) {
          for (var v = arguments[0], E = arguments[1], S = v, w = this.getNumGeometries(), N = S.getNumGeometries(), M = 0; M < w && M < N; ) {
            var Y = this.getGeometryN(M), W = S.getGeometryN(M), q = Y.compareToSameClass(W, E);
            if (q !== 0) return q;
            M++;
          }
          return M < w ? 1 : M < N ? -1 : 0;
        }
      } }, { key: "apply", value: function() {
        if (ht(arguments[0], He)) for (var a = arguments[0], l = 0; l < this._geometries.length; l++) this._geometries[l].apply(a);
        else if (ht(arguments[0], se)) {
          var d = arguments[0];
          if (this._geometries.length === 0) return null;
          for (var v = 0; v < this._geometries.length && (this._geometries[v].apply(d), !d.isDone()); v++) ;
          d.isGeometryChanged() && this.geometryChanged();
        } else if (ht(arguments[0], Ut)) {
          var E = arguments[0];
          E.filter(this);
          for (var S = 0; S < this._geometries.length; S++) this._geometries[S].apply(E);
        } else if (ht(arguments[0], D)) {
          var w = arguments[0];
          w.filter(this);
          for (var N = 0; N < this._geometries.length; N++) this._geometries[N].apply(w);
        }
      } }, { key: "getBoundary", value: function() {
        return et.checkNotGeometryCollection(this), z.shouldNeverReachHere(), null;
      } }, { key: "getGeometryType", value: function() {
        return et.TYPENAME_GEOMETRYCOLLECTION;
      } }, { key: "isEmpty", value: function() {
        for (var a = 0; a < this._geometries.length; a++) if (!this._geometries[a].isEmpty()) return !1;
        return !0;
      } }], [{ key: "constructor_", value: function() {
        if (this._geometries = null, arguments.length !== 0) {
          if (arguments.length === 2) {
            var a = arguments[0], l = arguments[1];
            if (et.constructor_.call(this, l), a === null && (a = []), et.hasNullElements(a)) throw new L("geometries must not contain null elements");
            this._geometries = a;
          }
        }
      } }]), o;
    }(et), ma = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "copyInternal", value: function() {
        for (var a = new Array(this._geometries.length).fill(null), l = 0; l < a.length; l++) a[l] = this._geometries[l].copy();
        return new o(a, this._factory);
      } }, { key: "isValid", value: function() {
        return !0;
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof et) {
          var a = arguments[0], l = arguments[1];
          return !!this.isEquivalentClass(a) && I(h(o.prototype), "equalsExact", this).call(this, a, l);
        }
        return I(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "getCoordinate", value: function() {
        if (arguments.length === 1 && Number.isInteger(arguments[0])) {
          var a = arguments[0];
          return this._geometries[a].getCoordinate();
        }
        return I(h(o.prototype), "getCoordinate", this).apply(this, arguments);
      } }, { key: "getBoundaryDimension", value: function() {
        return j.FALSE;
      } }, { key: "getTypeCode", value: function() {
        return et.TYPECODE_MULTIPOINT;
      } }, { key: "getDimension", value: function() {
        return 0;
      } }, { key: "getBoundary", value: function() {
        return this.getFactory().createGeometryCollection();
      } }, { key: "getGeometryType", value: function() {
        return et.TYPENAME_MULTIPOINT;
      } }, { key: "interfaces_", get: function() {
        return [we];
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        pe.constructor_.call(this, a, l);
      } }]), o;
    }(pe), Lr = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "copyInternal", value: function() {
        return new o(this._points.copy(), this._factory);
      } }, { key: "getBoundaryDimension", value: function() {
        return j.FALSE;
      } }, { key: "isClosed", value: function() {
        return !!this.isEmpty() || I(h(o.prototype), "isClosed", this).call(this);
      } }, { key: "reverseInternal", value: function() {
        var a = this._points.copy();
        return Bt.reverse(a), this.getFactory().createLinearRing(a);
      } }, { key: "getTypeCode", value: function() {
        return et.TYPECODE_LINEARRING;
      } }, { key: "validateConstruction", value: function() {
        if (!this.isEmpty() && !I(h(o.prototype), "isClosed", this).call(this)) throw new L("Points of LinearRing do not form a closed linestring");
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < o.MINIMUM_VALID_SIZE) throw new L("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
      } }, { key: "getGeometryType", value: function() {
        return et.TYPENAME_LINEARRING;
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        zt.constructor_.call(this, a, l), this.validateConstruction();
      } }]), o;
    }(zt);
    Lr.MINIMUM_VALID_SIZE = 4;
    var hi = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "setOrdinate", value: function(a, l) {
        switch (a) {
          case o.X:
            this.x = l;
            break;
          case o.Y:
            this.y = l;
            break;
          default:
            throw new L("Invalid ordinate index: " + a);
        }
      } }, { key: "getZ", value: function() {
        return P.NULL_ORDINATE;
      } }, { key: "getOrdinate", value: function(a) {
        switch (a) {
          case o.X:
            return this.x;
          case o.Y:
            return this.y;
        }
        throw new L("Invalid ordinate index: " + a);
      } }, { key: "setZ", value: function(a) {
        throw new L("CoordinateXY dimension 2 does not support z-ordinate");
      } }, { key: "copy", value: function() {
        return new o(this);
      } }, { key: "toString", value: function() {
        return "(" + this.x + ", " + this.y + ")";
      } }, { key: "setCoordinate", value: function(a) {
        this.x = a.x, this.y = a.y, this.z = a.getZ();
      } }], [{ key: "constructor_", value: function() {
        if (arguments.length === 0) P.constructor_.call(this);
        else if (arguments.length === 1) {
          if (arguments[0] instanceof o) {
            var a = arguments[0];
            P.constructor_.call(this, a.x, a.y);
          } else if (arguments[0] instanceof P) {
            var l = arguments[0];
            P.constructor_.call(this, l.x, l.y);
          }
        } else if (arguments.length === 2) {
          var d = arguments[0], v = arguments[1];
          P.constructor_.call(this, d, v, P.NULL_ORDINATE);
        }
      } }]), o;
    }(P);
    hi.X = 0, hi.Y = 1, hi.Z = -1, hi.M = -1;
    var ci = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "getM", value: function() {
        return this._m;
      } }, { key: "setOrdinate", value: function(a, l) {
        switch (a) {
          case o.X:
            this.x = l;
            break;
          case o.Y:
            this.y = l;
            break;
          case o.M:
            this._m = l;
            break;
          default:
            throw new L("Invalid ordinate index: " + a);
        }
      } }, { key: "setM", value: function(a) {
        this._m = a;
      } }, { key: "getZ", value: function() {
        return P.NULL_ORDINATE;
      } }, { key: "getOrdinate", value: function(a) {
        switch (a) {
          case o.X:
            return this.x;
          case o.Y:
            return this.y;
          case o.M:
            return this._m;
        }
        throw new L("Invalid ordinate index: " + a);
      } }, { key: "setZ", value: function(a) {
        throw new L("CoordinateXY dimension 2 does not support z-ordinate");
      } }, { key: "copy", value: function() {
        return new o(this);
      } }, { key: "toString", value: function() {
        return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
      } }, { key: "setCoordinate", value: function(a) {
        this.x = a.x, this.y = a.y, this.z = a.getZ(), this._m = a.getM();
      } }], [{ key: "constructor_", value: function() {
        if (this._m = null, arguments.length === 0) P.constructor_.call(this), this._m = 0;
        else if (arguments.length === 1) {
          if (arguments[0] instanceof o) {
            var a = arguments[0];
            P.constructor_.call(this, a.x, a.y), this._m = a._m;
          } else if (arguments[0] instanceof P) {
            var l = arguments[0];
            P.constructor_.call(this, l.x, l.y), this._m = this.getM();
          }
        } else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], E = arguments[2];
          P.constructor_.call(this, d, v, P.NULL_ORDINATE), this._m = E;
        }
      } }]), o;
    }(P);
    ci.X = 0, ci.Y = 1, ci.Z = -1, ci.M = 2;
    var va = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "getM", value: function() {
        return this._m;
      } }, { key: "setOrdinate", value: function(a, l) {
        switch (a) {
          case P.X:
            this.x = l;
            break;
          case P.Y:
            this.y = l;
            break;
          case P.Z:
            this.z = l;
            break;
          case P.M:
            this._m = l;
            break;
          default:
            throw new L("Invalid ordinate index: " + a);
        }
      } }, { key: "setM", value: function(a) {
        this._m = a;
      } }, { key: "getOrdinate", value: function(a) {
        switch (a) {
          case P.X:
            return this.x;
          case P.Y:
            return this.y;
          case P.Z:
            return this.getZ();
          case P.M:
            return this.getM();
        }
        throw new L("Invalid ordinate index: " + a);
      } }, { key: "copy", value: function() {
        return new o(this);
      } }, { key: "toString", value: function() {
        return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
      } }, { key: "setCoordinate", value: function(a) {
        this.x = a.x, this.y = a.y, this.z = a.getZ(), this._m = a.getM();
      } }], [{ key: "constructor_", value: function() {
        if (this._m = null, arguments.length === 0) P.constructor_.call(this), this._m = 0;
        else if (arguments.length === 1) {
          if (arguments[0] instanceof o) {
            var a = arguments[0];
            P.constructor_.call(this, a), this._m = a._m;
          } else if (arguments[0] instanceof P) {
            var l = arguments[0];
            P.constructor_.call(this, l), this._m = this.getM();
          }
        } else if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], E = arguments[2], S = arguments[3];
          P.constructor_.call(this, d, v, E), this._m = S;
        }
      } }]), o;
    }(P), Bs = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "measures", value: function(n) {
        return n instanceof hi ? 0 : n instanceof ci || n instanceof va ? 1 : 0;
      } }, { key: "dimension", value: function(n) {
        return n instanceof hi ? 2 : n instanceof ci ? 3 : n instanceof va ? 4 : 3;
      } }, { key: "create", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return c.create(n, 0);
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          return o === 2 ? new hi() : o === 3 && a === 0 ? new P() : o === 3 && a === 1 ? new ci() : o === 4 && a === 1 ? new va() : new P();
        }
      } }]), c;
    }(), Ar = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "getCoordinate", value: function(a) {
        return this.get(a);
      } }, { key: "addAll", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "boolean" && ht(arguments[0], Ie)) {
          for (var a = arguments[0], l = arguments[1], d = !1, v = a.iterator(); v.hasNext(); ) this.add(v.next(), l), d = !0;
          return d;
        }
        return I(h(o.prototype), "addAll", this).apply(this, arguments);
      } }, { key: "clone", value: function() {
        for (var a = I(h(o.prototype), "clone", this).call(this), l = 0; l < this.size(); l++) a.add(l, this.get(l).clone());
        return a;
      } }, { key: "toCoordinateArray", value: function() {
        if (arguments.length === 0) return this.toArray(o.coordArrayType);
        if (arguments.length === 1) {
          var a = arguments[0];
          if (a) return this.toArray(o.coordArrayType);
          for (var l = this.size(), d = new Array(l).fill(null), v = 0; v < l; v++) d[v] = this.get(l - v - 1);
          return d;
        }
      } }, { key: "add", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0];
          return I(h(o.prototype), "add", this).call(this, a);
        }
        if (arguments.length === 2) {
          if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
            var l = arguments[0], d = arguments[1];
            return this.add(l, d, !0), !0;
          }
          if (arguments[0] instanceof P && typeof arguments[1] == "boolean") {
            var v = arguments[0], E = arguments[1];
            if (!E && this.size() >= 1) {
              var S = this.get(this.size() - 1);
              if (S.equals2D(v)) return null;
            }
            I(h(o.prototype), "add", this).call(this, v);
          } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
            var w = arguments[0], N = arguments[1];
            return this.add(w, N), !0;
          }
        } else if (arguments.length === 3) {
          if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
            var M = arguments[0], Y = arguments[1], W = arguments[2];
            if (W) for (var q = 0; q < M.length; q++) this.add(M[q], Y);
            else for (var it = M.length - 1; it >= 0; it--) this.add(M[it], Y);
            return !0;
          }
          if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof P) {
            var at = arguments[0], ft = arguments[1], kt = arguments[2];
            if (!kt) {
              var Pt = this.size();
              if (Pt > 0) {
                if (at > 0) {
                  var Jt = this.get(at - 1);
                  if (Jt.equals2D(ft)) return null;
                }
                if (at < Pt) {
                  var _e = this.get(at);
                  if (_e.equals2D(ft)) return null;
                }
              }
            }
            I(h(o.prototype), "add", this).call(this, at, ft);
          }
        } else if (arguments.length === 4) {
          var ze = arguments[0], dn = arguments[1], di = arguments[2], Br = arguments[3], Yr = 1;
          di > Br && (Yr = -1);
          for (var ji = di; ji !== Br; ji += Yr) this.add(ze[ji], dn);
          return !0;
        }
      } }, { key: "closeRing", value: function() {
        if (this.size() > 0) {
          var a = this.get(0).copy();
          this.add(a, !1);
        }
      } }], [{ key: "constructor_", value: function() {
        if (arguments.length !== 0) {
          if (arguments.length === 1) {
            var a = arguments[0];
            this.ensureCapacity(a.length), this.add(a, !0);
          } else if (arguments.length === 2) {
            var l = arguments[0], d = arguments[1];
            this.ensureCapacity(l.length), this.add(l, d);
          }
        }
      } }]), o;
    }(ot);
    Ar.coordArrayType = new Array(0).fill(null);
    var Yt = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "isRing", value: function(n) {
        return !(n.length < 4) && !!n[0].equals2D(n[n.length - 1]);
      } }, { key: "ptNotInList", value: function(n, o) {
        for (var a = 0; a < n.length; a++) {
          var l = n[a];
          if (c.indexOf(l, o) < 0) return l;
        }
        return null;
      } }, { key: "scroll", value: function(n, o) {
        var a = c.indexOf(o, n);
        if (a < 0) return null;
        var l = new Array(n.length).fill(null);
        re.arraycopy(n, a, l, 0, n.length - a), re.arraycopy(n, 0, l, n.length - a, a), re.arraycopy(l, 0, n, 0, n.length);
      } }, { key: "equals", value: function() {
        if (arguments.length === 2) {
          var n = arguments[0], o = arguments[1];
          if (n === o) return !0;
          if (n === null || o === null || n.length !== o.length) return !1;
          for (var a = 0; a < n.length; a++) if (!n[a].equals(o[a])) return !1;
          return !0;
        }
        if (arguments.length === 3) {
          var l = arguments[0], d = arguments[1], v = arguments[2];
          if (l === d) return !0;
          if (l === null || d === null || l.length !== d.length) return !1;
          for (var E = 0; E < l.length; E++) if (v.compare(l[E], d[E]) !== 0) return !1;
          return !0;
        }
      } }, { key: "intersection", value: function(n, o) {
        for (var a = new Ar(), l = 0; l < n.length; l++) o.intersects(n[l]) && a.add(n[l], !0);
        return a.toCoordinateArray();
      } }, { key: "measures", value: function(n) {
        if (n === null || n.length === 0) return 0;
        var o, a = 0, l = b(n);
        try {
          for (l.s(); !(o = l.n()).done; ) {
            var d = o.value;
            a = Math.max(a, Bs.measures(d));
          }
        } catch (v) {
          l.e(v);
        } finally {
          l.f();
        }
        return a;
      } }, { key: "hasRepeatedPoints", value: function(n) {
        for (var o = 1; o < n.length; o++) if (n[o - 1].equals(n[o])) return !0;
        return !1;
      } }, { key: "removeRepeatedPoints", value: function(n) {
        return c.hasRepeatedPoints(n) ? new Ar(n, !1).toCoordinateArray() : n;
      } }, { key: "reverse", value: function(n) {
        for (var o = n.length - 1, a = Math.trunc(o / 2), l = 0; l <= a; l++) {
          var d = n[l];
          n[l] = n[o - l], n[o - l] = d;
        }
      } }, { key: "removeNull", value: function(n) {
        for (var o = 0, a = 0; a < n.length; a++) n[a] !== null && o++;
        var l = new Array(o).fill(null);
        if (o === 0) return l;
        for (var d = 0, v = 0; v < n.length; v++) n[v] !== null && (l[d++] = n[v]);
        return l;
      } }, { key: "copyDeep", value: function() {
        if (arguments.length === 1) {
          for (var n = arguments[0], o = new Array(n.length).fill(null), a = 0; a < n.length; a++) o[a] = n[a].copy();
          return o;
        }
        if (arguments.length === 5) for (var l = arguments[0], d = arguments[1], v = arguments[2], E = arguments[3], S = arguments[4], w = 0; w < S; w++) v[E + w] = l[d + w].copy();
      } }, { key: "isEqualReversed", value: function(n, o) {
        for (var a = 0; a < n.length; a++) {
          var l = n[a], d = o[n.length - a - 1];
          if (l.compareTo(d) !== 0) return !1;
        }
        return !0;
      } }, { key: "envelope", value: function(n) {
        for (var o = new bt(), a = 0; a < n.length; a++) o.expandToInclude(n[a]);
        return o;
      } }, { key: "toCoordinateArray", value: function(n) {
        return n.toArray(c.coordArrayType);
      } }, { key: "dimension", value: function(n) {
        if (n === null || n.length === 0) return 3;
        var o, a = 0, l = b(n);
        try {
          for (l.s(); !(o = l.n()).done; ) {
            var d = o.value;
            a = Math.max(a, Bs.dimension(d));
          }
        } catch (v) {
          l.e(v);
        } finally {
          l.f();
        }
        return a;
      } }, { key: "atLeastNCoordinatesOrNothing", value: function(n, o) {
        return o.length >= n ? o : [];
      } }, { key: "indexOf", value: function(n, o) {
        for (var a = 0; a < o.length; a++) if (n.equals(o[a])) return a;
        return -1;
      } }, { key: "increasingDirection", value: function(n) {
        for (var o = 0; o < Math.trunc(n.length / 2); o++) {
          var a = n.length - 1 - o, l = n[o].compareTo(n[a]);
          if (l !== 0) return l;
        }
        return 1;
      } }, { key: "compare", value: function(n, o) {
        for (var a = 0; a < n.length && a < o.length; ) {
          var l = n[a].compareTo(o[a]);
          if (l !== 0) return l;
          a++;
        }
        return a < o.length ? -1 : a < n.length ? 1 : 0;
      } }, { key: "minCoordinate", value: function(n) {
        for (var o = null, a = 0; a < n.length; a++) (o === null || o.compareTo(n[a]) > 0) && (o = n[a]);
        return o;
      } }, { key: "extract", value: function(n, o, a) {
        o = cn.clamp(o, 0, n.length);
        var l = (a = cn.clamp(a, -1, n.length)) - o + 1;
        a < 0 && (l = 0), o >= n.length && (l = 0), a < o && (l = 0);
        var d = new Array(l).fill(null);
        if (l === 0) return d;
        for (var v = 0, E = o; E <= a; E++) d[v++] = n[E];
        return d;
      } }]), c;
    }(), Vy = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "compare", value: function(n, o) {
        var a = n, l = o;
        return Yt.compare(a, l);
      } }, { key: "interfaces_", get: function() {
        return [pt];
      } }]), c;
    }(), Zy = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "compare", value: function(n, o) {
        var a = n, l = o;
        if (a.length < l.length) return -1;
        if (a.length > l.length) return 1;
        if (a.length === 0) return 0;
        var d = Yt.compare(a, l);
        return Yt.isEqualReversed(a, l) ? 0 : d;
      } }, { key: "OLDcompare", value: function(n, o) {
        var a = n, l = o;
        if (a.length < l.length) return -1;
        if (a.length > l.length) return 1;
        if (a.length === 0) return 0;
        for (var d = Yt.increasingDirection(a), v = Yt.increasingDirection(l), E = d > 0 ? 0 : a.length - 1, S = v > 0 ? 0 : a.length - 1, w = 0; w < a.length; w++) {
          var N = a[E].compareTo(l[S]);
          if (N !== 0) return N;
          E += d, S += v;
        }
        return 0;
      } }, { key: "interfaces_", get: function() {
        return [pt];
      } }]), c;
    }();
    Yt.ForwardComparator = Vy, Yt.BidirectionalComparator = Zy, Yt.coordArrayType = new Array(0).fill(null);
    var Ys = function() {
      function c(n) {
        e(this, c), this.str = n;
      }
      return s(c, [{ key: "append", value: function(n) {
        this.str += n;
      } }, { key: "setCharAt", value: function(n, o) {
        this.str = this.str.substr(0, n) + o + this.str.substr(n + 1);
      } }, { key: "toString", value: function() {
        return this.str;
      } }]), c;
    }(), Pr = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getM", value: function(n) {
        return this.hasM() ? this._coordinates[n].getM() : Z.NaN;
      } }, { key: "setOrdinate", value: function(n, o, a) {
        switch (o) {
          case vt.X:
            this._coordinates[n].x = a;
            break;
          case vt.Y:
            this._coordinates[n].y = a;
            break;
          default:
            this._coordinates[n].setOrdinate(o, a);
        }
      } }, { key: "getZ", value: function(n) {
        return this.hasZ() ? this._coordinates[n].getZ() : Z.NaN;
      } }, { key: "size", value: function() {
        return this._coordinates.length;
      } }, { key: "getOrdinate", value: function(n, o) {
        switch (o) {
          case vt.X:
            return this._coordinates[n].x;
          case vt.Y:
            return this._coordinates[n].y;
          default:
            return this._coordinates[n].getOrdinate(o);
        }
      } }, { key: "getCoordinate", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return this._coordinates[n];
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          a.setCoordinate(this._coordinates[o]);
        }
      } }, { key: "getCoordinateCopy", value: function(n) {
        var o = this.createCoordinate();
        return o.setCoordinate(this._coordinates[n]), o;
      } }, { key: "createCoordinate", value: function() {
        return Bs.create(this.getDimension(), this.getMeasures());
      } }, { key: "getDimension", value: function() {
        return this._dimension;
      } }, { key: "getX", value: function(n) {
        return this._coordinates[n].x;
      } }, { key: "getMeasures", value: function() {
        return this._measures;
      } }, { key: "expandEnvelope", value: function(n) {
        for (var o = 0; o < this._coordinates.length; o++) n.expandToInclude(this._coordinates[o]);
        return n;
      } }, { key: "copy", value: function() {
        for (var n = new Array(this.size()).fill(null), o = 0; o < this._coordinates.length; o++) {
          var a = this.createCoordinate();
          a.setCoordinate(this._coordinates[o]), n[o] = a;
        }
        return new c(n, this._dimension, this._measures);
      } }, { key: "toString", value: function() {
        if (this._coordinates.length > 0) {
          var n = new Ys(17 * this._coordinates.length);
          n.append("("), n.append(this._coordinates[0]);
          for (var o = 1; o < this._coordinates.length; o++) n.append(", "), n.append(this._coordinates[o]);
          return n.append(")"), n.toString();
        }
        return "()";
      } }, { key: "getY", value: function(n) {
        return this._coordinates[n].y;
      } }, { key: "toCoordinateArray", value: function() {
        return this._coordinates;
      } }, { key: "interfaces_", get: function() {
        return [vt, B];
      } }], [{ key: "constructor_", value: function() {
        if (this._dimension = 3, this._measures = 0, this._coordinates = null, arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var n = arguments[0];
            c.constructor_.call(this, n, Yt.dimension(n), Yt.measures(n));
          } else if (Number.isInteger(arguments[0])) {
            var o = arguments[0];
            this._coordinates = new Array(o).fill(null);
            for (var a = 0; a < o; a++) this._coordinates[a] = new P();
          } else if (ht(arguments[0], vt)) {
            var l = arguments[0];
            if (l === null) return this._coordinates = new Array(0).fill(null), null;
            this._dimension = l.getDimension(), this._measures = l.getMeasures(), this._coordinates = new Array(l.size()).fill(null);
            for (var d = 0; d < this._coordinates.length; d++) this._coordinates[d] = l.getCoordinateCopy(d);
          }
        } else if (arguments.length === 2) {
          if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
            var v = arguments[0], E = arguments[1];
            c.constructor_.call(this, v, E, Yt.measures(v));
          } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var S = arguments[0], w = arguments[1];
            this._coordinates = new Array(S).fill(null), this._dimension = w;
            for (var N = 0; N < S; N++) this._coordinates[N] = Bs.create(w);
          }
        } else if (arguments.length === 3) {
          if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
            var M = arguments[0], Y = arguments[1], W = arguments[2];
            this._dimension = Y, this._measures = W, this._coordinates = M === null ? new Array(0).fill(null) : M;
          } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var q = arguments[0], it = arguments[1], at = arguments[2];
            this._coordinates = new Array(q).fill(null), this._dimension = it, this._measures = at;
            for (var ft = 0; ft < q; ft++) this._coordinates[ft] = this.createCoordinate();
          }
        }
      } }]), c;
    }(), _a = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "readResolve", value: function() {
        return c.instance();
      } }, { key: "create", value: function() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var n = arguments[0];
            return new Pr(n);
          }
          if (ht(arguments[0], vt)) {
            var o = arguments[0];
            return new Pr(o);
          }
        } else {
          if (arguments.length === 2) {
            var a = arguments[0], l = arguments[1];
            return l > 3 && (l = 3), l < 2 && (l = 2), new Pr(a, l);
          }
          if (arguments.length === 3) {
            var d = arguments[0], v = arguments[1], E = arguments[2], S = v - E;
            return E > 1 && (E = 1), S > 3 && (S = 3), S < 2 && (S = 2), new Pr(d, S + E, E);
          }
        }
      } }, { key: "interfaces_", get: function() {
        return [Ln, B];
      } }], [{ key: "instance", value: function() {
        return c.instanceObject;
      } }]), c;
    }();
    _a.instanceObject = new _a();
    var xa = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "copyInternal", value: function() {
        for (var a = new Array(this._geometries.length).fill(null), l = 0; l < a.length; l++) a[l] = this._geometries[l].copy();
        return new o(a, this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof et) {
          var a = arguments[0], l = arguments[1];
          return !!this.isEquivalentClass(a) && I(h(o.prototype), "equalsExact", this).call(this, a, l);
        }
        return I(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "getBoundaryDimension", value: function() {
        return 1;
      } }, { key: "getTypeCode", value: function() {
        return et.TYPECODE_MULTIPOLYGON;
      } }, { key: "getDimension", value: function() {
        return 2;
      } }, { key: "getBoundary", value: function() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        for (var a = new ot(), l = 0; l < this._geometries.length; l++) for (var d = this._geometries[l].getBoundary(), v = 0; v < d.getNumGeometries(); v++) a.add(d.getGeometryN(v));
        var E = new Array(a.size()).fill(null);
        return this.getFactory().createMultiLineString(a.toArray(E));
      } }, { key: "getGeometryType", value: function() {
        return et.TYPENAME_MULTIPOLYGON;
      } }, { key: "interfaces_", get: function() {
        return [ke];
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        pe.constructor_.call(this, a, l);
      } }]), o;
    }(pe), Jl = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "get", value: function() {
      } }, { key: "put", value: function() {
      } }, { key: "size", value: function() {
      } }, { key: "values", value: function() {
      } }, { key: "entrySet", value: function() {
      } }]), c;
    }(), Hy = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), (a = n.call(this)).map = /* @__PURE__ */ new Map(), a;
      }
      return s(o, [{ key: "get", value: function(a) {
        return this.map.get(a) || null;
      } }, { key: "put", value: function(a, l) {
        return this.map.set(a, l), l;
      } }, { key: "values", value: function() {
        for (var a = new ot(), l = this.map.values(), d = l.next(); !d.done; ) a.add(d.value), d = l.next();
        return a;
      } }, { key: "entrySet", value: function() {
        var a = new ai();
        return this.map.entries().forEach(function(l) {
          return a.add(l);
        }), a;
      } }, { key: "size", value: function() {
        return this.map.size();
      } }]), o;
    }(Jl), Be = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "equals", value: function(n) {
        if (!(n instanceof c)) return !1;
        var o = n;
        return this._modelType === o._modelType && this._scale === o._scale;
      } }, { key: "compareTo", value: function(n) {
        var o = n, a = this.getMaximumSignificantDigits(), l = o.getMaximumSignificantDigits();
        return Mn.compare(a, l);
      } }, { key: "getScale", value: function() {
        return this._scale;
      } }, { key: "isFloating", value: function() {
        return this._modelType === c.FLOATING || this._modelType === c.FLOATING_SINGLE;
      } }, { key: "getType", value: function() {
        return this._modelType;
      } }, { key: "toString", value: function() {
        var n = "UNKNOWN";
        return this._modelType === c.FLOATING ? n = "Floating" : this._modelType === c.FLOATING_SINGLE ? n = "Floating-Single" : this._modelType === c.FIXED && (n = "Fixed (Scale=" + this.getScale() + ")"), n;
      } }, { key: "makePrecise", value: function() {
        if (typeof arguments[0] == "number") {
          var n = arguments[0];
          return Z.isNaN(n) || this._modelType === c.FLOATING_SINGLE ? n : this._modelType === c.FIXED ? Math.round(n * this._scale) / this._scale : n;
        }
        if (arguments[0] instanceof P) {
          var o = arguments[0];
          if (this._modelType === c.FLOATING) return null;
          o.x = this.makePrecise(o.x), o.y = this.makePrecise(o.y);
        }
      } }, { key: "getMaximumSignificantDigits", value: function() {
        var n = 16;
        return this._modelType === c.FLOATING ? n = 16 : this._modelType === c.FLOATING_SINGLE ? n = 6 : this._modelType === c.FIXED && (n = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), n;
      } }, { key: "setScale", value: function(n) {
        this._scale = Math.abs(n);
      } }, { key: "interfaces_", get: function() {
        return [B, F];
      } }], [{ key: "constructor_", value: function() {
        if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = c.FLOATING;
        else if (arguments.length === 1) {
          if (arguments[0] instanceof Yi) {
            var n = arguments[0];
            this._modelType = n, n === c.FIXED && this.setScale(1);
          } else if (typeof arguments[0] == "number") {
            var o = arguments[0];
            this._modelType = c.FIXED, this.setScale(o);
          } else if (arguments[0] instanceof c) {
            var a = arguments[0];
            this._modelType = a._modelType, this._scale = a._scale;
          }
        }
      } }, { key: "mostPrecise", value: function(n, o) {
        return n.compareTo(o) >= 0 ? n : o;
      } }]), c;
    }(), Yi = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "readResolve", value: function() {
        return c.nameToTypeMap.get(this._name);
      } }, { key: "toString", value: function() {
        return this._name;
      } }, { key: "interfaces_", get: function() {
        return [B];
      } }], [{ key: "constructor_", value: function() {
        this._name = null;
        var n = arguments[0];
        this._name = n, c.nameToTypeMap.put(n, this);
      } }]), c;
    }();
    Yi.nameToTypeMap = new Hy(), Be.Type = Yi, Be.FIXED = new Yi("FIXED"), Be.FLOATING = new Yi("FLOATING"), Be.FLOATING_SINGLE = new Yi("FLOATING SINGLE"), Be.maximumPreciseValue = 9007199254740992;
    var Ea = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "copyInternal", value: function() {
        for (var a = new Array(this._geometries.length).fill(null), l = 0; l < a.length; l++) a[l] = this._geometries[l].copy();
        return new o(a, this._factory);
      } }, { key: "equalsExact", value: function() {
        if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof et) {
          var a = arguments[0], l = arguments[1];
          return !!this.isEquivalentClass(a) && I(h(o.prototype), "equalsExact", this).call(this, a, l);
        }
        return I(h(o.prototype), "equalsExact", this).apply(this, arguments);
      } }, { key: "getBoundaryDimension", value: function() {
        return this.isClosed() ? j.FALSE : 0;
      } }, { key: "isClosed", value: function() {
        if (this.isEmpty()) return !1;
        for (var a = 0; a < this._geometries.length; a++) if (!this._geometries[a].isClosed()) return !1;
        return !0;
      } }, { key: "getTypeCode", value: function() {
        return et.TYPECODE_MULTILINESTRING;
      } }, { key: "getDimension", value: function() {
        return 1;
      } }, { key: "getBoundary", value: function() {
        throw new De();
      } }, { key: "getGeometryType", value: function() {
        return et.TYPENAME_MULTILINESTRING;
      } }, { key: "interfaces_", get: function() {
        return [Or];
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        pe.constructor_.call(this, a, l);
      } }]), o;
    }(pe), zi = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "createEmpty", value: function(n) {
        switch (n) {
          case -1:
            return this.createGeometryCollection();
          case 0:
            return this.createPoint();
          case 1:
            return this.createLineString();
          case 2:
            return this.createPolygon();
          default:
            throw new L("Invalid dimension: " + n);
        }
      } }, { key: "toGeometry", value: function(n) {
        return n.isNull() ? this.createPoint() : n.getMinX() === n.getMaxX() && n.getMinY() === n.getMaxY() ? this.createPoint(new P(n.getMinX(), n.getMinY())) : n.getMinX() === n.getMaxX() || n.getMinY() === n.getMaxY() ? this.createLineString([new P(n.getMinX(), n.getMinY()), new P(n.getMaxX(), n.getMaxY())]) : this.createPolygon(this.createLinearRing([new P(n.getMinX(), n.getMinY()), new P(n.getMinX(), n.getMaxY()), new P(n.getMaxX(), n.getMaxY()), new P(n.getMaxX(), n.getMinY()), new P(n.getMinX(), n.getMinY())]), null);
      } }, { key: "createLineString", value: function() {
        if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var n = arguments[0];
            return this.createLineString(n !== null ? this.getCoordinateSequenceFactory().create(n) : null);
          }
          if (ht(arguments[0], vt)) {
            var o = arguments[0];
            return new zt(o, this);
          }
        }
      } }, { key: "createMultiLineString", value: function() {
        if (arguments.length === 0) return new Ea(null, this);
        if (arguments.length === 1) {
          var n = arguments[0];
          return new Ea(n, this);
        }
      } }, { key: "buildGeometry", value: function(n) {
        for (var o = null, a = !1, l = !1, d = n.iterator(); d.hasNext(); ) {
          var v = d.next(), E = v.getTypeCode();
          o === null && (o = E), E !== o && (a = !0), v instanceof pe && (l = !0);
        }
        if (o === null) return this.createGeometryCollection();
        if (a || l) return this.createGeometryCollection(c.toGeometryArray(n));
        var S = n.iterator().next();
        if (n.size() > 1) {
          if (S instanceof Bi) return this.createMultiPolygon(c.toPolygonArray(n));
          if (S instanceof zt) return this.createMultiLineString(c.toLineStringArray(n));
          if (S instanceof ye) return this.createMultiPoint(c.toPointArray(n));
          z.shouldNeverReachHere("Unhandled geometry type: " + S.getGeometryType());
        }
        return S;
      } }, { key: "createMultiPointFromCoords", value: function(n) {
        return this.createMultiPoint(n !== null ? this.getCoordinateSequenceFactory().create(n) : null);
      } }, { key: "createPoint", value: function() {
        if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
          if (arguments[0] instanceof P) {
            var n = arguments[0];
            return this.createPoint(n !== null ? this.getCoordinateSequenceFactory().create([n]) : null);
          }
          if (ht(arguments[0], vt)) {
            var o = arguments[0];
            return new ye(o, this);
          }
        }
      } }, { key: "getCoordinateSequenceFactory", value: function() {
        return this._coordinateSequenceFactory;
      } }, { key: "createPolygon", value: function() {
        if (arguments.length === 0) return this.createPolygon(null, null);
        if (arguments.length === 1) {
          if (ht(arguments[0], vt)) {
            var n = arguments[0];
            return this.createPolygon(this.createLinearRing(n));
          }
          if (arguments[0] instanceof Array) {
            var o = arguments[0];
            return this.createPolygon(this.createLinearRing(o));
          }
          if (arguments[0] instanceof Lr) {
            var a = arguments[0];
            return this.createPolygon(a, null);
          }
        } else if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          return new Bi(l, d, this);
        }
      } }, { key: "getSRID", value: function() {
        return this._SRID;
      } }, { key: "createGeometryCollection", value: function() {
        if (arguments.length === 0) return new pe(null, this);
        if (arguments.length === 1) {
          var n = arguments[0];
          return new pe(n, this);
        }
      } }, { key: "getPrecisionModel", value: function() {
        return this._precisionModel;
      } }, { key: "createLinearRing", value: function() {
        if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
        if (arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var n = arguments[0];
            return this.createLinearRing(n !== null ? this.getCoordinateSequenceFactory().create(n) : null);
          }
          if (ht(arguments[0], vt)) {
            var o = arguments[0];
            return new Lr(o, this);
          }
        }
      } }, { key: "createMultiPolygon", value: function() {
        if (arguments.length === 0) return new xa(null, this);
        if (arguments.length === 1) {
          var n = arguments[0];
          return new xa(n, this);
        }
      } }, { key: "createMultiPoint", value: function() {
        if (arguments.length === 0) return new ma(null, this);
        if (arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var n = arguments[0];
            return new ma(n, this);
          }
          if (ht(arguments[0], vt)) {
            var o = arguments[0];
            if (o === null) return this.createMultiPoint(new Array(0).fill(null));
            for (var a = new Array(o.size()).fill(null), l = 0; l < o.size(); l++) {
              var d = this.getCoordinateSequenceFactory().create(1, o.getDimension(), o.getMeasures());
              Bt.copy(o, l, d, 0, 1), a[l] = this.createPoint(d);
            }
            return this.createMultiPoint(a);
          }
        }
      } }, { key: "interfaces_", get: function() {
        return [B];
      } }], [{ key: "constructor_", value: function() {
        if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, arguments.length === 0) c.constructor_.call(this, new Be(), 0);
        else if (arguments.length === 1) {
          if (ht(arguments[0], Ln)) {
            var n = arguments[0];
            c.constructor_.call(this, new Be(), 0, n);
          } else if (arguments[0] instanceof Be) {
            var o = arguments[0];
            c.constructor_.call(this, o, 0, c.getDefaultCoordinateSequenceFactory());
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          c.constructor_.call(this, a, l, c.getDefaultCoordinateSequenceFactory());
        } else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], E = arguments[2];
          this._precisionModel = d, this._coordinateSequenceFactory = E, this._SRID = v;
        }
      } }, { key: "toMultiPolygonArray", value: function(n) {
        var o = new Array(n.size()).fill(null);
        return n.toArray(o);
      } }, { key: "toGeometryArray", value: function(n) {
        if (n === null) return null;
        var o = new Array(n.size()).fill(null);
        return n.toArray(o);
      } }, { key: "getDefaultCoordinateSequenceFactory", value: function() {
        return _a.instance();
      } }, { key: "toMultiLineStringArray", value: function(n) {
        var o = new Array(n.size()).fill(null);
        return n.toArray(o);
      } }, { key: "toLineStringArray", value: function(n) {
        var o = new Array(n.size()).fill(null);
        return n.toArray(o);
      } }, { key: "toMultiPointArray", value: function(n) {
        var o = new Array(n.size()).fill(null);
        return n.toArray(o);
      } }, { key: "toLinearRingArray", value: function(n) {
        var o = new Array(n.size()).fill(null);
        return n.toArray(o);
      } }, { key: "toPointArray", value: function(n) {
        var o = new Array(n.size()).fill(null);
        return n.toArray(o);
      } }, { key: "toPolygonArray", value: function(n) {
        var o = new Array(n.size()).fill(null);
        return n.toArray(o);
      } }, { key: "createPointFromInternalCoord", value: function(n, o) {
        return o.getPrecisionModel().makePrecise(n), o.getFactory().createPoint(n);
      } }]), c;
    }(), Sa = "XY", Jy = "XYZ", Ky = "XYM", Qy = "XYZM", Kl = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, Ql = "EMPTY", zs = 1, fn = 2, An = 3, th = 4, $i = 5, tp = 6;
    for (var ep in Kl) Kl[ep].toUpperCase();
    var np = function() {
      function c(n) {
        e(this, c), this.wkt = n, this.index_ = -1;
      }
      return s(c, [{ key: "isAlpha_", value: function(n) {
        return n >= "a" && n <= "z" || n >= "A" && n <= "Z";
      } }, { key: "isNumeric_", value: function(n, o) {
        return n >= "0" && n <= "9" || n == "." && !(o !== void 0 && o);
      } }, { key: "isWhiteSpace_", value: function(n) {
        return n == " " || n == "	" || n == "\r" || n == `
`;
      } }, { key: "nextChar_", value: function() {
        return this.wkt.charAt(++this.index_);
      } }, { key: "nextToken", value: function() {
        var n, o = this.nextChar_(), a = this.index_, l = o;
        if (o == "(") n = fn;
        else if (o == ",") n = $i;
        else if (o == ")") n = An;
        else if (this.isNumeric_(o) || o == "-") n = th, l = this.readNumber_();
        else if (this.isAlpha_(o)) n = zs, l = this.readText_();
        else {
          if (this.isWhiteSpace_(o)) return this.nextToken();
          if (o !== "") throw new Error("Unexpected character: " + o);
          n = tp;
        }
        return { position: a, value: l, type: n };
      } }, { key: "readNumber_", value: function() {
        var n, o = this.index_, a = !1, l = !1;
        do
          n == "." ? a = !0 : n != "e" && n != "E" || (l = !0), n = this.nextChar_();
        while (this.isNumeric_(n, a) || !l && (n == "e" || n == "E") || l && (n == "-" || n == "+"));
        return parseFloat(this.wkt.substring(o, this.index_--));
      } }, { key: "readText_", value: function() {
        var n, o = this.index_;
        do
          n = this.nextChar_();
        while (this.isAlpha_(n));
        return this.wkt.substring(o, this.index_--).toUpperCase();
      } }]), c;
    }(), ip = function() {
      function c(n, o) {
        e(this, c), this.lexer_ = n, this.token_, this.layout_ = Sa, this.factory = o;
      }
      return s(c, [{ key: "consume_", value: function() {
        this.token_ = this.lexer_.nextToken();
      } }, { key: "isTokenType", value: function(n) {
        return this.token_.type == n;
      } }, { key: "match", value: function(n) {
        var o = this.isTokenType(n);
        return o && this.consume_(), o;
      } }, { key: "parse", value: function() {
        return this.consume_(), this.parseGeometry_();
      } }, { key: "parseGeometryLayout_", value: function() {
        var n = Sa, o = this.token_;
        if (this.isTokenType(zs)) {
          var a = o.value;
          a === "Z" ? n = Jy : a === "M" ? n = Ky : a === "ZM" && (n = Qy), n !== Sa && this.consume_();
        }
        return n;
      } }, { key: "parseGeometryCollectionText_", value: function() {
        if (this.match(fn)) {
          var n = [];
          do
            n.push(this.parseGeometry_());
          while (this.match($i));
          if (this.match(An)) return n;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parsePointText_", value: function() {
        if (this.match(fn)) {
          var n = this.parsePoint_();
          if (this.match(An)) return n;
        } else if (this.isEmptyGeometry_()) return null;
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parseLineStringText_", value: function() {
        if (this.match(fn)) {
          var n = this.parsePointList_();
          if (this.match(An)) return n;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parsePolygonText_", value: function() {
        if (this.match(fn)) {
          var n = this.parseLineStringTextList_();
          if (this.match(An)) return n;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parseMultiPointText_", value: function() {
        var n;
        if (this.match(fn)) {
          if (n = this.token_.type == fn ? this.parsePointTextList_() : this.parsePointList_(), this.match(An)) return n;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parseMultiLineStringText_", value: function() {
        if (this.match(fn)) {
          var n = this.parseLineStringTextList_();
          if (this.match(An)) return n;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parseMultiPolygonText_", value: function() {
        if (this.match(fn)) {
          var n = this.parsePolygonTextList_();
          if (this.match(An)) return n;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parsePoint_", value: function() {
        for (var n = [], o = this.layout_.length, a = 0; a < o; ++a) {
          var l = this.token_;
          if (!this.match(th)) break;
          n.push(l.value);
        }
        if (n.length == o) return n;
        throw new Error(this.formatErrorMessage_());
      } }, { key: "parsePointList_", value: function() {
        for (var n = [this.parsePoint_()]; this.match($i); ) n.push(this.parsePoint_());
        return n;
      } }, { key: "parsePointTextList_", value: function() {
        for (var n = [this.parsePointText_()]; this.match($i); ) n.push(this.parsePointText_());
        return n;
      } }, { key: "parseLineStringTextList_", value: function() {
        for (var n = [this.parseLineStringText_()]; this.match($i); ) n.push(this.parseLineStringText_());
        return n;
      } }, { key: "parsePolygonTextList_", value: function() {
        for (var n = [this.parsePolygonText_()]; this.match($i); ) n.push(this.parsePolygonText_());
        return n;
      } }, { key: "isEmptyGeometry_", value: function() {
        var n = this.isTokenType(zs) && this.token_.value == Ql;
        return n && this.consume_(), n;
      } }, { key: "formatErrorMessage_", value: function() {
        return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
      } }, { key: "parseGeometry_", value: function() {
        var n = this.factory, o = function(at) {
          return y(P, k(at));
        }, a = function(at) {
          var ft = at.map(function(kt) {
            return n.createLinearRing(kt.map(o));
          });
          return ft.length > 1 ? n.createPolygon(ft[0], ft.slice(1)) : n.createPolygon(ft[0]);
        }, l = this.token_;
        if (this.match(zs)) {
          var d = l.value;
          if (this.layout_ = this.parseGeometryLayout_(), d == "GEOMETRYCOLLECTION") {
            var v = this.parseGeometryCollectionText_();
            return n.createGeometryCollection(v);
          }
          switch (d) {
            case "POINT":
              var E = this.parsePointText_();
              return E ? n.createPoint(y(P, k(E))) : n.createPoint();
            case "LINESTRING":
              var S = this.parseLineStringText_().map(o);
              return n.createLineString(S);
            case "LINEARRING":
              var w = this.parseLineStringText_().map(o);
              return n.createLinearRing(w);
            case "POLYGON":
              var N = this.parsePolygonText_();
              return N && N.length !== 0 ? a(N) : n.createPolygon();
            case "MULTIPOINT":
              var M = this.parseMultiPointText_();
              if (!M || M.length === 0) return n.createMultiPoint();
              var Y = M.map(o).map(function(at) {
                return n.createPoint(at);
              });
              return n.createMultiPoint(Y);
            case "MULTILINESTRING":
              var W = this.parseMultiLineStringText_().map(function(at) {
                return n.createLineString(at.map(o));
              });
              return n.createMultiLineString(W);
            case "MULTIPOLYGON":
              var q = this.parseMultiPolygonText_();
              if (!q || q.length === 0) return n.createMultiPolygon();
              var it = q.map(a);
              return n.createMultiPolygon(it);
            default:
              throw new Error("Invalid geometry type: " + d);
          }
        }
        throw new Error(this.formatErrorMessage_());
      } }]), c;
    }();
    function eh(c) {
      if (c.isEmpty()) return "";
      var n = c.getCoordinate(), o = [n.x, n.y];
      return n.z === void 0 || Number.isNaN(n.z) || o.push(n.z), n.m === void 0 || Number.isNaN(n.m) || o.push(n.m), o.join(" ");
    }
    function Dr(c) {
      for (var n = c.getCoordinates().map(function(d) {
        var v = [d.x, d.y];
        return d.z === void 0 || Number.isNaN(d.z) || v.push(d.z), d.m === void 0 || Number.isNaN(d.m) || v.push(d.m), v;
      }), o = [], a = 0, l = n.length; a < l; ++a) o.push(n[a].join(" "));
      return o.join(", ");
    }
    function nh(c) {
      var n = [];
      n.push("(" + Dr(c.getExteriorRing()) + ")");
      for (var o = 0, a = c.getNumInteriorRing(); o < a; ++o) n.push("(" + Dr(c.getInteriorRingN(o)) + ")");
      return n.join(", ");
    }
    var rp = { Point: eh, LineString: Dr, LinearRing: Dr, Polygon: nh, MultiPoint: function(c) {
      for (var n = [], o = 0, a = c.getNumGeometries(); o < a; ++o) n.push("(" + eh(c.getGeometryN(o)) + ")");
      return n.join(", ");
    }, MultiLineString: function(c) {
      for (var n = [], o = 0, a = c.getNumGeometries(); o < a; ++o) n.push("(" + Dr(c.getGeometryN(o)) + ")");
      return n.join(", ");
    }, MultiPolygon: function(c) {
      for (var n = [], o = 0, a = c.getNumGeometries(); o < a; ++o) n.push("(" + nh(c.getGeometryN(o)) + ")");
      return n.join(", ");
    }, GeometryCollection: function(c) {
      for (var n = [], o = 0, a = c.getNumGeometries(); o < a; ++o) n.push(ih(c.getGeometryN(o)));
      return n.join(", ");
    } };
    function ih(c) {
      var n = c.getGeometryType(), o = rp[n];
      n = n.toUpperCase();
      var a = function(l) {
        var d = "";
        if (l.isEmpty()) return d;
        var v = l.getCoordinate();
        return v.z === void 0 || Number.isNaN(v.z) || (d += "Z"), v.m === void 0 || Number.isNaN(v.m) || (d += "M"), d;
      }(c);
      return a.length > 0 && (n += " " + a), c.isEmpty() ? n + " " + Ql : n + " (" + o(c) + ")";
    }
    var sp = function() {
      function c(n) {
        e(this, c), this.geometryFactory = n || new zi(), this.precisionModel = this.geometryFactory.getPrecisionModel();
      }
      return s(c, [{ key: "read", value: function(n) {
        var o = new np(n);
        return new ip(o, this.geometryFactory).parse();
      } }, { key: "write", value: function(n) {
        return ih(n);
      } }]), c;
    }(), Ia = function() {
      function c(n) {
        e(this, c), this.parser = new sp(n);
      }
      return s(c, [{ key: "write", value: function(n) {
        return this.parser.write(n);
      } }], [{ key: "toLineString", value: function(n, o) {
        if (arguments.length !== 2) throw new Error("Not implemented");
        return "LINESTRING ( " + n.x + " " + n.y + ", " + o.x + " " + o.y + " )";
      } }]), c;
    }(), Ot = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getIndexAlongSegment", value: function(n, o) {
        return this.computeIntLineIndex(), this._intLineIndex[n][o];
      } }, { key: "getTopologySummary", value: function() {
        var n = new Ys();
        return this.isEndPoint() && n.append(" endpoint"), this._isProper && n.append(" proper"), this.isCollinear() && n.append(" collinear"), n.toString();
      } }, { key: "computeIntersection", value: function(n, o, a, l) {
        this._inputLines[0][0] = n, this._inputLines[0][1] = o, this._inputLines[1][0] = a, this._inputLines[1][1] = l, this._result = this.computeIntersect(n, o, a, l);
      } }, { key: "getIntersectionNum", value: function() {
        return this._result;
      } }, { key: "computeIntLineIndex", value: function() {
        if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(function() {
          return Array(2);
        }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
        else if (arguments.length === 1) {
          var n = arguments[0], o = this.getEdgeDistance(n, 0), a = this.getEdgeDistance(n, 1);
          o > a ? (this._intLineIndex[n][0] = 0, this._intLineIndex[n][1] = 1) : (this._intLineIndex[n][0] = 1, this._intLineIndex[n][1] = 0);
        }
      } }, { key: "isProper", value: function() {
        return this.hasIntersection() && this._isProper;
      } }, { key: "setPrecisionModel", value: function(n) {
        this._precisionModel = n;
      } }, { key: "isInteriorIntersection", value: function() {
        if (arguments.length === 0) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
        if (arguments.length === 1) {
          for (var n = arguments[0], o = 0; o < this._result; o++) if (!this._intPt[o].equals2D(this._inputLines[n][0]) && !this._intPt[o].equals2D(this._inputLines[n][1])) return !0;
          return !1;
        }
      } }, { key: "getIntersection", value: function(n) {
        return this._intPt[n];
      } }, { key: "isEndPoint", value: function() {
        return this.hasIntersection() && !this._isProper;
      } }, { key: "hasIntersection", value: function() {
        return this._result !== c.NO_INTERSECTION;
      } }, { key: "getEdgeDistance", value: function(n, o) {
        return c.computeEdgeDistance(this._intPt[o], this._inputLines[n][0], this._inputLines[n][1]);
      } }, { key: "isCollinear", value: function() {
        return this._result === c.COLLINEAR_INTERSECTION;
      } }, { key: "toString", value: function() {
        return Ia.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Ia.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
      } }, { key: "getEndpoint", value: function(n, o) {
        return this._inputLines[n][o];
      } }, { key: "isIntersection", value: function(n) {
        for (var o = 0; o < this._result; o++) if (this._intPt[o].equals2D(n)) return !0;
        return !1;
      } }, { key: "getIntersectionAlongSegment", value: function(n, o) {
        return this.computeIntLineIndex(), this._intPt[this._intLineIndex[n][o]];
      } }], [{ key: "constructor_", value: function() {
        this._result = null, this._inputLines = Array(2).fill().map(function() {
          return Array(2);
        }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new P(), this._intPt[1] = new P(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
      } }, { key: "computeEdgeDistance", value: function(n, o, a) {
        var l = Math.abs(a.x - o.x), d = Math.abs(a.y - o.y), v = -1;
        if (n.equals(o)) v = 0;
        else if (n.equals(a)) v = l > d ? l : d;
        else {
          var E = Math.abs(n.x - o.x), S = Math.abs(n.y - o.y);
          (v = l > d ? E : S) !== 0 || n.equals(o) || (v = Math.max(E, S));
        }
        return z.isTrue(!(v === 0 && !n.equals(o)), "Bad distance calculation"), v;
      } }, { key: "nonRobustComputeEdgeDistance", value: function(n, o, a) {
        var l = n.x - o.x, d = n.y - o.y, v = Math.sqrt(l * l + d * d);
        return z.isTrue(!(v === 0 && !n.equals(o)), "Invalid distance calculation"), v;
      } }]), c;
    }();
    Ot.DONT_INTERSECT = 0, Ot.DO_INTERSECT = 1, Ot.COLLINEAR = 2, Ot.NO_INTERSECTION = 0, Ot.POINT_INTERSECTION = 1, Ot.COLLINEAR_INTERSECTION = 2;
    var fi = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        return e(this, o), n.call(this);
      }
      return s(o, [{ key: "isInSegmentEnvelopes", value: function(a) {
        var l = new bt(this._inputLines[0][0], this._inputLines[0][1]), d = new bt(this._inputLines[1][0], this._inputLines[1][1]);
        return l.contains(a) && d.contains(a);
      } }, { key: "computeIntersection", value: function() {
        if (arguments.length !== 3) return I(h(o.prototype), "computeIntersection", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1], d = arguments[2];
        if (this._isProper = !1, bt.intersects(l, d, a) && ut.index(l, d, a) === 0 && ut.index(d, l, a) === 0) return this._isProper = !0, (a.equals(l) || a.equals(d)) && (this._isProper = !1), this._result = Ot.POINT_INTERSECTION, null;
        this._result = Ot.NO_INTERSECTION;
      } }, { key: "intersection", value: function(a, l, d, v) {
        var E = this.intersectionSafe(a, l, d, v);
        return this.isInSegmentEnvelopes(E) || (E = new P(o.nearestEndpoint(a, l, d, v))), this._precisionModel !== null && this._precisionModel.makePrecise(E), E;
      } }, { key: "checkDD", value: function(a, l, d, v, E) {
        var S = On.intersection(a, l, d, v), w = this.isInSegmentEnvelopes(S);
        re.out.println("DD in env = " + w + "  --------------------- " + S), E.distance(S) > 1e-4 && re.out.println("Distance = " + E.distance(S));
      } }, { key: "intersectionSafe", value: function(a, l, d, v) {
        var E = li.intersection(a, l, d, v);
        return E === null && (E = o.nearestEndpoint(a, l, d, v)), E;
      } }, { key: "computeCollinearIntersection", value: function(a, l, d, v) {
        var E = bt.intersects(a, l, d), S = bt.intersects(a, l, v), w = bt.intersects(d, v, a), N = bt.intersects(d, v, l);
        return E && S ? (this._intPt[0] = d, this._intPt[1] = v, Ot.COLLINEAR_INTERSECTION) : w && N ? (this._intPt[0] = a, this._intPt[1] = l, Ot.COLLINEAR_INTERSECTION) : E && w ? (this._intPt[0] = d, this._intPt[1] = a, !d.equals(a) || S || N ? Ot.COLLINEAR_INTERSECTION : Ot.POINT_INTERSECTION) : E && N ? (this._intPt[0] = d, this._intPt[1] = l, !d.equals(l) || S || w ? Ot.COLLINEAR_INTERSECTION : Ot.POINT_INTERSECTION) : S && w ? (this._intPt[0] = v, this._intPt[1] = a, !v.equals(a) || E || N ? Ot.COLLINEAR_INTERSECTION : Ot.POINT_INTERSECTION) : S && N ? (this._intPt[0] = v, this._intPt[1] = l, !v.equals(l) || E || w ? Ot.COLLINEAR_INTERSECTION : Ot.POINT_INTERSECTION) : Ot.NO_INTERSECTION;
      } }, { key: "computeIntersect", value: function(a, l, d, v) {
        if (this._isProper = !1, !bt.intersects(a, l, d, v)) return Ot.NO_INTERSECTION;
        var E = ut.index(a, l, d), S = ut.index(a, l, v);
        if (E > 0 && S > 0 || E < 0 && S < 0) return Ot.NO_INTERSECTION;
        var w = ut.index(d, v, a), N = ut.index(d, v, l);
        return w > 0 && N > 0 || w < 0 && N < 0 ? Ot.NO_INTERSECTION : E === 0 && S === 0 && w === 0 && N === 0 ? this.computeCollinearIntersection(a, l, d, v) : (E === 0 || S === 0 || w === 0 || N === 0 ? (this._isProper = !1, a.equals2D(d) || a.equals2D(v) ? this._intPt[0] = a : l.equals2D(d) || l.equals2D(v) ? this._intPt[0] = l : E === 0 ? this._intPt[0] = new P(d) : S === 0 ? this._intPt[0] = new P(v) : w === 0 ? this._intPt[0] = new P(a) : N === 0 && (this._intPt[0] = new P(l))) : (this._isProper = !0, this._intPt[0] = this.intersection(a, l, d, v)), Ot.POINT_INTERSECTION);
      } }], [{ key: "nearestEndpoint", value: function(a, l, d, v) {
        var E = a, S = Ht.pointToSegment(a, d, v), w = Ht.pointToSegment(l, d, v);
        return w < S && (S = w, E = l), (w = Ht.pointToSegment(d, a, l)) < S && (S = w, E = d), (w = Ht.pointToSegment(v, a, l)) < S && (S = w, E = v), E;
      } }]), o;
    }(Ot), op = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "countSegment", value: function(n, o) {
        if (n.x < this._p.x && o.x < this._p.x) return null;
        if (this._p.x === o.x && this._p.y === o.y) return this._isPointOnSegment = !0, null;
        if (n.y === this._p.y && o.y === this._p.y) {
          var a = n.x, l = o.x;
          return a > l && (a = o.x, l = n.x), this._p.x >= a && this._p.x <= l && (this._isPointOnSegment = !0), null;
        }
        if (n.y > this._p.y && o.y <= this._p.y || o.y > this._p.y && n.y <= this._p.y) {
          var d = ut.index(n, o, this._p);
          if (d === ut.COLLINEAR) return this._isPointOnSegment = !0, null;
          o.y < n.y && (d = -d), d === ut.LEFT && this._crossingCount++;
        }
      } }, { key: "isPointInPolygon", value: function() {
        return this.getLocation() !== T.EXTERIOR;
      } }, { key: "getLocation", value: function() {
        return this._isPointOnSegment ? T.BOUNDARY : this._crossingCount % 2 == 1 ? T.INTERIOR : T.EXTERIOR;
      } }, { key: "isOnSegment", value: function() {
        return this._isPointOnSegment;
      } }], [{ key: "constructor_", value: function() {
        this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
        var n = arguments[0];
        this._p = n;
      } }, { key: "locatePointInRing", value: function() {
        if (arguments[0] instanceof P && ht(arguments[1], vt)) {
          for (var n = arguments[0], o = arguments[1], a = new c(n), l = new P(), d = new P(), v = 1; v < o.size(); v++) if (o.getCoordinate(v, l), o.getCoordinate(v - 1, d), a.countSegment(l, d), a.isOnSegment()) return a.getLocation();
          return a.getLocation();
        }
        if (arguments[0] instanceof P && arguments[1] instanceof Array) {
          for (var E = arguments[0], S = arguments[1], w = new c(E), N = 1; N < S.length; N++) {
            var M = S[N], Y = S[N - 1];
            if (w.countSegment(M, Y), w.isOnSegment()) return w.getLocation();
          }
          return w.getLocation();
        }
      } }]), c;
    }(), wa = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "isOnLine", value: function() {
        if (arguments[0] instanceof P && ht(arguments[1], vt)) {
          for (var n = arguments[0], o = arguments[1], a = new fi(), l = new P(), d = new P(), v = o.size(), E = 1; E < v; E++) if (o.getCoordinate(E - 1, l), o.getCoordinate(E, d), a.computeIntersection(n, l, d), a.hasIntersection()) return !0;
          return !1;
        }
        if (arguments[0] instanceof P && arguments[1] instanceof Array) {
          for (var S = arguments[0], w = arguments[1], N = new fi(), M = 1; M < w.length; M++) {
            var Y = w[M - 1], W = w[M];
            if (N.computeIntersection(S, Y, W), N.hasIntersection()) return !0;
          }
          return !1;
        }
      } }, { key: "locateInRing", value: function(n, o) {
        return op.locatePointInRing(n, o);
      } }, { key: "isInRing", value: function(n, o) {
        return c.locateInRing(n, o) !== T.EXTERIOR;
      } }]), c;
    }(), Ce = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "setAllLocations", value: function(n) {
        for (var o = 0; o < this.location.length; o++) this.location[o] = n;
      } }, { key: "isNull", value: function() {
        for (var n = 0; n < this.location.length; n++) if (this.location[n] !== T.NONE) return !1;
        return !0;
      } }, { key: "setAllLocationsIfNull", value: function(n) {
        for (var o = 0; o < this.location.length; o++) this.location[o] === T.NONE && (this.location[o] = n);
      } }, { key: "isLine", value: function() {
        return this.location.length === 1;
      } }, { key: "merge", value: function(n) {
        if (n.location.length > this.location.length) {
          var o = new Array(3).fill(null);
          o[U.ON] = this.location[U.ON], o[U.LEFT] = T.NONE, o[U.RIGHT] = T.NONE, this.location = o;
        }
        for (var a = 0; a < this.location.length; a++) this.location[a] === T.NONE && a < n.location.length && (this.location[a] = n.location[a]);
      } }, { key: "getLocations", value: function() {
        return this.location;
      } }, { key: "flip", value: function() {
        if (this.location.length <= 1) return null;
        var n = this.location[U.LEFT];
        this.location[U.LEFT] = this.location[U.RIGHT], this.location[U.RIGHT] = n;
      } }, { key: "toString", value: function() {
        var n = new Ge();
        return this.location.length > 1 && n.append(T.toLocationSymbol(this.location[U.LEFT])), n.append(T.toLocationSymbol(this.location[U.ON])), this.location.length > 1 && n.append(T.toLocationSymbol(this.location[U.RIGHT])), n.toString();
      } }, { key: "setLocations", value: function(n, o, a) {
        this.location[U.ON] = n, this.location[U.LEFT] = o, this.location[U.RIGHT] = a;
      } }, { key: "get", value: function(n) {
        return n < this.location.length ? this.location[n] : T.NONE;
      } }, { key: "isArea", value: function() {
        return this.location.length > 1;
      } }, { key: "isAnyNull", value: function() {
        for (var n = 0; n < this.location.length; n++) if (this.location[n] === T.NONE) return !0;
        return !1;
      } }, { key: "setLocation", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          this.setLocation(U.ON, n);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this.location[o] = a;
        }
      } }, { key: "init", value: function(n) {
        this.location = new Array(n).fill(null), this.setAllLocations(T.NONE);
      } }, { key: "isEqualOnSide", value: function(n, o) {
        return this.location[o] === n.location[o];
      } }, { key: "allPositionsEqual", value: function(n) {
        for (var o = 0; o < this.location.length; o++) if (this.location[o] !== n) return !1;
        return !0;
      } }], [{ key: "constructor_", value: function() {
        if (this.location = null, arguments.length === 1) {
          if (arguments[0] instanceof Array) {
            var n = arguments[0];
            this.init(n.length);
          } else if (Number.isInteger(arguments[0])) {
            var o = arguments[0];
            this.init(1), this.location[U.ON] = o;
          } else if (arguments[0] instanceof c) {
            var a = arguments[0];
            if (this.init(a.location.length), a !== null) for (var l = 0; l < this.location.length; l++) this.location[l] = a.location[l];
          }
        } else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], E = arguments[2];
          this.init(3), this.location[U.ON] = d, this.location[U.LEFT] = v, this.location[U.RIGHT] = E;
        }
      } }]), c;
    }(), Re = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getGeometryCount", value: function() {
        var n = 0;
        return this.elt[0].isNull() || n++, this.elt[1].isNull() || n++, n;
      } }, { key: "setAllLocations", value: function(n, o) {
        this.elt[n].setAllLocations(o);
      } }, { key: "isNull", value: function(n) {
        return this.elt[n].isNull();
      } }, { key: "setAllLocationsIfNull", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          this.setAllLocationsIfNull(0, n), this.setAllLocationsIfNull(1, n);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this.elt[o].setAllLocationsIfNull(a);
        }
      } }, { key: "isLine", value: function(n) {
        return this.elt[n].isLine();
      } }, { key: "merge", value: function(n) {
        for (var o = 0; o < 2; o++) this.elt[o] === null && n.elt[o] !== null ? this.elt[o] = new Ce(n.elt[o]) : this.elt[o].merge(n.elt[o]);
      } }, { key: "flip", value: function() {
        this.elt[0].flip(), this.elt[1].flip();
      } }, { key: "getLocation", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return this.elt[n].get(U.ON);
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          return this.elt[o].get(a);
        }
      } }, { key: "toString", value: function() {
        var n = new Ge();
        return this.elt[0] !== null && (n.append("A:"), n.append(this.elt[0].toString())), this.elt[1] !== null && (n.append(" B:"), n.append(this.elt[1].toString())), n.toString();
      } }, { key: "isArea", value: function() {
        if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
        if (arguments.length === 1) {
          var n = arguments[0];
          return this.elt[n].isArea();
        }
      } }, { key: "isAnyNull", value: function(n) {
        return this.elt[n].isAnyNull();
      } }, { key: "setLocation", value: function() {
        if (arguments.length === 2) {
          var n = arguments[0], o = arguments[1];
          this.elt[n].setLocation(U.ON, o);
        } else if (arguments.length === 3) {
          var a = arguments[0], l = arguments[1], d = arguments[2];
          this.elt[a].setLocation(l, d);
        }
      } }, { key: "isEqualOnSide", value: function(n, o) {
        return this.elt[0].isEqualOnSide(n.elt[0], o) && this.elt[1].isEqualOnSide(n.elt[1], o);
      } }, { key: "allPositionsEqual", value: function(n, o) {
        return this.elt[n].allPositionsEqual(o);
      } }, { key: "toLine", value: function(n) {
        this.elt[n].isArea() && (this.elt[n] = new Ce(this.elt[n].location[0]));
      } }], [{ key: "constructor_", value: function() {
        if (this.elt = new Array(2).fill(null), arguments.length === 1) {
          if (Number.isInteger(arguments[0])) {
            var n = arguments[0];
            this.elt[0] = new Ce(n), this.elt[1] = new Ce(n);
          } else if (arguments[0] instanceof c) {
            var o = arguments[0];
            this.elt[0] = new Ce(o.elt[0]), this.elt[1] = new Ce(o.elt[1]);
          }
        } else if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          this.elt[0] = new Ce(T.NONE), this.elt[1] = new Ce(T.NONE), this.elt[a].setLocation(l);
        } else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], E = arguments[2];
          this.elt[0] = new Ce(d, v, E), this.elt[1] = new Ce(d, v, E);
        } else if (arguments.length === 4) {
          var S = arguments[0], w = arguments[1], N = arguments[2], M = arguments[3];
          this.elt[0] = new Ce(T.NONE, T.NONE, T.NONE), this.elt[1] = new Ce(T.NONE, T.NONE, T.NONE), this.elt[S].setLocations(w, N, M);
        }
      } }, { key: "toLineLabel", value: function(n) {
        for (var o = new c(T.NONE), a = 0; a < 2; a++) o.setLocation(a, n.getLocation(a));
        return o;
      } }]), c;
    }(), $s = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "computeRing", value: function() {
        if (this._ring !== null) return null;
        for (var n = new Array(this._pts.size()).fill(null), o = 0; o < this._pts.size(); o++) n[o] = this._pts.get(o);
        this._ring = this._geometryFactory.createLinearRing(n), this._isHole = ut.isCCW(this._ring.getCoordinates());
      } }, { key: "isIsolated", value: function() {
        return this._label.getGeometryCount() === 1;
      } }, { key: "computePoints", value: function(n) {
        this._startDe = n;
        var o = n, a = !0;
        do {
          if (o === null) throw new de("Found null DirectedEdge");
          if (o.getEdgeRing() === this) throw new de("Directed Edge visited twice during ring-building at " + o.getCoordinate());
          this._edges.add(o);
          var l = o.getLabel();
          z.isTrue(l.isArea()), this.mergeLabel(l), this.addPoints(o.getEdge(), o.isForward(), a), a = !1, this.setEdgeRing(o, this), o = this.getNext(o);
        } while (o !== this._startDe);
      } }, { key: "getLinearRing", value: function() {
        return this._ring;
      } }, { key: "getCoordinate", value: function(n) {
        return this._pts.get(n);
      } }, { key: "computeMaxNodeDegree", value: function() {
        this._maxNodeDegree = 0;
        var n = this._startDe;
        do {
          var o = n.getNode().getEdges().getOutgoingDegree(this);
          o > this._maxNodeDegree && (this._maxNodeDegree = o), n = this.getNext(n);
        } while (n !== this._startDe);
        this._maxNodeDegree *= 2;
      } }, { key: "addPoints", value: function(n, o, a) {
        var l = n.getCoordinates();
        if (o) {
          var d = 1;
          a && (d = 0);
          for (var v = d; v < l.length; v++) this._pts.add(l[v]);
        } else {
          var E = l.length - 2;
          a && (E = l.length - 1);
          for (var S = E; S >= 0; S--) this._pts.add(l[S]);
        }
      } }, { key: "isHole", value: function() {
        return this._isHole;
      } }, { key: "setInResult", value: function() {
        var n = this._startDe;
        do
          n.getEdge().setInResult(!0), n = n.getNext();
        while (n !== this._startDe);
      } }, { key: "containsPoint", value: function(n) {
        var o = this.getLinearRing();
        if (!o.getEnvelopeInternal().contains(n) || !wa.isInRing(n, o.getCoordinates())) return !1;
        for (var a = this._holes.iterator(); a.hasNext(); )
          if (a.next().containsPoint(n)) return !1;
        return !0;
      } }, { key: "addHole", value: function(n) {
        this._holes.add(n);
      } }, { key: "isShell", value: function() {
        return this._shell === null;
      } }, { key: "getLabel", value: function() {
        return this._label;
      } }, { key: "getEdges", value: function() {
        return this._edges;
      } }, { key: "getMaxNodeDegree", value: function() {
        return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
      } }, { key: "getShell", value: function() {
        return this._shell;
      } }, { key: "mergeLabel", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          this.mergeLabel(n, 0), this.mergeLabel(n, 1);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1], l = o.getLocation(a, U.RIGHT);
          if (l === T.NONE) return null;
          if (this._label.getLocation(a) === T.NONE) return this._label.setLocation(a, l), null;
        }
      } }, { key: "setShell", value: function(n) {
        this._shell = n, n !== null && n.addHole(this);
      } }, { key: "toPolygon", value: function(n) {
        for (var o = new Array(this._holes.size()).fill(null), a = 0; a < this._holes.size(); a++) o[a] = this._holes.get(a).getLinearRing();
        return n.createPolygon(this.getLinearRing(), o);
      } }], [{ key: "constructor_", value: function() {
        if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new ot(), this._pts = new ot(), this._label = new Re(T.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new ot(), this._geometryFactory = null, arguments.length !== 0) {
          if (arguments.length === 2) {
            var n = arguments[0], o = arguments[1];
            this._geometryFactory = o, this.computePoints(n), this.computeRing();
          }
        }
      } }]), c;
    }(), ap = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "setEdgeRing", value: function(a, l) {
        a.setMinEdgeRing(l);
      } }, { key: "getNext", value: function(a) {
        return a.getNextMin();
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        $s.constructor_.call(this, a, l);
      } }]), o;
    }($s), up = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "buildMinimalRings", value: function() {
        var a = new ot(), l = this._startDe;
        do {
          if (l.getMinEdgeRing() === null) {
            var d = new ap(l, this._geometryFactory);
            a.add(d);
          }
          l = l.getNext();
        } while (l !== this._startDe);
        return a;
      } }, { key: "setEdgeRing", value: function(a, l) {
        a.setEdgeRing(l);
      } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function() {
        var a = this._startDe;
        do
          a.getNode().getEdges().linkMinimalDirectedEdges(this), a = a.getNext();
        while (a !== this._startDe);
      } }, { key: "getNext", value: function(a) {
        return a.getNext();
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0], l = arguments[1];
        $s.constructor_.call(this, a, l);
      } }]), o;
    }($s), rh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "setVisited", value: function(n) {
        this._isVisited = n;
      } }, { key: "setInResult", value: function(n) {
        this._isInResult = n;
      } }, { key: "isCovered", value: function() {
        return this._isCovered;
      } }, { key: "isCoveredSet", value: function() {
        return this._isCoveredSet;
      } }, { key: "setLabel", value: function(n) {
        this._label = n;
      } }, { key: "getLabel", value: function() {
        return this._label;
      } }, { key: "setCovered", value: function(n) {
        this._isCovered = n, this._isCoveredSet = !0;
      } }, { key: "updateIM", value: function(n) {
        z.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(n);
      } }, { key: "isInResult", value: function() {
        return this._isInResult;
      } }, { key: "isVisited", value: function() {
        return this._isVisited;
      } }], [{ key: "constructor_", value: function() {
        if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length !== 0) {
          if (arguments.length === 1) {
            var n = arguments[0];
            this._label = n;
          }
        }
      } }]), c;
    }(), Xs = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "isIncidentEdgeInResult", value: function() {
        for (var a = this.getEdges().getEdges().iterator(); a.hasNext(); )
          if (a.next().getEdge().isInResult()) return !0;
        return !1;
      } }, { key: "isIsolated", value: function() {
        return this._label.getGeometryCount() === 1;
      } }, { key: "getCoordinate", value: function() {
        return this._coord;
      } }, { key: "print", value: function(a) {
        a.println("node " + this._coord + " lbl: " + this._label);
      } }, { key: "computeIM", value: function(a) {
      } }, { key: "computeMergedLocation", value: function(a, l) {
        var d = T.NONE;
        if (d = this._label.getLocation(l), !a.isNull(l)) {
          var v = a.getLocation(l);
          d !== T.BOUNDARY && (d = v);
        }
        return d;
      } }, { key: "setLabel", value: function() {
        if (arguments.length !== 2 || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return I(h(o.prototype), "setLabel", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1];
        this._label === null ? this._label = new Re(a, l) : this._label.setLocation(a, l);
      } }, { key: "getEdges", value: function() {
        return this._edges;
      } }, { key: "mergeLabel", value: function() {
        if (arguments[0] instanceof o) {
          var a = arguments[0];
          this.mergeLabel(a._label);
        } else if (arguments[0] instanceof Re) for (var l = arguments[0], d = 0; d < 2; d++) {
          var v = this.computeMergedLocation(l, d), E = this._label.getLocation(d);
          E === T.NONE && this._label.setLocation(d, v);
        }
      } }, { key: "add", value: function(a) {
        this._edges.insert(a), a.setNode(this);
      } }, { key: "setLabelBoundary", value: function(a) {
        if (this._label === null) return null;
        var l = T.NONE;
        this._label !== null && (l = this._label.getLocation(a));
        var d = null;
        switch (l) {
          case T.BOUNDARY:
            d = T.INTERIOR;
            break;
          case T.INTERIOR:
          default:
            d = T.BOUNDARY;
        }
        this._label.setLocation(a, d);
      } }], [{ key: "constructor_", value: function() {
        this._coord = null, this._edges = null;
        var a = arguments[0], l = arguments[1];
        this._coord = a, this._edges = l, this._label = new Re(0, T.NONE);
      } }]), o;
    }(rh), lp = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        return e(this, o), n.apply(this, arguments);
      }
      return o;
    }(Jl);
    function sh(c) {
      return c == null ? 0 : c.color;
    }
    function It(c) {
      return c == null ? null : c.parent;
    }
    function Je(c, n) {
      c !== null && (c.color = n);
    }
    function ka(c) {
      return c == null ? null : c.left;
    }
    function oh(c) {
      return c == null ? null : c.right;
    }
    var Fr = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), (a = n.call(this)).root_ = null, a.size_ = 0, a;
      }
      return s(o, [{ key: "get", value: function(a) {
        for (var l = this.root_; l !== null; ) {
          var d = a.compareTo(l.key);
          if (d < 0) l = l.left;
          else {
            if (!(d > 0)) return l.value;
            l = l.right;
          }
        }
        return null;
      } }, { key: "put", value: function(a, l) {
        if (this.root_ === null) return this.root_ = { key: a, value: l, left: null, right: null, parent: null, color: 0, getValue: function() {
          return this.value;
        }, getKey: function() {
          return this.key;
        } }, this.size_ = 1, null;
        var d, v, E = this.root_;
        do
          if (d = E, (v = a.compareTo(E.key)) < 0) E = E.left;
          else {
            if (!(v > 0)) {
              var S = E.value;
              return E.value = l, S;
            }
            E = E.right;
          }
        while (E !== null);
        var w = { key: a, left: null, right: null, value: l, parent: d, color: 0, getValue: function() {
          return this.value;
        }, getKey: function() {
          return this.key;
        } };
        return v < 0 ? d.left = w : d.right = w, this.fixAfterInsertion(w), this.size_++, null;
      } }, { key: "fixAfterInsertion", value: function(a) {
        var l;
        for (a.color = 1; a != null && a !== this.root_ && a.parent.color === 1; ) It(a) === ka(It(It(a))) ? sh(l = oh(It(It(a)))) === 1 ? (Je(It(a), 0), Je(l, 0), Je(It(It(a)), 1), a = It(It(a))) : (a === oh(It(a)) && (a = It(a), this.rotateLeft(a)), Je(It(a), 0), Je(It(It(a)), 1), this.rotateRight(It(It(a)))) : sh(l = ka(It(It(a)))) === 1 ? (Je(It(a), 0), Je(l, 0), Je(It(It(a)), 1), a = It(It(a))) : (a === ka(It(a)) && (a = It(a), this.rotateRight(a)), Je(It(a), 0), Je(It(It(a)), 1), this.rotateLeft(It(It(a))));
        this.root_.color = 0;
      } }, { key: "values", value: function() {
        var a = new ot(), l = this.getFirstEntry();
        if (l !== null) for (a.add(l.value); (l = o.successor(l)) !== null; ) a.add(l.value);
        return a;
      } }, { key: "entrySet", value: function() {
        var a = new ai(), l = this.getFirstEntry();
        if (l !== null) for (a.add(l); (l = o.successor(l)) !== null; ) a.add(l);
        return a;
      } }, { key: "rotateLeft", value: function(a) {
        if (a != null) {
          var l = a.right;
          a.right = l.left, l.left != null && (l.left.parent = a), l.parent = a.parent, a.parent == null ? this.root_ = l : a.parent.left === a ? a.parent.left = l : a.parent.right = l, l.left = a, a.parent = l;
        }
      } }, { key: "rotateRight", value: function(a) {
        if (a != null) {
          var l = a.left;
          a.left = l.right, l.right != null && (l.right.parent = a), l.parent = a.parent, a.parent == null ? this.root_ = l : a.parent.right === a ? a.parent.right = l : a.parent.left = l, l.right = a, a.parent = l;
        }
      } }, { key: "getFirstEntry", value: function() {
        var a = this.root_;
        if (a != null) for (; a.left != null; ) a = a.left;
        return a;
      } }, { key: "size", value: function() {
        return this.size_;
      } }, { key: "containsKey", value: function(a) {
        for (var l = this.root_; l !== null; ) {
          var d = a.compareTo(l.key);
          if (d < 0) l = l.left;
          else {
            if (!(d > 0)) return !0;
            l = l.right;
          }
        }
        return !1;
      } }], [{ key: "successor", value: function(a) {
        var l;
        if (a === null) return null;
        if (a.right !== null) {
          for (l = a.right; l.left !== null; ) l = l.left;
          return l;
        }
        l = a.parent;
        for (var d = a; l !== null && d === l.right; ) d = l, l = l.parent;
        return l;
      } }]), o;
    }(lp), ah = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "find", value: function(n) {
        return this.nodeMap.get(n);
      } }, { key: "addNode", value: function() {
        if (arguments[0] instanceof P) {
          var n = arguments[0], o = this.nodeMap.get(n);
          return o === null && (o = this.nodeFact.createNode(n), this.nodeMap.put(n, o)), o;
        }
        if (arguments[0] instanceof Xs) {
          var a = arguments[0], l = this.nodeMap.get(a.getCoordinate());
          return l === null ? (this.nodeMap.put(a.getCoordinate(), a), a) : (l.mergeLabel(a), l);
        }
      } }, { key: "print", value: function(n) {
        for (var o = this.iterator(); o.hasNext(); )
          o.next().print(n);
      } }, { key: "iterator", value: function() {
        return this.nodeMap.values().iterator();
      } }, { key: "values", value: function() {
        return this.nodeMap.values();
      } }, { key: "getBoundaryNodes", value: function(n) {
        for (var o = new ot(), a = this.iterator(); a.hasNext(); ) {
          var l = a.next();
          l.getLabel().getLocation(n) === T.BOUNDARY && o.add(l);
        }
        return o;
      } }, { key: "add", value: function(n) {
        var o = n.getCoordinate();
        this.addNode(o).add(n);
      } }], [{ key: "constructor_", value: function() {
        this.nodeMap = new Fr(), this.nodeFact = null;
        var n = arguments[0];
        this.nodeFact = n;
      } }]), c;
    }(), oe = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "isNorthern", value: function(n) {
        return n === c.NE || n === c.NW;
      } }, { key: "isOpposite", value: function(n, o) {
        return n !== o && (n - o + 4) % 4 === 2;
      } }, { key: "commonHalfPlane", value: function(n, o) {
        if (n === o) return n;
        if ((n - o + 4) % 4 === 2) return -1;
        var a = n < o ? n : o;
        return a === 0 && (n > o ? n : o) === 3 ? 3 : a;
      } }, { key: "isInHalfPlane", value: function(n, o) {
        return o === c.SE ? n === c.SE || n === c.SW : n === o || n === o + 1;
      } }, { key: "quadrant", value: function() {
        if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var n = arguments[0], o = arguments[1];
          if (n === 0 && o === 0) throw new L("Cannot compute the quadrant for point ( " + n + ", " + o + " )");
          return n >= 0 ? o >= 0 ? c.NE : c.SE : o >= 0 ? c.NW : c.SW;
        }
        if (arguments[0] instanceof P && arguments[1] instanceof P) {
          var a = arguments[0], l = arguments[1];
          if (l.x === a.x && l.y === a.y) throw new L("Cannot compute the quadrant for two identical points " + a);
          return l.x >= a.x ? l.y >= a.y ? c.NE : c.SE : l.y >= a.y ? c.NW : c.SW;
        }
      } }]), c;
    }();
    oe.NE = 0, oe.NW = 1, oe.SW = 2, oe.SE = 3;
    var uh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "compareDirection", value: function(n) {
        return this._dx === n._dx && this._dy === n._dy ? 0 : this._quadrant > n._quadrant ? 1 : this._quadrant < n._quadrant ? -1 : ut.index(n._p0, n._p1, this._p1);
      } }, { key: "getDy", value: function() {
        return this._dy;
      } }, { key: "getCoordinate", value: function() {
        return this._p0;
      } }, { key: "setNode", value: function(n) {
        this._node = n;
      } }, { key: "print", value: function(n) {
        var o = Math.atan2(this._dy, this._dx), a = this.getClass().getName(), l = a.lastIndexOf("."), d = a.substring(l + 1);
        n.print("  " + d + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + o + "   " + this._label);
      } }, { key: "compareTo", value: function(n) {
        var o = n;
        return this.compareDirection(o);
      } }, { key: "getDirectedCoordinate", value: function() {
        return this._p1;
      } }, { key: "getDx", value: function() {
        return this._dx;
      } }, { key: "getLabel", value: function() {
        return this._label;
      } }, { key: "getEdge", value: function() {
        return this._edge;
      } }, { key: "getQuadrant", value: function() {
        return this._quadrant;
      } }, { key: "getNode", value: function() {
        return this._node;
      } }, { key: "toString", value: function() {
        var n = Math.atan2(this._dy, this._dx), o = this.getClass().getName(), a = o.lastIndexOf(".");
        return "  " + o.substring(a + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + n + "   " + this._label;
      } }, { key: "computeLabel", value: function(n) {
      } }, { key: "init", value: function(n, o) {
        this._p0 = n, this._p1 = o, this._dx = o.x - n.x, this._dy = o.y - n.y, this._quadrant = oe.quadrant(this._dx, this._dy), z.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }], [{ key: "constructor_", value: function() {
        if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
          var n = arguments[0];
          this._edge = n;
        } else if (arguments.length === 3) {
          var o = arguments[0], a = arguments[1], l = arguments[2];
          c.constructor_.call(this, o, a, l, null);
        } else if (arguments.length === 4) {
          var d = arguments[0], v = arguments[1], E = arguments[2], S = arguments[3];
          c.constructor_.call(this, d), this.init(v, E), this._label = S;
        }
      } }]), c;
    }(), Ca = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "getNextMin", value: function() {
        return this._nextMin;
      } }, { key: "getDepth", value: function(a) {
        return this._depth[a];
      } }, { key: "setVisited", value: function(a) {
        this._isVisited = a;
      } }, { key: "computeDirectedLabel", value: function() {
        this._label = new Re(this._edge.getLabel()), this._isForward || this._label.flip();
      } }, { key: "getNext", value: function() {
        return this._next;
      } }, { key: "setDepth", value: function(a, l) {
        if (this._depth[a] !== -999 && this._depth[a] !== l) throw new de("assigned depths do not match", this.getCoordinate());
        this._depth[a] = l;
      } }, { key: "isInteriorAreaEdge", value: function() {
        for (var a = !0, l = 0; l < 2; l++) this._label.isArea(l) && this._label.getLocation(l, U.LEFT) === T.INTERIOR && this._label.getLocation(l, U.RIGHT) === T.INTERIOR || (a = !1);
        return a;
      } }, { key: "setNextMin", value: function(a) {
        this._nextMin = a;
      } }, { key: "print", value: function(a) {
        I(h(o.prototype), "print", this).call(this, a), a.print(" " + this._depth[U.LEFT] + "/" + this._depth[U.RIGHT]), a.print(" (" + this.getDepthDelta() + ")"), this._isInResult && a.print(" inResult");
      } }, { key: "setMinEdgeRing", value: function(a) {
        this._minEdgeRing = a;
      } }, { key: "isLineEdge", value: function() {
        var a = this._label.isLine(0) || this._label.isLine(1), l = !this._label.isArea(0) || this._label.allPositionsEqual(0, T.EXTERIOR), d = !this._label.isArea(1) || this._label.allPositionsEqual(1, T.EXTERIOR);
        return a && l && d;
      } }, { key: "setEdgeRing", value: function(a) {
        this._edgeRing = a;
      } }, { key: "getMinEdgeRing", value: function() {
        return this._minEdgeRing;
      } }, { key: "getDepthDelta", value: function() {
        var a = this._edge.getDepthDelta();
        return this._isForward || (a = -a), a;
      } }, { key: "setInResult", value: function(a) {
        this._isInResult = a;
      } }, { key: "getSym", value: function() {
        return this._sym;
      } }, { key: "isForward", value: function() {
        return this._isForward;
      } }, { key: "getEdge", value: function() {
        return this._edge;
      } }, { key: "printEdge", value: function(a) {
        this.print(a), a.print(" "), this._isForward ? this._edge.print(a) : this._edge.printReverse(a);
      } }, { key: "setSym", value: function(a) {
        this._sym = a;
      } }, { key: "setVisitedEdge", value: function(a) {
        this.setVisited(a), this._sym.setVisited(a);
      } }, { key: "setEdgeDepths", value: function(a, l) {
        var d = this.getEdge().getDepthDelta();
        this._isForward || (d = -d);
        var v = 1;
        a === U.LEFT && (v = -1);
        var E = U.opposite(a), S = l + d * v;
        this.setDepth(a, l), this.setDepth(E, S);
      } }, { key: "getEdgeRing", value: function() {
        return this._edgeRing;
      } }, { key: "isInResult", value: function() {
        return this._isInResult;
      } }, { key: "setNext", value: function(a) {
        this._next = a;
      } }, { key: "isVisited", value: function() {
        return this._isVisited;
      } }], [{ key: "constructor_", value: function() {
        this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
        var a = arguments[0], l = arguments[1];
        if (uh.constructor_.call(this, a), this._isForward = l, l) this.init(a.getCoordinate(0), a.getCoordinate(1));
        else {
          var d = a.getNumPoints() - 1;
          this.init(a.getCoordinate(d), a.getCoordinate(d - 1));
        }
        this.computeDirectedLabel();
      } }, { key: "depthFactor", value: function(a, l) {
        return a === T.EXTERIOR && l === T.INTERIOR ? 1 : a === T.INTERIOR && l === T.EXTERIOR ? -1 : 0;
      } }]), o;
    }(uh), lh = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "createNode", value: function(n) {
        return new Xs(n, null);
      } }]), c;
    }(), hh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "printEdges", value: function(n) {
        n.println("Edges:");
        for (var o = 0; o < this._edges.size(); o++) {
          n.println("edge " + o + ":");
          var a = this._edges.get(o);
          a.print(n), a.eiList.print(n);
        }
      } }, { key: "find", value: function(n) {
        return this._nodes.find(n);
      } }, { key: "addNode", value: function() {
        if (arguments[0] instanceof Xs) {
          var n = arguments[0];
          return this._nodes.addNode(n);
        }
        if (arguments[0] instanceof P) {
          var o = arguments[0];
          return this._nodes.addNode(o);
        }
      } }, { key: "getNodeIterator", value: function() {
        return this._nodes.iterator();
      } }, { key: "linkResultDirectedEdges", value: function() {
        for (var n = this._nodes.iterator(); n.hasNext(); )
          n.next().getEdges().linkResultDirectedEdges();
      } }, { key: "debugPrintln", value: function(n) {
        re.out.println(n);
      } }, { key: "isBoundaryNode", value: function(n, o) {
        var a = this._nodes.find(o);
        if (a === null) return !1;
        var l = a.getLabel();
        return l !== null && l.getLocation(n) === T.BOUNDARY;
      } }, { key: "linkAllDirectedEdges", value: function() {
        for (var n = this._nodes.iterator(); n.hasNext(); )
          n.next().getEdges().linkAllDirectedEdges();
      } }, { key: "matchInSameDirection", value: function(n, o, a, l) {
        return !!n.equals(a) && ut.index(n, o, l) === ut.COLLINEAR && oe.quadrant(n, o) === oe.quadrant(a, l);
      } }, { key: "getEdgeEnds", value: function() {
        return this._edgeEndList;
      } }, { key: "debugPrint", value: function(n) {
        re.out.print(n);
      } }, { key: "getEdgeIterator", value: function() {
        return this._edges.iterator();
      } }, { key: "findEdgeInSameDirection", value: function(n, o) {
        for (var a = 0; a < this._edges.size(); a++) {
          var l = this._edges.get(a), d = l.getCoordinates();
          if (this.matchInSameDirection(n, o, d[0], d[1]) || this.matchInSameDirection(n, o, d[d.length - 1], d[d.length - 2])) return l;
        }
        return null;
      } }, { key: "insertEdge", value: function(n) {
        this._edges.add(n);
      } }, { key: "findEdgeEnd", value: function(n) {
        for (var o = this.getEdgeEnds().iterator(); o.hasNext(); ) {
          var a = o.next();
          if (a.getEdge() === n) return a;
        }
        return null;
      } }, { key: "addEdges", value: function(n) {
        for (var o = n.iterator(); o.hasNext(); ) {
          var a = o.next();
          this._edges.add(a);
          var l = new Ca(a, !0), d = new Ca(a, !1);
          l.setSym(d), d.setSym(l), this.add(l), this.add(d);
        }
      } }, { key: "add", value: function(n) {
        this._nodes.add(n), this._edgeEndList.add(n);
      } }, { key: "getNodes", value: function() {
        return this._nodes.values();
      } }, { key: "findEdge", value: function(n, o) {
        for (var a = 0; a < this._edges.size(); a++) {
          var l = this._edges.get(a), d = l.getCoordinates();
          if (n.equals(d[0]) && o.equals(d[1])) return l;
        }
        return null;
      } }], [{ key: "constructor_", value: function() {
        if (this._edges = new ot(), this._nodes = null, this._edgeEndList = new ot(), arguments.length === 0) this._nodes = new ah(new lh());
        else if (arguments.length === 1) {
          var n = arguments[0];
          this._nodes = new ah(n);
        }
      } }, { key: "linkResultDirectedEdges", value: function(n) {
        for (var o = n.iterator(); o.hasNext(); )
          o.next().getEdges().linkResultDirectedEdges();
      } }]), c;
    }(), hp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "sortShellsAndHoles", value: function(n, o, a) {
        for (var l = n.iterator(); l.hasNext(); ) {
          var d = l.next();
          d.isHole() ? a.add(d) : o.add(d);
        }
      } }, { key: "computePolygons", value: function(n) {
        for (var o = new ot(), a = n.iterator(); a.hasNext(); ) {
          var l = a.next().toPolygon(this._geometryFactory);
          o.add(l);
        }
        return o;
      } }, { key: "placeFreeHoles", value: function(n, o) {
        for (var a = o.iterator(); a.hasNext(); ) {
          var l = a.next();
          if (l.getShell() === null) {
            var d = c.findEdgeRingContaining(l, n);
            if (d === null) throw new de("unable to assign hole to a shell", l.getCoordinate(0));
            l.setShell(d);
          }
        }
      } }, { key: "buildMinimalEdgeRings", value: function(n, o, a) {
        for (var l = new ot(), d = n.iterator(); d.hasNext(); ) {
          var v = d.next();
          if (v.getMaxNodeDegree() > 2) {
            v.linkDirectedEdgesForMinimalEdgeRings();
            var E = v.buildMinimalRings(), S = this.findShell(E);
            S !== null ? (this.placePolygonHoles(S, E), o.add(S)) : a.addAll(E);
          } else l.add(v);
        }
        return l;
      } }, { key: "buildMaximalEdgeRings", value: function(n) {
        for (var o = new ot(), a = n.iterator(); a.hasNext(); ) {
          var l = a.next();
          if (l.isInResult() && l.getLabel().isArea() && l.getEdgeRing() === null) {
            var d = new up(l, this._geometryFactory);
            o.add(d), d.setInResult();
          }
        }
        return o;
      } }, { key: "placePolygonHoles", value: function(n, o) {
        for (var a = o.iterator(); a.hasNext(); ) {
          var l = a.next();
          l.isHole() && l.setShell(n);
        }
      } }, { key: "getPolygons", value: function() {
        return this.computePolygons(this._shellList);
      } }, { key: "findShell", value: function(n) {
        for (var o = 0, a = null, l = n.iterator(); l.hasNext(); ) {
          var d = l.next();
          d.isHole() || (a = d, o++);
        }
        return z.isTrue(o <= 1, "found two shells in MinimalEdgeRing list"), a;
      } }, { key: "add", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          this.add(n.getEdgeEnds(), n.getNodes());
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          hh.linkResultDirectedEdges(a);
          var l = this.buildMaximalEdgeRings(o), d = new ot(), v = this.buildMinimalEdgeRings(l, this._shellList, d);
          this.sortShellsAndHoles(v, this._shellList, d), this.placeFreeHoles(this._shellList, d);
        }
      } }], [{ key: "constructor_", value: function() {
        this._geometryFactory = null, this._shellList = new ot();
        var n = arguments[0];
        this._geometryFactory = n;
      } }, { key: "findEdgeRingContaining", value: function(n, o) {
        for (var a = n.getLinearRing(), l = a.getEnvelopeInternal(), d = a.getCoordinateN(0), v = null, E = null, S = o.iterator(); S.hasNext(); ) {
          var w = S.next(), N = w.getLinearRing(), M = N.getEnvelopeInternal();
          if (!M.equals(l) && M.contains(l)) {
            d = Yt.ptNotInList(a.getCoordinates(), N.getCoordinates());
            var Y = !1;
            wa.isInRing(d, N.getCoordinates()) && (Y = !0), Y && (v === null || E.contains(M)) && (E = (v = w).getLinearRing().getEnvelopeInternal());
          }
        }
        return v;
      } }]), c;
    }(), ch = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "getBounds", value: function() {
      } }]), c;
    }(), gn = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getItem", value: function() {
        return this._item;
      } }, { key: "getBounds", value: function() {
        return this._bounds;
      } }, { key: "interfaces_", get: function() {
        return [ch, B];
      } }], [{ key: "constructor_", value: function() {
        this._bounds = null, this._item = null;
        var n = arguments[0], o = arguments[1];
        this._bounds = n, this._item = o;
      } }]), c;
    }(), qs = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "poll", value: function() {
        if (this.isEmpty()) return null;
        var n = this._items.get(1);
        return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), n;
      } }, { key: "size", value: function() {
        return this._size;
      } }, { key: "reorder", value: function(n) {
        for (var o = null, a = this._items.get(n); 2 * n <= this._size && ((o = 2 * n) !== this._size && this._items.get(o + 1).compareTo(this._items.get(o)) < 0 && o++, this._items.get(o).compareTo(a) < 0); n = o) this._items.set(n, this._items.get(o));
        this._items.set(n, a);
      } }, { key: "clear", value: function() {
        this._size = 0, this._items.clear();
      } }, { key: "peek", value: function() {
        return this.isEmpty() ? null : this._items.get(1);
      } }, { key: "isEmpty", value: function() {
        return this._size === 0;
      } }, { key: "add", value: function(n) {
        this._items.add(null), this._size += 1;
        var o = this._size;
        for (this._items.set(0, n); n.compareTo(this._items.get(Math.trunc(o / 2))) < 0; o /= 2) this._items.set(o, this._items.get(Math.trunc(o / 2)));
        this._items.set(o, n);
      } }], [{ key: "constructor_", value: function() {
        this._size = null, this._items = null, this._size = 0, this._items = new ot(), this._items.add(null);
      } }]), c;
    }(), cp = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "insert", value: function(n, o) {
      } }, { key: "remove", value: function(n, o) {
      } }, { key: "query", value: function() {
      } }]), c;
    }(), be = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getLevel", value: function() {
        return this._level;
      } }, { key: "size", value: function() {
        return this._childBoundables.size();
      } }, { key: "getChildBoundables", value: function() {
        return this._childBoundables;
      } }, { key: "addChildBoundable", value: function(n) {
        z.isTrue(this._bounds === null), this._childBoundables.add(n);
      } }, { key: "isEmpty", value: function() {
        return this._childBoundables.isEmpty();
      } }, { key: "getBounds", value: function() {
        return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
      } }, { key: "interfaces_", get: function() {
        return [ch, B];
      } }], [{ key: "constructor_", value: function() {
        if (this._childBoundables = new ot(), this._bounds = null, this._level = null, arguments.length !== 0) {
          if (arguments.length === 1) {
            var n = arguments[0];
            this._level = n;
          }
        }
      } }]), c;
    }(), Xi = { reverseOrder: function() {
      return { compare: function(c, n) {
        return n.compareTo(c);
      } };
    }, min: function(c) {
      return Xi.sort(c), c.get(0);
    }, sort: function(c, n) {
      var o = c.toArray();
      n ? At.sort(o, n) : At.sort(o);
      for (var a = c.iterator(), l = 0, d = o.length; l < d; l++) a.next(), a.set(o[l]);
    }, singletonList: function(c) {
      var n = new ot();
      return n.add(c), n;
    } }, fp = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "maxDistance", value: function(n, o, a, l, d, v, E, S) {
        var w = c.distance(n, o, d, v);
        return w = Math.max(w, c.distance(n, o, E, S)), w = Math.max(w, c.distance(a, l, d, v)), w = Math.max(w, c.distance(a, l, E, S));
      } }, { key: "distance", value: function(n, o, a, l) {
        var d = a - n, v = l - o;
        return Math.sqrt(d * d + v * v);
      } }, { key: "maximumDistance", value: function(n, o) {
        var a = Math.min(n.getMinX(), o.getMinX()), l = Math.min(n.getMinY(), o.getMinY()), d = Math.max(n.getMaxX(), o.getMaxX()), v = Math.max(n.getMaxY(), o.getMaxY());
        return c.distance(a, l, d, v);
      } }, { key: "minMaxDistance", value: function(n, o) {
        var a = n.getMinX(), l = n.getMinY(), d = n.getMaxX(), v = n.getMaxY(), E = o.getMinX(), S = o.getMinY(), w = o.getMaxX(), N = o.getMaxY(), M = c.maxDistance(a, l, a, v, E, S, E, N);
        return M = Math.min(M, c.maxDistance(a, l, a, v, E, S, w, S)), M = Math.min(M, c.maxDistance(a, l, a, v, w, N, E, N)), M = Math.min(M, c.maxDistance(a, l, a, v, w, N, w, S)), M = Math.min(M, c.maxDistance(a, l, d, l, E, S, E, N)), M = Math.min(M, c.maxDistance(a, l, d, l, E, S, w, S)), M = Math.min(M, c.maxDistance(a, l, d, l, w, N, E, N)), M = Math.min(M, c.maxDistance(a, l, d, l, w, N, w, S)), M = Math.min(M, c.maxDistance(d, v, a, v, E, S, E, N)), M = Math.min(M, c.maxDistance(d, v, a, v, E, S, w, S)), M = Math.min(M, c.maxDistance(d, v, a, v, w, N, E, N)), M = Math.min(M, c.maxDistance(d, v, a, v, w, N, w, S)), M = Math.min(M, c.maxDistance(d, v, d, l, E, S, E, N)), M = Math.min(M, c.maxDistance(d, v, d, l, E, S, w, S)), M = Math.min(M, c.maxDistance(d, v, d, l, w, N, E, N)), M = Math.min(M, c.maxDistance(d, v, d, l, w, N, w, S));
      } }]), c;
    }(), qi = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "maximumDistance", value: function() {
        return fp.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
      } }, { key: "expandToQueue", value: function(n, o) {
        var a = c.isComposite(this._boundable1), l = c.isComposite(this._boundable2);
        if (a && l) return c.area(this._boundable1) > c.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, n, o), null) : (this.expand(this._boundable2, this._boundable1, !0, n, o), null);
        if (a) return this.expand(this._boundable1, this._boundable2, !1, n, o), null;
        if (l) return this.expand(this._boundable2, this._boundable1, !0, n, o), null;
        throw new L("neither boundable is composite");
      } }, { key: "isLeaves", value: function() {
        return !(c.isComposite(this._boundable1) || c.isComposite(this._boundable2));
      } }, { key: "compareTo", value: function(n) {
        var o = n;
        return this._distance < o._distance ? -1 : this._distance > o._distance ? 1 : 0;
      } }, { key: "expand", value: function(n, o, a, l, d) {
        for (var v = n.getChildBoundables().iterator(); v.hasNext(); ) {
          var E = v.next(), S = null;
          (S = a ? new c(o, E, this._itemDistance) : new c(E, o, this._itemDistance)).getDistance() < d && l.add(S);
        }
      } }, { key: "getBoundable", value: function(n) {
        return n === 0 ? this._boundable1 : this._boundable2;
      } }, { key: "getDistance", value: function() {
        return this._distance;
      } }, { key: "distance", value: function() {
        return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }], [{ key: "constructor_", value: function() {
        this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
        var n = arguments[0], o = arguments[1], a = arguments[2];
        this._boundable1 = n, this._boundable2 = o, this._itemDistance = a, this._distance = this.distance();
      } }, { key: "area", value: function(n) {
        return n.getBounds().getArea();
      } }, { key: "isComposite", value: function(n) {
        return n instanceof be;
      } }]), c;
    }(), fh = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "visitItem", value: function(n) {
      } }]), c;
    }(), Wi = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "queryInternal", value: function() {
        if (ht(arguments[2], fh) && arguments[0] instanceof Object && arguments[1] instanceof be) for (var n = arguments[0], o = arguments[1], a = arguments[2], l = o.getChildBoundables(), d = 0; d < l.size(); d++) {
          var v = l.get(d);
          this.getIntersectsOp().intersects(v.getBounds(), n) && (v instanceof be ? this.queryInternal(n, v, a) : v instanceof gn ? a.visitItem(v.getItem()) : z.shouldNeverReachHere());
        }
        else if (ht(arguments[2], Fe) && arguments[0] instanceof Object && arguments[1] instanceof be) for (var E = arguments[0], S = arguments[1], w = arguments[2], N = S.getChildBoundables(), M = 0; M < N.size(); M++) {
          var Y = N.get(M);
          this.getIntersectsOp().intersects(Y.getBounds(), E) && (Y instanceof be ? this.queryInternal(E, Y, w) : Y instanceof gn ? w.add(Y.getItem()) : z.shouldNeverReachHere());
        }
      } }, { key: "getNodeCapacity", value: function() {
        return this._nodeCapacity;
      } }, { key: "lastNode", value: function(n) {
        return n.get(n.size() - 1);
      } }, { key: "size", value: function() {
        if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
        if (arguments.length === 1) {
          for (var n = arguments[0], o = 0, a = n.getChildBoundables().iterator(); a.hasNext(); ) {
            var l = a.next();
            l instanceof be ? o += this.size(l) : l instanceof gn && (o += 1);
          }
          return o;
        }
      } }, { key: "removeItem", value: function(n, o) {
        for (var a = null, l = n.getChildBoundables().iterator(); l.hasNext(); ) {
          var d = l.next();
          d instanceof gn && d.getItem() === o && (a = d);
        }
        return a !== null && (n.getChildBoundables().remove(a), !0);
      } }, { key: "itemsTree", value: function() {
        if (arguments.length === 0) {
          this.build();
          var n = this.itemsTree(this._root);
          return n === null ? new ot() : n;
        }
        if (arguments.length === 1) {
          for (var o = arguments[0], a = new ot(), l = o.getChildBoundables().iterator(); l.hasNext(); ) {
            var d = l.next();
            if (d instanceof be) {
              var v = this.itemsTree(d);
              v !== null && a.add(v);
            } else d instanceof gn ? a.add(d.getItem()) : z.shouldNeverReachHere();
          }
          return a.size() <= 0 ? null : a;
        }
      } }, { key: "insert", value: function(n, o) {
        z.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new gn(n, o));
      } }, { key: "boundablesAtLevel", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0], o = new ot();
          return this.boundablesAtLevel(n, this._root, o), o;
        }
        if (arguments.length === 3) {
          var a = arguments[0], l = arguments[1], d = arguments[2];
          if (z.isTrue(a > -2), l.getLevel() === a) return d.add(l), null;
          for (var v = l.getChildBoundables().iterator(); v.hasNext(); ) {
            var E = v.next();
            E instanceof be ? this.boundablesAtLevel(a, E, d) : (z.isTrue(E instanceof gn), a === -1 && d.add(E));
          }
          return null;
        }
      } }, { key: "query", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          this.build();
          var o = new ot();
          return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.queryInternal(n, this._root, o), o;
        }
        if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          if (this.build(), this.isEmpty()) return null;
          this.getIntersectsOp().intersects(this._root.getBounds(), a) && this.queryInternal(a, this._root, l);
        }
      } }, { key: "build", value: function() {
        if (this._built) return null;
        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
      } }, { key: "getRoot", value: function() {
        return this.build(), this._root;
      } }, { key: "remove", value: function() {
        if (arguments.length === 2) {
          var n = arguments[0], o = arguments[1];
          return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.remove(n, this._root, o);
        }
        if (arguments.length === 3) {
          var a = arguments[0], l = arguments[1], d = arguments[2], v = this.removeItem(l, d);
          if (v) return !0;
          for (var E = null, S = l.getChildBoundables().iterator(); S.hasNext(); ) {
            var w = S.next();
            if (this.getIntersectsOp().intersects(w.getBounds(), a) && w instanceof be && (v = this.remove(a, w, d))) {
              E = w;
              break;
            }
          }
          return E !== null && E.getChildBoundables().isEmpty() && l.getChildBoundables().remove(E), v;
        }
      } }, { key: "createHigherLevels", value: function(n, o) {
        z.isTrue(!n.isEmpty());
        var a = this.createParentBoundables(n, o + 1);
        return a.size() === 1 ? a.get(0) : this.createHigherLevels(a, o + 1);
      } }, { key: "depth", value: function() {
        if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
        if (arguments.length === 1) {
          for (var n = arguments[0], o = 0, a = n.getChildBoundables().iterator(); a.hasNext(); ) {
            var l = a.next();
            if (l instanceof be) {
              var d = this.depth(l);
              d > o && (o = d);
            }
          }
          return o + 1;
        }
      } }, { key: "createParentBoundables", value: function(n, o) {
        z.isTrue(!n.isEmpty());
        var a = new ot();
        a.add(this.createNode(o));
        var l = new ot(n);
        Xi.sort(l, this.getComparator());
        for (var d = l.iterator(); d.hasNext(); ) {
          var v = d.next();
          this.lastNode(a).getChildBoundables().size() === this.getNodeCapacity() && a.add(this.createNode(o)), this.lastNode(a).addChildBoundable(v);
        }
        return a;
      } }, { key: "isEmpty", value: function() {
        return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
      } }, { key: "interfaces_", get: function() {
        return [B];
      } }], [{ key: "constructor_", value: function() {
        if (this._root = null, this._built = !1, this._itemBoundables = new ot(), this._nodeCapacity = null, arguments.length === 0) c.constructor_.call(this, c.DEFAULT_NODE_CAPACITY);
        else if (arguments.length === 1) {
          var n = arguments[0];
          z.isTrue(n > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n;
        }
      } }, { key: "compareDoubles", value: function(n, o) {
        return n > o ? 1 : n < o ? -1 : 0;
      } }]), c;
    }();
    Wi.IntersectsOp = function() {
    }, Wi.DEFAULT_NODE_CAPACITY = 10;
    var gp = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "distance", value: function(n, o) {
      } }]), c;
    }(), Ke = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "createParentBoundablesFromVerticalSlices", value: function(a, l) {
        z.isTrue(a.length > 0);
        for (var d = new ot(), v = 0; v < a.length; v++) d.addAll(this.createParentBoundablesFromVerticalSlice(a[v], l));
        return d;
      } }, { key: "nearestNeighbourK", value: function() {
        if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1];
          return this.nearestNeighbourK(a, Z.POSITIVE_INFINITY, l);
        }
        if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], E = arguments[2], S = v, w = new qs();
          w.add(d);
          for (var N = new qs(); !w.isEmpty() && S >= 0; ) {
            var M = w.poll(), Y = M.getDistance();
            if (Y >= S) break;
            if (M.isLeaves()) if (N.size() < E) N.add(M);
            else {
              var W = N.peek();
              W.getDistance() > Y && (N.poll(), N.add(M));
              var q = N.peek();
              S = q.getDistance();
            }
            else M.expandToQueue(w, S);
          }
          return o.getItems(N);
        }
      } }, { key: "createNode", value: function(a) {
        return new gh(a);
      } }, { key: "size", value: function() {
        return arguments.length === 0 ? I(h(o.prototype), "size", this).call(this) : I(h(o.prototype), "size", this).apply(this, arguments);
      } }, { key: "insert", value: function() {
        if (!(arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof bt)) return I(h(o.prototype), "insert", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1];
        if (a.isNull()) return null;
        I(h(o.prototype), "insert", this).call(this, a, l);
      } }, { key: "getIntersectsOp", value: function() {
        return o.intersectsOp;
      } }, { key: "verticalSlices", value: function(a, l) {
        for (var d = Math.trunc(Math.ceil(a.size() / l)), v = new Array(l).fill(null), E = a.iterator(), S = 0; S < l; S++) {
          v[S] = new ot();
          for (var w = 0; E.hasNext() && w < d; ) {
            var N = E.next();
            v[S].add(N), w++;
          }
        }
        return v;
      } }, { key: "query", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0];
          return I(h(o.prototype), "query", this).call(this, a);
        }
        if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          I(h(o.prototype), "query", this).call(this, l, d);
        }
      } }, { key: "getComparator", value: function() {
        return o.yComparator;
      } }, { key: "createParentBoundablesFromVerticalSlice", value: function(a, l) {
        return I(h(o.prototype), "createParentBoundables", this).call(this, a, l);
      } }, { key: "remove", value: function() {
        if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof bt) {
          var a = arguments[0], l = arguments[1];
          return I(h(o.prototype), "remove", this).call(this, a, l);
        }
        return I(h(o.prototype), "remove", this).apply(this, arguments);
      } }, { key: "depth", value: function() {
        return arguments.length === 0 ? I(h(o.prototype), "depth", this).call(this) : I(h(o.prototype), "depth", this).apply(this, arguments);
      } }, { key: "createParentBoundables", value: function(a, l) {
        z.isTrue(!a.isEmpty());
        var d = Math.trunc(Math.ceil(a.size() / this.getNodeCapacity())), v = new ot(a);
        Xi.sort(v, o.xComparator);
        var E = this.verticalSlices(v, Math.trunc(Math.ceil(Math.sqrt(d))));
        return this.createParentBoundablesFromVerticalSlices(E, l);
      } }, { key: "nearestNeighbour", value: function() {
        if (arguments.length === 1) {
          if (ht(arguments[0], gp)) {
            var a = arguments[0];
            if (this.isEmpty()) return null;
            var l = new qi(this.getRoot(), this.getRoot(), a);
            return this.nearestNeighbour(l);
          }
          if (arguments[0] instanceof qi) {
            var d = arguments[0], v = Z.POSITIVE_INFINITY, E = null, S = new qs();
            for (S.add(d); !S.isEmpty() && v > 0; ) {
              var w = S.poll(), N = w.getDistance();
              if (N >= v) break;
              w.isLeaves() ? (v = N, E = w) : w.expandToQueue(S, v);
            }
            return E === null ? null : [E.getBoundable(0).getItem(), E.getBoundable(1).getItem()];
          }
        } else {
          if (arguments.length === 2) {
            var M = arguments[0], Y = arguments[1];
            if (this.isEmpty() || M.isEmpty()) return null;
            var W = new qi(this.getRoot(), M.getRoot(), Y);
            return this.nearestNeighbour(W);
          }
          if (arguments.length === 3) {
            var q = arguments[0], it = arguments[1], at = arguments[2], ft = new gn(q, it), kt = new qi(this.getRoot(), ft, at);
            return this.nearestNeighbour(kt)[0];
          }
          if (arguments.length === 4) {
            var Pt = arguments[0], Jt = arguments[1], _e = arguments[2], ze = arguments[3], dn = new gn(Pt, Jt), di = new qi(this.getRoot(), dn, _e);
            return this.nearestNeighbourK(di, ze);
          }
        }
      } }, { key: "isWithinDistance", value: function() {
        if (arguments.length === 2) {
          var a = arguments[0], l = arguments[1], d = Z.POSITIVE_INFINITY, v = new qs();
          for (v.add(a); !v.isEmpty(); ) {
            var E = v.poll(), S = E.getDistance();
            if (S > l) return !1;
            if (E.maximumDistance() <= l) return !0;
            if (E.isLeaves()) {
              if ((d = S) <= l) return !0;
            } else E.expandToQueue(v, d);
          }
          return !1;
        }
        if (arguments.length === 3) {
          var w = arguments[0], N = arguments[1], M = arguments[2], Y = new qi(this.getRoot(), w.getRoot(), N);
          return this.isWithinDistance(Y, M);
        }
      } }, { key: "interfaces_", get: function() {
        return [cp, B];
      } }], [{ key: "constructor_", value: function() {
        if (arguments.length === 0) o.constructor_.call(this, o.DEFAULT_NODE_CAPACITY);
        else if (arguments.length === 1) {
          var a = arguments[0];
          Wi.constructor_.call(this, a);
        }
      } }, { key: "centreX", value: function(a) {
        return o.avg(a.getMinX(), a.getMaxX());
      } }, { key: "avg", value: function(a, l) {
        return (a + l) / 2;
      } }, { key: "getItems", value: function(a) {
        for (var l = new Array(a.size()).fill(null), d = 0; !a.isEmpty(); ) {
          var v = a.poll();
          l[d] = v.getBoundable(0).getItem(), d++;
        }
        return l;
      } }, { key: "centreY", value: function(a) {
        return o.avg(a.getMinY(), a.getMaxY());
      } }]), o;
    }(Wi), gh = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "computeBounds", value: function() {
        for (var a = null, l = this.getChildBoundables().iterator(); l.hasNext(); ) {
          var d = l.next();
          a === null ? a = new bt(d.getBounds()) : a.expandToInclude(d.getBounds());
        }
        return a;
      } }], [{ key: "constructor_", value: function() {
        var a = arguments[0];
        be.constructor_.call(this, a);
      } }]), o;
    }(be);
    Ke.STRtreeNode = gh, Ke.xComparator = new (function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "interfaces_", get: function() {
        return [pt];
      } }, { key: "compare", value: function(n, o) {
        return Wi.compareDoubles(Ke.centreX(n.getBounds()), Ke.centreX(o.getBounds()));
      } }]), c;
    }())(), Ke.yComparator = new (function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "interfaces_", get: function() {
        return [pt];
      } }, { key: "compare", value: function(n, o) {
        return Wi.compareDoubles(Ke.centreY(n.getBounds()), Ke.centreY(o.getBounds()));
      } }]), c;
    }())(), Ke.intersectsOp = new (function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "interfaces_", get: function() {
        return [IntersectsOp];
      } }, { key: "intersects", value: function(n, o) {
        return n.intersects(o);
      } }]), c;
    }())(), Ke.DEFAULT_NODE_CAPACITY = 10;
    var dp = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "relativeSign", value: function(n, o) {
        return n < o ? -1 : n > o ? 1 : 0;
      } }, { key: "compare", value: function(n, o, a) {
        if (o.equals2D(a)) return 0;
        var l = c.relativeSign(o.x, a.x), d = c.relativeSign(o.y, a.y);
        switch (n) {
          case 0:
            return c.compareValue(l, d);
          case 1:
            return c.compareValue(d, l);
          case 2:
            return c.compareValue(d, -l);
          case 3:
            return c.compareValue(-l, d);
          case 4:
            return c.compareValue(-l, -d);
          case 5:
            return c.compareValue(-d, -l);
          case 6:
            return c.compareValue(-d, l);
          case 7:
            return c.compareValue(l, -d);
        }
        return z.shouldNeverReachHere("invalid octant value"), 0;
      } }, { key: "compareValue", value: function(n, o) {
        return n < 0 ? -1 : n > 0 ? 1 : o < 0 ? -1 : o > 0 ? 1 : 0;
      } }]), c;
    }(), yp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getCoordinate", value: function() {
        return this.coord;
      } }, { key: "print", value: function(n) {
        n.print(this.coord), n.print(" seg # = " + this.segmentIndex);
      } }, { key: "compareTo", value: function(n) {
        var o = n;
        return this.segmentIndex < o.segmentIndex ? -1 : this.segmentIndex > o.segmentIndex ? 1 : this.coord.equals2D(o.coord) ? 0 : this._isInterior ? o._isInterior ? dp.compare(this._segmentOctant, this.coord, o.coord) : 1 : -1;
      } }, { key: "isEndPoint", value: function(n) {
        return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === n;
      } }, { key: "toString", value: function() {
        return this.segmentIndex + ":" + this.coord.toString();
      } }, { key: "isInterior", value: function() {
        return this._isInterior;
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }], [{ key: "constructor_", value: function() {
        this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
        var n = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
        this._segString = n, this.coord = new P(o), this.segmentIndex = a, this._segmentOctant = l, this._isInterior = !o.equals2D(n.getCoordinate(a));
      } }]), c;
    }(), pp = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "hasNext", value: function() {
      } }, { key: "next", value: function() {
      } }, { key: "remove", value: function() {
      } }]), c;
    }(), mp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getSplitCoordinates", value: function() {
        var n = new Ar();
        this.addEndpoints();
        for (var o = this.iterator(), a = o.next(); o.hasNext(); ) {
          var l = o.next();
          this.addEdgeCoordinates(a, l, n), a = l;
        }
        return n.toCoordinateArray();
      } }, { key: "addCollapsedNodes", value: function() {
        var n = new ot();
        this.findCollapsesFromInsertedNodes(n), this.findCollapsesFromExistingVertices(n);
        for (var o = n.iterator(); o.hasNext(); ) {
          var a = o.next().intValue();
          this.add(this._edge.getCoordinate(a), a);
        }
      } }, { key: "createSplitEdgePts", value: function(n, o) {
        var a = o.segmentIndex - n.segmentIndex + 2;
        if (a === 2) return [new P(n.coord), new P(o.coord)];
        var l = this._edge.getCoordinate(o.segmentIndex), d = o.isInterior() || !o.coord.equals2D(l);
        d || a--;
        var v = new Array(a).fill(null), E = 0;
        v[E++] = new P(n.coord);
        for (var S = n.segmentIndex + 1; S <= o.segmentIndex; S++) v[E++] = this._edge.getCoordinate(S);
        return d && (v[E] = new P(o.coord)), v;
      } }, { key: "print", value: function(n) {
        n.println("Intersections:");
        for (var o = this.iterator(); o.hasNext(); )
          o.next().print(n);
      } }, { key: "findCollapsesFromExistingVertices", value: function(n) {
        for (var o = 0; o < this._edge.size() - 2; o++) {
          var a = this._edge.getCoordinate(o);
          this._edge.getCoordinate(o + 1);
          var l = this._edge.getCoordinate(o + 2);
          a.equals2D(l) && n.add(Mn.valueOf(o + 1));
        }
      } }, { key: "addEdgeCoordinates", value: function(n, o, a) {
        var l = this.createSplitEdgePts(n, o);
        a.add(l, !1);
      } }, { key: "iterator", value: function() {
        return this._nodeMap.values().iterator();
      } }, { key: "addSplitEdges", value: function(n) {
        this.addEndpoints(), this.addCollapsedNodes();
        for (var o = this.iterator(), a = o.next(); o.hasNext(); ) {
          var l = o.next(), d = this.createSplitEdge(a, l);
          n.add(d), a = l;
        }
      } }, { key: "findCollapseIndex", value: function(n, o, a) {
        if (!n.coord.equals2D(o.coord)) return !1;
        var l = o.segmentIndex - n.segmentIndex;
        return o.isInterior() || l--, l === 1 && (a[0] = n.segmentIndex + 1, !0);
      } }, { key: "findCollapsesFromInsertedNodes", value: function(n) {
        for (var o = new Array(1).fill(null), a = this.iterator(), l = a.next(); a.hasNext(); ) {
          var d = a.next();
          this.findCollapseIndex(l, d, o) && n.add(Mn.valueOf(o[0])), l = d;
        }
      } }, { key: "getEdge", value: function() {
        return this._edge;
      } }, { key: "addEndpoints", value: function() {
        var n = this._edge.size() - 1;
        this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(n), n);
      } }, { key: "createSplitEdge", value: function(n, o) {
        var a = this.createSplitEdgePts(n, o);
        return new gi(a, this._edge.getData());
      } }, { key: "add", value: function(n, o) {
        var a = new yp(this._edge, n, o, this._edge.getSegmentOctant(o)), l = this._nodeMap.get(a);
        return l !== null ? (z.isTrue(l.coord.equals2D(n), "Found equal nodes with different coordinates"), l) : (this._nodeMap.put(a, a), a);
      } }, { key: "checkSplitEdgesCorrectness", value: function(n) {
        var o = this._edge.getCoordinates(), a = n.get(0).getCoordinate(0);
        if (!a.equals2D(o[0])) throw new mt("bad split edge start point at " + a);
        var l = n.get(n.size() - 1).getCoordinates(), d = l[l.length - 1];
        if (!d.equals2D(o[o.length - 1])) throw new mt("bad split edge end point at " + d);
      } }], [{ key: "constructor_", value: function() {
        this._nodeMap = new Fr(), this._edge = null;
        var n = arguments[0];
        this._edge = n;
      } }]), c;
    }(), vp = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "octant", value: function() {
        if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var n = arguments[0], o = arguments[1];
          if (n === 0 && o === 0) throw new L("Cannot compute the octant for point ( " + n + ", " + o + " )");
          var a = Math.abs(n), l = Math.abs(o);
          return n >= 0 ? o >= 0 ? a >= l ? 0 : 1 : a >= l ? 7 : 6 : o >= 0 ? a >= l ? 3 : 2 : a >= l ? 4 : 5;
        }
        if (arguments[0] instanceof P && arguments[1] instanceof P) {
          var d = arguments[0], v = arguments[1], E = v.x - d.x, S = v.y - d.y;
          if (E === 0 && S === 0) throw new L("Cannot compute the octant for two identical points " + d);
          return c.octant(E, S);
        }
      } }]), c;
    }(), _p = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "getCoordinates", value: function() {
      } }, { key: "size", value: function() {
      } }, { key: "getCoordinate", value: function(n) {
      } }, { key: "isClosed", value: function() {
      } }, { key: "setData", value: function(n) {
      } }, { key: "getData", value: function() {
      } }]), c;
    }(), xp = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "addIntersection", value: function(n, o) {
      } }, { key: "interfaces_", get: function() {
        return [_p];
      } }]), c;
    }(), gi = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getCoordinates", value: function() {
        return this._pts;
      } }, { key: "size", value: function() {
        return this._pts.length;
      } }, { key: "getCoordinate", value: function(n) {
        return this._pts[n];
      } }, { key: "isClosed", value: function() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
      } }, { key: "getSegmentOctant", value: function(n) {
        return n === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(n), this.getCoordinate(n + 1));
      } }, { key: "setData", value: function(n) {
        this._data = n;
      } }, { key: "safeOctant", value: function(n, o) {
        return n.equals2D(o) ? 0 : vp.octant(n, o);
      } }, { key: "getData", value: function() {
        return this._data;
      } }, { key: "addIntersection", value: function() {
        if (arguments.length === 2) {
          var n = arguments[0], o = arguments[1];
          this.addIntersectionNode(n, o);
        } else if (arguments.length === 4) {
          var a = arguments[0], l = arguments[1], d = arguments[3], v = new P(a.getIntersection(d));
          this.addIntersection(v, l);
        }
      } }, { key: "toString", value: function() {
        return Ia.toLineString(new Pr(this._pts));
      } }, { key: "getNodeList", value: function() {
        return this._nodeList;
      } }, { key: "addIntersectionNode", value: function(n, o) {
        var a = o, l = a + 1;
        if (l < this._pts.length) {
          var d = this._pts[l];
          n.equals2D(d) && (a = l);
        }
        return this._nodeList.add(n, a);
      } }, { key: "addIntersections", value: function(n, o, a) {
        for (var l = 0; l < n.getIntersectionNum(); l++) this.addIntersection(n, o, a, l);
      } }, { key: "interfaces_", get: function() {
        return [xp];
      } }], [{ key: "constructor_", value: function() {
        this._nodeList = new mp(this), this._pts = null, this._data = null;
        var n = arguments[0], o = arguments[1];
        this._pts = n, this._data = o;
      } }, { key: "getNodedSubstrings", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0], o = new ot();
          return c.getNodedSubstrings(n, o), o;
        }
        if (arguments.length === 2) for (var a = arguments[0], l = arguments[1], d = a.iterator(); d.hasNext(); ) {
          var v = d.next();
          v.getNodeList().addSplitEdges(l);
        }
      } }]), c;
    }(), me = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "minX", value: function() {
        return Math.min(this.p0.x, this.p1.x);
      } }, { key: "orientationIndex", value: function() {
        if (arguments[0] instanceof c) {
          var n = arguments[0], o = ut.index(this.p0, this.p1, n.p0), a = ut.index(this.p0, this.p1, n.p1);
          return o >= 0 && a >= 0 || o <= 0 && a <= 0 ? Math.max(o, a) : 0;
        }
        if (arguments[0] instanceof P) {
          var l = arguments[0];
          return ut.index(this.p0, this.p1, l);
        }
      } }, { key: "toGeometry", value: function(n) {
        return n.createLineString([this.p0, this.p1]);
      } }, { key: "isVertical", value: function() {
        return this.p0.x === this.p1.x;
      } }, { key: "equals", value: function(n) {
        if (!(n instanceof c)) return !1;
        var o = n;
        return this.p0.equals(o.p0) && this.p1.equals(o.p1);
      } }, { key: "intersection", value: function(n) {
        var o = new fi();
        return o.computeIntersection(this.p0, this.p1, n.p0, n.p1), o.hasIntersection() ? o.getIntersection(0) : null;
      } }, { key: "project", value: function() {
        if (arguments[0] instanceof P) {
          var n = arguments[0];
          if (n.equals(this.p0) || n.equals(this.p1)) return new P(n);
          var o = this.projectionFactor(n), a = new P();
          return a.x = this.p0.x + o * (this.p1.x - this.p0.x), a.y = this.p0.y + o * (this.p1.y - this.p0.y), a;
        }
        if (arguments[0] instanceof c) {
          var l = arguments[0], d = this.projectionFactor(l.p0), v = this.projectionFactor(l.p1);
          if (d >= 1 && v >= 1 || d <= 0 && v <= 0) return null;
          var E = this.project(l.p0);
          d < 0 && (E = this.p0), d > 1 && (E = this.p1);
          var S = this.project(l.p1);
          return v < 0 && (S = this.p0), v > 1 && (S = this.p1), new c(E, S);
        }
      } }, { key: "normalize", value: function() {
        this.p1.compareTo(this.p0) < 0 && this.reverse();
      } }, { key: "angle", value: function() {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
      } }, { key: "getCoordinate", value: function(n) {
        return n === 0 ? this.p0 : this.p1;
      } }, { key: "distancePerpendicular", value: function(n) {
        return Ht.pointToLinePerpendicular(n, this.p0, this.p1);
      } }, { key: "minY", value: function() {
        return Math.min(this.p0.y, this.p1.y);
      } }, { key: "midPoint", value: function() {
        return c.midPoint(this.p0, this.p1);
      } }, { key: "projectionFactor", value: function(n) {
        if (n.equals(this.p0)) return 0;
        if (n.equals(this.p1)) return 1;
        var o = this.p1.x - this.p0.x, a = this.p1.y - this.p0.y, l = o * o + a * a;
        return l <= 0 ? Z.NaN : ((n.x - this.p0.x) * o + (n.y - this.p0.y) * a) / l;
      } }, { key: "closestPoints", value: function(n) {
        var o = this.intersection(n);
        if (o !== null) return [o, o];
        var a = new Array(2).fill(null), l = Z.MAX_VALUE, d = null, v = this.closestPoint(n.p0);
        l = v.distance(n.p0), a[0] = v, a[1] = n.p0;
        var E = this.closestPoint(n.p1);
        (d = E.distance(n.p1)) < l && (l = d, a[0] = E, a[1] = n.p1);
        var S = n.closestPoint(this.p0);
        (d = S.distance(this.p0)) < l && (l = d, a[0] = this.p0, a[1] = S);
        var w = n.closestPoint(this.p1);
        return (d = w.distance(this.p1)) < l && (l = d, a[0] = this.p1, a[1] = w), a;
      } }, { key: "closestPoint", value: function(n) {
        var o = this.projectionFactor(n);
        return o > 0 && o < 1 ? this.project(n) : this.p0.distance(n) < this.p1.distance(n) ? this.p0 : this.p1;
      } }, { key: "maxX", value: function() {
        return Math.max(this.p0.x, this.p1.x);
      } }, { key: "getLength", value: function() {
        return this.p0.distance(this.p1);
      } }, { key: "compareTo", value: function(n) {
        var o = n, a = this.p0.compareTo(o.p0);
        return a !== 0 ? a : this.p1.compareTo(o.p1);
      } }, { key: "reverse", value: function() {
        var n = this.p0;
        this.p0 = this.p1, this.p1 = n;
      } }, { key: "equalsTopo", value: function(n) {
        return this.p0.equals(n.p0) && this.p1.equals(n.p1) || this.p0.equals(n.p1) && this.p1.equals(n.p0);
      } }, { key: "lineIntersection", value: function(n) {
        return li.intersection(this.p0, this.p1, n.p0, n.p1);
      } }, { key: "maxY", value: function() {
        return Math.max(this.p0.y, this.p1.y);
      } }, { key: "pointAlongOffset", value: function(n, o) {
        var a = this.p0.x + n * (this.p1.x - this.p0.x), l = this.p0.y + n * (this.p1.y - this.p0.y), d = this.p1.x - this.p0.x, v = this.p1.y - this.p0.y, E = Math.sqrt(d * d + v * v), S = 0, w = 0;
        if (o !== 0) {
          if (E <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
          S = o * d / E, w = o * v / E;
        }
        return new P(a - w, l + S);
      } }, { key: "setCoordinates", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          this.setCoordinates(n.p0, n.p1);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this.p0.x = o.x, this.p0.y = o.y, this.p1.x = a.x, this.p1.y = a.y;
        }
      } }, { key: "segmentFraction", value: function(n) {
        var o = this.projectionFactor(n);
        return o < 0 ? o = 0 : (o > 1 || Z.isNaN(o)) && (o = 1), o;
      } }, { key: "toString", value: function() {
        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
      } }, { key: "isHorizontal", value: function() {
        return this.p0.y === this.p1.y;
      } }, { key: "reflect", value: function(n) {
        var o = this.p1.getY() - this.p0.getY(), a = this.p0.getX() - this.p1.getX(), l = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), d = o * o + a * a, v = o * o - a * a, E = n.getX(), S = n.getY();
        return new P((-v * E - 2 * o * a * S - 2 * o * l) / d, (v * S - 2 * o * a * E - 2 * a * l) / d);
      } }, { key: "distance", value: function() {
        if (arguments[0] instanceof c) {
          var n = arguments[0];
          return Ht.segmentToSegment(this.p0, this.p1, n.p0, n.p1);
        }
        if (arguments[0] instanceof P) {
          var o = arguments[0];
          return Ht.pointToSegment(o, this.p0, this.p1);
        }
      } }, { key: "pointAlong", value: function(n) {
        var o = new P();
        return o.x = this.p0.x + n * (this.p1.x - this.p0.x), o.y = this.p0.y + n * (this.p1.y - this.p0.y), o;
      } }, { key: "hashCode", value: function() {
        var n = Z.doubleToLongBits(this.p0.x);
        n ^= 31 * Z.doubleToLongBits(this.p0.y);
        var o = Math.trunc(n) ^ Math.trunc(n >> 32), a = Z.doubleToLongBits(this.p1.x);
        return a ^= 31 * Z.doubleToLongBits(this.p1.y), o ^ (Math.trunc(a) ^ Math.trunc(a >> 32));
      } }, { key: "interfaces_", get: function() {
        return [F, B];
      } }], [{ key: "constructor_", value: function() {
        if (this.p0 = null, this.p1 = null, arguments.length === 0) c.constructor_.call(this, new P(), new P());
        else if (arguments.length === 1) {
          var n = arguments[0];
          c.constructor_.call(this, n.p0, n.p1);
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this.p0 = o, this.p1 = a;
        } else if (arguments.length === 4) {
          var l = arguments[0], d = arguments[1], v = arguments[2], E = arguments[3];
          c.constructor_.call(this, new P(l, d), new P(v, E));
        }
      } }, { key: "midPoint", value: function(n, o) {
        return new P((n.x + o.x) / 2, (n.y + o.y) / 2);
      } }]), c;
    }(), Ep = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "overlap", value: function() {
        if (arguments.length !== 2) {
          if (arguments.length === 4) {
            var n = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
            n.getLineSegment(o, this._overlapSeg1), a.getLineSegment(l, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        }
      } }], [{ key: "constructor_", value: function() {
        this._overlapSeg1 = new me(), this._overlapSeg2 = new me();
      } }]), c;
    }(), dh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getLineSegment", value: function(n, o) {
        o.p0 = this._pts[n], o.p1 = this._pts[n + 1];
      } }, { key: "computeSelect", value: function(n, o, a, l) {
        var d = this._pts[o], v = this._pts[a];
        if (a - o == 1) return l.select(this, o), null;
        if (!n.intersects(d, v)) return null;
        var E = Math.trunc((o + a) / 2);
        o < E && this.computeSelect(n, o, E, l), E < a && this.computeSelect(n, E, a, l);
      } }, { key: "getCoordinates", value: function() {
        for (var n = new Array(this._end - this._start + 1).fill(null), o = 0, a = this._start; a <= this._end; a++) n[o++] = this._pts[a];
        return n;
      } }, { key: "computeOverlaps", value: function() {
        if (arguments.length === 2) {
          var n = arguments[0], o = arguments[1];
          this.computeOverlaps(this._start, this._end, n, n._start, n._end, o);
        } else if (arguments.length === 6) {
          var a = arguments[0], l = arguments[1], d = arguments[2], v = arguments[3], E = arguments[4], S = arguments[5];
          if (l - a == 1 && E - v == 1) return S.overlap(this, a, d, v), null;
          if (!this.overlaps(a, l, d, v, E)) return null;
          var w = Math.trunc((a + l) / 2), N = Math.trunc((v + E) / 2);
          a < w && (v < N && this.computeOverlaps(a, w, d, v, N, S), N < E && this.computeOverlaps(a, w, d, N, E, S)), w < l && (v < N && this.computeOverlaps(w, l, d, v, N, S), N < E && this.computeOverlaps(w, l, d, N, E, S));
        }
      } }, { key: "setId", value: function(n) {
        this._id = n;
      } }, { key: "select", value: function(n, o) {
        this.computeSelect(n, this._start, this._end, o);
      } }, { key: "getEnvelope", value: function() {
        if (this._env === null) {
          var n = this._pts[this._start], o = this._pts[this._end];
          this._env = new bt(n, o);
        }
        return this._env;
      } }, { key: "overlaps", value: function(n, o, a, l, d) {
        return bt.intersects(this._pts[n], this._pts[o], a._pts[l], a._pts[d]);
      } }, { key: "getEndIndex", value: function() {
        return this._end;
      } }, { key: "getStartIndex", value: function() {
        return this._start;
      } }, { key: "getContext", value: function() {
        return this._context;
      } }, { key: "getId", value: function() {
        return this._id;
      } }], [{ key: "constructor_", value: function() {
        this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
        var n = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
        this._pts = n, this._start = o, this._end = a, this._context = l;
      } }]), c;
    }(), Sp = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "findChainEnd", value: function(n, o) {
        for (var a = o; a < n.length - 1 && n[a].equals2D(n[a + 1]); ) a++;
        if (a >= n.length - 1) return n.length - 1;
        for (var l = oe.quadrant(n[a], n[a + 1]), d = o + 1; d < n.length && !(!n[d - 1].equals2D(n[d]) && oe.quadrant(n[d - 1], n[d]) !== l); )
          d++;
        return d - 1;
      } }, { key: "getChains", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return c.getChains(n, null);
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1], l = new ot(), d = 0;
          do {
            var v = c.findChainEnd(o, d), E = new dh(o, d, v, a);
            l.add(E), d = v;
          } while (d < o.length - 1);
          return l;
        }
      } }]), c;
    }(), Ra = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "computeNodes", value: function(n) {
      } }, { key: "getNodedSubstrings", value: function() {
      } }]), c;
    }(), yh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "setSegmentIntersector", value: function(n) {
        this._segInt = n;
      } }, { key: "interfaces_", get: function() {
        return [Ra];
      } }], [{ key: "constructor_", value: function() {
        if (this._segInt = null, arguments.length !== 0) {
          if (arguments.length === 1) {
            var n = arguments[0];
            this.setSegmentIntersector(n);
          }
        }
      } }]), c;
    }(), ba = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "getMonotoneChains", value: function() {
        return this._monoChains;
      } }, { key: "getNodedSubstrings", value: function() {
        return gi.getNodedSubstrings(this._nodedSegStrings);
      } }, { key: "getIndex", value: function() {
        return this._index;
      } }, { key: "add", value: function(a) {
        for (var l = Sp.getChains(a.getCoordinates(), a).iterator(); l.hasNext(); ) {
          var d = l.next();
          d.setId(this._idCounter++), this._index.insert(d.getEnvelope(), d), this._monoChains.add(d);
        }
      } }, { key: "computeNodes", value: function(a) {
        this._nodedSegStrings = a;
        for (var l = a.iterator(); l.hasNext(); ) this.add(l.next());
        this.intersectChains();
      } }, { key: "intersectChains", value: function() {
        for (var a = new ph(this._segInt), l = this._monoChains.iterator(); l.hasNext(); ) for (var d = l.next(), v = this._index.query(d.getEnvelope()).iterator(); v.hasNext(); ) {
          var E = v.next();
          if (E.getId() > d.getId() && (d.computeOverlaps(E, a), this._nOverlaps++), this._segInt.isDone()) return null;
        }
      } }], [{ key: "constructor_", value: function() {
        if (this._monoChains = new ot(), this._index = new Ke(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, arguments.length !== 0) {
          if (arguments.length === 1) {
            var a = arguments[0];
            yh.constructor_.call(this, a);
          }
        }
      } }]), o;
    }(yh), ph = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "overlap", value: function() {
        if (arguments.length !== 4) return I(h(o.prototype), "overlap", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1], d = arguments[2], v = arguments[3], E = a.getContext(), S = d.getContext();
        this._si.processIntersections(E, l, S, v);
      } }], [{ key: "constructor_", value: function() {
        this._si = null;
        var a = arguments[0];
        this._si = a;
      } }]), o;
    }(Ep);
    ba.SegmentOverlapAction = ph;
    var Ye = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "isDeletable", value: function(n, o, a, l) {
        var d = this._inputLine[n], v = this._inputLine[o], E = this._inputLine[a];
        return !!this.isConcave(d, v, E) && !!this.isShallow(d, v, E, l) && this.isShallowSampled(d, v, n, a, l);
      } }, { key: "deleteShallowConcavities", value: function() {
        for (var n = 1, o = this.findNextNonDeletedIndex(n), a = this.findNextNonDeletedIndex(o), l = !1; a < this._inputLine.length; ) {
          var d = !1;
          this.isDeletable(n, o, a, this._distanceTol) && (this._isDeleted[o] = c.DELETE, d = !0, l = !0), n = d ? a : o, o = this.findNextNonDeletedIndex(n), a = this.findNextNonDeletedIndex(o);
        }
        return l;
      } }, { key: "isShallowConcavity", value: function(n, o, a, l) {
        return ut.index(n, o, a) === this._angleOrientation && Ht.pointToSegment(o, n, a) < l;
      } }, { key: "isShallowSampled", value: function(n, o, a, l, d) {
        var v = Math.trunc((l - a) / c.NUM_PTS_TO_CHECK);
        v <= 0 && (v = 1);
        for (var E = a; E < l; E += v) if (!this.isShallow(n, o, this._inputLine[E], d)) return !1;
        return !0;
      } }, { key: "isConcave", value: function(n, o, a) {
        var l = ut.index(n, o, a) === this._angleOrientation;
        return l;
      } }, { key: "simplify", value: function(n) {
        this._distanceTol = Math.abs(n), n < 0 && (this._angleOrientation = ut.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
        var o = !1;
        do
          o = this.deleteShallowConcavities();
        while (o);
        return this.collapseLine();
      } }, { key: "findNextNonDeletedIndex", value: function(n) {
        for (var o = n + 1; o < this._inputLine.length && this._isDeleted[o] === c.DELETE; ) o++;
        return o;
      } }, { key: "isShallow", value: function(n, o, a, l) {
        return Ht.pointToSegment(o, n, a) < l;
      } }, { key: "collapseLine", value: function() {
        for (var n = new Ar(), o = 0; o < this._inputLine.length; o++) this._isDeleted[o] !== c.DELETE && n.add(this._inputLine[o]);
        return n.toCoordinateArray();
      } }], [{ key: "constructor_", value: function() {
        this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ut.COUNTERCLOCKWISE;
        var n = arguments[0];
        this._inputLine = n;
      } }, { key: "simplify", value: function(n, o) {
        return new c(n).simplify(o);
      } }]), c;
    }();
    Ye.INIT = 0, Ye.DELETE = 1, Ye.KEEP = 1, Ye.NUM_PTS_TO_CHECK = 10;
    var mh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getCoordinates", value: function() {
        return this._ptList.toArray(c.COORDINATE_ARRAY_TYPE);
      } }, { key: "setPrecisionModel", value: function(n) {
        this._precisionModel = n;
      } }, { key: "addPt", value: function(n) {
        var o = new P(n);
        if (this._precisionModel.makePrecise(o), this.isRedundant(o)) return null;
        this._ptList.add(o);
      } }, { key: "reverse", value: function() {
      } }, { key: "addPts", value: function(n, o) {
        if (o) for (var a = 0; a < n.length; a++) this.addPt(n[a]);
        else for (var l = n.length - 1; l >= 0; l--) this.addPt(n[l]);
      } }, { key: "isRedundant", value: function(n) {
        if (this._ptList.size() < 1) return !1;
        var o = this._ptList.get(this._ptList.size() - 1);
        return n.distance(o) < this._minimimVertexDistance;
      } }, { key: "toString", value: function() {
        return new zi().createLineString(this.getCoordinates()).toString();
      } }, { key: "closeRing", value: function() {
        if (this._ptList.size() < 1) return null;
        var n = new P(this._ptList.get(0)), o = this._ptList.get(this._ptList.size() - 1);
        if (n.equals(o)) return null;
        this._ptList.add(n);
      } }, { key: "setMinimumVertexDistance", value: function(n) {
        this._minimimVertexDistance = n;
      } }], [{ key: "constructor_", value: function() {
        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new ot();
      } }]), c;
    }();
    mh.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
    var ve = function() {
      function c() {
        e(this, c);
      }
      return s(c, null, [{ key: "toDegrees", value: function(n) {
        return 180 * n / Math.PI;
      } }, { key: "normalize", value: function(n) {
        for (; n > Math.PI; ) n -= c.PI_TIMES_2;
        for (; n <= -Math.PI; ) n += c.PI_TIMES_2;
        return n;
      } }, { key: "angle", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return Math.atan2(n.y, n.x);
        }
        if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1], l = a.x - o.x, d = a.y - o.y;
          return Math.atan2(d, l);
        }
      } }, { key: "isAcute", value: function(n, o, a) {
        var l = n.x - o.x, d = n.y - o.y;
        return l * (a.x - o.x) + d * (a.y - o.y) > 0;
      } }, { key: "isObtuse", value: function(n, o, a) {
        var l = n.x - o.x, d = n.y - o.y;
        return l * (a.x - o.x) + d * (a.y - o.y) < 0;
      } }, { key: "interiorAngle", value: function(n, o, a) {
        var l = c.angle(o, n), d = c.angle(o, a);
        return Math.abs(d - l);
      } }, { key: "normalizePositive", value: function(n) {
        if (n < 0) {
          for (; n < 0; ) n += c.PI_TIMES_2;
          n >= c.PI_TIMES_2 && (n = 0);
        } else {
          for (; n >= c.PI_TIMES_2; ) n -= c.PI_TIMES_2;
          n < 0 && (n = 0);
        }
        return n;
      } }, { key: "angleBetween", value: function(n, o, a) {
        var l = c.angle(o, n), d = c.angle(o, a);
        return c.diff(l, d);
      } }, { key: "diff", value: function(n, o) {
        var a = null;
        return (a = n < o ? o - n : n - o) > Math.PI && (a = 2 * Math.PI - a), a;
      } }, { key: "toRadians", value: function(n) {
        return n * Math.PI / 180;
      } }, { key: "getTurn", value: function(n, o) {
        var a = Math.sin(o - n);
        return a > 0 ? c.COUNTERCLOCKWISE : a < 0 ? c.CLOCKWISE : c.NONE;
      } }, { key: "angleBetweenOriented", value: function(n, o, a) {
        var l = c.angle(o, n), d = c.angle(o, a) - l;
        return d <= -Math.PI ? d + c.PI_TIMES_2 : d > Math.PI ? d - c.PI_TIMES_2 : d;
      } }]), c;
    }();
    ve.PI_TIMES_2 = 2 * Math.PI, ve.PI_OVER_2 = Math.PI / 2, ve.PI_OVER_4 = Math.PI / 4, ve.COUNTERCLOCKWISE = ut.COUNTERCLOCKWISE, ve.CLOCKWISE = ut.CLOCKWISE, ve.NONE = ut.COLLINEAR;
    var Gr = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "addNextSegment", value: function(n, o) {
        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = n, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
        var a = ut.index(this._s0, this._s1, this._s2), l = a === ut.CLOCKWISE && this._side === U.LEFT || a === ut.COUNTERCLOCKWISE && this._side === U.RIGHT;
        a === 0 ? this.addCollinear(o) : l ? this.addOutsideTurn(a, o) : this.addInsideTurn(a, o);
      } }, { key: "addLineEndCap", value: function(n, o) {
        var a = new me(n, o), l = new me();
        this.computeOffsetSegment(a, U.LEFT, this._distance, l);
        var d = new me();
        this.computeOffsetSegment(a, U.RIGHT, this._distance, d);
        var v = o.x - n.x, E = o.y - n.y, S = Math.atan2(E, v);
        switch (this._bufParams.getEndCapStyle()) {
          case O.CAP_ROUND:
            this._segList.addPt(l.p1), this.addDirectedFillet(o, S + Math.PI / 2, S - Math.PI / 2, ut.CLOCKWISE, this._distance), this._segList.addPt(d.p1);
            break;
          case O.CAP_FLAT:
            this._segList.addPt(l.p1), this._segList.addPt(d.p1);
            break;
          case O.CAP_SQUARE:
            var w = new P();
            w.x = Math.abs(this._distance) * Math.cos(S), w.y = Math.abs(this._distance) * Math.sin(S);
            var N = new P(l.p1.x + w.x, l.p1.y + w.y), M = new P(d.p1.x + w.x, d.p1.y + w.y);
            this._segList.addPt(N), this._segList.addPt(M);
        }
      } }, { key: "getCoordinates", value: function() {
        return this._segList.getCoordinates();
      } }, { key: "addMitreJoin", value: function(n, o, a, l) {
        var d = li.intersection(o.p0, o.p1, a.p0, a.p1);
        if (d !== null && (l <= 0 ? 1 : d.distance(n) / Math.abs(l)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(d), null;
        this.addLimitedMitreJoin(o, a, l, this._bufParams.getMitreLimit());
      } }, { key: "addOutsideTurn", value: function(n, o) {
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * c.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
        this._bufParams.getJoinStyle() === O.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === O.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (o && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, n, this._distance), this._segList.addPt(this._offset1.p0));
      } }, { key: "createSquare", value: function(n) {
        this._segList.addPt(new P(n.x + this._distance, n.y + this._distance)), this._segList.addPt(new P(n.x + this._distance, n.y - this._distance)), this._segList.addPt(new P(n.x - this._distance, n.y - this._distance)), this._segList.addPt(new P(n.x - this._distance, n.y + this._distance)), this._segList.closeRing();
      } }, { key: "addSegments", value: function(n, o) {
        this._segList.addPts(n, o);
      } }, { key: "addFirstSegment", value: function() {
        this._segList.addPt(this._offset1.p0);
      } }, { key: "addCornerFillet", value: function(n, o, a, l, d) {
        var v = o.x - n.x, E = o.y - n.y, S = Math.atan2(E, v), w = a.x - n.x, N = a.y - n.y, M = Math.atan2(N, w);
        l === ut.CLOCKWISE ? S <= M && (S += 2 * Math.PI) : S >= M && (S -= 2 * Math.PI), this._segList.addPt(o), this.addDirectedFillet(n, S, M, l, d), this._segList.addPt(a);
      } }, { key: "addLastSegment", value: function() {
        this._segList.addPt(this._offset1.p1);
      } }, { key: "initSideSegments", value: function(n, o, a) {
        this._s1 = n, this._s2 = o, this._side = a, this._seg1.setCoordinates(n, o), this.computeOffsetSegment(this._seg1, a, this._distance, this._offset1);
      } }, { key: "addLimitedMitreJoin", value: function(n, o, a, l) {
        var d = this._seg0.p1, v = ve.angle(d, this._seg0.p0), E = ve.angleBetweenOriented(this._seg0.p0, d, this._seg1.p1) / 2, S = ve.normalize(v + E), w = ve.normalize(S + Math.PI), N = l * a, M = a - N * Math.abs(Math.sin(E)), Y = d.x + N * Math.cos(w), W = d.y + N * Math.sin(w), q = new P(Y, W), it = new me(d, q), at = it.pointAlongOffset(1, M), ft = it.pointAlongOffset(1, -M);
        this._side === U.LEFT ? (this._segList.addPt(at), this._segList.addPt(ft)) : (this._segList.addPt(ft), this._segList.addPt(at));
      } }, { key: "addDirectedFillet", value: function(n, o, a, l, d) {
        var v = l === ut.CLOCKWISE ? -1 : 1, E = Math.abs(o - a), S = Math.trunc(E / this._filletAngleQuantum + 0.5);
        if (S < 1) return null;
        for (var w = E / S, N = new P(), M = 0; M < S; M++) {
          var Y = o + v * M * w;
          N.x = n.x + d * Math.cos(Y), N.y = n.y + d * Math.sin(Y), this._segList.addPt(N);
        }
      } }, { key: "computeOffsetSegment", value: function(n, o, a, l) {
        var d = o === U.LEFT ? 1 : -1, v = n.p1.x - n.p0.x, E = n.p1.y - n.p0.y, S = Math.sqrt(v * v + E * E), w = d * a * v / S, N = d * a * E / S;
        l.p0.x = n.p0.x - N, l.p0.y = n.p0.y + w, l.p1.x = n.p1.x - N, l.p1.y = n.p1.y + w;
      } }, { key: "addInsideTurn", value: function(n, o) {
        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
        else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * c.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
        else {
          if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
            var a = new P((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(a);
            var l = new P((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(l);
          } else this._segList.addPt(this._s1);
          this._segList.addPt(this._offset1.p0);
        }
      } }, { key: "createCircle", value: function(n) {
        var o = new P(n.x + this._distance, n.y);
        this._segList.addPt(o), this.addDirectedFillet(n, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
      } }, { key: "addBevelJoin", value: function(n, o) {
        this._segList.addPt(n.p1), this._segList.addPt(o.p0);
      } }, { key: "init", value: function(n) {
        this._distance = n, this._maxCurveSegmentError = n * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new mh(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(n * c.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
      } }, { key: "addCollinear", value: function(n) {
        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === O.JOIN_BEVEL || this._bufParams.getJoinStyle() === O.JOIN_MITRE ? (n && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ut.CLOCKWISE, this._distance));
      } }, { key: "closeRing", value: function() {
        this._segList.closeRing();
      } }, { key: "hasNarrowConcaveAngle", value: function() {
        return this._hasNarrowConcaveAngle;
      } }], [{ key: "constructor_", value: function() {
        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new me(), this._seg1 = new me(), this._offset0 = new me(), this._offset1 = new me(), this._side = 0, this._hasNarrowConcaveAngle = !1;
        var n = arguments[0], o = arguments[1], a = arguments[2];
        this._precisionModel = n, this._bufParams = o, this._li = new fi(), this._filletAngleQuantum = Math.PI / 2 / o.getQuadrantSegments(), o.getQuadrantSegments() >= 8 && o.getJoinStyle() === O.JOIN_ROUND && (this._closingSegLengthFactor = c.MAX_CLOSING_SEG_LEN_FACTOR), this.init(a);
      } }]), c;
    }();
    Gr.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, Gr.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, Gr.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Gr.MAX_CLOSING_SEG_LEN_FACTOR = 80;
    var Ip = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getOffsetCurve", value: function(n, o) {
        if (this._distance = o, o === 0) return null;
        var a = o < 0, l = Math.abs(o), d = this.getSegGen(l);
        n.length <= 1 ? this.computePointCurve(n[0], d) : this.computeOffsetCurve(n, a, d);
        var v = d.getCoordinates();
        return a && Yt.reverse(v), v;
      } }, { key: "computeSingleSidedBufferCurve", value: function(n, o, a) {
        var l = this.simplifyTolerance(this._distance);
        if (o) {
          a.addSegments(n, !0);
          var d = Ye.simplify(n, -l), v = d.length - 1;
          a.initSideSegments(d[v], d[v - 1], U.LEFT), a.addFirstSegment();
          for (var E = v - 2; E >= 0; E--) a.addNextSegment(d[E], !0);
        } else {
          a.addSegments(n, !1);
          var S = Ye.simplify(n, l), w = S.length - 1;
          a.initSideSegments(S[0], S[1], U.LEFT), a.addFirstSegment();
          for (var N = 2; N <= w; N++) a.addNextSegment(S[N], !0);
        }
        a.addLastSegment(), a.closeRing();
      } }, { key: "computeRingBufferCurve", value: function(n, o, a) {
        var l = this.simplifyTolerance(this._distance);
        o === U.RIGHT && (l = -l);
        var d = Ye.simplify(n, l), v = d.length - 1;
        a.initSideSegments(d[v - 1], d[0], o);
        for (var E = 1; E <= v; E++) {
          var S = E !== 1;
          a.addNextSegment(d[E], S);
        }
        a.closeRing();
      } }, { key: "computeLineBufferCurve", value: function(n, o) {
        var a = this.simplifyTolerance(this._distance), l = Ye.simplify(n, a), d = l.length - 1;
        o.initSideSegments(l[0], l[1], U.LEFT);
        for (var v = 2; v <= d; v++) o.addNextSegment(l[v], !0);
        o.addLastSegment(), o.addLineEndCap(l[d - 1], l[d]);
        var E = Ye.simplify(n, -a), S = E.length - 1;
        o.initSideSegments(E[S], E[S - 1], U.LEFT);
        for (var w = S - 2; w >= 0; w--) o.addNextSegment(E[w], !0);
        o.addLastSegment(), o.addLineEndCap(E[1], E[0]), o.closeRing();
      } }, { key: "computePointCurve", value: function(n, o) {
        switch (this._bufParams.getEndCapStyle()) {
          case O.CAP_ROUND:
            o.createCircle(n);
            break;
          case O.CAP_SQUARE:
            o.createSquare(n);
        }
      } }, { key: "getLineCurve", value: function(n, o) {
        if (this._distance = o, this.isLineOffsetEmpty(o)) return null;
        var a = Math.abs(o), l = this.getSegGen(a);
        if (n.length <= 1) this.computePointCurve(n[0], l);
        else if (this._bufParams.isSingleSided()) {
          var d = o < 0;
          this.computeSingleSidedBufferCurve(n, d, l);
        } else this.computeLineBufferCurve(n, l);
        return l.getCoordinates();
      } }, { key: "getBufferParameters", value: function() {
        return this._bufParams;
      } }, { key: "simplifyTolerance", value: function(n) {
        return n * this._bufParams.getSimplifyFactor();
      } }, { key: "getRingCurve", value: function(n, o, a) {
        if (this._distance = a, n.length <= 2) return this.getLineCurve(n, a);
        if (a === 0) return c.copyCoordinates(n);
        var l = this.getSegGen(a);
        return this.computeRingBufferCurve(n, o, l), l.getCoordinates();
      } }, { key: "computeOffsetCurve", value: function(n, o, a) {
        var l = this.simplifyTolerance(this._distance);
        if (o) {
          var d = Ye.simplify(n, -l), v = d.length - 1;
          a.initSideSegments(d[v], d[v - 1], U.LEFT), a.addFirstSegment();
          for (var E = v - 2; E >= 0; E--) a.addNextSegment(d[E], !0);
        } else {
          var S = Ye.simplify(n, l), w = S.length - 1;
          a.initSideSegments(S[0], S[1], U.LEFT), a.addFirstSegment();
          for (var N = 2; N <= w; N++) a.addNextSegment(S[N], !0);
        }
        a.addLastSegment();
      } }, { key: "isLineOffsetEmpty", value: function(n) {
        return n === 0 || n < 0 && !this._bufParams.isSingleSided();
      } }, { key: "getSegGen", value: function(n) {
        return new Gr(this._precisionModel, this._bufParams, n);
      } }], [{ key: "constructor_", value: function() {
        this._distance = 0, this._precisionModel = null, this._bufParams = null;
        var n = arguments[0], o = arguments[1];
        this._precisionModel = n, this._bufParams = o;
      } }, { key: "copyCoordinates", value: function(n) {
        for (var o = new Array(n.length).fill(null), a = 0; a < o.length; a++) o[a] = new P(n[a]);
        return o;
      } }]), c;
    }(), vh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "findStabbedSegments", value: function() {
        if (arguments.length === 1) {
          for (var n = arguments[0], o = new ot(), a = this._subgraphs.iterator(); a.hasNext(); ) {
            var l = a.next(), d = l.getEnvelope();
            n.y < d.getMinY() || n.y > d.getMaxY() || this.findStabbedSegments(n, l.getDirectedEdges(), o);
          }
          return o;
        }
        if (arguments.length === 3) {
          if (ht(arguments[2], Fe) && arguments[0] instanceof P && arguments[1] instanceof Ca) for (var v = arguments[0], E = arguments[1], S = arguments[2], w = E.getEdge().getCoordinates(), N = 0; N < w.length - 1; N++) {
            this._seg.p0 = w[N], this._seg.p1 = w[N + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
            var M = Math.max(this._seg.p0.x, this._seg.p1.x);
            if (!(M < v.x) && !(this._seg.isHorizontal() || v.y < this._seg.p0.y || v.y > this._seg.p1.y || ut.index(this._seg.p0, this._seg.p1, v) === ut.RIGHT)) {
              var Y = E.getDepth(U.LEFT);
              this._seg.p0.equals(w[N]) || (Y = E.getDepth(U.RIGHT));
              var W = new _h(this._seg, Y);
              S.add(W);
            }
          }
          else if (ht(arguments[2], Fe) && arguments[0] instanceof P && ht(arguments[1], Fe)) for (var q = arguments[0], it = arguments[1], at = arguments[2], ft = it.iterator(); ft.hasNext(); ) {
            var kt = ft.next();
            kt.isForward() && this.findStabbedSegments(q, kt, at);
          }
        }
      } }, { key: "getDepth", value: function(n) {
        var o = this.findStabbedSegments(n);
        return o.size() === 0 ? 0 : Xi.min(o)._leftDepth;
      } }], [{ key: "constructor_", value: function() {
        this._subgraphs = null, this._seg = new me();
        var n = arguments[0];
        this._subgraphs = n;
      } }]), c;
    }(), _h = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "compareTo", value: function(n) {
        var o = n;
        if (this._upwardSeg.minX() >= o._upwardSeg.maxX()) return 1;
        if (this._upwardSeg.maxX() <= o._upwardSeg.minX()) return -1;
        var a = this._upwardSeg.orientationIndex(o._upwardSeg);
        return a !== 0 || (a = -1 * o._upwardSeg.orientationIndex(this._upwardSeg)) !== 0 ? a : this._upwardSeg.compareTo(o._upwardSeg);
      } }, { key: "compareX", value: function(n, o) {
        var a = n.p0.compareTo(o.p0);
        return a !== 0 ? a : n.p1.compareTo(o.p1);
      } }, { key: "toString", value: function() {
        return this._upwardSeg.toString();
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }], [{ key: "constructor_", value: function() {
        this._upwardSeg = null, this._leftDepth = null;
        var n = arguments[0], o = arguments[1];
        this._upwardSeg = new me(n), this._leftDepth = o;
      } }]), c;
    }();
    vh.DepthSegment = _h;
    var xh = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, null, [{ key: "constructor_", value: function() {
        A.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
      } }]), o;
    }(A), Ta = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getY", value: function() {
        var n = this.y / this.w;
        if (Z.isNaN(n) || Z.isInfinite(n)) throw new xh();
        return n;
      } }, { key: "getX", value: function() {
        var n = this.x / this.w;
        if (Z.isNaN(n) || Z.isInfinite(n)) throw new xh();
        return n;
      } }, { key: "getCoordinate", value: function() {
        var n = new P();
        return n.x = this.getX(), n.y = this.getY(), n;
      } }], [{ key: "constructor_", value: function() {
        if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1;
        else if (arguments.length === 1) {
          var n = arguments[0];
          this.x = n.x, this.y = n.y, this.w = 1;
        } else if (arguments.length === 2) {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], a = arguments[1];
            this.x = o, this.y = a, this.w = 1;
          } else if (arguments[0] instanceof c && arguments[1] instanceof c) {
            var l = arguments[0], d = arguments[1];
            this.x = l.y * d.w - d.y * l.w, this.y = d.x * l.w - l.x * d.w, this.w = l.x * d.y - d.x * l.y;
          } else if (arguments[0] instanceof P && arguments[1] instanceof P) {
            var v = arguments[0], E = arguments[1];
            this.x = v.y - E.y, this.y = E.x - v.x, this.w = v.x * E.y - E.x * v.y;
          }
        } else if (arguments.length === 3) {
          var S = arguments[0], w = arguments[1], N = arguments[2];
          this.x = S, this.y = w, this.w = N;
        } else if (arguments.length === 4) {
          var M = arguments[0], Y = arguments[1], W = arguments[2], q = arguments[3], it = M.y - Y.y, at = Y.x - M.x, ft = M.x * Y.y - Y.x * M.y, kt = W.y - q.y, Pt = q.x - W.x, Jt = W.x * q.y - q.x * W.y;
          this.x = at * Jt - Pt * ft, this.y = kt * ft - it * Jt, this.w = it * Pt - kt * at;
        }
      } }]), c;
    }(), wp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "area", value: function() {
        return c.area(this.p0, this.p1, this.p2);
      } }, { key: "signedArea", value: function() {
        return c.signedArea(this.p0, this.p1, this.p2);
      } }, { key: "interpolateZ", value: function(n) {
        if (n === null) throw new L("Supplied point is null.");
        return c.interpolateZ(n, this.p0, this.p1, this.p2);
      } }, { key: "longestSideLength", value: function() {
        return c.longestSideLength(this.p0, this.p1, this.p2);
      } }, { key: "isAcute", value: function() {
        return c.isAcute(this.p0, this.p1, this.p2);
      } }, { key: "circumcentre", value: function() {
        return c.circumcentre(this.p0, this.p1, this.p2);
      } }, { key: "area3D", value: function() {
        return c.area3D(this.p0, this.p1, this.p2);
      } }, { key: "centroid", value: function() {
        return c.centroid(this.p0, this.p1, this.p2);
      } }, { key: "inCentre", value: function() {
        return c.inCentre(this.p0, this.p1, this.p2);
      } }], [{ key: "constructor_", value: function() {
        this.p0 = null, this.p1 = null, this.p2 = null;
        var n = arguments[0], o = arguments[1], a = arguments[2];
        this.p0 = n, this.p1 = o, this.p2 = a;
      } }, { key: "area", value: function(n, o, a) {
        return Math.abs(((a.x - n.x) * (o.y - n.y) - (o.x - n.x) * (a.y - n.y)) / 2);
      } }, { key: "signedArea", value: function(n, o, a) {
        return ((a.x - n.x) * (o.y - n.y) - (o.x - n.x) * (a.y - n.y)) / 2;
      } }, { key: "det", value: function(n, o, a, l) {
        return n * l - o * a;
      } }, { key: "interpolateZ", value: function(n, o, a, l) {
        var d = o.x, v = o.y, E = a.x - d, S = l.x - d, w = a.y - v, N = l.y - v, M = E * N - S * w, Y = n.x - d, W = n.y - v, q = (N * Y - S * W) / M, it = (-w * Y + E * W) / M;
        return o.getZ() + q * (a.getZ() - o.getZ()) + it * (l.getZ() - o.getZ());
      } }, { key: "longestSideLength", value: function(n, o, a) {
        var l = n.distance(o), d = o.distance(a), v = a.distance(n), E = l;
        return d > E && (E = d), v > E && (E = v), E;
      } }, { key: "circumcentreDD", value: function(n, o, a) {
        var l = rt.valueOf(n.x).subtract(a.x), d = rt.valueOf(n.y).subtract(a.y), v = rt.valueOf(o.x).subtract(a.x), E = rt.valueOf(o.y).subtract(a.y), S = rt.determinant(l, d, v, E).multiply(2), w = l.sqr().add(d.sqr()), N = v.sqr().add(E.sqr()), M = rt.determinant(d, w, E, N), Y = rt.determinant(l, w, v, N), W = rt.valueOf(a.x).subtract(M.divide(S)).doubleValue(), q = rt.valueOf(a.y).add(Y.divide(S)).doubleValue();
        return new P(W, q);
      } }, { key: "isAcute", value: function(n, o, a) {
        return !!ve.isAcute(n, o, a) && !!ve.isAcute(o, a, n) && !!ve.isAcute(a, n, o);
      } }, { key: "circumcentre", value: function(n, o, a) {
        var l = a.x, d = a.y, v = n.x - l, E = n.y - d, S = o.x - l, w = o.y - d, N = 2 * c.det(v, E, S, w), M = c.det(E, v * v + E * E, w, S * S + w * w), Y = c.det(v, v * v + E * E, S, S * S + w * w);
        return new P(l - M / N, d + Y / N);
      } }, { key: "perpendicularBisector", value: function(n, o) {
        var a = o.x - n.x, l = o.y - n.y, d = new Ta(n.x + a / 2, n.y + l / 2, 1), v = new Ta(n.x - l + a / 2, n.y + a + l / 2, 1);
        return new Ta(d, v);
      } }, { key: "angleBisector", value: function(n, o, a) {
        var l = o.distance(n), d = l / (l + o.distance(a)), v = a.x - n.x, E = a.y - n.y;
        return new P(n.x + d * v, n.y + d * E);
      } }, { key: "area3D", value: function(n, o, a) {
        var l = o.x - n.x, d = o.y - n.y, v = o.getZ() - n.getZ(), E = a.x - n.x, S = a.y - n.y, w = a.getZ() - n.getZ(), N = d * w - v * S, M = v * E - l * w, Y = l * S - d * E, W = N * N + M * M + Y * Y, q = Math.sqrt(W) / 2;
        return q;
      } }, { key: "centroid", value: function(n, o, a) {
        var l = (n.x + o.x + a.x) / 3, d = (n.y + o.y + a.y) / 3;
        return new P(l, d);
      } }, { key: "inCentre", value: function(n, o, a) {
        var l = o.distance(a), d = n.distance(a), v = n.distance(o), E = l + d + v, S = (l * n.x + d * o.x + v * a.x) / E, w = (l * n.y + d * o.y + v * a.y) / E;
        return new P(S, w);
      } }]), c;
    }(), kp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "addRingSide", value: function(n, o, a, l, d) {
        if (o === 0 && n.length < Lr.MINIMUM_VALID_SIZE) return null;
        var v = l, E = d;
        n.length >= Lr.MINIMUM_VALID_SIZE && ut.isCCW(n) && (v = d, E = l, a = U.opposite(a));
        var S = this._curveBuilder.getRingCurve(n, a, o);
        this.addCurve(S, v, E);
      } }, { key: "addRingBothSides", value: function(n, o) {
        this.addRingSide(n, o, U.LEFT, T.EXTERIOR, T.INTERIOR), this.addRingSide(n, o, U.RIGHT, T.INTERIOR, T.EXTERIOR);
      } }, { key: "addPoint", value: function(n) {
        if (this._distance <= 0) return null;
        var o = n.getCoordinates(), a = this._curveBuilder.getLineCurve(o, this._distance);
        this.addCurve(a, T.EXTERIOR, T.INTERIOR);
      } }, { key: "addPolygon", value: function(n) {
        var o = this._distance, a = U.LEFT;
        this._distance < 0 && (o = -this._distance, a = U.RIGHT);
        var l = n.getExteriorRing(), d = Yt.removeRepeatedPoints(l.getCoordinates());
        if (this._distance < 0 && this.isErodedCompletely(l, this._distance) || this._distance <= 0 && d.length < 3) return null;
        this.addRingSide(d, o, a, T.EXTERIOR, T.INTERIOR);
        for (var v = 0; v < n.getNumInteriorRing(); v++) {
          var E = n.getInteriorRingN(v), S = Yt.removeRepeatedPoints(E.getCoordinates());
          this._distance > 0 && this.isErodedCompletely(E, -this._distance) || this.addRingSide(S, o, U.opposite(a), T.INTERIOR, T.EXTERIOR);
        }
      } }, { key: "isTriangleErodedCompletely", value: function(n, o) {
        var a = new wp(n[0], n[1], n[2]), l = a.inCentre();
        return Ht.pointToSegment(l, a.p0, a.p1) < Math.abs(o);
      } }, { key: "addLineString", value: function(n) {
        if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
        var o = Yt.removeRepeatedPoints(n.getCoordinates());
        if (Yt.isRing(o) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(o, this._distance);
        else {
          var a = this._curveBuilder.getLineCurve(o, this._distance);
          this.addCurve(a, T.EXTERIOR, T.INTERIOR);
        }
      } }, { key: "addCurve", value: function(n, o, a) {
        if (n === null || n.length < 2) return null;
        var l = new gi(n, new Re(0, T.BOUNDARY, o, a));
        this._curveList.add(l);
      } }, { key: "getCurves", value: function() {
        return this.add(this._inputGeom), this._curveList;
      } }, { key: "add", value: function(n) {
        if (n.isEmpty()) return null;
        if (n instanceof Bi) this.addPolygon(n);
        else if (n instanceof zt) this.addLineString(n);
        else if (n instanceof ye) this.addPoint(n);
        else if (n instanceof ma) this.addCollection(n);
        else if (n instanceof Ea) this.addCollection(n);
        else if (n instanceof xa) this.addCollection(n);
        else {
          if (!(n instanceof pe)) throw new De(n.getGeometryType());
          this.addCollection(n);
        }
      } }, { key: "isErodedCompletely", value: function(n, o) {
        var a = n.getCoordinates();
        if (a.length < 4) return o < 0;
        if (a.length === 4) return this.isTriangleErodedCompletely(a, o);
        var l = n.getEnvelopeInternal(), d = Math.min(l.getHeight(), l.getWidth());
        return o < 0 && 2 * Math.abs(o) > d;
      } }, { key: "addCollection", value: function(n) {
        for (var o = 0; o < n.getNumGeometries(); o++) {
          var a = n.getGeometryN(o);
          this.add(a);
        }
      } }], [{ key: "constructor_", value: function() {
        this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new ot();
        var n = arguments[0], o = arguments[1], a = arguments[2];
        this._inputGeom = n, this._distance = o, this._curveBuilder = a;
      } }]), c;
    }(), Cp = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "locate", value: function(n) {
      } }]), c;
    }(), Rp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "next", value: function() {
        if (this._atStart) return this._atStart = !1, c.isAtomic(this._parent) && this._index++, this._parent;
        if (this._subcollectionIterator !== null) {
          if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
          this._subcollectionIterator = null;
        }
        if (this._index >= this._max) throw new Gi();
        var n = this._parent.getGeometryN(this._index++);
        return n instanceof pe ? (this._subcollectionIterator = new c(n), this._subcollectionIterator.next()) : n;
      } }, { key: "remove", value: function() {
        throw new De(this.getClass().getName());
      } }, { key: "hasNext", value: function() {
        if (this._atStart) return !0;
        if (this._subcollectionIterator !== null) {
          if (this._subcollectionIterator.hasNext()) return !0;
          this._subcollectionIterator = null;
        }
        return !(this._index >= this._max);
      } }, { key: "interfaces_", get: function() {
        return [pp];
      } }], [{ key: "constructor_", value: function() {
        this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
        var n = arguments[0];
        this._parent = n, this._atStart = !0, this._index = 0, this._max = n.getNumGeometries();
      } }, { key: "isAtomic", value: function(n) {
        return !(n instanceof pe);
      } }]), c;
    }(), bp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "locate", value: function(n) {
        return c.locate(n, this._geom);
      } }, { key: "interfaces_", get: function() {
        return [Cp];
      } }], [{ key: "constructor_", value: function() {
        this._geom = null;
        var n = arguments[0];
        this._geom = n;
      } }, { key: "locatePointInPolygon", value: function(n, o) {
        if (o.isEmpty()) return T.EXTERIOR;
        var a = o.getExteriorRing(), l = c.locatePointInRing(n, a);
        if (l !== T.INTERIOR) return l;
        for (var d = 0; d < o.getNumInteriorRing(); d++) {
          var v = o.getInteriorRingN(d), E = c.locatePointInRing(n, v);
          if (E === T.BOUNDARY) return T.BOUNDARY;
          if (E === T.INTERIOR) return T.EXTERIOR;
        }
        return T.INTERIOR;
      } }, { key: "locatePointInRing", value: function(n, o) {
        return o.getEnvelopeInternal().intersects(n) ? wa.locateInRing(n, o.getCoordinates()) : T.EXTERIOR;
      } }, { key: "containsPointInPolygon", value: function(n, o) {
        return T.EXTERIOR !== c.locatePointInPolygon(n, o);
      } }, { key: "locateInGeometry", value: function(n, o) {
        if (o instanceof Bi) return c.locatePointInPolygon(n, o);
        if (o instanceof pe) for (var a = new Rp(o); a.hasNext(); ) {
          var l = a.next();
          if (l !== o) {
            var d = c.locateInGeometry(n, l);
            if (d !== T.EXTERIOR) return d;
          }
        }
        return T.EXTERIOR;
      } }, { key: "isContained", value: function(n, o) {
        return T.EXTERIOR !== c.locate(n, o);
      } }, { key: "locate", value: function(n, o) {
        return o.isEmpty() ? T.EXTERIOR : o.getEnvelopeInternal().intersects(n) ? c.locateInGeometry(n, o) : T.EXTERIOR;
      } }]), c;
    }(), Tp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getNextCW", value: function(n) {
        this.getEdges();
        var o = this._edgeList.indexOf(n), a = o - 1;
        return o === 0 && (a = this._edgeList.size() - 1), this._edgeList.get(a);
      } }, { key: "propagateSideLabels", value: function(n) {
        for (var o = T.NONE, a = this.iterator(); a.hasNext(); ) {
          var l = a.next().getLabel();
          l.isArea(n) && l.getLocation(n, U.LEFT) !== T.NONE && (o = l.getLocation(n, U.LEFT));
        }
        if (o === T.NONE) return null;
        for (var d = o, v = this.iterator(); v.hasNext(); ) {
          var E = v.next(), S = E.getLabel();
          if (S.getLocation(n, U.ON) === T.NONE && S.setLocation(n, U.ON, d), S.isArea(n)) {
            var w = S.getLocation(n, U.LEFT), N = S.getLocation(n, U.RIGHT);
            if (N !== T.NONE) {
              if (N !== d) throw new de("side location conflict", E.getCoordinate());
              w === T.NONE && z.shouldNeverReachHere("found single null side (at " + E.getCoordinate() + ")"), d = w;
            } else z.isTrue(S.getLocation(n, U.LEFT) === T.NONE, "found single null side"), S.setLocation(n, U.RIGHT, d), S.setLocation(n, U.LEFT, d);
          }
        }
      } }, { key: "getCoordinate", value: function() {
        var n = this.iterator();
        return n.hasNext() ? n.next().getCoordinate() : null;
      } }, { key: "print", value: function(n) {
        re.out.println("EdgeEndStar:   " + this.getCoordinate());
        for (var o = this.iterator(); o.hasNext(); )
          o.next().print(n);
      } }, { key: "isAreaLabelsConsistent", value: function(n) {
        return this.computeEdgeEndLabels(n.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
      } }, { key: "checkAreaLabelsConsistent", value: function(n) {
        var o = this.getEdges();
        if (o.size() <= 0) return !0;
        var a = o.size() - 1, l = o.get(a).getLabel().getLocation(n, U.LEFT);
        z.isTrue(l !== T.NONE, "Found unlabelled area edge");
        for (var d = l, v = this.iterator(); v.hasNext(); ) {
          var E = v.next().getLabel();
          z.isTrue(E.isArea(n), "Found non-area edge");
          var S = E.getLocation(n, U.LEFT), w = E.getLocation(n, U.RIGHT);
          if (S === w || w !== d) return !1;
          d = S;
        }
        return !0;
      } }, { key: "findIndex", value: function(n) {
        this.iterator();
        for (var o = 0; o < this._edgeList.size(); o++)
          if (this._edgeList.get(o) === n) return o;
        return -1;
      } }, { key: "iterator", value: function() {
        return this.getEdges().iterator();
      } }, { key: "getEdges", value: function() {
        return this._edgeList === null && (this._edgeList = new ot(this._edgeMap.values())), this._edgeList;
      } }, { key: "getLocation", value: function(n, o, a) {
        return this._ptInAreaLocation[n] === T.NONE && (this._ptInAreaLocation[n] = bp.locate(o, a[n].getGeometry())), this._ptInAreaLocation[n];
      } }, { key: "toString", value: function() {
        var n = new Ge();
        n.append("EdgeEndStar:   " + this.getCoordinate()), n.append(`
`);
        for (var o = this.iterator(); o.hasNext(); ) {
          var a = o.next();
          n.append(a), n.append(`
`);
        }
        return n.toString();
      } }, { key: "computeEdgeEndLabels", value: function(n) {
        for (var o = this.iterator(); o.hasNext(); )
          o.next().computeLabel(n);
      } }, { key: "computeLabelling", value: function(n) {
        this.computeEdgeEndLabels(n[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
        for (var o = [!1, !1], a = this.iterator(); a.hasNext(); ) for (var l = a.next().getLabel(), d = 0; d < 2; d++) l.isLine(d) && l.getLocation(d) === T.BOUNDARY && (o[d] = !0);
        for (var v = this.iterator(); v.hasNext(); ) for (var E = v.next(), S = E.getLabel(), w = 0; w < 2; w++) if (S.isAnyNull(w)) {
          var N = T.NONE;
          if (o[w]) N = T.EXTERIOR;
          else {
            var M = E.getCoordinate();
            N = this.getLocation(w, M, n);
          }
          S.setAllLocationsIfNull(w, N);
        }
      } }, { key: "getDegree", value: function() {
        return this._edgeMap.size();
      } }, { key: "insertEdgeEnd", value: function(n, o) {
        this._edgeMap.put(n, o), this._edgeList = null;
      } }], [{ key: "constructor_", value: function() {
        this._edgeMap = new Fr(), this._edgeList = null, this._ptInAreaLocation = [T.NONE, T.NONE];
      } }]), c;
    }(), Np = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "linkResultDirectedEdges", value: function() {
        this.getResultAreaEdges();
        for (var a = null, l = null, d = this._SCANNING_FOR_INCOMING, v = 0; v < this._resultAreaEdgeList.size(); v++) {
          var E = this._resultAreaEdgeList.get(v), S = E.getSym();
          if (E.getLabel().isArea()) switch (a === null && E.isInResult() && (a = E), d) {
            case this._SCANNING_FOR_INCOMING:
              if (!S.isInResult()) continue;
              l = S, d = this._LINKING_TO_OUTGOING;
              break;
            case this._LINKING_TO_OUTGOING:
              if (!E.isInResult()) continue;
              l.setNext(E), d = this._SCANNING_FOR_INCOMING;
          }
        }
        if (d === this._LINKING_TO_OUTGOING) {
          if (a === null) throw new de("no outgoing dirEdge found", this.getCoordinate());
          z.isTrue(a.isInResult(), "unable to link last incoming dirEdge"), l.setNext(a);
        }
      } }, { key: "insert", value: function(a) {
        var l = a;
        this.insertEdgeEnd(l, l);
      } }, { key: "getRightmostEdge", value: function() {
        var a = this.getEdges(), l = a.size();
        if (l < 1) return null;
        var d = a.get(0);
        if (l === 1) return d;
        var v = a.get(l - 1), E = d.getQuadrant(), S = v.getQuadrant();
        return oe.isNorthern(E) && oe.isNorthern(S) ? d : oe.isNorthern(E) || oe.isNorthern(S) ? d.getDy() !== 0 ? d : v.getDy() !== 0 ? v : (z.shouldNeverReachHere("found two horizontal edges incident on node"), null) : v;
      } }, { key: "print", value: function(a) {
        re.out.println("DirectedEdgeStar: " + this.getCoordinate());
        for (var l = this.iterator(); l.hasNext(); ) {
          var d = l.next();
          a.print("out "), d.print(a), a.println(), a.print("in "), d.getSym().print(a), a.println();
        }
      } }, { key: "getResultAreaEdges", value: function() {
        if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
        this._resultAreaEdgeList = new ot();
        for (var a = this.iterator(); a.hasNext(); ) {
          var l = a.next();
          (l.isInResult() || l.getSym().isInResult()) && this._resultAreaEdgeList.add(l);
        }
        return this._resultAreaEdgeList;
      } }, { key: "updateLabelling", value: function(a) {
        for (var l = this.iterator(); l.hasNext(); ) {
          var d = l.next().getLabel();
          d.setAllLocationsIfNull(0, a.getLocation(0)), d.setAllLocationsIfNull(1, a.getLocation(1));
        }
      } }, { key: "linkAllDirectedEdges", value: function() {
        this.getEdges();
        for (var a = null, l = null, d = this._edgeList.size() - 1; d >= 0; d--) {
          var v = this._edgeList.get(d), E = v.getSym();
          l === null && (l = E), a !== null && E.setNext(a), a = v;
        }
        l.setNext(a);
      } }, { key: "computeDepths", value: function() {
        if (arguments.length === 1) {
          var a = arguments[0], l = this.findIndex(a), d = a.getDepth(U.LEFT), v = a.getDepth(U.RIGHT), E = this.computeDepths(l + 1, this._edgeList.size(), d), S = this.computeDepths(0, l, E);
          if (S !== v) throw new de("depth mismatch at " + a.getCoordinate());
        } else if (arguments.length === 3) {
          for (var w = arguments[0], N = arguments[1], M = arguments[2], Y = M, W = w; W < N; W++) {
            var q = this._edgeList.get(W);
            q.setEdgeDepths(U.RIGHT, Y), Y = q.getDepth(U.LEFT);
          }
          return Y;
        }
      } }, { key: "mergeSymLabels", value: function() {
        for (var a = this.iterator(); a.hasNext(); ) {
          var l = a.next();
          l.getLabel().merge(l.getSym().getLabel());
        }
      } }, { key: "linkMinimalDirectedEdges", value: function(a) {
        for (var l = null, d = null, v = this._SCANNING_FOR_INCOMING, E = this._resultAreaEdgeList.size() - 1; E >= 0; E--) {
          var S = this._resultAreaEdgeList.get(E), w = S.getSym();
          switch (l === null && S.getEdgeRing() === a && (l = S), v) {
            case this._SCANNING_FOR_INCOMING:
              if (w.getEdgeRing() !== a) continue;
              d = w, v = this._LINKING_TO_OUTGOING;
              break;
            case this._LINKING_TO_OUTGOING:
              if (S.getEdgeRing() !== a) continue;
              d.setNextMin(S), v = this._SCANNING_FOR_INCOMING;
          }
        }
        v === this._LINKING_TO_OUTGOING && (z.isTrue(l !== null, "found null for first outgoing dirEdge"), z.isTrue(l.getEdgeRing() === a, "unable to link last incoming dirEdge"), d.setNextMin(l));
      } }, { key: "getOutgoingDegree", value: function() {
        if (arguments.length === 0) {
          for (var a = 0, l = this.iterator(); l.hasNext(); ) {
            var d = l.next();
            d.isInResult() && a++;
          }
          return a;
        }
        if (arguments.length === 1) {
          for (var v = arguments[0], E = 0, S = this.iterator(); S.hasNext(); ) {
            var w = S.next();
            w.getEdgeRing() === v && E++;
          }
          return E;
        }
      } }, { key: "getLabel", value: function() {
        return this._label;
      } }, { key: "findCoveredLineEdges", value: function() {
        for (var a = T.NONE, l = this.iterator(); l.hasNext(); ) {
          var d = l.next(), v = d.getSym();
          if (!d.isLineEdge()) {
            if (d.isInResult()) {
              a = T.INTERIOR;
              break;
            }
            if (v.isInResult()) {
              a = T.EXTERIOR;
              break;
            }
          }
        }
        if (a === T.NONE) return null;
        for (var E = a, S = this.iterator(); S.hasNext(); ) {
          var w = S.next(), N = w.getSym();
          w.isLineEdge() ? w.getEdge().setCovered(E === T.INTERIOR) : (w.isInResult() && (E = T.EXTERIOR), N.isInResult() && (E = T.INTERIOR));
        }
      } }, { key: "computeLabelling", value: function(a) {
        I(h(o.prototype), "computeLabelling", this).call(this, a), this._label = new Re(T.NONE);
        for (var l = this.iterator(); l.hasNext(); ) for (var d = l.next().getEdge().getLabel(), v = 0; v < 2; v++) {
          var E = d.getLocation(v);
          E !== T.INTERIOR && E !== T.BOUNDARY || this._label.setLocation(v, T.INTERIOR);
        }
      } }], [{ key: "constructor_", value: function() {
        this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
      } }]), o;
    }(Tp), Mp = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        return e(this, o), n.call(this);
      }
      return s(o, [{ key: "createNode", value: function(a) {
        return new Xs(a, new Np());
      } }]), o;
    }(lh), Eh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "compareTo", value: function(n) {
        var o = n;
        return c.compareOriented(this._pts, this._orientation, o._pts, o._orientation);
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }], [{ key: "constructor_", value: function() {
        this._pts = null, this._orientation = null;
        var n = arguments[0];
        this._pts = n, this._orientation = c.orientation(n);
      } }, { key: "orientation", value: function(n) {
        return Yt.increasingDirection(n) === 1;
      } }, { key: "compareOriented", value: function(n, o, a, l) {
        for (var d = o ? 1 : -1, v = l ? 1 : -1, E = o ? n.length : -1, S = l ? a.length : -1, w = o ? 0 : n.length - 1, N = l ? 0 : a.length - 1; ; ) {
          var M = n[w].compareTo(a[N]);
          if (M !== 0) return M;
          var Y = (w += d) === E, W = (N += v) === S;
          if (Y && !W) return -1;
          if (!Y && W) return 1;
          if (Y && W) return 0;
        }
      } }]), c;
    }(), Op = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "print", value: function(n) {
        n.print("MULTILINESTRING ( ");
        for (var o = 0; o < this._edges.size(); o++) {
          var a = this._edges.get(o);
          o > 0 && n.print(","), n.print("(");
          for (var l = a.getCoordinates(), d = 0; d < l.length; d++) d > 0 && n.print(","), n.print(l[d].x + " " + l[d].y);
          n.println(")");
        }
        n.print(")  ");
      } }, { key: "addAll", value: function(n) {
        for (var o = n.iterator(); o.hasNext(); ) this.add(o.next());
      } }, { key: "findEdgeIndex", value: function(n) {
        for (var o = 0; o < this._edges.size(); o++) if (this._edges.get(o).equals(n)) return o;
        return -1;
      } }, { key: "iterator", value: function() {
        return this._edges.iterator();
      } }, { key: "getEdges", value: function() {
        return this._edges;
      } }, { key: "get", value: function(n) {
        return this._edges.get(n);
      } }, { key: "findEqualEdge", value: function(n) {
        var o = new Eh(n.getCoordinates());
        return this._ocaMap.get(o);
      } }, { key: "add", value: function(n) {
        this._edges.add(n);
        var o = new Eh(n.getCoordinates());
        this._ocaMap.put(o, n);
      } }], [{ key: "constructor_", value: function() {
        this._edges = new ot(), this._ocaMap = new Fr();
      } }]), c;
    }(), Sh = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "processIntersections", value: function(n, o, a, l) {
      } }, { key: "isDone", value: function() {
      } }]), c;
    }(), Lp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "isTrivialIntersection", value: function(n, o, a, l) {
        if (n === a && this._li.getIntersectionNum() === 1) {
          if (c.isAdjacentSegments(o, l)) return !0;
          if (n.isClosed()) {
            var d = n.size() - 1;
            if (o === 0 && l === d || l === 0 && o === d) return !0;
          }
        }
        return !1;
      } }, { key: "getProperIntersectionPoint", value: function() {
        return this._properIntersectionPoint;
      } }, { key: "hasProperInteriorIntersection", value: function() {
        return this._hasProperInterior;
      } }, { key: "getLineIntersector", value: function() {
        return this._li;
      } }, { key: "hasProperIntersection", value: function() {
        return this._hasProper;
      } }, { key: "processIntersections", value: function(n, o, a, l) {
        if (n === a && o === l) return null;
        this.numTests++;
        var d = n.getCoordinates()[o], v = n.getCoordinates()[o + 1], E = a.getCoordinates()[l], S = a.getCoordinates()[l + 1];
        this._li.computeIntersection(d, v, E, S), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(n, o, a, l) || (this._hasIntersection = !0, n.addIntersections(this._li, o, 0), a.addIntersections(this._li, l, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
      } }, { key: "hasIntersection", value: function() {
        return this._hasIntersection;
      } }, { key: "isDone", value: function() {
        return !1;
      } }, { key: "hasInteriorIntersection", value: function() {
        return this._hasInterior;
      } }, { key: "interfaces_", get: function() {
        return [Sh];
      } }], [{ key: "constructor_", value: function() {
        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
        var n = arguments[0];
        this._li = n;
      } }, { key: "isAdjacentSegments", value: function(n, o) {
        return Math.abs(n - o) === 1;
      } }]), c;
    }(), Ap = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getSegmentIndex", value: function() {
        return this.segmentIndex;
      } }, { key: "getCoordinate", value: function() {
        return this.coord;
      } }, { key: "print", value: function(n) {
        n.print(this.coord), n.print(" seg # = " + this.segmentIndex), n.println(" dist = " + this.dist);
      } }, { key: "compareTo", value: function(n) {
        var o = n;
        return this.compare(o.segmentIndex, o.dist);
      } }, { key: "isEndPoint", value: function(n) {
        return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === n;
      } }, { key: "toString", value: function() {
        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
      } }, { key: "getDistance", value: function() {
        return this.dist;
      } }, { key: "compare", value: function(n, o) {
        return this.segmentIndex < n ? -1 : this.segmentIndex > n ? 1 : this.dist < o ? -1 : this.dist > o ? 1 : 0;
      } }, { key: "interfaces_", get: function() {
        return [F];
      } }], [{ key: "constructor_", value: function() {
        this.coord = null, this.segmentIndex = null, this.dist = null;
        var n = arguments[0], o = arguments[1], a = arguments[2];
        this.coord = new P(n), this.segmentIndex = o, this.dist = a;
      } }]), c;
    }(), Pp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "print", value: function(n) {
        n.println("Intersections:");
        for (var o = this.iterator(); o.hasNext(); )
          o.next().print(n);
      } }, { key: "iterator", value: function() {
        return this._nodeMap.values().iterator();
      } }, { key: "addSplitEdges", value: function(n) {
        this.addEndpoints();
        for (var o = this.iterator(), a = o.next(); o.hasNext(); ) {
          var l = o.next(), d = this.createSplitEdge(a, l);
          n.add(d), a = l;
        }
      } }, { key: "addEndpoints", value: function() {
        var n = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[n], n, 0);
      } }, { key: "createSplitEdge", value: function(n, o) {
        var a = o.segmentIndex - n.segmentIndex + 2, l = this.edge.pts[o.segmentIndex], d = o.dist > 0 || !o.coord.equals2D(l);
        d || a--;
        var v = new Array(a).fill(null), E = 0;
        v[E++] = new P(n.coord);
        for (var S = n.segmentIndex + 1; S <= o.segmentIndex; S++) v[E++] = this.edge.pts[S];
        return d && (v[E] = o.coord), new wh(v, new Re(this.edge._label));
      } }, { key: "add", value: function(n, o, a) {
        var l = new Ap(n, o, a), d = this._nodeMap.get(l);
        return d !== null ? d : (this._nodeMap.put(l, l), l);
      } }, { key: "isIntersection", value: function(n) {
        for (var o = this.iterator(); o.hasNext(); )
          if (o.next().coord.equals(n)) return !0;
        return !1;
      } }], [{ key: "constructor_", value: function() {
        this._nodeMap = new Fr(), this.edge = null;
        var n = arguments[0];
        this.edge = n;
      } }]), c;
    }(), Dp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "isIntersects", value: function() {
        return !this.isDisjoint();
      } }, { key: "isCovers", value: function() {
        return (c.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) || c.isTrue(this._matrix[T.INTERIOR][T.BOUNDARY]) || c.isTrue(this._matrix[T.BOUNDARY][T.INTERIOR]) || c.isTrue(this._matrix[T.BOUNDARY][T.BOUNDARY])) && this._matrix[T.EXTERIOR][T.INTERIOR] === j.FALSE && this._matrix[T.EXTERIOR][T.BOUNDARY] === j.FALSE;
      } }, { key: "isCoveredBy", value: function() {
        return (c.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) || c.isTrue(this._matrix[T.INTERIOR][T.BOUNDARY]) || c.isTrue(this._matrix[T.BOUNDARY][T.INTERIOR]) || c.isTrue(this._matrix[T.BOUNDARY][T.BOUNDARY])) && this._matrix[T.INTERIOR][T.EXTERIOR] === j.FALSE && this._matrix[T.BOUNDARY][T.EXTERIOR] === j.FALSE;
      } }, { key: "set", value: function() {
        if (arguments.length === 1) for (var n = arguments[0], o = 0; o < n.length; o++) {
          var a = Math.trunc(o / 3), l = o % 3;
          this._matrix[a][l] = j.toDimensionValue(n.charAt(o));
        }
        else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], E = arguments[2];
          this._matrix[d][v] = E;
        }
      } }, { key: "isContains", value: function() {
        return c.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && this._matrix[T.EXTERIOR][T.INTERIOR] === j.FALSE && this._matrix[T.EXTERIOR][T.BOUNDARY] === j.FALSE;
      } }, { key: "setAtLeast", value: function() {
        if (arguments.length === 1) for (var n = arguments[0], o = 0; o < n.length; o++) {
          var a = Math.trunc(o / 3), l = o % 3;
          this.setAtLeast(a, l, j.toDimensionValue(n.charAt(o)));
        }
        else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], E = arguments[2];
          this._matrix[d][v] < E && (this._matrix[d][v] = E);
        }
      } }, { key: "setAtLeastIfValid", value: function(n, o, a) {
        n >= 0 && o >= 0 && this.setAtLeast(n, o, a);
      } }, { key: "isWithin", value: function() {
        return c.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && this._matrix[T.INTERIOR][T.EXTERIOR] === j.FALSE && this._matrix[T.BOUNDARY][T.EXTERIOR] === j.FALSE;
      } }, { key: "isTouches", value: function(n, o) {
        return n > o ? this.isTouches(o, n) : (n === j.A && o === j.A || n === j.L && o === j.L || n === j.L && o === j.A || n === j.P && o === j.A || n === j.P && o === j.L) && this._matrix[T.INTERIOR][T.INTERIOR] === j.FALSE && (c.isTrue(this._matrix[T.INTERIOR][T.BOUNDARY]) || c.isTrue(this._matrix[T.BOUNDARY][T.INTERIOR]) || c.isTrue(this._matrix[T.BOUNDARY][T.BOUNDARY]));
      } }, { key: "isOverlaps", value: function(n, o) {
        return n === j.P && o === j.P || n === j.A && o === j.A ? c.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && c.isTrue(this._matrix[T.INTERIOR][T.EXTERIOR]) && c.isTrue(this._matrix[T.EXTERIOR][T.INTERIOR]) : n === j.L && o === j.L && this._matrix[T.INTERIOR][T.INTERIOR] === 1 && c.isTrue(this._matrix[T.INTERIOR][T.EXTERIOR]) && c.isTrue(this._matrix[T.EXTERIOR][T.INTERIOR]);
      } }, { key: "isEquals", value: function(n, o) {
        return n === o && c.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && this._matrix[T.INTERIOR][T.EXTERIOR] === j.FALSE && this._matrix[T.BOUNDARY][T.EXTERIOR] === j.FALSE && this._matrix[T.EXTERIOR][T.INTERIOR] === j.FALSE && this._matrix[T.EXTERIOR][T.BOUNDARY] === j.FALSE;
      } }, { key: "toString", value: function() {
        for (var n = new Ys("123456789"), o = 0; o < 3; o++) for (var a = 0; a < 3; a++) n.setCharAt(3 * o + a, j.toDimensionSymbol(this._matrix[o][a]));
        return n.toString();
      } }, { key: "setAll", value: function(n) {
        for (var o = 0; o < 3; o++) for (var a = 0; a < 3; a++) this._matrix[o][a] = n;
      } }, { key: "get", value: function(n, o) {
        return this._matrix[n][o];
      } }, { key: "transpose", value: function() {
        var n = this._matrix[1][0];
        return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = n, n = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = n, n = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = n, this;
      } }, { key: "matches", value: function(n) {
        if (n.length !== 9) throw new L("Should be length 9: " + n);
        for (var o = 0; o < 3; o++) for (var a = 0; a < 3; a++) if (!c.matches(this._matrix[o][a], n.charAt(3 * o + a))) return !1;
        return !0;
      } }, { key: "add", value: function(n) {
        for (var o = 0; o < 3; o++) for (var a = 0; a < 3; a++) this.setAtLeast(o, a, n.get(o, a));
      } }, { key: "isDisjoint", value: function() {
        return this._matrix[T.INTERIOR][T.INTERIOR] === j.FALSE && this._matrix[T.INTERIOR][T.BOUNDARY] === j.FALSE && this._matrix[T.BOUNDARY][T.INTERIOR] === j.FALSE && this._matrix[T.BOUNDARY][T.BOUNDARY] === j.FALSE;
      } }, { key: "isCrosses", value: function(n, o) {
        return n === j.P && o === j.L || n === j.P && o === j.A || n === j.L && o === j.A ? c.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && c.isTrue(this._matrix[T.INTERIOR][T.EXTERIOR]) : n === j.L && o === j.P || n === j.A && o === j.P || n === j.A && o === j.L ? c.isTrue(this._matrix[T.INTERIOR][T.INTERIOR]) && c.isTrue(this._matrix[T.EXTERIOR][T.INTERIOR]) : n === j.L && o === j.L && this._matrix[T.INTERIOR][T.INTERIOR] === 0;
      } }, { key: "interfaces_", get: function() {
        return [G];
      } }], [{ key: "constructor_", value: function() {
        if (this._matrix = null, arguments.length === 0) this._matrix = Array(3).fill().map(function() {
          return Array(3);
        }), this.setAll(j.FALSE);
        else if (arguments.length === 1) {
          if (typeof arguments[0] == "string") {
            var n = arguments[0];
            c.constructor_.call(this), this.set(n);
          } else if (arguments[0] instanceof c) {
            var o = arguments[0];
            c.constructor_.call(this), this._matrix[T.INTERIOR][T.INTERIOR] = o._matrix[T.INTERIOR][T.INTERIOR], this._matrix[T.INTERIOR][T.BOUNDARY] = o._matrix[T.INTERIOR][T.BOUNDARY], this._matrix[T.INTERIOR][T.EXTERIOR] = o._matrix[T.INTERIOR][T.EXTERIOR], this._matrix[T.BOUNDARY][T.INTERIOR] = o._matrix[T.BOUNDARY][T.INTERIOR], this._matrix[T.BOUNDARY][T.BOUNDARY] = o._matrix[T.BOUNDARY][T.BOUNDARY], this._matrix[T.BOUNDARY][T.EXTERIOR] = o._matrix[T.BOUNDARY][T.EXTERIOR], this._matrix[T.EXTERIOR][T.INTERIOR] = o._matrix[T.EXTERIOR][T.INTERIOR], this._matrix[T.EXTERIOR][T.BOUNDARY] = o._matrix[T.EXTERIOR][T.BOUNDARY], this._matrix[T.EXTERIOR][T.EXTERIOR] = o._matrix[T.EXTERIOR][T.EXTERIOR];
          }
        }
      } }, { key: "matches", value: function() {
        if (Number.isInteger(arguments[0]) && typeof arguments[1] == "string") {
          var n = arguments[0], o = arguments[1];
          return o === j.SYM_DONTCARE || o === j.SYM_TRUE && (n >= 0 || n === j.TRUE) || o === j.SYM_FALSE && n === j.FALSE || o === j.SYM_P && n === j.P || o === j.SYM_L && n === j.L || o === j.SYM_A && n === j.A;
        }
        if (typeof arguments[0] == "string" && typeof arguments[1] == "string") {
          var a = arguments[0], l = arguments[1], d = new c(a);
          return d.matches(l);
        }
      } }, { key: "isTrue", value: function(n) {
        return n >= 0 || n === j.TRUE;
      } }]), c;
    }(), Fp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "size", value: function() {
        return this._size;
      } }, { key: "addAll", value: function(n) {
        return n === null || n.length === 0 ? null : (this.ensureCapacity(this._size + n.length), re.arraycopy(n, 0, this._data, this._size, n.length), void (this._size += n.length));
      } }, { key: "ensureCapacity", value: function(n) {
        if (n <= this._data.length) return null;
        var o = Math.max(n, 2 * this._data.length);
        this._data = At.copyOf(this._data, o);
      } }, { key: "toArray", value: function() {
        var n = new Array(this._size).fill(null);
        return re.arraycopy(this._data, 0, n, 0, this._size), n;
      } }, { key: "add", value: function(n) {
        this.ensureCapacity(this._size + 1), this._data[this._size] = n, ++this._size;
      } }], [{ key: "constructor_", value: function() {
        if (this._data = null, this._size = 0, arguments.length === 0) c.constructor_.call(this, 10);
        else if (arguments.length === 1) {
          var n = arguments[0];
          this._data = new Array(n).fill(null);
        }
      } }]), c;
    }(), Gp = function() {
      function c() {
        e(this, c);
      }
      return s(c, [{ key: "getChainStartIndices", value: function(n) {
        var o = 0, a = new Fp(Math.trunc(n.length / 2));
        a.add(o);
        do {
          var l = this.findChainEnd(n, o);
          a.add(l), o = l;
        } while (o < n.length - 1);
        return a.toArray();
      } }, { key: "findChainEnd", value: function(n, o) {
        for (var a = oe.quadrant(n[o], n[o + 1]), l = o + 1; l < n.length && oe.quadrant(n[l - 1], n[l]) === a; )
          l++;
        return l - 1;
      } }, { key: "OLDgetChainStartIndices", value: function(n) {
        var o = 0, a = new ot();
        a.add(o);
        do {
          var l = this.findChainEnd(n, o);
          a.add(l), o = l;
        } while (o < n.length - 1);
        return c.toIntArray(a);
      } }], [{ key: "toIntArray", value: function(n) {
        for (var o = new Array(n.size()).fill(null), a = 0; a < o.length; a++) o[a] = n.get(a).intValue();
        return o;
      } }]), c;
    }(), Bp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getCoordinates", value: function() {
        return this.pts;
      } }, { key: "getMaxX", value: function(n) {
        var o = this.pts[this.startIndex[n]].x, a = this.pts[this.startIndex[n + 1]].x;
        return o > a ? o : a;
      } }, { key: "getMinX", value: function(n) {
        var o = this.pts[this.startIndex[n]].x, a = this.pts[this.startIndex[n + 1]].x;
        return o < a ? o : a;
      } }, { key: "computeIntersectsForChain", value: function() {
        if (arguments.length === 4) {
          var n = arguments[0], o = arguments[1], a = arguments[2], l = arguments[3];
          this.computeIntersectsForChain(this.startIndex[n], this.startIndex[n + 1], o, o.startIndex[a], o.startIndex[a + 1], l);
        } else if (arguments.length === 6) {
          var d = arguments[0], v = arguments[1], E = arguments[2], S = arguments[3], w = arguments[4], N = arguments[5];
          if (v - d == 1 && w - S == 1) return N.addIntersections(this.e, d, E.e, S), null;
          if (!this.overlaps(d, v, E, S, w)) return null;
          var M = Math.trunc((d + v) / 2), Y = Math.trunc((S + w) / 2);
          d < M && (S < Y && this.computeIntersectsForChain(d, M, E, S, Y, N), Y < w && this.computeIntersectsForChain(d, M, E, Y, w, N)), M < v && (S < Y && this.computeIntersectsForChain(M, v, E, S, Y, N), Y < w && this.computeIntersectsForChain(M, v, E, Y, w, N));
        }
      } }, { key: "overlaps", value: function(n, o, a, l, d) {
        return bt.intersects(this.pts[n], this.pts[o], a.pts[l], a.pts[d]);
      } }, { key: "getStartIndexes", value: function() {
        return this.startIndex;
      } }, { key: "computeIntersects", value: function(n, o) {
        for (var a = 0; a < this.startIndex.length - 1; a++) for (var l = 0; l < n.startIndex.length - 1; l++) this.computeIntersectsForChain(a, n, l, o);
      } }], [{ key: "constructor_", value: function() {
        this.e = null, this.pts = null, this.startIndex = null;
        var n = arguments[0];
        this.e = n, this.pts = n.getCoordinates();
        var o = new Gp();
        this.startIndex = o.getChainStartIndices(this.pts);
      } }]), c;
    }(), Ih = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "getDepth", value: function(n, o) {
        return this._depth[n][o];
      } }, { key: "setDepth", value: function(n, o, a) {
        this._depth[n][o] = a;
      } }, { key: "isNull", value: function() {
        if (arguments.length === 0) {
          for (var n = 0; n < 2; n++) for (var o = 0; o < 3; o++) if (this._depth[n][o] !== c.NULL_VALUE) return !1;
          return !0;
        }
        if (arguments.length === 1) {
          var a = arguments[0];
          return this._depth[a][1] === c.NULL_VALUE;
        }
        if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          return this._depth[l][d] === c.NULL_VALUE;
        }
      } }, { key: "normalize", value: function() {
        for (var n = 0; n < 2; n++) if (!this.isNull(n)) {
          var o = this._depth[n][1];
          this._depth[n][2] < o && (o = this._depth[n][2]), o < 0 && (o = 0);
          for (var a = 1; a < 3; a++) {
            var l = 0;
            this._depth[n][a] > o && (l = 1), this._depth[n][a] = l;
          }
        }
      } }, { key: "getDelta", value: function(n) {
        return this._depth[n][U.RIGHT] - this._depth[n][U.LEFT];
      } }, { key: "getLocation", value: function(n, o) {
        return this._depth[n][o] <= 0 ? T.EXTERIOR : T.INTERIOR;
      } }, { key: "toString", value: function() {
        return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
      } }, { key: "add", value: function() {
        if (arguments.length === 1) for (var n = arguments[0], o = 0; o < 2; o++) for (var a = 1; a < 3; a++) {
          var l = n.getLocation(o, a);
          l !== T.EXTERIOR && l !== T.INTERIOR || (this.isNull(o, a) ? this._depth[o][a] = c.depthAtLocation(l) : this._depth[o][a] += c.depthAtLocation(l));
        }
        else if (arguments.length === 3) {
          var d = arguments[0], v = arguments[1], E = arguments[2];
          E === T.INTERIOR && this._depth[d][v]++;
        }
      } }], [{ key: "constructor_", value: function() {
        this._depth = Array(2).fill().map(function() {
          return Array(3);
        });
        for (var n = 0; n < 2; n++) for (var o = 0; o < 3; o++) this._depth[n][o] = c.NULL_VALUE;
      } }, { key: "depthAtLocation", value: function(n) {
        return n === T.EXTERIOR ? 0 : n === T.INTERIOR ? 1 : c.NULL_VALUE;
      } }]), c;
    }();
    Ih.NULL_VALUE = -1;
    var wh = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "getDepth", value: function() {
        return this._depth;
      } }, { key: "getCollapsedEdge", value: function() {
        var a = new Array(2).fill(null);
        return a[0] = this.pts[0], a[1] = this.pts[1], new o(a, Re.toLineLabel(this._label));
      } }, { key: "isIsolated", value: function() {
        return this._isIsolated;
      } }, { key: "getCoordinates", value: function() {
        return this.pts;
      } }, { key: "setIsolated", value: function(a) {
        this._isIsolated = a;
      } }, { key: "setName", value: function(a) {
        this._name = a;
      } }, { key: "equals", value: function(a) {
        if (!(a instanceof o)) return !1;
        var l = a;
        if (this.pts.length !== l.pts.length) return !1;
        for (var d = !0, v = !0, E = this.pts.length, S = 0; S < this.pts.length; S++) if (this.pts[S].equals2D(l.pts[S]) || (d = !1), this.pts[S].equals2D(l.pts[--E]) || (v = !1), !d && !v) return !1;
        return !0;
      } }, { key: "getCoordinate", value: function() {
        if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null;
        if (arguments.length === 1) {
          var a = arguments[0];
          return this.pts[a];
        }
      } }, { key: "print", value: function(a) {
        a.print("edge " + this._name + ": "), a.print("LINESTRING (");
        for (var l = 0; l < this.pts.length; l++) l > 0 && a.print(","), a.print(this.pts[l].x + " " + this.pts[l].y);
        a.print(")  " + this._label + " " + this._depthDelta);
      } }, { key: "computeIM", value: function(a) {
        o.updateIM(this._label, a);
      } }, { key: "isCollapsed", value: function() {
        return !!this._label.isArea() && this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]);
      } }, { key: "isClosed", value: function() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      } }, { key: "getMaximumSegmentIndex", value: function() {
        return this.pts.length - 1;
      } }, { key: "getDepthDelta", value: function() {
        return this._depthDelta;
      } }, { key: "getNumPoints", value: function() {
        return this.pts.length;
      } }, { key: "printReverse", value: function(a) {
        a.print("edge " + this._name + ": ");
        for (var l = this.pts.length - 1; l >= 0; l--) a.print(this.pts[l] + " ");
        a.println("");
      } }, { key: "getMonotoneChainEdge", value: function() {
        return this._mce === null && (this._mce = new Bp(this)), this._mce;
      } }, { key: "getEnvelope", value: function() {
        if (this._env === null) {
          this._env = new bt();
          for (var a = 0; a < this.pts.length; a++) this._env.expandToInclude(this.pts[a]);
        }
        return this._env;
      } }, { key: "addIntersection", value: function(a, l, d, v) {
        var E = new P(a.getIntersection(v)), S = l, w = a.getEdgeDistance(d, v), N = S + 1;
        if (N < this.pts.length) {
          var M = this.pts[N];
          E.equals2D(M) && (S = N, w = 0);
        }
        this.eiList.add(E, S, w);
      } }, { key: "toString", value: function() {
        var a = new Ys();
        a.append("edge " + this._name + ": "), a.append("LINESTRING (");
        for (var l = 0; l < this.pts.length; l++) l > 0 && a.append(","), a.append(this.pts[l].x + " " + this.pts[l].y);
        return a.append(")  " + this._label + " " + this._depthDelta), a.toString();
      } }, { key: "isPointwiseEqual", value: function(a) {
        if (this.pts.length !== a.pts.length) return !1;
        for (var l = 0; l < this.pts.length; l++) if (!this.pts[l].equals2D(a.pts[l])) return !1;
        return !0;
      } }, { key: "setDepthDelta", value: function(a) {
        this._depthDelta = a;
      } }, { key: "getEdgeIntersectionList", value: function() {
        return this.eiList;
      } }, { key: "addIntersections", value: function(a, l, d) {
        for (var v = 0; v < a.getIntersectionNum(); v++) this.addIntersection(a, l, d, v);
      } }], [{ key: "constructor_", value: function() {
        if (this.pts = null, this._env = null, this.eiList = new Pp(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new Ih(), this._depthDelta = 0, arguments.length === 1) {
          var a = arguments[0];
          o.constructor_.call(this, a, null);
        } else if (arguments.length === 2) {
          var l = arguments[0], d = arguments[1];
          this.pts = l, this._label = d;
        }
      } }, { key: "updateIM", value: function() {
        if (!(arguments.length === 2 && arguments[1] instanceof Dp && arguments[0] instanceof Re)) return I(h(o), "updateIM", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1];
        l.setAtLeastIfValid(a.getLocation(0, U.ON), a.getLocation(1, U.ON), 1), a.isArea() && (l.setAtLeastIfValid(a.getLocation(0, U.LEFT), a.getLocation(1, U.LEFT), 2), l.setAtLeastIfValid(a.getLocation(0, U.RIGHT), a.getLocation(1, U.RIGHT), 2));
      } }]), o;
    }(rh), kh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "setWorkingPrecisionModel", value: function(n) {
        this._workingPrecisionModel = n;
      } }, { key: "insertUniqueEdge", value: function(n) {
        var o = this._edgeList.findEqualEdge(n);
        if (o !== null) {
          var a = o.getLabel(), l = n.getLabel();
          o.isPointwiseEqual(n) || (l = new Re(n.getLabel())).flip(), a.merge(l);
          var d = c.depthDelta(l), v = o.getDepthDelta() + d;
          o.setDepthDelta(v);
        } else this._edgeList.add(n), n.setDepthDelta(c.depthDelta(n.getLabel()));
      } }, { key: "buildSubgraphs", value: function(n, o) {
        for (var a = new ot(), l = n.iterator(); l.hasNext(); ) {
          var d = l.next(), v = d.getRightmostCoordinate(), E = new vh(a).getDepth(v);
          d.computeDepth(E), d.findResultEdges(), a.add(d), o.add(d.getDirectedEdges(), d.getNodes());
        }
      } }, { key: "createSubgraphs", value: function(n) {
        for (var o = new ot(), a = n.getNodes().iterator(); a.hasNext(); ) {
          var l = a.next();
          if (!l.isVisited()) {
            var d = new Fs();
            d.create(l), o.add(d);
          }
        }
        return Xi.sort(o, Xi.reverseOrder()), o;
      } }, { key: "createEmptyResultGeometry", value: function() {
        return this._geomFact.createPolygon();
      } }, { key: "getNoder", value: function(n) {
        if (this._workingNoder !== null) return this._workingNoder;
        var o = new ba(), a = new fi();
        return a.setPrecisionModel(n), o.setSegmentIntersector(new Lp(a)), o;
      } }, { key: "buffer", value: function(n, o) {
        var a = this._workingPrecisionModel;
        a === null && (a = n.getPrecisionModel()), this._geomFact = n.getFactory();
        var l = new Ip(a, this._bufParams), d = new kp(n, o, l).getCurves();
        if (d.size() <= 0) return this.createEmptyResultGeometry();
        this.computeNodedEdges(d, a), this._graph = new hh(new Mp()), this._graph.addEdges(this._edgeList.getEdges());
        var v = this.createSubgraphs(this._graph), E = new hp(this._geomFact);
        this.buildSubgraphs(v, E);
        var S = E.getPolygons();
        return S.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(S);
      } }, { key: "computeNodedEdges", value: function(n, o) {
        var a = this.getNoder(o);
        a.computeNodes(n);
        for (var l = a.getNodedSubstrings().iterator(); l.hasNext(); ) {
          var d = l.next(), v = d.getCoordinates();
          if (v.length !== 2 || !v[0].equals2D(v[1])) {
            var E = d.getData(), S = new wh(d.getCoordinates(), new Re(E));
            this.insertUniqueEdge(S);
          }
        }
      } }, { key: "setNoder", value: function(n) {
        this._workingNoder = n;
      } }], [{ key: "constructor_", value: function() {
        this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Op();
        var n = arguments[0];
        this._bufParams = n;
      } }, { key: "depthDelta", value: function(n) {
        var o = n.getLocation(0, U.LEFT), a = n.getLocation(0, U.RIGHT);
        return o === T.INTERIOR && a === T.EXTERIOR ? 1 : o === T.EXTERIOR && a === T.INTERIOR ? -1 : 0;
      } }, { key: "convertSegStrings", value: function(n) {
        for (var o = new zi(), a = new ot(); n.hasNext(); ) {
          var l = n.next(), d = o.createLineString(l.getCoordinates());
          a.add(d);
        }
        return o.buildGeometry(a);
      } }]), c;
    }(), Yp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "rescale", value: function() {
        if (ht(arguments[0], Ie)) for (var n = arguments[0], o = n.iterator(); o.hasNext(); ) {
          var a = o.next();
          this.rescale(a.getCoordinates());
        }
        else if (arguments[0] instanceof Array) {
          for (var l = arguments[0], d = 0; d < l.length; d++) l[d].x = l[d].x / this._scaleFactor + this._offsetX, l[d].y = l[d].y / this._scaleFactor + this._offsetY;
          l.length === 2 && l[0].equals2D(l[1]) && re.out.println(l);
        }
      } }, { key: "scale", value: function() {
        if (ht(arguments[0], Ie)) {
          for (var n = arguments[0], o = new ot(n.size()), a = n.iterator(); a.hasNext(); ) {
            var l = a.next();
            o.add(new gi(this.scale(l.getCoordinates()), l.getData()));
          }
          return o;
        }
        if (arguments[0] instanceof Array) {
          for (var d = arguments[0], v = new Array(d.length).fill(null), E = 0; E < d.length; E++) v[E] = new P(Math.round((d[E].x - this._offsetX) * this._scaleFactor), Math.round((d[E].y - this._offsetY) * this._scaleFactor), d[E].getZ());
          var S = Yt.removeRepeatedPoints(v);
          return S;
        }
      } }, { key: "isIntegerPrecision", value: function() {
        return this._scaleFactor === 1;
      } }, { key: "getNodedSubstrings", value: function() {
        var n = this._noder.getNodedSubstrings();
        return this._isScaled && this.rescale(n), n;
      } }, { key: "computeNodes", value: function(n) {
        var o = n;
        this._isScaled && (o = this.scale(n)), this._noder.computeNodes(o);
      } }, { key: "interfaces_", get: function() {
        return [Ra];
      } }], [{ key: "constructor_", value: function() {
        if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) {
          var n = arguments[0], o = arguments[1];
          c.constructor_.call(this, n, o, 0, 0);
        } else if (arguments.length === 4) {
          var a = arguments[0], l = arguments[1];
          this._noder = a, this._scaleFactor = l, this._isScaled = !this.isIntegerPrecision();
        }
      } }]), c;
    }(), Ch = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "checkEndPtVertexIntersections", value: function() {
        if (arguments.length === 0) for (var n = this._segStrings.iterator(); n.hasNext(); ) {
          var o = n.next(), a = o.getCoordinates();
          this.checkEndPtVertexIntersections(a[0], this._segStrings), this.checkEndPtVertexIntersections(a[a.length - 1], this._segStrings);
        }
        else if (arguments.length === 2) {
          for (var l = arguments[0], d = arguments[1], v = d.iterator(); v.hasNext(); ) for (var E = v.next(), S = E.getCoordinates(), w = 1; w < S.length - 1; w++) if (S[w].equals(l)) throw new mt("found endpt/interior pt intersection at index " + w + " :pt " + l);
        }
      } }, { key: "checkInteriorIntersections", value: function() {
        if (arguments.length === 0) for (var n = this._segStrings.iterator(); n.hasNext(); ) for (var o = n.next(), a = this._segStrings.iterator(); a.hasNext(); ) {
          var l = a.next();
          this.checkInteriorIntersections(o, l);
        }
        else if (arguments.length === 2) for (var d = arguments[0], v = arguments[1], E = d.getCoordinates(), S = v.getCoordinates(), w = 0; w < E.length - 1; w++) for (var N = 0; N < S.length - 1; N++) this.checkInteriorIntersections(d, w, v, N);
        else if (arguments.length === 4) {
          var M = arguments[0], Y = arguments[1], W = arguments[2], q = arguments[3];
          if (M === W && Y === q) return null;
          var it = M.getCoordinates()[Y], at = M.getCoordinates()[Y + 1], ft = W.getCoordinates()[q], kt = W.getCoordinates()[q + 1];
          if (this._li.computeIntersection(it, at, ft, kt), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, it, at) || this.hasInteriorIntersection(this._li, ft, kt))) throw new mt("found non-noded intersection at " + it + "-" + at + " and " + ft + "-" + kt);
        }
      } }, { key: "checkValid", value: function() {
        this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
      } }, { key: "checkCollapses", value: function() {
        if (arguments.length === 0) for (var n = this._segStrings.iterator(); n.hasNext(); ) {
          var o = n.next();
          this.checkCollapses(o);
        }
        else if (arguments.length === 1) for (var a = arguments[0], l = a.getCoordinates(), d = 0; d < l.length - 2; d++) this.checkCollapse(l[d], l[d + 1], l[d + 2]);
      } }, { key: "hasInteriorIntersection", value: function(n, o, a) {
        for (var l = 0; l < n.getIntersectionNum(); l++) {
          var d = n.getIntersection(l);
          if (!d.equals(o) && !d.equals(a)) return !0;
        }
        return !1;
      } }, { key: "checkCollapse", value: function(n, o, a) {
        if (n.equals(a)) throw new mt("found non-noded collapse at " + c.fact.createLineString([n, o, a]));
      } }], [{ key: "constructor_", value: function() {
        this._li = new fi(), this._segStrings = null;
        var n = arguments[0];
        this._segStrings = n;
      } }]), c;
    }();
    Ch.fact = new zi();
    var Na = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "intersectsScaled", value: function(n, o) {
        var a = Math.min(n.x, o.x), l = Math.max(n.x, o.x), d = Math.min(n.y, o.y), v = Math.max(n.y, o.y), E = this._maxx < a || this._minx > l || this._maxy < d || this._miny > v;
        if (E) return !1;
        var S = this.intersectsToleranceSquare(n, o);
        return z.isTrue(!(E && S), "Found bad envelope test"), S;
      } }, { key: "initCorners", value: function(n) {
        var o = 0.5;
        this._minx = n.x - o, this._maxx = n.x + o, this._miny = n.y - o, this._maxy = n.y + o, this._corner[0] = new P(this._maxx, this._maxy), this._corner[1] = new P(this._minx, this._maxy), this._corner[2] = new P(this._minx, this._miny), this._corner[3] = new P(this._maxx, this._miny);
      } }, { key: "intersects", value: function(n, o) {
        return this._scaleFactor === 1 ? this.intersectsScaled(n, o) : (this.copyScaled(n, this._p0Scaled), this.copyScaled(o, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
      } }, { key: "scale", value: function(n) {
        return Math.round(n * this._scaleFactor);
      } }, { key: "getCoordinate", value: function() {
        return this._originalPt;
      } }, { key: "copyScaled", value: function(n, o) {
        o.x = this.scale(n.x), o.y = this.scale(n.y);
      } }, { key: "getSafeEnvelope", value: function() {
        if (this._safeEnv === null) {
          var n = c.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
          this._safeEnv = new bt(this._originalPt.x - n, this._originalPt.x + n, this._originalPt.y - n, this._originalPt.y + n);
        }
        return this._safeEnv;
      } }, { key: "intersectsPixelClosure", value: function(n, o) {
        return this._li.computeIntersection(n, o, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(n, o, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(n, o, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(n, o, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
      } }, { key: "intersectsToleranceSquare", value: function(n, o) {
        var a = !1, l = !1;
        return this._li.computeIntersection(n, o, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(n, o, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (a = !0), this._li.computeIntersection(n, o, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (l = !0), this._li.computeIntersection(n, o, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!a || !l) || !!n.equals(this._pt) || !!o.equals(this._pt))));
      } }, { key: "addSnappedNode", value: function(n, o) {
        var a = n.getCoordinate(o), l = n.getCoordinate(o + 1);
        return !!this.intersects(a, l) && (n.addIntersection(this.getCoordinate(), o), !0);
      } }], [{ key: "constructor_", value: function() {
        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
        var n = arguments[0], o = arguments[1], a = arguments[2];
        if (this._originalPt = n, this._pt = n, this._scaleFactor = o, this._li = a, o <= 0) throw new L("Scale factor must be non-zero");
        o !== 1 && (this._pt = new P(this.scale(n.x), this.scale(n.y)), this._p0Scaled = new P(), this._p1Scaled = new P()), this.initCorners(this._pt);
      } }]), c;
    }();
    Na.SAFE_ENV_EXPANSION_FACTOR = 0.75;
    var zp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "select", value: function() {
        if (arguments.length !== 1) {
          if (arguments.length === 2) {
            var n = arguments[0], o = arguments[1];
            n.getLineSegment(o, this.selectedSegment), this.select(this.selectedSegment);
          }
        }
      } }], [{ key: "constructor_", value: function() {
        this.selectedSegment = new me();
      } }]), c;
    }(), Rh = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "snap", value: function() {
        if (arguments.length === 1) {
          var n = arguments[0];
          return this.snap(n, null, -1);
        }
        if (arguments.length === 3) {
          var o = arguments[0], a = arguments[1], l = arguments[2], d = o.getSafeEnvelope(), v = new bh(o, a, l);
          return this._index.query(d, new (function() {
            function E() {
              e(this, E);
            }
            return s(E, [{ key: "interfaces_", get: function() {
              return [fh];
            } }, { key: "visitItem", value: function(S) {
              S.select(d, v);
            } }]), E;
          }())()), v.isNodeAdded();
        }
      } }], [{ key: "constructor_", value: function() {
        this._index = null;
        var n = arguments[0];
        this._index = n;
      } }]), c;
    }(), bh = function(c) {
      u(o, c);
      var n = x(o);
      function o() {
        var a;
        return e(this, o), a = n.call(this), o.constructor_.apply(m(a), arguments), a;
      }
      return s(o, [{ key: "isNodeAdded", value: function() {
        return this._isNodeAdded;
      } }, { key: "select", value: function() {
        if (!(arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof dh)) return I(h(o.prototype), "select", this).apply(this, arguments);
        var a = arguments[0], l = arguments[1], d = a.getContext();
        if (this._parentEdge === d && (l === this._hotPixelVertexIndex || l + 1 === this._hotPixelVertexIndex)) return null;
        this._isNodeAdded |= this._hotPixel.addSnappedNode(d, l);
      } }], [{ key: "constructor_", value: function() {
        this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
        var a = arguments[0], l = arguments[1], d = arguments[2];
        this._hotPixel = a, this._parentEdge = l, this._hotPixelVertexIndex = d;
      } }]), o;
    }(zp);
    Rh.HotPixelSnapAction = bh;
    var $p = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "processIntersections", value: function(n, o, a, l) {
        if (n === a && o === l) return null;
        var d = n.getCoordinates()[o], v = n.getCoordinates()[o + 1], E = a.getCoordinates()[l], S = a.getCoordinates()[l + 1];
        if (this._li.computeIntersection(d, v, E, S), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
          for (var w = 0; w < this._li.getIntersectionNum(); w++) this._interiorIntersections.add(this._li.getIntersection(w));
          n.addIntersections(this._li, o, 0), a.addIntersections(this._li, l, 1);
        }
      } }, { key: "isDone", value: function() {
        return !1;
      } }, { key: "getInteriorIntersections", value: function() {
        return this._interiorIntersections;
      } }, { key: "interfaces_", get: function() {
        return [Sh];
      } }], [{ key: "constructor_", value: function() {
        this._li = null, this._interiorIntersections = null;
        var n = arguments[0];
        this._li = n, this._interiorIntersections = new ot();
      } }]), c;
    }(), Xp = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "checkCorrectness", value: function(n) {
        var o = gi.getNodedSubstrings(n), a = new Ch(o);
        try {
          a.checkValid();
        } catch (l) {
          if (!(l instanceof A)) throw l;
          l.printStackTrace();
        }
      } }, { key: "getNodedSubstrings", value: function() {
        return gi.getNodedSubstrings(this._nodedSegStrings);
      } }, { key: "snapRound", value: function(n, o) {
        var a = this.findInteriorIntersections(n, o);
        this.computeIntersectionSnaps(a), this.computeVertexSnaps(n);
      } }, { key: "findInteriorIntersections", value: function(n, o) {
        var a = new $p(o);
        return this._noder.setSegmentIntersector(a), this._noder.computeNodes(n), a.getInteriorIntersections();
      } }, { key: "computeVertexSnaps", value: function() {
        if (ht(arguments[0], Ie)) for (var n = arguments[0], o = n.iterator(); o.hasNext(); ) {
          var a = o.next();
          this.computeVertexSnaps(a);
        }
        else if (arguments[0] instanceof gi) for (var l = arguments[0], d = l.getCoordinates(), v = 0; v < d.length; v++) {
          var E = new Na(d[v], this._scaleFactor, this._li), S = this._pointSnapper.snap(E, l, v);
          S && l.addIntersection(d[v], v);
        }
      } }, { key: "computeNodes", value: function(n) {
        this._nodedSegStrings = n, this._noder = new ba(), this._pointSnapper = new Rh(this._noder.getIndex()), this.snapRound(n, this._li);
      } }, { key: "computeIntersectionSnaps", value: function(n) {
        for (var o = n.iterator(); o.hasNext(); ) {
          var a = o.next(), l = new Na(a, this._scaleFactor, this._li);
          this._pointSnapper.snap(l);
        }
      } }, { key: "interfaces_", get: function() {
        return [Ra];
      } }], [{ key: "constructor_", value: function() {
        this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
        var n = arguments[0];
        this._pm = n, this._li = new fi(), this._li.setPrecisionModel(n), this._scaleFactor = n.getScale();
      } }]), c;
    }(), Ui = function() {
      function c() {
        e(this, c), c.constructor_.apply(this, arguments);
      }
      return s(c, [{ key: "bufferFixedPrecision", value: function(n) {
        var o = new Yp(new Xp(new Be(1)), n.getScale()), a = new kh(this._bufParams);
        a.setWorkingPrecisionModel(n), a.setNoder(o), this._resultGeometry = a.buffer(this._argGeom, this._distance);
      } }, { key: "bufferReducedPrecision", value: function() {
        if (arguments.length === 0) {
          for (var n = c.MAX_PRECISION_DIGITS; n >= 0; n--) {
            try {
              this.bufferReducedPrecision(n);
            } catch (d) {
              if (!(d instanceof de)) throw d;
              this._saveException = d;
            }
            if (this._resultGeometry !== null) return null;
          }
          throw this._saveException;
        }
        if (arguments.length === 1) {
          var o = arguments[0], a = c.precisionScaleFactor(this._argGeom, this._distance, o), l = new Be(a);
          this.bufferFixedPrecision(l);
        }
      } }, { key: "computeGeometry", value: function() {
        if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null;
        var n = this._argGeom.getFactory().getPrecisionModel();
        n.getType() === Be.FIXED ? this.bufferFixedPrecision(n) : this.bufferReducedPrecision();
      } }, { key: "setQuadrantSegments", value: function(n) {
        this._bufParams.setQuadrantSegments(n);
      } }, { key: "bufferOriginalPrecision", value: function() {
        try {
          var n = new kh(this._bufParams);
          this._resultGeometry = n.buffer(this._argGeom, this._distance);
        } catch (o) {
          if (!(o instanceof mt)) throw o;
          this._saveException = o;
        }
      } }, { key: "getResultGeometry", value: function(n) {
        return this._distance = n, this.computeGeometry(), this._resultGeometry;
      } }, { key: "setEndCapStyle", value: function(n) {
        this._bufParams.setEndCapStyle(n);
      } }], [{ key: "constructor_", value: function() {
        if (this._argGeom = null, this._distance = null, this._bufParams = new O(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
          var n = arguments[0];
          this._argGeom = n;
        } else if (arguments.length === 2) {
          var o = arguments[0], a = arguments[1];
          this._argGeom = o, this._bufParams = a;
        }
      } }, { key: "bufferOp", value: function() {
        if (arguments.length === 2) {
          var n = arguments[0], o = arguments[1], a = new c(n), l = a.getResultGeometry(o);
          return l;
        }
        if (arguments.length === 3) {
          if (Number.isInteger(arguments[2]) && arguments[0] instanceof et && typeof arguments[1] == "number") {
            var d = arguments[0], v = arguments[1], E = arguments[2], S = new c(d);
            S.setQuadrantSegments(E);
            var w = S.getResultGeometry(v);
            return w;
          }
          if (arguments[2] instanceof O && arguments[0] instanceof et && typeof arguments[1] == "number") {
            var N = arguments[0], M = arguments[1], Y = arguments[2], W = new c(N, Y), q = W.getResultGeometry(M);
            return q;
          }
        } else if (arguments.length === 4) {
          var it = arguments[0], at = arguments[1], ft = arguments[2], kt = arguments[3], Pt = new c(it);
          Pt.setQuadrantSegments(ft), Pt.setEndCapStyle(kt);
          var Jt = Pt.getResultGeometry(at);
          return Jt;
        }
      } }, { key: "precisionScaleFactor", value: function(n, o, a) {
        var l = n.getEnvelopeInternal(), d = cn.max(Math.abs(l.getMaxX()), Math.abs(l.getMaxY()), Math.abs(l.getMinX()), Math.abs(l.getMinY())) + 2 * (o > 0 ? o : 0), v = a - Math.trunc(Math.log(d) / Math.log(10) + 1);
        return Math.pow(10, v);
      } }]), c;
    }();
    Ui.CAP_ROUND = O.CAP_ROUND, Ui.CAP_BUTT = O.CAP_FLAT, Ui.CAP_FLAT = O.CAP_FLAT, Ui.CAP_SQUARE = O.CAP_SQUARE, Ui.MAX_PRECISION_DIGITS = 12;
    var qp = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Th = function() {
      function c(n) {
        e(this, c), this.geometryFactory = n || new zi();
      }
      return s(c, [{ key: "read", value: function(n) {
        var o, a = (o = typeof n == "string" ? JSON.parse(n) : n).type;
        if (!Te[a]) throw new Error("Unknown GeoJSON type: " + o.type);
        return qp.indexOf(a) !== -1 ? Te[a].call(this, o.coordinates) : a === "GeometryCollection" ? Te[a].call(this, o.geometries) : Te[a].call(this, o);
      } }, { key: "write", value: function(n) {
        var o = n.getGeometryType();
        if (!Qe[o]) throw new Error("Geometry is not supported");
        return Qe[o].call(this, n);
      } }]), c;
    }(), Te = { Feature: function(c) {
      var n = {};
      for (var o in c) n[o] = c[o];
      if (c.geometry) {
        var a = c.geometry.type;
        if (!Te[a]) throw new Error("Unknown GeoJSON type: " + c.type);
        n.geometry = this.read(c.geometry);
      }
      return c.bbox && (n.bbox = Te.bbox.call(this, c.bbox)), n;
    }, FeatureCollection: function(c) {
      var n = {};
      if (c.features) {
        n.features = [];
        for (var o = 0; o < c.features.length; ++o) n.features.push(this.read(c.features[o]));
      }
      return c.bbox && (n.bbox = this.parse.bbox.call(this, c.bbox)), n;
    }, coordinates: function(c) {
      for (var n = [], o = 0; o < c.length; ++o) {
        var a = c[o];
        n.push(y(P, k(a)));
      }
      return n;
    }, bbox: function(c) {
      return this.geometryFactory.createLinearRing([new P(c[0], c[1]), new P(c[2], c[1]), new P(c[2], c[3]), new P(c[0], c[3]), new P(c[0], c[1])]);
    }, Point: function(c) {
      var n = y(P, k(c));
      return this.geometryFactory.createPoint(n);
    }, MultiPoint: function(c) {
      for (var n = [], o = 0; o < c.length; ++o) n.push(Te.Point.call(this, c[o]));
      return this.geometryFactory.createMultiPoint(n);
    }, LineString: function(c) {
      var n = Te.coordinates.call(this, c);
      return this.geometryFactory.createLineString(n);
    }, MultiLineString: function(c) {
      for (var n = [], o = 0; o < c.length; ++o) n.push(Te.LineString.call(this, c[o]));
      return this.geometryFactory.createMultiLineString(n);
    }, Polygon: function(c) {
      for (var n = Te.coordinates.call(this, c[0]), o = this.geometryFactory.createLinearRing(n), a = [], l = 1; l < c.length; ++l) {
        var d = c[l], v = Te.coordinates.call(this, d), E = this.geometryFactory.createLinearRing(v);
        a.push(E);
      }
      return this.geometryFactory.createPolygon(o, a);
    }, MultiPolygon: function(c) {
      for (var n = [], o = 0; o < c.length; ++o) {
        var a = c[o];
        n.push(Te.Polygon.call(this, a));
      }
      return this.geometryFactory.createMultiPolygon(n);
    }, GeometryCollection: function(c) {
      for (var n = [], o = 0; o < c.length; ++o) {
        var a = c[o];
        n.push(this.read(a));
      }
      return this.geometryFactory.createGeometryCollection(n);
    } }, Qe = { coordinate: function(c) {
      var n = [c.x, c.y];
      return c.z && n.push(c.z), c.m && n.push(c.m), n;
    }, Point: function(c) {
      return { type: "Point", coordinates: Qe.coordinate.call(this, c.getCoordinate()) };
    }, MultiPoint: function(c) {
      for (var n = [], o = 0; o < c._geometries.length; ++o) {
        var a = c._geometries[o], l = Qe.Point.call(this, a);
        n.push(l.coordinates);
      }
      return { type: "MultiPoint", coordinates: n };
    }, LineString: function(c) {
      for (var n = [], o = c.getCoordinates(), a = 0; a < o.length; ++a) {
        var l = o[a];
        n.push(Qe.coordinate.call(this, l));
      }
      return { type: "LineString", coordinates: n };
    }, MultiLineString: function(c) {
      for (var n = [], o = 0; o < c._geometries.length; ++o) {
        var a = c._geometries[o], l = Qe.LineString.call(this, a);
        n.push(l.coordinates);
      }
      return { type: "MultiLineString", coordinates: n };
    }, Polygon: function(c) {
      var n = [], o = Qe.LineString.call(this, c._shell);
      n.push(o.coordinates);
      for (var a = 0; a < c._holes.length; ++a) {
        var l = c._holes[a], d = Qe.LineString.call(this, l);
        n.push(d.coordinates);
      }
      return { type: "Polygon", coordinates: n };
    }, MultiPolygon: function(c) {
      for (var n = [], o = 0; o < c._geometries.length; ++o) {
        var a = c._geometries[o], l = Qe.Polygon.call(this, a);
        n.push(l.coordinates);
      }
      return { type: "MultiPolygon", coordinates: n };
    }, GeometryCollection: function(c) {
      for (var n = [], o = 0; o < c._geometries.length; ++o) {
        var a = c._geometries[o], l = a.getGeometryType();
        n.push(Qe[l].call(this, a));
      }
      return { type: "GeometryCollection", geometries: n };
    } };
    return { BufferOp: Ui, GeoJSONReader: function() {
      function c(n) {
        e(this, c), this.parser = new Th(n || new zi());
      }
      return s(c, [{ key: "read", value: function(n) {
        return this.parser.read(n);
      } }]), c;
    }(), GeoJSONWriter: function() {
      function c() {
        e(this, c), this.parser = new Th(this.geometryFactory);
      }
      return s(c, [{ key: "write", value: function(n) {
        return this.parser.write(n);
      } }]), c;
    }() };
  });
})(Ty);
var jI = Ty.exports;
const VI = /* @__PURE__ */ xd(jI);
function oi() {
  return new qo();
}
function qo() {
  this.reset();
}
qo.prototype = {
  constructor: qo,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(i) {
    Wf(eo, i, this.t), Wf(this, eo.s, this.s), this.s ? this.t += eo.t : this.s = eo.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var eo = new qo();
function Wf(i, t, e) {
  var r = i.s = t + e, s = r - t, u = r - s;
  i.t = t - u + (e - s);
}
var Nt = 1e-6, St = Math.PI, sn = St / 2, Uf = St / 4, un = St * 2, zn = 180 / St, Me = St / 180, Wt = Math.abs, ZI = Math.atan, mr = Math.atan2, Dt = Math.cos, Ft = Math.sin, br = Math.sqrt;
function Ny(i) {
  return i > 1 ? 0 : i < -1 ? St : Math.acos(i);
}
function Mi(i) {
  return i > 1 ? sn : i < -1 ? -sn : Math.asin(i);
}
function ts() {
}
function Wo(i, t) {
  i && Vf.hasOwnProperty(i.type) && Vf[i.type](i, t);
}
var jf = {
  Feature: function(i, t) {
    Wo(i.geometry, t);
  },
  FeatureCollection: function(i, t) {
    for (var e = i.features, r = -1, s = e.length; ++r < s; ) Wo(e[r].geometry, t);
  }
}, Vf = {
  Sphere: function(i, t) {
    t.sphere();
  },
  Point: function(i, t) {
    i = i.coordinates, t.point(i[0], i[1], i[2]);
  },
  MultiPoint: function(i, t) {
    for (var e = i.coordinates, r = -1, s = e.length; ++r < s; ) i = e[r], t.point(i[0], i[1], i[2]);
  },
  LineString: function(i, t) {
    Vu(i.coordinates, t, 0);
  },
  MultiLineString: function(i, t) {
    for (var e = i.coordinates, r = -1, s = e.length; ++r < s; ) Vu(e[r], t, 0);
  },
  Polygon: function(i, t) {
    Zf(i.coordinates, t);
  },
  MultiPolygon: function(i, t) {
    for (var e = i.coordinates, r = -1, s = e.length; ++r < s; ) Zf(e[r], t);
  },
  GeometryCollection: function(i, t) {
    for (var e = i.geometries, r = -1, s = e.length; ++r < s; ) Wo(e[r], t);
  }
};
function Vu(i, t, e) {
  var r = -1, s = i.length - e, u;
  for (t.lineStart(); ++r < s; ) u = i[r], t.point(u[0], u[1], u[2]);
  t.lineEnd();
}
function Zf(i, t) {
  var e = -1, r = i.length;
  for (t.polygonStart(); ++e < r; ) Vu(i[e], t, 1);
  t.polygonEnd();
}
function HI(i, t) {
  i && jf.hasOwnProperty(i.type) ? jf[i.type](i, t) : Wo(i, t);
}
oi();
oi();
function Zu(i) {
  return [mr(i[1], i[0]), Mi(i[2])];
}
function vr(i) {
  var t = i[0], e = i[1], r = Dt(e);
  return [r * Dt(t), r * Ft(t), Ft(e)];
}
function no(i, t) {
  return i[0] * t[0] + i[1] * t[1] + i[2] * t[2];
}
function Uo(i, t) {
  return [i[1] * t[2] - i[2] * t[1], i[2] * t[0] - i[0] * t[2], i[0] * t[1] - i[1] * t[0]];
}
function hu(i, t) {
  i[0] += t[0], i[1] += t[1], i[2] += t[2];
}
function io(i, t) {
  return [i[0] * t, i[1] * t, i[2] * t];
}
function Hu(i) {
  var t = br(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]);
  i[0] /= t, i[1] /= t, i[2] /= t;
}
oi();
function My(i, t) {
  function e(r, s) {
    return r = i(r, s), t(r[0], r[1]);
  }
  return i.invert && t.invert && (e.invert = function(r, s) {
    return r = t.invert(r, s), r && i.invert(r[0], r[1]);
  }), e;
}
function Ju(i, t) {
  return [i > St ? i - un : i < -St ? i + un : i, t];
}
Ju.invert = Ju;
function JI(i, t, e) {
  return (i %= un) ? t || e ? My(Jf(i), Kf(t, e)) : Jf(i) : t || e ? Kf(t, e) : Ju;
}
function Hf(i) {
  return function(t, e) {
    return t += i, [t > St ? t - un : t < -St ? t + un : t, e];
  };
}
function Jf(i) {
  var t = Hf(i);
  return t.invert = Hf(-i), t;
}
function Kf(i, t) {
  var e = Dt(i), r = Ft(i), s = Dt(t), u = Ft(t);
  function h(f, g) {
    var y = Dt(g), p = Dt(f) * y, m = Ft(f) * y, _ = Ft(g), x = _ * e + p * r;
    return [
      mr(m * s - x * u, p * e - _ * r),
      Mi(x * s + m * u)
    ];
  }
  return h.invert = function(f, g) {
    var y = Dt(g), p = Dt(f) * y, m = Ft(f) * y, _ = Ft(g), x = _ * s - m * u;
    return [
      mr(m * s + _ * u, p * e + x * r),
      Mi(x * e - p * r)
    ];
  }, h;
}
function KI(i, t, e, r, s, u) {
  if (e) {
    var h = Dt(t), f = Ft(t), g = r * e;
    s == null ? (s = t + r * un, u = t - g / 2) : (s = Qf(h, s), u = Qf(h, u), (r > 0 ? s < u : s > u) && (s += r * un));
    for (var y, p = s; r > 0 ? p > u : p < u; p -= g)
      y = Zu([h, -f * Dt(p), -f * Ft(p)]), i.point(y[0], y[1]);
  }
}
function Qf(i, t) {
  t = vr(t), t[0] -= i, Hu(t);
  var e = Ny(-t[1]);
  return ((-t[2] < 0 ? -e : e) + un - Nt) % un;
}
function Oy() {
  var i = [], t;
  return {
    point: function(e, r) {
      t.push([e, r]);
    },
    lineStart: function() {
      i.push(t = []);
    },
    lineEnd: ts,
    rejoin: function() {
      i.length > 1 && i.push(i.pop().concat(i.shift()));
    },
    result: function() {
      var e = i;
      return i = [], t = null, e;
    }
  };
}
function QI(i, t, e, r, s, u) {
  var h = i[0], f = i[1], g = t[0], y = t[1], p = 0, m = 1, _ = g - h, x = y - f, I;
  if (I = e - h, !(!_ && I > 0)) {
    if (I /= _, _ < 0) {
      if (I < p) return;
      I < m && (m = I);
    } else if (_ > 0) {
      if (I > m) return;
      I > p && (p = I);
    }
    if (I = s - h, !(!_ && I < 0)) {
      if (I /= _, _ < 0) {
        if (I > m) return;
        I > p && (p = I);
      } else if (_ > 0) {
        if (I < p) return;
        I < m && (m = I);
      }
      if (I = r - f, !(!x && I > 0)) {
        if (I /= x, x < 0) {
          if (I < p) return;
          I < m && (m = I);
        } else if (x > 0) {
          if (I > m) return;
          I > p && (p = I);
        }
        if (I = u - f, !(!x && I < 0)) {
          if (I /= x, x < 0) {
            if (I > m) return;
            I > p && (p = I);
          } else if (x > 0) {
            if (I < p) return;
            I < m && (m = I);
          }
          return p > 0 && (i[0] = h + p * _, i[1] = f + p * x), m < 1 && (t[0] = h + m * _, t[1] = f + m * x), !0;
        }
      }
    }
  }
}
function po(i, t) {
  return Wt(i[0] - t[0]) < Nt && Wt(i[1] - t[1]) < Nt;
}
function ro(i, t, e, r) {
  this.x = i, this.z = t, this.o = e, this.e = r, this.v = !1, this.n = this.p = null;
}
function Ly(i, t, e, r, s) {
  var u = [], h = [], f, g;
  if (i.forEach(function(I) {
    if (!((k = I.length - 1) <= 0)) {
      var k, C = I[0], R = I[k], b;
      if (po(C, R)) {
        for (s.lineStart(), f = 0; f < k; ++f) s.point((C = I[f])[0], C[1]);
        s.lineEnd();
        return;
      }
      u.push(b = new ro(C, I, null, !0)), h.push(b.o = new ro(C, null, b, !1)), u.push(b = new ro(R, I, null, !1)), h.push(b.o = new ro(R, null, b, !0));
    }
  }), !!u.length) {
    for (h.sort(t), tg(u), tg(h), f = 0, g = h.length; f < g; ++f)
      h[f].e = e = !e;
    for (var y = u[0], p, m; ; ) {
      for (var _ = y, x = !0; _.v; ) if ((_ = _.n) === y) return;
      p = _.z, s.lineStart();
      do {
        if (_.v = _.o.v = !0, _.e) {
          if (x)
            for (f = 0, g = p.length; f < g; ++f) s.point((m = p[f])[0], m[1]);
          else
            r(_.x, _.n.x, 1, s);
          _ = _.n;
        } else {
          if (x)
            for (p = _.p.z, f = p.length - 1; f >= 0; --f) s.point((m = p[f])[0], m[1]);
          else
            r(_.x, _.p.x, -1, s);
          _ = _.p;
        }
        _ = _.o, p = _.z, x = !x;
      } while (!_.v);
      s.lineEnd();
    }
  }
}
function tg(i) {
  if (t = i.length) {
    for (var t, e = 0, r = i[0], s; ++e < t; )
      r.n = s = i[e], s.p = r, r = s;
    r.n = s = i[0], s.p = r;
  }
}
function Ay(i, t) {
  return i < t ? -1 : i > t ? 1 : i >= t ? 0 : NaN;
}
function tw(i) {
  return i.length === 1 && (i = ew(i)), {
    left: function(t, e, r, s) {
      for (r == null && (r = 0), s == null && (s = t.length); r < s; ) {
        var u = r + s >>> 1;
        i(t[u], e) < 0 ? r = u + 1 : s = u;
      }
      return r;
    },
    right: function(t, e, r, s) {
      for (r == null && (r = 0), s == null && (s = t.length); r < s; ) {
        var u = r + s >>> 1;
        i(t[u], e) > 0 ? s = u : r = u + 1;
      }
      return r;
    }
  };
}
function ew(i) {
  return function(t, e) {
    return Ay(i(t), e);
  };
}
tw(Ay);
function Py(i) {
  for (var t = i.length, e, r = -1, s = 0, u, h; ++r < t; ) s += i[r].length;
  for (u = new Array(s); --t >= 0; )
    for (h = i[t], e = h.length; --e >= 0; )
      u[--s] = h[e];
  return u;
}
var es = 1e9, so = -es;
function nw(i, t, e, r) {
  function s(y, p) {
    return i <= y && y <= e && t <= p && p <= r;
  }
  function u(y, p, m, _) {
    var x = 0, I = 0;
    if (y == null || (x = h(y, m)) !== (I = h(p, m)) || g(y, p) < 0 ^ m > 0)
      do
        _.point(x === 0 || x === 3 ? i : e, x > 1 ? r : t);
      while ((x = (x + m + 4) % 4) !== I);
    else
      _.point(p[0], p[1]);
  }
  function h(y, p) {
    return Wt(y[0] - i) < Nt ? p > 0 ? 0 : 3 : Wt(y[0] - e) < Nt ? p > 0 ? 2 : 1 : Wt(y[1] - t) < Nt ? p > 0 ? 1 : 0 : p > 0 ? 3 : 2;
  }
  function f(y, p) {
    return g(y.x, p.x);
  }
  function g(y, p) {
    var m = h(y, 1), _ = h(p, 1);
    return m !== _ ? m - _ : m === 0 ? p[1] - y[1] : m === 1 ? y[0] - p[0] : m === 2 ? y[1] - p[1] : p[0] - y[0];
  }
  return function(y) {
    var p = y, m = Oy(), _, x, I, k, C, R, b, O, A, L, D, F = {
      point: G,
      lineStart: H,
      lineEnd: Q,
      polygonStart: tt,
      polygonEnd: J
    };
    function G(K, V) {
      s(K, V) && p.point(K, V);
    }
    function B() {
      for (var K = 0, V = 0, lt = x.length; V < lt; ++V)
        for (var ct = x[V], Et = 1, Z = ct.length, pt = ct[0], mt, Lt, z = pt[0], ge = pt[1]; Et < Z; ++Et)
          mt = z, Lt = ge, pt = ct[Et], z = pt[0], ge = pt[1], Lt <= r ? ge > r && (z - mt) * (r - Lt) > (ge - Lt) * (i - mt) && ++K : ge <= r && (z - mt) * (r - Lt) < (ge - Lt) * (i - mt) && --K;
      return K;
    }
    function tt() {
      p = m, _ = [], x = [], D = !0;
    }
    function J() {
      var K = B(), V = D && K, lt = (_ = Py(_)).length;
      (V || lt) && (y.polygonStart(), V && (y.lineStart(), u(null, null, 1, y), y.lineEnd()), lt && Ly(_, f, K, u, y), y.polygonEnd()), p = y, _ = x = I = null;
    }
    function H() {
      F.point = X, x && x.push(I = []), L = !0, A = !1, b = O = NaN;
    }
    function Q() {
      _ && (X(k, C), R && A && m.rejoin(), _.push(m.result())), F.point = G, A && p.lineEnd();
    }
    function X(K, V) {
      var lt = s(K, V);
      if (x && I.push([K, V]), L)
        k = K, C = V, R = lt, L = !1, lt && (p.lineStart(), p.point(K, V));
      else if (lt && A) p.point(K, V);
      else {
        var ct = [b = Math.max(so, Math.min(es, b)), O = Math.max(so, Math.min(es, O))], Et = [K = Math.max(so, Math.min(es, K)), V = Math.max(so, Math.min(es, V))];
        QI(ct, Et, i, t, e, r) ? (A || (p.lineStart(), p.point(ct[0], ct[1])), p.point(Et[0], Et[1]), lt || p.lineEnd(), D = !1) : lt && (p.lineStart(), p.point(K, V), D = !1);
      }
      b = K, O = V, A = lt;
    }
    return F;
  };
}
var cu = oi();
function iw(i, t) {
  var e = t[0], r = t[1], s = [Ft(e), -Dt(e), 0], u = 0, h = 0;
  cu.reset();
  for (var f = 0, g = i.length; f < g; ++f)
    if (p = (y = i[f]).length)
      for (var y, p, m = y[p - 1], _ = m[0], x = m[1] / 2 + Uf, I = Ft(x), k = Dt(x), C = 0; C < p; ++C, _ = b, I = A, k = L, m = R) {
        var R = y[C], b = R[0], O = R[1] / 2 + Uf, A = Ft(O), L = Dt(O), D = b - _, F = D >= 0 ? 1 : -1, G = F * D, B = G > St, tt = I * A;
        if (cu.add(mr(tt * F * Ft(G), k * L + tt * Dt(G))), u += B ? D + F * un : D, B ^ _ >= e ^ b >= e) {
          var J = Uo(vr(m), vr(R));
          Hu(J);
          var H = Uo(s, J);
          Hu(H);
          var Q = (B ^ D >= 0 ? -1 : 1) * Mi(H[2]);
          (r > Q || r === Q && (J[0] || J[1])) && (h += B ^ D >= 0 ? 1 : -1);
        }
      }
  return (u < -Nt || u < Nt && cu < -Nt) ^ h & 1;
}
oi();
function eg(i) {
  return i;
}
oi();
oi();
var _r = 1 / 0, jo = _r, Is = -_r, Vo = Is, ng = {
  point: rw,
  lineStart: ts,
  lineEnd: ts,
  polygonStart: ts,
  polygonEnd: ts,
  result: function() {
    var i = [[_r, jo], [Is, Vo]];
    return Is = Vo = -(jo = _r = 1 / 0), i;
  }
};
function rw(i, t) {
  i < _r && (_r = i), i > Is && (Is = i), t < jo && (jo = t), t > Vo && (Vo = t);
}
oi();
function Dy(i, t, e, r) {
  return function(s, u) {
    var h = t(u), f = s.invert(r[0], r[1]), g = Oy(), y = t(g), p = !1, m, _, x, I = {
      point: k,
      lineStart: R,
      lineEnd: b,
      polygonStart: function() {
        I.point = O, I.lineStart = A, I.lineEnd = L, _ = [], m = [];
      },
      polygonEnd: function() {
        I.point = k, I.lineStart = R, I.lineEnd = b, _ = Py(_);
        var D = iw(m, f);
        _.length ? (p || (u.polygonStart(), p = !0), Ly(_, ow, D, e, u)) : D && (p || (u.polygonStart(), p = !0), u.lineStart(), e(null, null, 1, u), u.lineEnd()), p && (u.polygonEnd(), p = !1), _ = m = null;
      },
      sphere: function() {
        u.polygonStart(), u.lineStart(), e(null, null, 1, u), u.lineEnd(), u.polygonEnd();
      }
    };
    function k(D, F) {
      var G = s(D, F);
      i(D = G[0], F = G[1]) && u.point(D, F);
    }
    function C(D, F) {
      var G = s(D, F);
      h.point(G[0], G[1]);
    }
    function R() {
      I.point = C, h.lineStart();
    }
    function b() {
      I.point = k, h.lineEnd();
    }
    function O(D, F) {
      x.push([D, F]);
      var G = s(D, F);
      y.point(G[0], G[1]);
    }
    function A() {
      y.lineStart(), x = [];
    }
    function L() {
      O(x[0][0], x[0][1]), y.lineEnd();
      var D = y.clean(), F = g.result(), G, B = F.length, tt, J, H;
      if (x.pop(), m.push(x), x = null, !!B) {
        if (D & 1) {
          if (J = F[0], (tt = J.length - 1) > 0) {
            for (p || (u.polygonStart(), p = !0), u.lineStart(), G = 0; G < tt; ++G) u.point((H = J[G])[0], H[1]);
            u.lineEnd();
          }
          return;
        }
        B > 1 && D & 2 && F.push(F.pop().concat(F.shift())), _.push(F.filter(sw));
      }
    }
    return I;
  };
}
function sw(i) {
  return i.length > 1;
}
function ow(i, t) {
  return ((i = i.x)[0] < 0 ? i[1] - sn - Nt : sn - i[1]) - ((t = t.x)[0] < 0 ? t[1] - sn - Nt : sn - t[1]);
}
const ig = Dy(
  function() {
    return !0;
  },
  aw,
  lw,
  [-St, -sn]
);
function aw(i) {
  var t = NaN, e = NaN, r = NaN, s;
  return {
    lineStart: function() {
      i.lineStart(), s = 1;
    },
    point: function(u, h) {
      var f = u > 0 ? St : -St, g = Wt(u - t);
      Wt(g - St) < Nt ? (i.point(t, e = (e + h) / 2 > 0 ? sn : -sn), i.point(r, e), i.lineEnd(), i.lineStart(), i.point(f, e), i.point(u, e), s = 0) : r !== f && g >= St && (Wt(t - r) < Nt && (t -= r * Nt), Wt(u - f) < Nt && (u -= f * Nt), e = uw(t, e, u, h), i.point(r, e), i.lineEnd(), i.lineStart(), i.point(f, e), s = 0), i.point(t = u, e = h), r = f;
    },
    lineEnd: function() {
      i.lineEnd(), t = e = NaN;
    },
    clean: function() {
      return 2 - s;
    }
  };
}
function uw(i, t, e, r) {
  var s, u, h = Ft(i - e);
  return Wt(h) > Nt ? ZI((Ft(t) * (u = Dt(r)) * Ft(e) - Ft(r) * (s = Dt(t)) * Ft(i)) / (s * u * h)) : (t + r) / 2;
}
function lw(i, t, e, r) {
  var s;
  if (i == null)
    s = e * sn, r.point(-St, s), r.point(0, s), r.point(St, s), r.point(St, 0), r.point(St, -s), r.point(0, -s), r.point(-St, -s), r.point(-St, 0), r.point(-St, s);
  else if (Wt(i[0] - t[0]) > Nt) {
    var u = i[0] < t[0] ? St : -St;
    s = e * u / 2, r.point(-u, s), r.point(0, s), r.point(u, s);
  } else
    r.point(t[0], t[1]);
}
function hw(i, t) {
  var e = Dt(i), r = e > 0, s = Wt(e) > Nt;
  function u(p, m, _, x) {
    KI(x, i, t, _, p, m);
  }
  function h(p, m) {
    return Dt(p) * Dt(m) > e;
  }
  function f(p) {
    var m, _, x, I, k;
    return {
      lineStart: function() {
        I = x = !1, k = 1;
      },
      point: function(C, R) {
        var b = [C, R], O, A = h(C, R), L = r ? A ? 0 : y(C, R) : A ? y(C + (C < 0 ? St : -St), R) : 0;
        if (!m && (I = x = A) && p.lineStart(), A !== x && (O = g(m, b), (!O || po(m, O) || po(b, O)) && (b[0] += Nt, b[1] += Nt, A = h(b[0], b[1]))), A !== x)
          k = 0, A ? (p.lineStart(), O = g(b, m), p.point(O[0], O[1])) : (O = g(m, b), p.point(O[0], O[1]), p.lineEnd()), m = O;
        else if (s && m && r ^ A) {
          var D;
          !(L & _) && (D = g(b, m, !0)) && (k = 0, r ? (p.lineStart(), p.point(D[0][0], D[0][1]), p.point(D[1][0], D[1][1]), p.lineEnd()) : (p.point(D[1][0], D[1][1]), p.lineEnd(), p.lineStart(), p.point(D[0][0], D[0][1])));
        }
        A && (!m || !po(m, b)) && p.point(b[0], b[1]), m = b, x = A, _ = L;
      },
      lineEnd: function() {
        x && p.lineEnd(), m = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return k | (I && x) << 1;
      }
    };
  }
  function g(p, m, _) {
    var x = vr(p), I = vr(m), k = [1, 0, 0], C = Uo(x, I), R = no(C, C), b = C[0], O = R - b * b;
    if (!O) return !_ && p;
    var A = e * R / O, L = -e * b / O, D = Uo(k, C), F = io(k, A), G = io(C, L);
    hu(F, G);
    var B = D, tt = no(F, B), J = no(B, B), H = tt * tt - J * (no(F, F) - 1);
    if (!(H < 0)) {
      var Q = br(H), X = io(B, (-tt - Q) / J);
      if (hu(X, F), X = Zu(X), !_) return X;
      var K = p[0], V = m[0], lt = p[1], ct = m[1], Et;
      V < K && (Et = K, K = V, V = Et);
      var Z = V - K, pt = Wt(Z - St) < Nt, mt = pt || Z < Nt;
      if (!pt && ct < lt && (Et = lt, lt = ct, ct = Et), mt ? pt ? lt + ct > 0 ^ X[1] < (Wt(X[0] - K) < Nt ? lt : ct) : lt <= X[1] && X[1] <= ct : Z > St ^ (K <= X[0] && X[0] <= V)) {
        var Lt = io(B, (-tt + Q) / J);
        return hu(Lt, F), [X, Zu(Lt)];
      }
    }
  }
  function y(p, m) {
    var _ = r ? i : St - i, x = 0;
    return p < -_ ? x |= 1 : p > _ && (x |= 2), m < -_ ? x |= 4 : m > _ && (x |= 8), x;
  }
  return Dy(h, f, u, r ? [0, -i] : [-St, i - St]);
}
function Fy(i) {
  return function(t) {
    var e = new Ku();
    for (var r in i) e[r] = i[r];
    return e.stream = t, e;
  };
}
function Ku() {
}
Ku.prototype = {
  constructor: Ku,
  point: function(i, t) {
    this.stream.point(i, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function Gy(i, t, e) {
  var r = t[1][0] - t[0][0], s = t[1][1] - t[0][1], u = i.clipExtent && i.clipExtent();
  i.scale(150).translate([0, 0]), u != null && i.clipExtent(null), HI(e, i.stream(ng));
  var h = ng.result(), f = Math.min(r / (h[1][0] - h[0][0]), s / (h[1][1] - h[0][1])), g = +t[0][0] + (r - f * (h[1][0] + h[0][0])) / 2, y = +t[0][1] + (s - f * (h[1][1] + h[0][1])) / 2;
  return u != null && i.clipExtent(u), i.scale(f * 150).translate([g, y]);
}
function cw(i, t, e) {
  return Gy(i, [[0, 0], t], e);
}
var rg = 16, fw = Dt(30 * Me);
function sg(i, t) {
  return +t ? dw(i, t) : gw(i);
}
function gw(i) {
  return Fy({
    point: function(t, e) {
      t = i(t, e), this.stream.point(t[0], t[1]);
    }
  });
}
function dw(i, t) {
  function e(r, s, u, h, f, g, y, p, m, _, x, I, k, C) {
    var R = y - r, b = p - s, O = R * R + b * b;
    if (O > 4 * t && k--) {
      var A = h + _, L = f + x, D = g + I, F = br(A * A + L * L + D * D), G = Mi(D /= F), B = Wt(Wt(D) - 1) < Nt || Wt(u - m) < Nt ? (u + m) / 2 : mr(L, A), tt = i(B, G), J = tt[0], H = tt[1], Q = J - r, X = H - s, K = b * Q - R * X;
      (K * K / O > t || Wt((R * Q + b * X) / O - 0.5) > 0.3 || h * _ + f * x + g * I < fw) && (e(r, s, u, h, f, g, J, H, B, A /= F, L /= F, D, k, C), C.point(J, H), e(J, H, B, A, L, D, y, p, m, _, x, I, k, C));
    }
  }
  return function(r) {
    var s, u, h, f, g, y, p, m, _, x, I, k, C = {
      point: R,
      lineStart: b,
      lineEnd: A,
      polygonStart: function() {
        r.polygonStart(), C.lineStart = L;
      },
      polygonEnd: function() {
        r.polygonEnd(), C.lineStart = b;
      }
    };
    function R(G, B) {
      G = i(G, B), r.point(G[0], G[1]);
    }
    function b() {
      m = NaN, C.point = O, r.lineStart();
    }
    function O(G, B) {
      var tt = vr([G, B]), J = i(G, B);
      e(m, _, p, x, I, k, m = J[0], _ = J[1], p = G, x = tt[0], I = tt[1], k = tt[2], rg, r), r.point(m, _);
    }
    function A() {
      C.point = R, r.lineEnd();
    }
    function L() {
      b(), C.point = D, C.lineEnd = F;
    }
    function D(G, B) {
      O(s = G, B), u = m, h = _, f = x, g = I, y = k, C.point = O;
    }
    function F() {
      e(m, _, p, x, I, k, u, h, s, f, g, y, rg, r), C.lineEnd = A, A();
    }
    return C;
  };
}
var yw = Fy({
  point: function(i, t) {
    this.stream.point(i * Me, t * Me);
  }
});
function pw(i) {
  return mw(function() {
    return i;
  })();
}
function mw(i) {
  var t, e = 150, r = 480, s = 250, u, h, f = 0, g = 0, y = 0, p = 0, m = 0, _, x, I = null, k = ig, C = null, R, b, O, A = eg, L = 0.5, D = sg(J, L), F, G;
  function B(X) {
    return X = x(X[0] * Me, X[1] * Me), [X[0] * e + u, h - X[1] * e];
  }
  function tt(X) {
    return X = x.invert((X[0] - u) / e, (h - X[1]) / e), X && [X[0] * zn, X[1] * zn];
  }
  function J(X, K) {
    return X = t(X, K), [X[0] * e + u, h - X[1] * e];
  }
  B.stream = function(X) {
    return F && G === X ? F : F = yw(k(_, D(A(G = X))));
  }, B.clipAngle = function(X) {
    return arguments.length ? (k = +X ? hw(I = X * Me, 6 * Me) : (I = null, ig), Q()) : I * zn;
  }, B.clipExtent = function(X) {
    return arguments.length ? (A = X == null ? (C = R = b = O = null, eg) : nw(C = +X[0][0], R = +X[0][1], b = +X[1][0], O = +X[1][1]), Q()) : C == null ? null : [[C, R], [b, O]];
  }, B.scale = function(X) {
    return arguments.length ? (e = +X, H()) : e;
  }, B.translate = function(X) {
    return arguments.length ? (r = +X[0], s = +X[1], H()) : [r, s];
  }, B.center = function(X) {
    return arguments.length ? (f = X[0] % 360 * Me, g = X[1] % 360 * Me, H()) : [f * zn, g * zn];
  }, B.rotate = function(X) {
    return arguments.length ? (y = X[0] % 360 * Me, p = X[1] % 360 * Me, m = X.length > 2 ? X[2] % 360 * Me : 0, H()) : [y * zn, p * zn, m * zn];
  }, B.precision = function(X) {
    return arguments.length ? (D = sg(J, L = X * X), Q()) : br(L);
  }, B.fitExtent = function(X, K) {
    return Gy(B, X, K);
  }, B.fitSize = function(X, K) {
    return cw(B, X, K);
  };
  function H() {
    x = My(_ = JI(y, p, m), t);
    var X = t(f, g);
    return u = r - X[0] * e, h = s + X[1] * e, Q();
  }
  function Q() {
    return F = G = null, B;
  }
  return function() {
    return t = i.apply(this, arguments), B.invert = t.invert && tt, H();
  };
}
function By(i) {
  return function(t, e) {
    var r = Dt(t), s = Dt(e), u = i(r * s);
    return [
      u * s * Ft(t),
      u * Ft(e)
    ];
  };
}
function Yy(i) {
  return function(t, e) {
    var r = br(t * t + e * e), s = i(r), u = Ft(s), h = Dt(s);
    return [
      mr(t * u, r * h),
      Mi(r && e * u / r)
    ];
  };
}
var vw = By(function(i) {
  return br(2 / (1 + i));
});
vw.invert = Yy(function(i) {
  return 2 * Mi(i / 2);
});
var zy = By(function(i) {
  return (i = Ny(i)) && i / Ft(i);
});
zy.invert = Yy(function(i) {
  return i;
});
function _w() {
  return pw(zy).scale(79.4188).clipAngle(180 - 1e-3);
}
function og(i, t) {
  return [i, t];
}
og.invert = og;
var xw = Object.defineProperty, Tr = (i, t) => xw(i, "name", { value: t, configurable: !0 }), { BufferOp: Ew, GeoJSONReader: Sw, GeoJSONWriter: Iw } = VI;
function $y(i, t, e) {
  e = e || {};
  var r = e.units || "kilometers", s = e.steps || 8;
  if (!i)
    throw new Error("geojson is required");
  if (typeof e != "object")
    throw new Error("options must be an object");
  if (typeof s != "number")
    throw new Error("steps must be an number");
  if (t === void 0)
    throw new Error("radius is required");
  if (s <= 0)
    throw new Error("steps must be greater than 0");
  var u = [];
  switch (i.type) {
    case "GeometryCollection":
      return Rr(i, function(h) {
        var f = os(h, t, r, s);
        f && u.push(f);
      }), bn(u);
    case "FeatureCollection":
      return Xo(i, function(h) {
        var f = os(h, t, r, s);
        f && Xo(f, function(g) {
          g && u.push(g);
        });
      }), bn(u);
  }
  return os(i, t, r, s);
}
Tr($y, "buffer");
function os(i, t, e, r) {
  var s = i.properties || {}, u = i.type === "Feature" ? i.geometry : i;
  if (u.type === "GeometryCollection") {
    var h = [];
    return Rr(i, function(k) {
      var C = os(k, t, e, r);
      C && h.push(C);
    }), bn(h);
  }
  var f = Xy(u), g = {
    type: u.type,
    coordinates: jl(u.coordinates, f)
  }, y = new Sw(), p = y.read(g), m = ql(ca(t, e), "meters"), _ = Ew.bufferOp(p, m, r), x = new Iw();
  if (_ = x.write(_), !Ul(_.coordinates)) {
    var I = {
      type: _.type,
      coordinates: Vl(_.coordinates, f)
    };
    return Ze(I, s);
  }
}
Tr(os, "bufferFeature");
function Ul(i) {
  return Array.isArray(i[0]) ? Ul(i[0]) : isNaN(i[0]);
}
Tr(Ul, "coordsIsNaN");
function jl(i, t) {
  return typeof i[0] != "object" ? t(i) : i.map(function(e) {
    return jl(e, t);
  });
}
Tr(jl, "projectCoords");
function Vl(i, t) {
  return typeof i[0] != "object" ? t.invert(i) : i.map(function(e) {
    return Vl(e, t);
  });
}
Tr(Vl, "unprojectCoords");
function Xy(i) {
  var t = by(i).geometry.coordinates, e = [-t[0], -t[1]];
  return _w().rotate(e).scale(ue);
}
Tr(Xy, "defineProjection");
var ww = $y;
/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function kw(i, t) {
  var e = { label: 0, sent: function() {
    if (u[0] & 1) throw u[1];
    return u[1];
  }, trys: [], ops: [] }, r, s, u, h;
  return h = { next: f(0), throw: f(1), return: f(2) }, typeof Symbol == "function" && (h[Symbol.iterator] = function() {
    return this;
  }), h;
  function f(y) {
    return function(p) {
      return g([y, p]);
    };
  }
  function g(y) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; e; ) try {
      if (r = 1, s && (u = y[0] & 2 ? s.return : y[0] ? s.throw || ((u = s.return) && u.call(s), 0) : s.next) && !(u = u.call(s, y[1])).done) return u;
      switch (s = 0, u && (y = [y[0] & 2, u.value]), y[0]) {
        case 0:
        case 1:
          u = y;
          break;
        case 4:
          return e.label++, { value: y[1], done: !1 };
        case 5:
          e.label++, s = y[1], y = [0];
          continue;
        case 7:
          y = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (u = e.trys, !(u = u.length > 0 && u[u.length - 1]) && (y[0] === 6 || y[0] === 2)) {
            e = 0;
            continue;
          }
          if (y[0] === 3 && (!u || y[1] > u[0] && y[1] < u[3])) {
            e.label = y[1];
            break;
          }
          if (y[0] === 6 && e.label < u[1]) {
            e.label = u[1], u = y;
            break;
          }
          if (u && e.label < u[2]) {
            e.label = u[2], e.ops.push(y);
            break;
          }
          u[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      y = t.call(i, e);
    } catch (p) {
      y = [6, p], s = 0;
    } finally {
      r = u = 0;
    }
    if (y[0] & 5) throw y[1];
    return { value: y[0] ? y[1] : void 0, done: !0 };
  }
}
var ii = (
  /** @class */
  /* @__PURE__ */ function() {
    function i(t, e) {
      this.next = null, this.key = t, this.data = e, this.left = null, this.right = null;
    }
    return i;
  }()
);
function Cw(i, t) {
  return i > t ? 1 : i < t ? -1 : 0;
}
function Xn(i, t, e) {
  for (var r = new ii(null, null), s = r, u = r; ; ) {
    var h = e(i, t.key);
    if (h < 0) {
      if (t.left === null)
        break;
      if (e(i, t.left.key) < 0) {
        var f = t.left;
        if (t.left = f.right, f.right = t, t = f, t.left === null)
          break;
      }
      u.left = t, u = t, t = t.left;
    } else if (h > 0) {
      if (t.right === null)
        break;
      if (e(i, t.right.key) > 0) {
        var f = t.right;
        if (t.right = f.left, f.left = t, t = f, t.right === null)
          break;
      }
      s.right = t, s = t, t = t.right;
    } else
      break;
  }
  return s.right = t.left, u.left = t.right, t.left = r.right, t.right = r.left, t;
}
function fu(i, t, e, r) {
  var s = new ii(i, t);
  if (e === null)
    return s.left = s.right = null, s;
  e = Xn(i, e, r);
  var u = r(i, e.key);
  return u < 0 ? (s.left = e.left, s.right = e, e.left = null) : u >= 0 && (s.right = e.right, s.left = e, e.right = null), s;
}
function ag(i, t, e) {
  var r = null, s = null;
  if (t) {
    t = Xn(i, t, e);
    var u = e(t.key, i);
    u === 0 ? (r = t.left, s = t.right) : u < 0 ? (s = t.right, t.right = null, r = t) : (r = t.left, t.left = null, s = t);
  }
  return { left: r, right: s };
}
function Rw(i, t, e) {
  return t === null ? i : (i === null || (t = Xn(i.key, t, e), t.left = i), t);
}
function Qu(i, t, e, r, s) {
  if (i) {
    r("" + t + (e ? "└── " : "├── ") + s(i) + `
`);
    var u = t + (e ? "    " : "│   ");
    i.left && Qu(i.left, u, !1, r, s), i.right && Qu(i.right, u, !0, r, s);
  }
}
var Zl = (
  /** @class */
  function() {
    function i(t) {
      t === void 0 && (t = Cw), this._root = null, this._size = 0, this._comparator = t;
    }
    return i.prototype.insert = function(t, e) {
      return this._size++, this._root = fu(t, e, this._root, this._comparator);
    }, i.prototype.add = function(t, e) {
      var r = new ii(t, e);
      this._root === null && (r.left = r.right = null, this._size++, this._root = r);
      var s = this._comparator, u = Xn(t, this._root, s), h = s(t, u.key);
      return h === 0 ? this._root = u : (h < 0 ? (r.left = u.left, r.right = u, u.left = null) : h > 0 && (r.right = u.right, r.left = u, u.right = null), this._size++, this._root = r), this._root;
    }, i.prototype.remove = function(t) {
      this._root = this._remove(t, this._root, this._comparator);
    }, i.prototype._remove = function(t, e, r) {
      var s;
      if (e === null)
        return null;
      e = Xn(t, e, r);
      var u = r(t, e.key);
      return u === 0 ? (e.left === null ? s = e.right : (s = Xn(t, e.left, r), s.right = e.right), this._size--, s) : e;
    }, i.prototype.pop = function() {
      var t = this._root;
      if (t) {
        for (; t.left; )
          t = t.left;
        return this._root = Xn(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), { key: t.key, data: t.data };
      }
      return null;
    }, i.prototype.findStatic = function(t) {
      for (var e = this._root, r = this._comparator; e; ) {
        var s = r(t, e.key);
        if (s === 0)
          return e;
        s < 0 ? e = e.left : e = e.right;
      }
      return null;
    }, i.prototype.find = function(t) {
      return this._root && (this._root = Xn(t, this._root, this._comparator), this._comparator(t, this._root.key) !== 0) ? null : this._root;
    }, i.prototype.contains = function(t) {
      for (var e = this._root, r = this._comparator; e; ) {
        var s = r(t, e.key);
        if (s === 0)
          return !0;
        s < 0 ? e = e.left : e = e.right;
      }
      return !1;
    }, i.prototype.forEach = function(t, e) {
      for (var r = this._root, s = [], u = !1; !u; )
        r !== null ? (s.push(r), r = r.left) : s.length !== 0 ? (r = s.pop(), t.call(e, r), r = r.right) : u = !0;
      return this;
    }, i.prototype.range = function(t, e, r, s) {
      for (var u = [], h = this._comparator, f = this._root, g; u.length !== 0 || f; )
        if (f)
          u.push(f), f = f.left;
        else {
          if (f = u.pop(), g = h(f.key, e), g > 0)
            break;
          if (h(f.key, t) >= 0 && r.call(s, f))
            return this;
          f = f.right;
        }
      return this;
    }, i.prototype.keys = function() {
      var t = [];
      return this.forEach(function(e) {
        var r = e.key;
        return t.push(r);
      }), t;
    }, i.prototype.values = function() {
      var t = [];
      return this.forEach(function(e) {
        var r = e.data;
        return t.push(r);
      }), t;
    }, i.prototype.min = function() {
      return this._root ? this.minNode(this._root).key : null;
    }, i.prototype.max = function() {
      return this._root ? this.maxNode(this._root).key : null;
    }, i.prototype.minNode = function(t) {
      if (t === void 0 && (t = this._root), t)
        for (; t.left; )
          t = t.left;
      return t;
    }, i.prototype.maxNode = function(t) {
      if (t === void 0 && (t = this._root), t)
        for (; t.right; )
          t = t.right;
      return t;
    }, i.prototype.at = function(t) {
      for (var e = this._root, r = !1, s = 0, u = []; !r; )
        if (e)
          u.push(e), e = e.left;
        else if (u.length > 0) {
          if (e = u.pop(), s === t)
            return e;
          s++, e = e.right;
        } else
          r = !0;
      return null;
    }, i.prototype.next = function(t) {
      var e = this._root, r = null;
      if (t.right) {
        for (r = t.right; r.left; )
          r = r.left;
        return r;
      }
      for (var s = this._comparator; e; ) {
        var u = s(t.key, e.key);
        if (u === 0)
          break;
        u < 0 ? (r = e, e = e.left) : e = e.right;
      }
      return r;
    }, i.prototype.prev = function(t) {
      var e = this._root, r = null;
      if (t.left !== null) {
        for (r = t.left; r.right; )
          r = r.right;
        return r;
      }
      for (var s = this._comparator; e; ) {
        var u = s(t.key, e.key);
        if (u === 0)
          break;
        u < 0 ? e = e.left : (r = e, e = e.right);
      }
      return r;
    }, i.prototype.clear = function() {
      return this._root = null, this._size = 0, this;
    }, i.prototype.toList = function() {
      return Tw(this._root);
    }, i.prototype.load = function(t, e, r) {
      e === void 0 && (e = []), r === void 0 && (r = !1);
      var s = t.length, u = this._comparator;
      if (r && nl(t, e, 0, s - 1, u), this._root === null)
        this._root = tl(t, e, 0, s), this._size = s;
      else {
        var h = Nw(this.toList(), bw(t, e), u);
        s = this._size + s, this._root = el({ head: h }, 0, s);
      }
      return this;
    }, i.prototype.isEmpty = function() {
      return this._root === null;
    }, Object.defineProperty(i.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(i.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: !0,
      configurable: !0
    }), i.prototype.toString = function(t) {
      t === void 0 && (t = function(r) {
        return String(r.key);
      });
      var e = [];
      return Qu(this._root, "", !0, function(r) {
        return e.push(r);
      }, t), e.join("");
    }, i.prototype.update = function(t, e, r) {
      var s = this._comparator, u = ag(t, this._root, s), h = u.left, f = u.right;
      s(t, e) < 0 ? f = fu(e, r, f, s) : h = fu(e, r, h, s), this._root = Rw(h, f, s);
    }, i.prototype.split = function(t) {
      return ag(t, this._root, this._comparator);
    }, i.prototype[Symbol.iterator] = function() {
      var t, e, r;
      return kw(this, function(s) {
        switch (s.label) {
          case 0:
            t = this._root, e = [], r = !1, s.label = 1;
          case 1:
            return r ? [3, 6] : t === null ? [3, 2] : (e.push(t), t = t.left, [3, 5]);
          case 2:
            return e.length === 0 ? [3, 4] : (t = e.pop(), [4, t]);
          case 3:
            return s.sent(), t = t.right, [3, 5];
          case 4:
            r = !0, s.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    }, i;
  }()
);
function tl(i, t, e, r) {
  var s = r - e;
  if (s > 0) {
    var u = e + Math.floor(s / 2), h = i[u], f = t[u], g = new ii(h, f);
    return g.left = tl(i, t, e, u), g.right = tl(i, t, u + 1, r), g;
  }
  return null;
}
function bw(i, t) {
  for (var e = new ii(null, null), r = e, s = 0; s < i.length; s++)
    r = r.next = new ii(i[s], t[s]);
  return r.next = null, e.next;
}
function Tw(i) {
  for (var t = i, e = [], r = !1, s = new ii(null, null), u = s; !r; )
    t ? (e.push(t), t = t.left) : e.length > 0 ? (t = u = u.next = e.pop(), t = t.right) : r = !0;
  return u.next = null, s.next;
}
function el(i, t, e) {
  var r = e - t;
  if (r > 0) {
    var s = t + Math.floor(r / 2), u = el(i, t, s), h = i.head;
    return h.left = u, i.head = i.head.next, h.right = el(i, s + 1, e), h;
  }
  return null;
}
function Nw(i, t, e) {
  for (var r = new ii(null, null), s = r, u = i, h = t; u !== null && h !== null; )
    e(u.key, h.key) < 0 ? (s.next = u, u = u.next) : (s.next = h, h = h.next), s = s.next;
  return u !== null ? s.next = u : h !== null && (s.next = h), r.next;
}
function nl(i, t, e, r, s) {
  if (!(e >= r)) {
    for (var u = i[e + r >> 1], h = e - 1, f = r + 1; ; ) {
      do
        h++;
      while (s(i[h], u) < 0);
      do
        f--;
      while (s(i[f], u) > 0);
      if (h >= f)
        break;
      var g = i[h];
      i[h] = i[f], i[f] = g, g = t[h], t[h] = t[f], t[f] = g;
    }
    nl(i, t, e, f, s), nl(i, t, f + 1, r, s);
  }
}
const kn = 11102230246251565e-32, Kt = 134217729, Mw = (3 + 8 * kn) * kn;
function gu(i, t, e, r, s) {
  let u, h, f, g, y = t[0], p = r[0], m = 0, _ = 0;
  p > y == p > -y ? (u = y, y = t[++m]) : (u = p, p = r[++_]);
  let x = 0;
  if (m < i && _ < e)
    for (p > y == p > -y ? (h = y + u, f = u - (h - y), y = t[++m]) : (h = p + u, f = u - (h - p), p = r[++_]), u = h, f !== 0 && (s[x++] = f); m < i && _ < e; )
      p > y == p > -y ? (h = u + y, g = h - u, f = u - (h - g) + (y - g), y = t[++m]) : (h = u + p, g = h - u, f = u - (h - g) + (p - g), p = r[++_]), u = h, f !== 0 && (s[x++] = f);
  for (; m < i; )
    h = u + y, g = h - u, f = u - (h - g) + (y - g), y = t[++m], u = h, f !== 0 && (s[x++] = f);
  for (; _ < e; )
    h = u + p, g = h - u, f = u - (h - g) + (p - g), p = r[++_], u = h, f !== 0 && (s[x++] = f);
  return (u !== 0 || x === 0) && (s[x++] = u), x;
}
function Ow(i, t) {
  let e = t[0];
  for (let r = 1; r < i; r++) e += t[r];
  return e;
}
function Ls(i) {
  return new Float64Array(i);
}
const Lw = (3 + 16 * kn) * kn, Aw = (2 + 12 * kn) * kn, Pw = (9 + 64 * kn) * kn * kn, Qi = Ls(4), ug = Ls(8), lg = Ls(12), hg = Ls(16), ae = Ls(4);
function Dw(i, t, e, r, s, u, h) {
  let f, g, y, p, m, _, x, I, k, C, R, b, O, A, L, D, F, G;
  const B = i - s, tt = e - s, J = t - u, H = r - u;
  A = B * H, _ = Kt * B, x = _ - (_ - B), I = B - x, _ = Kt * H, k = _ - (_ - H), C = H - k, L = I * C - (A - x * k - I * k - x * C), D = J * tt, _ = Kt * J, x = _ - (_ - J), I = J - x, _ = Kt * tt, k = _ - (_ - tt), C = tt - k, F = I * C - (D - x * k - I * k - x * C), R = L - F, m = L - R, Qi[0] = L - (R + m) + (m - F), b = A + R, m = b - A, O = A - (b - m) + (R - m), R = O - D, m = O - R, Qi[1] = O - (R + m) + (m - D), G = b + R, m = G - b, Qi[2] = b - (G - m) + (R - m), Qi[3] = G;
  let Q = Ow(4, Qi), X = Aw * h;
  if (Q >= X || -Q >= X || (m = i - B, f = i - (B + m) + (m - s), m = e - tt, y = e - (tt + m) + (m - s), m = t - J, g = t - (J + m) + (m - u), m = r - H, p = r - (H + m) + (m - u), f === 0 && g === 0 && y === 0 && p === 0) || (X = Pw * h + Mw * Math.abs(Q), Q += B * p + H * f - (J * y + tt * g), Q >= X || -Q >= X)) return Q;
  A = f * H, _ = Kt * f, x = _ - (_ - f), I = f - x, _ = Kt * H, k = _ - (_ - H), C = H - k, L = I * C - (A - x * k - I * k - x * C), D = g * tt, _ = Kt * g, x = _ - (_ - g), I = g - x, _ = Kt * tt, k = _ - (_ - tt), C = tt - k, F = I * C - (D - x * k - I * k - x * C), R = L - F, m = L - R, ae[0] = L - (R + m) + (m - F), b = A + R, m = b - A, O = A - (b - m) + (R - m), R = O - D, m = O - R, ae[1] = O - (R + m) + (m - D), G = b + R, m = G - b, ae[2] = b - (G - m) + (R - m), ae[3] = G;
  const K = gu(4, Qi, 4, ae, ug);
  A = B * p, _ = Kt * B, x = _ - (_ - B), I = B - x, _ = Kt * p, k = _ - (_ - p), C = p - k, L = I * C - (A - x * k - I * k - x * C), D = J * y, _ = Kt * J, x = _ - (_ - J), I = J - x, _ = Kt * y, k = _ - (_ - y), C = y - k, F = I * C - (D - x * k - I * k - x * C), R = L - F, m = L - R, ae[0] = L - (R + m) + (m - F), b = A + R, m = b - A, O = A - (b - m) + (R - m), R = O - D, m = O - R, ae[1] = O - (R + m) + (m - D), G = b + R, m = G - b, ae[2] = b - (G - m) + (R - m), ae[3] = G;
  const V = gu(K, ug, 4, ae, lg);
  A = f * p, _ = Kt * f, x = _ - (_ - f), I = f - x, _ = Kt * p, k = _ - (_ - p), C = p - k, L = I * C - (A - x * k - I * k - x * C), D = g * y, _ = Kt * g, x = _ - (_ - g), I = g - x, _ = Kt * y, k = _ - (_ - y), C = y - k, F = I * C - (D - x * k - I * k - x * C), R = L - F, m = L - R, ae[0] = L - (R + m) + (m - F), b = A + R, m = b - A, O = A - (b - m) + (R - m), R = O - D, m = O - R, ae[1] = O - (R + m) + (m - D), G = b + R, m = G - b, ae[2] = b - (G - m) + (R - m), ae[3] = G;
  const lt = gu(V, lg, 4, ae, hg);
  return hg[lt - 1];
}
function Fw(i, t, e, r, s, u) {
  const h = (t - u) * (e - s), f = (i - s) * (r - u), g = h - f, y = Math.abs(h + f);
  return Math.abs(g) >= Lw * y ? g : -Dw(i, t, e, r, s, u, y);
}
const Vr = (i, t) => i.ll.x <= t.x && t.x <= i.ur.x && i.ll.y <= t.y && t.y <= i.ur.y, il = (i, t) => {
  if (t.ur.x < i.ll.x || i.ur.x < t.ll.x || t.ur.y < i.ll.y || i.ur.y < t.ll.y) return null;
  const e = i.ll.x < t.ll.x ? t.ll.x : i.ll.x, r = i.ur.x < t.ur.x ? i.ur.x : t.ur.x, s = i.ll.y < t.ll.y ? t.ll.y : i.ll.y, u = i.ur.y < t.ur.y ? i.ur.y : t.ur.y;
  return {
    ll: {
      x: e,
      y: s
    },
    ur: {
      x: r,
      y: u
    }
  };
};
let Zn = Number.EPSILON;
Zn === void 0 && (Zn = Math.pow(2, -52));
const Gw = Zn * Zn, cg = (i, t) => {
  if (-Zn < i && i < Zn && -Zn < t && t < Zn)
    return 0;
  const e = i - t;
  return e * e < Gw * i * t ? 0 : i < t ? -1 : 1;
};
class Bw {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new fg(), this.yRounder = new fg();
  }
  round(t, e) {
    return {
      x: this.xRounder.round(t),
      y: this.yRounder.round(e)
    };
  }
}
class fg {
  constructor() {
    this.tree = new Zl(), this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(t) {
    const e = this.tree.add(t), r = this.tree.prev(e);
    if (r !== null && cg(e.key, r.key) === 0)
      return this.tree.remove(t), r.key;
    const s = this.tree.next(e);
    return s !== null && cg(e.key, s.key) === 0 ? (this.tree.remove(t), s.key) : t;
  }
}
const ws = new Bw(), mo = (i, t) => i.x * t.y - i.y * t.x, qy = (i, t) => i.x * t.x + i.y * t.y, gg = (i, t, e) => {
  const r = Fw(i.x, i.y, t.x, t.y, e.x, e.y);
  return r > 0 ? -1 : r < 0 ? 1 : 0;
}, Zo = (i) => Math.sqrt(qy(i, i)), Yw = (i, t, e) => {
  const r = {
    x: t.x - i.x,
    y: t.y - i.y
  }, s = {
    x: e.x - i.x,
    y: e.y - i.y
  };
  return mo(s, r) / Zo(s) / Zo(r);
}, zw = (i, t, e) => {
  const r = {
    x: t.x - i.x,
    y: t.y - i.y
  }, s = {
    x: e.x - i.x,
    y: e.y - i.y
  };
  return qy(s, r) / Zo(s) / Zo(r);
}, dg = (i, t, e) => t.y === 0 ? null : {
  x: i.x + t.x / t.y * (e - i.y),
  y: e
}, yg = (i, t, e) => t.x === 0 ? null : {
  x: e,
  y: i.y + t.y / t.x * (e - i.x)
}, $w = (i, t, e, r) => {
  if (t.x === 0) return yg(e, r, i.x);
  if (r.x === 0) return yg(i, t, e.x);
  if (t.y === 0) return dg(e, r, i.y);
  if (r.y === 0) return dg(i, t, e.y);
  const s = mo(t, r);
  if (s == 0) return null;
  const u = {
    x: e.x - i.x,
    y: e.y - i.y
  }, h = mo(u, t) / s, f = mo(u, r) / s, g = i.x + f * t.x, y = e.x + h * r.x, p = i.y + f * t.y, m = e.y + h * r.y, _ = (g + y) / 2, x = (p + m) / 2;
  return {
    x: _,
    y: x
  };
};
class Ae {
  // for ordering sweep events in the sweep event queue
  static compare(t, e) {
    const r = Ae.comparePoints(t.point, e.point);
    return r !== 0 ? r : (t.point !== e.point && t.link(e), t.isLeft !== e.isLeft ? t.isLeft ? 1 : -1 : ti.compare(t.segment, e.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(t, e) {
    return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(t, e) {
    t.events === void 0 ? t.events = [this] : t.events.push(this), this.point = t, this.isLeft = e;
  }
  link(t) {
    if (t.point === this.point)
      throw new Error("Tried to link already linked events");
    const e = t.point.events;
    for (let r = 0, s = e.length; r < s; r++) {
      const u = e[r];
      this.point.events.push(u), u.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const t = this.point.events.length;
    for (let e = 0; e < t; e++) {
      const r = this.point.events[e];
      if (r.segment.consumedBy === void 0)
        for (let s = e + 1; s < t; s++) {
          const u = this.point.events[s];
          u.consumedBy === void 0 && r.otherSE.point.events === u.otherSE.point.events && r.segment.consume(u.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const t = [];
    for (let e = 0, r = this.point.events.length; e < r; e++) {
      const s = this.point.events[e];
      s !== this && !s.segment.ringOut && s.segment.isInResult() && t.push(s);
    }
    return t;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(t) {
    const e = /* @__PURE__ */ new Map(), r = (s) => {
      const u = s.otherSE;
      e.set(s, {
        sine: Yw(this.point, t.point, u.point),
        cosine: zw(this.point, t.point, u.point)
      });
    };
    return (s, u) => {
      e.has(s) || r(s), e.has(u) || r(u);
      const {
        sine: h,
        cosine: f
      } = e.get(s), {
        sine: g,
        cosine: y
      } = e.get(u);
      return h >= 0 && g >= 0 ? f < y ? 1 : f > y ? -1 : 0 : h < 0 && g < 0 ? f < y ? -1 : f > y ? 1 : 0 : g < h ? -1 : g > h ? 1 : 0;
    };
  }
}
let Xw = 0;
class ti {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(t, e) {
    const r = t.leftSE.point.x, s = e.leftSE.point.x, u = t.rightSE.point.x, h = e.rightSE.point.x;
    if (h < r) return 1;
    if (u < s) return -1;
    const f = t.leftSE.point.y, g = e.leftSE.point.y, y = t.rightSE.point.y, p = e.rightSE.point.y;
    if (r < s) {
      if (g < f && g < y) return 1;
      if (g > f && g > y) return -1;
      const m = t.comparePoint(e.leftSE.point);
      if (m < 0) return 1;
      if (m > 0) return -1;
      const _ = e.comparePoint(t.rightSE.point);
      return _ !== 0 ? _ : -1;
    }
    if (r > s) {
      if (f < g && f < p) return -1;
      if (f > g && f > p) return 1;
      const m = e.comparePoint(t.leftSE.point);
      if (m !== 0) return m;
      const _ = t.comparePoint(e.rightSE.point);
      return _ < 0 ? 1 : _ > 0 ? -1 : 1;
    }
    if (f < g) return -1;
    if (f > g) return 1;
    if (u < h) {
      const m = e.comparePoint(t.rightSE.point);
      if (m !== 0) return m;
    }
    if (u > h) {
      const m = t.comparePoint(e.rightSE.point);
      if (m < 0) return 1;
      if (m > 0) return -1;
    }
    if (u !== h) {
      const m = y - f, _ = u - r, x = p - g, I = h - s;
      if (m > _ && x < I) return 1;
      if (m < _ && x > I) return -1;
    }
    return u > h ? 1 : u < h || y < p ? -1 : y > p ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(t, e, r, s) {
    this.id = ++Xw, this.leftSE = t, t.segment = this, t.otherSE = e, this.rightSE = e, e.segment = this, e.otherSE = t, this.rings = r, this.windings = s;
  }
  static fromRing(t, e, r) {
    let s, u, h;
    const f = Ae.comparePoints(t, e);
    if (f < 0)
      s = t, u = e, h = 1;
    else if (f > 0)
      s = e, u = t, h = -1;
    else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);
    const g = new Ae(s, !0), y = new Ae(u, !1);
    return new ti(g, y, [r], [h]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(t) {
    this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const t = this.leftSE.point.y, e = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: t < e ? t : e
      },
      ur: {
        x: this.rightSE.point.x,
        y: t > e ? t : e
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(t) {
    return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(t) {
    if (this.isAnEndpoint(t)) return 0;
    const e = this.leftSE.point, r = this.rightSE.point, s = this.vector();
    if (e.x === r.x)
      return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
    const u = (t.y - e.y) / s.y, h = e.x + u * s.x;
    if (t.x === h) return 0;
    const f = (t.x - e.x) / s.x, g = e.y + f * s.y;
    return t.y === g ? 0 : t.y < g ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(t) {
    const e = this.bbox(), r = t.bbox(), s = il(e, r);
    if (s === null) return null;
    const u = this.leftSE.point, h = this.rightSE.point, f = t.leftSE.point, g = t.rightSE.point, y = Vr(e, f) && this.comparePoint(f) === 0, p = Vr(r, u) && t.comparePoint(u) === 0, m = Vr(e, g) && this.comparePoint(g) === 0, _ = Vr(r, h) && t.comparePoint(h) === 0;
    if (p && y)
      return _ && !m ? h : !_ && m ? g : null;
    if (p)
      return m && u.x === g.x && u.y === g.y ? null : u;
    if (y)
      return _ && h.x === f.x && h.y === f.y ? null : f;
    if (_ && m) return null;
    if (_) return h;
    if (m) return g;
    const x = $w(u, this.vector(), f, t.vector());
    return x === null || !Vr(s, x) ? null : ws.round(x.x, x.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(t) {
    const e = [], r = t.events !== void 0, s = new Ae(t, !0), u = new Ae(t, !1), h = this.rightSE;
    this.replaceRightSE(u), e.push(u), e.push(s);
    const f = new ti(s, h, this.rings.slice(), this.windings.slice());
    return Ae.comparePoints(f.leftSE.point, f.rightSE.point) > 0 && f.swapEvents(), Ae.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r && (s.checkForConsuming(), u.checkForConsuming()), e;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const t = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let e = 0, r = this.windings.length; e < r; e++)
      this.windings[e] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(t) {
    let e = this, r = t;
    for (; e.consumedBy; ) e = e.consumedBy;
    for (; r.consumedBy; ) r = r.consumedBy;
    const s = ti.compare(e, r);
    if (s !== 0) {
      if (s > 0) {
        const u = e;
        e = r, r = u;
      }
      if (e.prev === r) {
        const u = e;
        e = r, r = u;
      }
      for (let u = 0, h = r.rings.length; u < h; u++) {
        const f = r.rings[u], g = r.windings[u], y = e.rings.indexOf(f);
        y === -1 ? (e.rings.push(f), e.windings.push(g)) : e.windings[y] += g;
      }
      r.rings = null, r.windings = null, r.consumedBy = e, r.leftSE.consumedBy = e.leftSE, r.rightSE.consumedBy = e.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const t = this.prev.consumedBy || this.prev;
      this._beforeState = t.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const t = this.beforeState();
    this._afterState = {
      rings: t.rings.slice(0),
      windings: t.windings.slice(0),
      multiPolys: []
    };
    const e = this._afterState.rings, r = this._afterState.windings, s = this._afterState.multiPolys;
    for (let f = 0, g = this.rings.length; f < g; f++) {
      const y = this.rings[f], p = this.windings[f], m = e.indexOf(y);
      m === -1 ? (e.push(y), r.push(p)) : r[m] += p;
    }
    const u = [], h = [];
    for (let f = 0, g = e.length; f < g; f++) {
      if (r[f] === 0) continue;
      const y = e[f], p = y.poly;
      if (h.indexOf(p) === -1)
        if (y.isExterior) u.push(p);
        else {
          h.indexOf(p) === -1 && h.push(p);
          const m = u.indexOf(y.poly);
          m !== -1 && u.splice(m, 1);
        }
    }
    for (let f = 0, g = u.length; f < g; f++) {
      const y = u[f].multiPoly;
      s.indexOf(y) === -1 && s.push(y);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const t = this.beforeState().multiPolys, e = this.afterState().multiPolys;
    switch (We.type) {
      case "union": {
        const r = t.length === 0, s = e.length === 0;
        this._isInResult = r !== s;
        break;
      }
      case "intersection": {
        let r, s;
        t.length < e.length ? (r = t.length, s = e.length) : (r = e.length, s = t.length), this._isInResult = s === We.numMultiPolys && r < s;
        break;
      }
      case "xor": {
        const r = Math.abs(t.length - e.length);
        this._isInResult = r % 2 === 1;
        break;
      }
      case "difference": {
        const r = (s) => s.length === 1 && s[0].isSubject;
        this._isInResult = r(t) !== r(e);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${We.type}`);
    }
    return this._isInResult;
  }
}
class pg {
  constructor(t, e, r) {
    if (!Array.isArray(t) || t.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = e, this.isExterior = r, this.segments = [], typeof t[0][0] != "number" || typeof t[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const s = ws.round(t[0][0], t[0][1]);
    this.bbox = {
      ll: {
        x: s.x,
        y: s.y
      },
      ur: {
        x: s.x,
        y: s.y
      }
    };
    let u = s;
    for (let h = 1, f = t.length; h < f; h++) {
      if (typeof t[h][0] != "number" || typeof t[h][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      let g = ws.round(t[h][0], t[h][1]);
      g.x === u.x && g.y === u.y || (this.segments.push(ti.fromRing(u, g, this)), g.x < this.bbox.ll.x && (this.bbox.ll.x = g.x), g.y < this.bbox.ll.y && (this.bbox.ll.y = g.y), g.x > this.bbox.ur.x && (this.bbox.ur.x = g.x), g.y > this.bbox.ur.y && (this.bbox.ur.y = g.y), u = g);
    }
    (s.x !== u.x || s.y !== u.y) && this.segments.push(ti.fromRing(u, s, this));
  }
  getSweepEvents() {
    const t = [];
    for (let e = 0, r = this.segments.length; e < r; e++) {
      const s = this.segments[e];
      t.push(s.leftSE), t.push(s.rightSE);
    }
    return t;
  }
}
class qw {
  constructor(t, e) {
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new pg(t[0], this, !0), this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    }, this.interiorRings = [];
    for (let r = 1, s = t.length; r < s; r++) {
      const u = new pg(t[r], this, !1);
      u.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = u.bbox.ll.x), u.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = u.bbox.ll.y), u.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = u.bbox.ur.x), u.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = u.bbox.ur.y), this.interiorRings.push(u);
    }
    this.multiPoly = e;
  }
  getSweepEvents() {
    const t = this.exteriorRing.getSweepEvents();
    for (let e = 0, r = this.interiorRings.length; e < r; e++) {
      const s = this.interiorRings[e].getSweepEvents();
      for (let u = 0, h = s.length; u < h; u++)
        t.push(s[u]);
    }
    return t;
  }
}
class mg {
  constructor(t, e) {
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof t[0][0][0] == "number" && (t = [t]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let r = 0, s = t.length; r < s; r++) {
      const u = new qw(t[r], this);
      u.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = u.bbox.ll.x), u.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = u.bbox.ll.y), u.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = u.bbox.ur.x), u.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = u.bbox.ur.y), this.polys.push(u);
    }
    this.isSubject = e;
  }
  getSweepEvents() {
    const t = [];
    for (let e = 0, r = this.polys.length; e < r; e++) {
      const s = this.polys[e].getSweepEvents();
      for (let u = 0, h = s.length; u < h; u++)
        t.push(s[u]);
    }
    return t;
  }
}
class Ho {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(t) {
    const e = [];
    for (let r = 0, s = t.length; r < s; r++) {
      const u = t[r];
      if (!u.isInResult() || u.ringOut) continue;
      let h = null, f = u.leftSE, g = u.rightSE;
      const y = [f], p = f.point, m = [];
      for (; h = f, f = g, y.push(f), f.point !== p; )
        for (; ; ) {
          const _ = f.getAvailableLinkedEvents();
          if (_.length === 0) {
            const k = y[0].point, C = y[y.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${k.x}, ${k.y}]. Last matching segment found ends at [${C.x}, ${C.y}].`);
          }
          if (_.length === 1) {
            g = _[0].otherSE;
            break;
          }
          let x = null;
          for (let k = 0, C = m.length; k < C; k++)
            if (m[k].point === f.point) {
              x = k;
              break;
            }
          if (x !== null) {
            const k = m.splice(x)[0], C = y.splice(k.index);
            C.unshift(C[0].otherSE), e.push(new Ho(C.reverse()));
            continue;
          }
          m.push({
            index: y.length,
            point: f.point
          });
          const I = f.getLeftmostComparator(h);
          g = _.sort(I)[0].otherSE;
          break;
        }
      e.push(new Ho(y));
    }
    return e;
  }
  constructor(t) {
    this.events = t;
    for (let e = 0, r = t.length; e < r; e++)
      t[e].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let t = this.events[0].point;
    const e = [t];
    for (let y = 1, p = this.events.length - 1; y < p; y++) {
      const m = this.events[y].point, _ = this.events[y + 1].point;
      gg(m, t, _) !== 0 && (e.push(m), t = m);
    }
    if (e.length === 1) return null;
    const r = e[0], s = e[1];
    gg(r, t, s) === 0 && e.shift(), e.push(e[0]);
    const u = this.isExteriorRing() ? 1 : -1, h = this.isExteriorRing() ? 0 : e.length - 1, f = this.isExteriorRing() ? e.length : -1, g = [];
    for (let y = h; y != f; y += u) g.push([e[y].x, e[y].y]);
    return g;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const t = this.enclosingRing();
      this._isExteriorRing = t ? !t.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let t = this.events[0];
    for (let s = 1, u = this.events.length; s < u; s++) {
      const h = this.events[s];
      Ae.compare(t, h) > 0 && (t = h);
    }
    let e = t.segment.prevInResult(), r = e ? e.prevInResult() : null;
    for (; ; ) {
      if (!e) return null;
      if (!r) return e.ringOut;
      if (r.ringOut !== e.ringOut)
        return r.ringOut.enclosingRing() !== e.ringOut ? e.ringOut : e.ringOut.enclosingRing();
      e = r.prevInResult(), r = e ? e.prevInResult() : null;
    }
  }
}
class vg {
  constructor(t) {
    this.exteriorRing = t, t.poly = this, this.interiorRings = [];
  }
  addInterior(t) {
    this.interiorRings.push(t), t.poly = this;
  }
  getGeom() {
    const t = [this.exteriorRing.getGeom()];
    if (t[0] === null) return null;
    for (let e = 0, r = this.interiorRings.length; e < r; e++) {
      const s = this.interiorRings[e].getGeom();
      s !== null && t.push(s);
    }
    return t;
  }
}
class Ww {
  constructor(t) {
    this.rings = t, this.polys = this._composePolys(t);
  }
  getGeom() {
    const t = [];
    for (let e = 0, r = this.polys.length; e < r; e++) {
      const s = this.polys[e].getGeom();
      s !== null && t.push(s);
    }
    return t;
  }
  _composePolys(t) {
    const e = [];
    for (let r = 0, s = t.length; r < s; r++) {
      const u = t[r];
      if (!u.poly)
        if (u.isExteriorRing()) e.push(new vg(u));
        else {
          const h = u.enclosingRing();
          h.poly || e.push(new vg(h)), h.poly.addInterior(u);
        }
    }
    return e;
  }
}
class Uw {
  constructor(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ti.compare;
    this.queue = t, this.tree = new Zl(e), this.segments = [];
  }
  process(t) {
    const e = t.segment, r = [];
    if (t.consumedBy)
      return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), r;
    const s = t.isLeft ? this.tree.add(e) : this.tree.find(e);
    if (!s) throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);
    let u = s, h = s, f, g;
    for (; f === void 0; )
      u = this.tree.prev(u), u === null ? f = null : u.key.consumedBy === void 0 && (f = u.key);
    for (; g === void 0; )
      h = this.tree.next(h), h === null ? g = null : h.key.consumedBy === void 0 && (g = h.key);
    if (t.isLeft) {
      let y = null;
      if (f) {
        const m = f.getIntersection(e);
        if (m !== null && (e.isAnEndpoint(m) || (y = m), !f.isAnEndpoint(m))) {
          const _ = this._splitSafely(f, m);
          for (let x = 0, I = _.length; x < I; x++)
            r.push(_[x]);
        }
      }
      let p = null;
      if (g) {
        const m = g.getIntersection(e);
        if (m !== null && (e.isAnEndpoint(m) || (p = m), !g.isAnEndpoint(m))) {
          const _ = this._splitSafely(g, m);
          for (let x = 0, I = _.length; x < I; x++)
            r.push(_[x]);
        }
      }
      if (y !== null || p !== null) {
        let m = null;
        y === null ? m = p : p === null ? m = y : m = Ae.comparePoints(y, p) <= 0 ? y : p, this.queue.remove(e.rightSE), r.push(e.rightSE);
        const _ = e.split(m);
        for (let x = 0, I = _.length; x < I; x++)
          r.push(_[x]);
      }
      r.length > 0 ? (this.tree.remove(e), r.push(t)) : (this.segments.push(e), e.prev = f);
    } else {
      if (f && g) {
        const y = f.getIntersection(g);
        if (y !== null) {
          if (!f.isAnEndpoint(y)) {
            const p = this._splitSafely(f, y);
            for (let m = 0, _ = p.length; m < _; m++)
              r.push(p[m]);
          }
          if (!g.isAnEndpoint(y)) {
            const p = this._splitSafely(g, y);
            for (let m = 0, _ = p.length; m < _; m++)
              r.push(p[m]);
          }
        }
      }
      this.tree.remove(e);
    }
    return r;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(t, e) {
    this.tree.remove(t);
    const r = t.rightSE;
    this.queue.remove(r);
    const s = t.split(e);
    return s.push(r), t.consumedBy === void 0 && this.tree.add(t), s;
  }
}
const _g = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, jw = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class Vw {
  run(t, e, r) {
    We.type = t, ws.reset();
    const s = [new mg(e, !0)];
    for (let m = 0, _ = r.length; m < _; m++)
      s.push(new mg(r[m], !1));
    if (We.numMultiPolys = s.length, We.type === "difference") {
      const m = s[0];
      let _ = 1;
      for (; _ < s.length; )
        il(s[_].bbox, m.bbox) !== null ? _++ : s.splice(_, 1);
    }
    if (We.type === "intersection")
      for (let m = 0, _ = s.length; m < _; m++) {
        const x = s[m];
        for (let I = m + 1, k = s.length; I < k; I++)
          if (il(x.bbox, s[I].bbox) === null) return [];
      }
    const u = new Zl(Ae.compare);
    for (let m = 0, _ = s.length; m < _; m++) {
      const x = s[m].getSweepEvents();
      for (let I = 0, k = x.length; I < k; I++)
        if (u.insert(x[I]), u.size > _g)
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
    }
    const h = new Uw(u);
    let f = u.size, g = u.pop();
    for (; g; ) {
      const m = g.key;
      if (u.size === f) {
        const x = m.segment;
        throw new Error(`Unable to pop() ${m.isLeft ? "left" : "right"} SweepEvent [${m.point.x}, ${m.point.y}] from segment #${x.id} [${x.leftSE.point.x}, ${x.leftSE.point.y}] -> [${x.rightSE.point.x}, ${x.rightSE.point.y}] from queue.`);
      }
      if (u.size > _g)
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      if (h.segments.length > jw)
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      const _ = h.process(m);
      for (let x = 0, I = _.length; x < I; x++) {
        const k = _[x];
        k.consumedBy === void 0 && u.insert(k);
      }
      f = u.size, g = u.pop();
    }
    ws.reset();
    const y = Ho.factory(h.segments);
    return new Ww(y).getGeom();
  }
}
const We = new Vw(), Zw = function(i) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    e[r - 1] = arguments[r];
  return We.run("union", i, e);
}, Hw = function(i) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    e[r - 1] = arguments[r];
  return We.run("intersection", i, e);
}, Jw = function(i) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    e[r - 1] = arguments[r];
  return We.run("xor", i, e);
}, Kw = function(i) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    e[r - 1] = arguments[r];
  return We.run("difference", i, e);
};
var Qw = {
  union: Zw,
  intersection: Hw,
  xor: Jw,
  difference: Kw
}, tk = Object.defineProperty, ek = (i, t) => tk(i, "name", { value: t, configurable: !0 });
function Wy(i) {
  const t = [];
  if (Rr(i, (s) => {
    t.push(s.coordinates);
  }), t.length < 2)
    throw new Error("Must have at least two features");
  const e = i.features[0].properties || {}, r = Qw.difference(t[0], ...t.slice(1));
  return r.length === 0 ? null : r.length === 1 ? Os(r[0], e) : Xl(r, e);
}
ek(Wy, "difference");
var nk = Wy;
function xg(i) {
  let t;
  for (const e of i)
    t && e[0] - t[0] >= 180 ? e[0] -= 360 : t && e[0] - t[0] < -180 && (e[0] += 360), t = e;
}
function Eg(i, t) {
  const e = nk(
    bn([
      Os([
        [
          [180, 90],
          [-180, 90],
          [-180, -90],
          [180, -90],
          [180, 90]
        ]
      ]),
      i
    ])
  );
  if (!e)
    return;
  e.properties = { isMask: "y" };
  const r = ww(i, 0);
  if (r) {
    if (r.geometry.type === "Polygon")
      for (const s of r.geometry.coordinates)
        xg(s);
    else
      for (const s of r.geometry.coordinates)
        for (const u of s)
          xg(u);
    t(bn([r, e]));
  }
}
const Sg = "EPSG:4326";
function ik(i) {
  var u;
  const t = i.getProperties(), { isMask: e } = t, r = (u = i.getGeometry()) == null ? void 0 : u.getType(), s = e ? 0 : r === "LineString" || r === "MultiLineString" ? 3 : 2;
  return new Qn({
    stroke: e ? void 0 : new gr({
      color: "#3170fe",
      lineDash: [s, s],
      width: s,
      lineCap: "butt"
    }),
    fill: e ? new Ni({
      color: "#00000020"
    }) : void 0,
    image: new bs({
      src: `/icons/marker_${t.isReverse ? "reverse" : t.isSelected ? "selected" : "unselected"}.svg`,
      anchor: [0.5, 1]
    }),
    zIndex: t.isSelected ? 2 : t.isReverse ? 0 : 1,
    text: t.isSelected && t.tooltip ? new ra({
      backgroundFill: new Ni({ color: "white" }),
      text: t.tooltip,
      offsetY: -40,
      backgroundStroke: new gr({
        color: "white",
        lineJoin: "round",
        width: 3
      }),
      padding: [2, 0, 0, 2]
    }) : void 0
  });
}
function uk(i, t = {}, e = {}, r = ik) {
  let s = -1, u, h, f, g = !1;
  const y = new _0({
    updateWhileAnimating: !0
  });
  i.addLayer(y);
  const p = new k0({});
  y.setSource(p), y.setStyle(r), i.on("click", (x) => {
    i.forEachFeatureAtPixel(x.pixel, (I) => {
      const k = I.getId();
      if (k)
        return x.stopPropagation(), h == null || h({ type: "markerClick", id: k }), I;
    });
  }), i.on("pointermove", (x) => {
    const I = i.forEachFeatureAtPixel(x.pixel, (k) => k.getId());
    u !== I && (u && (h == null || h({
      type: "markerMouseLeave",
      id: u
    })), I && (h == null || h({
      type: "markerMouseEnter",
      id: I
    })), i.getTargetElement().style.cursor = I ? "pointer" : g ? "crosshair" : "", u = I);
  });
  function m(x) {
    return x.transform(Sg, i.getView().getProjection());
  }
  const _ = (x) => {
    h == null || h({
      type: "mapClick",
      coordinates: Yh(x.coordinate, i.getView().getProjection())
    });
  };
  return {
    setEventHandler(x) {
      x ? (h = x, i.on("click", _)) : (h = void 0, i.un("click", _));
    },
    flyTo(x, I) {
      i.getView().animate({
        center: Us(x, i.getView().getProjection()),
        zoom: I,
        duration: 2e3,
        ...t
      });
    },
    fitBounds(x, I, k) {
      i.getView().fit(Fm(x, Sg, i.getView().getProjection()), {
        padding: [I, I, I, I],
        maxZoom: k,
        duration: 2e3,
        ...e
      });
    },
    indicateReverse(x) {
      g = x, i.getTargetElement().style.cursor = x ? "crosshair" : "";
    },
    setReverseMarker(x) {
      f ? x ? f.getGeometry().setCoordinates(
        Us(x, i.getView().getProjection())
      ) : (p.removeFeature(f), f.dispose(), f = void 0) : x && (f = new yn(
        new Kn(Us(x, i.getView().getProjection()))
      ), f.setProperties({ isReverse: !0 }), p.addFeature(f));
    },
    setMarkers(x, I) {
      function k(C) {
        var R;
        if (C)
          for (const b of C.features) {
            const O = b.geometry.type === "Polygon" ? new ei(b.geometry.coordinates) : b.geometry.type === "MultiPolygon" ? new cs(b.geometry.coordinates) : null;
            O && p.addFeature(
              new yn({
                isMask: !!((R = b.properties) != null && R.isMask),
                geometry: m(O)
              })
            );
          }
      }
      if (p.clear(), f && p.addFeature(f), k(), I) {
        let C = !1;
        if (I.geometry.type === "GeometryCollection") {
          const R = I.geometry.geometries.map(
            (b) => b.type === "Polygon" ? new ei(b.coordinates) : b.type === "MultiPolygon" ? new cs(b.coordinates) : null
          ).filter((b) => !!b);
          if (R.length > 0)
            p.addFeature(
              new yn(m(new Eo(R)))
            ), C = !0;
          else
            for (const b of I.geometry.geometries)
              b.type === "LineString" ? (p.addFeature(
                new yn(
                  m(new Ti(b.coordinates))
                )
              ), C = !0) : b.type === "MultiLineString" && p.addFeature(
                new yn(
                  m(new hs(b.coordinates))
                )
              ), C = !0;
        }
        if (!C) {
          if (I.geometry.type === "Polygon")
            Eg(I, k);
          else if (I.geometry.type === "MultiPolygon")
            Eg(I, k);
          else if (I.geometry.type === "LineString") {
            p.addFeature(
              new yn(
                m(new Ti(I.geometry.coordinates))
              )
            );
            return;
          } else if (I.geometry.type === "MultiLineString") {
            p.addFeature(
              new yn(
                m(new hs(I.geometry.coordinates))
              )
            );
            return;
          }
        }
        p.addFeature(new yn(m(new Kn(I.center))));
      }
      for (const C of x ?? []) {
        if (C === I)
          continue;
        const R = new yn(
          new Kn(Us(C.center, i.getView().getProjection()))
        );
        R.setId(C.id), R.setProperties({
          fuzzy: !!C.matching_text,
          tooltip: C.place_type[0] === "reverse" ? C.place_name : C.place_name.replace(/,.*/, "")
        }), p.addFeature(R);
      }
    },
    setSelectedMarker(x) {
      var C, R, b;
      const I = p.getFeatures(), k = (C = I[0]) != null && C.getProperties().isReverse ? 1 : 0;
      s > -1 && ((R = I[s + k]) == null || R.setProperties({
        isSelected: !1
      })), x > -1 && ((b = I[x + k]) == null || b.setProperties({
        isSelected: !0
      })), s = x;
    },
    getCenterAndZoom() {
      const x = i.getView(), I = x.getCenter(), k = x.getZoom();
      if (!(!I || k === void 0))
        return [k, ...Yh(I, x.getProjection())];
    }
  };
}
export {
  uk as createOpenLayersMapController
};
//# sourceMappingURL=openlayers-controller.js.map
