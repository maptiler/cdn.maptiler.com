(function(L,b){typeof exports=="object"&&typeof module<"u"?b(exports):typeof define=="function"&&define.amd?define(["exports"],b):(L=typeof globalThis<"u"?globalThis:L||self,b(L.maplibreglMaptilerGeocodingController={}))})(this,function(L){"use strict";var We=Object.defineProperty;var Je=(L,b,T)=>b in L?We(L,b,{enumerable:!0,configurable:!0,writable:!0,value:T}):L[b]=T;var vt=(L,b,T)=>Je(L,typeof b!="symbol"?b+"":b,T);function b(i,t,e={}){const n={type:"Feature"};return(e.id===0||e.id)&&(n.id=e.id),e.bbox&&(n.bbox=e.bbox),n.properties=t||{},n.geometry=i,n}function T(i,t,e={}){for(const r of i){if(r.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(r[r.length-1].length!==r[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<r[r.length-1].length;o++)if(r[r.length-1][o]!==r[0][o])throw new Error("First and last Position are not equivalent.")}return b({type:"Polygon",coordinates:i},t,e)}function V(i,t={}){const e={type:"FeatureCollection"};return t.id&&(e.id=t.id),t.bbox&&(e.bbox=t.bbox),e.features=i,e}function wt(i,t,e={}){return b({type:"MultiPolygon",coordinates:i},t,e)}/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 *//*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */function Zt(i,t){var e={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},n,r,o,u;return u={next:s(0),throw:s(1),return:s(2)},typeof Symbol=="function"&&(u[Symbol.iterator]=function(){return this}),u;function s(f){return function(g){return c([f,g])}}function c(f){if(n)throw new TypeError("Generator is already executing.");for(;e;)try{if(n=1,r&&(o=f[0]&2?r.return:f[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,f[1])).done)return o;switch(r=0,o&&(f=[f[0]&2,o.value]),f[0]){case 0:case 1:o=f;break;case 4:return e.label++,{value:f[1],done:!1};case 5:e.label++,r=f[1],f=[0];continue;case 7:f=e.ops.pop(),e.trys.pop();continue;default:if(o=e.trys,!(o=o.length>0&&o[o.length-1])&&(f[0]===6||f[0]===2)){e=0;continue}if(f[0]===3&&(!o||f[1]>o[0]&&f[1]<o[3])){e.label=f[1];break}if(f[0]===6&&e.label<o[1]){e.label=o[1],o=f;break}if(o&&e.label<o[2]){e.label=o[2],e.ops.push(f);break}o[2]&&e.ops.pop(),e.trys.pop();continue}f=t.call(i,e)}catch(g){f=[6,g],r=0}finally{n=o=0}if(f[0]&5)throw f[1];return{value:f[0]?f[1]:void 0,done:!0}}}var z=function(){function i(t,e){this.next=null,this.key=t,this.data=e,this.left=null,this.right=null}return i}();function Wt(i,t){return i>t?1:i<t?-1:0}function F(i,t,e){for(var n=new z(null,null),r=n,o=n;;){var u=e(i,t.key);if(u<0){if(t.left===null)break;if(e(i,t.left.key)<0){var s=t.left;if(t.left=s.right,s.right=t,t=s,t.left===null)break}o.left=t,o=t,t=t.left}else if(u>0){if(t.right===null)break;if(e(i,t.right.key)>0){var s=t.right;if(t.right=s.left,s.left=t,t=s,t.right===null)break}r.right=t,r=t,t=t.right}else break}return r.right=t.left,o.left=t.right,t.left=n.right,t.right=n.left,t}function ot(i,t,e,n){var r=new z(i,t);if(e===null)return r.left=r.right=null,r;e=F(i,e,n);var o=n(i,e.key);return o<0?(r.left=e.left,r.right=e,e.left=null):o>=0&&(r.right=e.right,r.left=e,e.right=null),r}function Et(i,t,e){var n=null,r=null;if(t){t=F(i,t,e);var o=e(t.key,i);o===0?(n=t.left,r=t.right):o<0?(r=t.right,t.right=null,n=t):(n=t.left,t.left=null,r=t)}return{left:n,right:r}}function Jt(i,t,e){return t===null?i:(i===null||(t=F(i.key,t,e),t.left=i),t)}function st(i,t,e,n,r){if(i){n(""+t+(e?"└── ":"├── ")+r(i)+`
`);var o=t+(e?"    ":"│   ");i.left&&st(i.left,o,!1,n,r),i.right&&st(i.right,o,!0,n,r)}}var lt=function(){function i(t){t===void 0&&(t=Wt),this._root=null,this._size=0,this._comparator=t}return i.prototype.insert=function(t,e){return this._size++,this._root=ot(t,e,this._root,this._comparator)},i.prototype.add=function(t,e){var n=new z(t,e);this._root===null&&(n.left=n.right=null,this._size++,this._root=n);var r=this._comparator,o=F(t,this._root,r),u=r(t,o.key);return u===0?this._root=o:(u<0?(n.left=o.left,n.right=o,o.left=null):u>0&&(n.right=o.right,n.left=o,o.right=null),this._size++,this._root=n),this._root},i.prototype.remove=function(t){this._root=this._remove(t,this._root,this._comparator)},i.prototype._remove=function(t,e,n){var r;if(e===null)return null;e=F(t,e,n);var o=n(t,e.key);return o===0?(e.left===null?r=e.right:(r=F(t,e.left,n),r.right=e.right),this._size--,r):e},i.prototype.pop=function(){var t=this._root;if(t){for(;t.left;)t=t.left;return this._root=F(t.key,this._root,this._comparator),this._root=this._remove(t.key,this._root,this._comparator),{key:t.key,data:t.data}}return null},i.prototype.findStatic=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(r===0)return e;r<0?e=e.left:e=e.right}return null},i.prototype.find=function(t){return this._root&&(this._root=F(t,this._root,this._comparator),this._comparator(t,this._root.key)!==0)?null:this._root},i.prototype.contains=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(r===0)return!0;r<0?e=e.left:e=e.right}return!1},i.prototype.forEach=function(t,e){for(var n=this._root,r=[],o=!1;!o;)n!==null?(r.push(n),n=n.left):r.length!==0?(n=r.pop(),t.call(e,n),n=n.right):o=!0;return this},i.prototype.range=function(t,e,n,r){for(var o=[],u=this._comparator,s=this._root,c;o.length!==0||s;)if(s)o.push(s),s=s.left;else{if(s=o.pop(),c=u(s.key,e),c>0)break;if(u(s.key,t)>=0&&n.call(r,s))return this;s=s.right}return this},i.prototype.keys=function(){var t=[];return this.forEach(function(e){var n=e.key;return t.push(n)}),t},i.prototype.values=function(){var t=[];return this.forEach(function(e){var n=e.data;return t.push(n)}),t},i.prototype.min=function(){return this._root?this.minNode(this._root).key:null},i.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},i.prototype.minNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.left;)t=t.left;return t},i.prototype.maxNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.right;)t=t.right;return t},i.prototype.at=function(t){for(var e=this._root,n=!1,r=0,o=[];!n;)if(e)o.push(e),e=e.left;else if(o.length>0){if(e=o.pop(),r===t)return e;r++,e=e.right}else n=!0;return null},i.prototype.next=function(t){var e=this._root,n=null;if(t.right){for(n=t.right;n.left;)n=n.left;return n}for(var r=this._comparator;e;){var o=r(t.key,e.key);if(o===0)break;o<0?(n=e,e=e.left):e=e.right}return n},i.prototype.prev=function(t){var e=this._root,n=null;if(t.left!==null){for(n=t.left;n.right;)n=n.right;return n}for(var r=this._comparator;e;){var o=r(t.key,e.key);if(o===0)break;o<0?e=e.left:(n=e,e=e.right)}return n},i.prototype.clear=function(){return this._root=null,this._size=0,this},i.prototype.toList=function(){return Ht(this._root)},i.prototype.load=function(t,e,n){e===void 0&&(e=[]),n===void 0&&(n=!1);var r=t.length,o=this._comparator;if(n&&ct(t,e,0,r-1,o),this._root===null)this._root=ut(t,e,0,r),this._size=r;else{var u=te(this.toList(),Kt(t,e),o);r=this._size+r,this._root=ft({head:u},0,r)}return this},i.prototype.isEmpty=function(){return this._root===null},Object.defineProperty(i.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),i.prototype.toString=function(t){t===void 0&&(t=function(n){return String(n.key)});var e=[];return st(this._root,"",!0,function(n){return e.push(n)},t),e.join("")},i.prototype.update=function(t,e,n){var r=this._comparator,o=Et(t,this._root,r),u=o.left,s=o.right;r(t,e)<0?s=ot(e,n,s,r):u=ot(e,n,u,r),this._root=Jt(u,s,r)},i.prototype.split=function(t){return Et(t,this._root,this._comparator)},i.prototype[Symbol.iterator]=function(){var t,e,n;return Zt(this,function(r){switch(r.label){case 0:t=this._root,e=[],n=!1,r.label=1;case 1:return n?[3,6]:t===null?[3,2]:(e.push(t),t=t.left,[3,5]);case 2:return e.length===0?[3,4]:(t=e.pop(),[4,t]);case 3:return r.sent(),t=t.right,[3,5];case 4:n=!0,r.label=5;case 5:return[3,1];case 6:return[2]}})},i}();function ut(i,t,e,n){var r=n-e;if(r>0){var o=e+Math.floor(r/2),u=i[o],s=t[o],c=new z(u,s);return c.left=ut(i,t,e,o),c.right=ut(i,t,o+1,n),c}return null}function Kt(i,t){for(var e=new z(null,null),n=e,r=0;r<i.length;r++)n=n.next=new z(i[r],t[r]);return n.next=null,e.next}function Ht(i){for(var t=i,e=[],n=!1,r=new z(null,null),o=r;!n;)t?(e.push(t),t=t.left):e.length>0?(t=o=o.next=e.pop(),t=t.right):n=!0;return o.next=null,r.next}function ft(i,t,e){var n=e-t;if(n>0){var r=t+Math.floor(n/2),o=ft(i,t,r),u=i.head;return u.left=o,i.head=i.head.next,u.right=ft(i,r+1,e),u}return null}function te(i,t,e){for(var n=new z(null,null),r=n,o=i,u=t;o!==null&&u!==null;)e(o.key,u.key)<0?(r.next=o,o=o.next):(r.next=u,u=u.next),r=r.next;return o!==null?r.next=o:u!==null&&(r.next=u),n.next}function ct(i,t,e,n,r){if(!(e>=n)){for(var o=i[e+n>>1],u=e-1,s=n+1;;){do u++;while(r(i[u],o)<0);do s--;while(r(i[s],o)>0);if(u>=s)break;var c=i[u];i[u]=i[s],i[s]=c,c=t[u],t[u]=t[s],t[s]=c}ct(i,t,e,s,r),ct(i,t,s+1,n,r)}}const N=11102230246251565e-32,_=134217729,ee=(3+8*N)*N;function ht(i,t,e,n,r){let o,u,s,c,f=t[0],g=n[0],l=0,h=0;g>f==g>-f?(o=f,f=t[++l]):(o=g,g=n[++h]);let a=0;if(l<i&&h<e)for(g>f==g>-f?(u=f+o,s=o-(u-f),f=t[++l]):(u=g+o,s=o-(u-g),g=n[++h]),o=u,s!==0&&(r[a++]=s);l<i&&h<e;)g>f==g>-f?(u=o+f,c=u-o,s=o-(u-c)+(f-c),f=t[++l]):(u=o+g,c=u-o,s=o-(u-c)+(g-c),g=n[++h]),o=u,s!==0&&(r[a++]=s);for(;l<i;)u=o+f,c=u-o,s=o-(u-c)+(f-c),f=t[++l],o=u,s!==0&&(r[a++]=s);for(;h<e;)u=o+g,c=u-o,s=o-(u-c)+(g-c),g=n[++h],o=u,s!==0&&(r[a++]=s);return(o!==0||a===0)&&(r[a++]=o),a}function ne(i,t){let e=t[0];for(let n=1;n<i;n++)e+=t[n];return e}function G(i){return new Float64Array(i)}const ie=(3+16*N)*N,re=(2+12*N)*N,oe=(9+64*N)*N*N,U=G(4),mt=G(8),bt=G(12),_t=G(16),P=G(4);function se(i,t,e,n,r,o,u){let s,c,f,g,l,h,a,d,x,y,p,v,E,w,m,S,k,M;const I=i-r,$=e-r,A=t-o,O=n-o;w=I*O,h=_*I,a=h-(h-I),d=I-a,h=_*O,x=h-(h-O),y=O-x,m=d*y-(w-a*x-d*x-a*y),S=A*$,h=_*A,a=h-(h-A),d=A-a,h=_*$,x=h-(h-$),y=$-x,k=d*y-(S-a*x-d*x-a*y),p=m-k,l=m-p,U[0]=m-(p+l)+(l-k),v=w+p,l=v-w,E=w-(v-l)+(p-l),p=E-S,l=E-p,U[1]=E-(p+l)+(l-S),M=v+p,l=M-v,U[2]=v-(M-l)+(p-l),U[3]=M;let B=ne(4,U),H=re*u;if(B>=H||-B>=H||(l=i-I,s=i-(I+l)+(l-r),l=e-$,f=e-($+l)+(l-r),l=t-A,c=t-(A+l)+(l-o),l=n-O,g=n-(O+l)+(l-o),s===0&&c===0&&f===0&&g===0)||(H=oe*u+ee*Math.abs(B),B+=I*g+O*s-(A*f+$*c),B>=H||-B>=H))return B;w=s*O,h=_*s,a=h-(h-s),d=s-a,h=_*O,x=h-(h-O),y=O-x,m=d*y-(w-a*x-d*x-a*y),S=c*$,h=_*c,a=h-(h-c),d=c-a,h=_*$,x=h-(h-$),y=$-x,k=d*y-(S-a*x-d*x-a*y),p=m-k,l=m-p,P[0]=m-(p+l)+(l-k),v=w+p,l=v-w,E=w-(v-l)+(p-l),p=E-S,l=E-p,P[1]=E-(p+l)+(l-S),M=v+p,l=M-v,P[2]=v-(M-l)+(p-l),P[3]=M;const Ve=ht(4,U,4,P,mt);w=I*g,h=_*I,a=h-(h-I),d=I-a,h=_*g,x=h-(h-g),y=g-x,m=d*y-(w-a*x-d*x-a*y),S=A*f,h=_*A,a=h-(h-A),d=A-a,h=_*f,x=h-(h-f),y=f-x,k=d*y-(S-a*x-d*x-a*y),p=m-k,l=m-p,P[0]=m-(p+l)+(l-k),v=w+p,l=v-w,E=w-(v-l)+(p-l),p=E-S,l=E-p,P[1]=E-(p+l)+(l-S),M=v+p,l=M-v,P[2]=v-(M-l)+(p-l),P[3]=M;const Ge=ht(Ve,mt,4,P,bt);w=s*g,h=_*s,a=h-(h-s),d=s-a,h=_*g,x=h-(h-g),y=g-x,m=d*y-(w-a*x-d*x-a*y),S=c*f,h=_*c,a=h-(h-c),d=c-a,h=_*f,x=h-(h-f),y=f-x,k=d*y-(S-a*x-d*x-a*y),p=m-k,l=m-p,P[0]=m-(p+l)+(l-k),v=w+p,l=v-w,E=w-(v-l)+(p-l),p=E-S,l=E-p,P[1]=E-(p+l)+(l-S),M=v+p,l=M-v,P[2]=v-(M-l)+(p-l),P[3]=M;const Ze=ht(Ge,bt,4,P,_t);return _t[Ze-1]}function le(i,t,e,n,r,o){const u=(t-o)*(e-r),s=(i-r)*(n-o),c=u-s,f=Math.abs(u+s);return Math.abs(c)>=ie*f?c:-se(i,t,e,n,r,o,f)}const Z=(i,t)=>i.ll.x<=t.x&&t.x<=i.ur.x&&i.ll.y<=t.y&&t.y<=i.ur.y,at=(i,t)=>{if(t.ur.x<i.ll.x||i.ur.x<t.ll.x||t.ur.y<i.ll.y||i.ur.y<t.ll.y)return null;const e=i.ll.x<t.ll.x?t.ll.x:i.ll.x,n=i.ur.x<t.ur.x?i.ur.x:t.ur.x,r=i.ll.y<t.ll.y?t.ll.y:i.ll.y,o=i.ur.y<t.ur.y?i.ur.y:t.ur.y;return{ll:{x:e,y:r},ur:{x:n,y:o}}};let j=Number.EPSILON;j===void 0&&(j=Math.pow(2,-52));const ue=j*j,St=(i,t)=>{if(-j<i&&i<j&&-j<t&&t<j)return 0;const e=i-t;return e*e<ue*i*t?0:i<t?-1:1};class fe{constructor(){this.reset()}reset(){this.xRounder=new Mt,this.yRounder=new Mt}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}}class Mt{constructor(){this.tree=new lt,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(n!==null&&St(e.key,n.key)===0)return this.tree.remove(t),n.key;const r=this.tree.next(e);return r!==null&&St(e.key,r.key)===0?(this.tree.remove(t),r.key):t}}const W=new fe,tt=(i,t)=>i.x*t.y-i.y*t.x,Pt=(i,t)=>i.x*t.x+i.y*t.y,Lt=(i,t,e)=>{const n=le(i.x,i.y,t.x,t.y,e.x,e.y);return n>0?-1:n<0?1:0},et=i=>Math.sqrt(Pt(i,i)),ce=(i,t,e)=>{const n={x:t.x-i.x,y:t.y-i.y},r={x:e.x-i.x,y:e.y-i.y};return tt(r,n)/et(r)/et(n)},he=(i,t,e)=>{const n={x:t.x-i.x,y:t.y-i.y},r={x:e.x-i.x,y:e.y-i.y};return Pt(r,n)/et(r)/et(n)},Rt=(i,t,e)=>t.y===0?null:{x:i.x+t.x/t.y*(e-i.y),y:e},kt=(i,t,e)=>t.x===0?null:{x:e,y:i.y+t.y/t.x*(e-i.x)},ae=(i,t,e,n)=>{if(t.x===0)return kt(e,n,i.x);if(n.x===0)return kt(i,t,e.x);if(t.y===0)return Rt(e,n,i.y);if(n.y===0)return Rt(i,t,e.y);const r=tt(t,n);if(r==0)return null;const o={x:e.x-i.x,y:e.y-i.y},u=tt(o,t)/r,s=tt(o,n)/r,c=i.x+s*t.x,f=e.x+u*n.x,g=i.y+s*t.y,l=e.y+u*n.y,h=(c+f)/2,a=(g+l)/2;return{x:h,y:a}};class R{static compare(t,e){const n=R.comparePoints(t.point,e.point);return n!==0?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:q.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){t.events===void 0?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let n=0,r=e.length;n<r;n++){const o=e[n];this.point.events.push(o),o.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(n.segment.consumedBy===void 0)for(let r=e+1;r<t;r++){const o=this.point.events[r];o.consumedBy===void 0&&n.otherSE.point.events===o.otherSE.point.events&&n.segment.consume(o.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const r=this.point.events[e];r!==this&&!r.segment.ringOut&&r.segment.isInResult()&&t.push(r)}return t}getLeftmostComparator(t){const e=new Map,n=r=>{const o=r.otherSE;e.set(r,{sine:ce(this.point,t.point,o.point),cosine:he(this.point,t.point,o.point)})};return(r,o)=>{e.has(r)||n(r),e.has(o)||n(o);const{sine:u,cosine:s}=e.get(r),{sine:c,cosine:f}=e.get(o);return u>=0&&c>=0?s<f?1:s>f?-1:0:u<0&&c<0?s<f?-1:s>f?1:0:c<u?-1:c>u?1:0}}}let ge=0;class q{static compare(t,e){const n=t.leftSE.point.x,r=e.leftSE.point.x,o=t.rightSE.point.x,u=e.rightSE.point.x;if(u<n)return 1;if(o<r)return-1;const s=t.leftSE.point.y,c=e.leftSE.point.y,f=t.rightSE.point.y,g=e.rightSE.point.y;if(n<r){if(c<s&&c<f)return 1;if(c>s&&c>f)return-1;const l=t.comparePoint(e.leftSE.point);if(l<0)return 1;if(l>0)return-1;const h=e.comparePoint(t.rightSE.point);return h!==0?h:-1}if(n>r){if(s<c&&s<g)return-1;if(s>c&&s>g)return 1;const l=e.comparePoint(t.leftSE.point);if(l!==0)return l;const h=t.comparePoint(e.rightSE.point);return h<0?1:h>0?-1:1}if(s<c)return-1;if(s>c)return 1;if(o<u){const l=e.comparePoint(t.rightSE.point);if(l!==0)return l}if(o>u){const l=t.comparePoint(e.rightSE.point);if(l<0)return 1;if(l>0)return-1}if(o!==u){const l=f-s,h=o-n,a=g-c,d=u-r;if(l>h&&a<d)return 1;if(l<h&&a>d)return-1}return o>u?1:o<u||f<g?-1:f>g?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,r){this.id=++ge,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=r}static fromRing(t,e,n){let r,o,u;const s=R.comparePoints(t,e);if(s<0)r=t,o=e,u=1;else if(s>0)r=e,o=t,u=-1;else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);const c=new R(r,!0),f=new R(o,!1);return new q(c,f,[n],[u])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,r=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const o=(t.y-e.y)/r.y,u=e.x+o*r.x;if(t.x===u)return 0;const s=(t.x-e.x)/r.x,c=e.y+s*r.y;return t.y===c?0:t.y<c?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),r=at(e,n);if(r===null)return null;const o=this.leftSE.point,u=this.rightSE.point,s=t.leftSE.point,c=t.rightSE.point,f=Z(e,s)&&this.comparePoint(s)===0,g=Z(n,o)&&t.comparePoint(o)===0,l=Z(e,c)&&this.comparePoint(c)===0,h=Z(n,u)&&t.comparePoint(u)===0;if(g&&f)return h&&!l?u:!h&&l?c:null;if(g)return l&&o.x===c.x&&o.y===c.y?null:o;if(f)return h&&u.x===s.x&&u.y===s.y?null:s;if(h&&l)return null;if(h)return u;if(l)return c;const a=ae(o,this.vector(),s,t.vector());return a===null||!Z(r,a)?null:W.round(a.x,a.y)}split(t){const e=[],n=t.events!==void 0,r=new R(t,!0),o=new R(t,!1),u=this.rightSE;this.replaceRightSE(o),e.push(o),e.push(r);const s=new q(r,u,this.rings.slice(),this.windings.slice());return R.comparePoints(s.leftSE.point,s.rightSE.point)>0&&s.swapEvents(),R.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(r.checkForConsuming(),o.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const r=q.compare(e,n);if(r!==0){if(r>0){const o=e;e=n,n=o}if(e.prev===n){const o=e;e=n,n=o}for(let o=0,u=n.rings.length;o<u;o++){const s=n.rings[o],c=n.windings[o],f=e.rings.indexOf(s);f===-1?(e.rings.push(s),e.windings.push(c)):e.windings[f]+=c}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}beforeState(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else{const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}return this._beforeState}afterState(){if(this._afterState!==void 0)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,r=this._afterState.multiPolys;for(let s=0,c=this.rings.length;s<c;s++){const f=this.rings[s],g=this.windings[s],l=e.indexOf(f);l===-1?(e.push(f),n.push(g)):n[l]+=g}const o=[],u=[];for(let s=0,c=e.length;s<c;s++){if(n[s]===0)continue;const f=e[s],g=f.poly;if(u.indexOf(g)===-1)if(f.isExterior)o.push(g);else{u.indexOf(g)===-1&&u.push(g);const l=o.indexOf(f.poly);l!==-1&&o.splice(l,1)}}for(let s=0,c=o.length;s<c;s++){const f=o[s].multiPoly;r.indexOf(f)===-1&&r.push(f)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(this._isInResult!==void 0)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(C.type){case"union":{const n=t.length===0,r=e.length===0;this._isInResult=n!==r;break}case"intersection":{let n,r;t.length<e.length?(n=t.length,r=e.length):(n=e.length,r=t.length),this._isInResult=r===C.numMultiPolys&&n<r;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2===1;break}case"difference":{const n=r=>r.length===1&&r[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${C.type}`)}return this._isInResult}}class Ct{constructor(t,e,n){if(!Array.isArray(t)||t.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],typeof t[0][0]!="number"||typeof t[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const r=W.round(t[0][0],t[0][1]);this.bbox={ll:{x:r.x,y:r.y},ur:{x:r.x,y:r.y}};let o=r;for(let u=1,s=t.length;u<s;u++){if(typeof t[u][0]!="number"||typeof t[u][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let c=W.round(t[u][0],t[u][1]);c.x===o.x&&c.y===o.y||(this.segments.push(q.fromRing(o,c,this)),c.x<this.bbox.ll.x&&(this.bbox.ll.x=c.x),c.y<this.bbox.ll.y&&(this.bbox.ll.y=c.y),c.x>this.bbox.ur.x&&(this.bbox.ur.x=c.x),c.y>this.bbox.ur.y&&(this.bbox.ur.y=c.y),o=c)}(r.x!==o.x||r.y!==o.y)&&this.segments.push(q.fromRing(o,r,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const r=this.segments[e];t.push(r.leftSE),t.push(r.rightSE)}return t}}class pe{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new Ct(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,r=t.length;n<r;n++){const o=new Ct(t[n],this,!1);o.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=o.bbox.ll.x),o.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=o.bbox.ll.y),o.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=o.bbox.ur.x),o.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=o.bbox.ur.y),this.interiorRings.push(o)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const r=this.interiorRings[e].getSweepEvents();for(let o=0,u=r.length;o<u;o++)t.push(r[o])}return t}}class It{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof t[0][0][0]=="number"&&(t=[t])}catch{}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let n=0,r=t.length;n<r;n++){const o=new pe(t[n],this);o.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=o.bbox.ll.x),o.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=o.bbox.ll.y),o.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=o.bbox.ur.x),o.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=o.bbox.ur.y),this.polys.push(o)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const r=this.polys[e].getSweepEvents();for(let o=0,u=r.length;o<u;o++)t.push(r[o])}return t}}class nt{static factory(t){const e=[];for(let n=0,r=t.length;n<r;n++){const o=t[n];if(!o.isInResult()||o.ringOut)continue;let u=null,s=o.leftSE,c=o.rightSE;const f=[s],g=s.point,l=[];for(;u=s,s=c,f.push(s),s.point!==g;)for(;;){const h=s.getAvailableLinkedEvents();if(h.length===0){const x=f[0].point,y=f[f.length-1].point;throw new Error(`Unable to complete output ring starting at [${x.x}, ${x.y}]. Last matching segment found ends at [${y.x}, ${y.y}].`)}if(h.length===1){c=h[0].otherSE;break}let a=null;for(let x=0,y=l.length;x<y;x++)if(l[x].point===s.point){a=x;break}if(a!==null){const x=l.splice(a)[0],y=f.splice(x.index);y.unshift(y[0].otherSE),e.push(new nt(y.reverse()));continue}l.push({index:f.length,point:s.point});const d=s.getLeftmostComparator(u);c=h.sort(d)[0].otherSE;break}e.push(new nt(f))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let f=1,g=this.events.length-1;f<g;f++){const l=this.events[f].point,h=this.events[f+1].point;Lt(l,t,h)!==0&&(e.push(l),t=l)}if(e.length===1)return null;const n=e[0],r=e[1];Lt(n,t,r)===0&&e.shift(),e.push(e[0]);const o=this.isExteriorRing()?1:-1,u=this.isExteriorRing()?0:e.length-1,s=this.isExteriorRing()?e.length:-1,c=[];for(let f=u;f!=s;f+=o)c.push([e[f].x,e[f].y]);return c}isExteriorRing(){if(this._isExteriorRing===void 0){const t=this.enclosingRing();this._isExteriorRing=t?!t.isExteriorRing():!0}return this._isExteriorRing}enclosingRing(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let r=1,o=this.events.length;r<o;r++){const u=this.events[r];R.compare(t,u)>0&&(t=u)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class $t{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(t[0]===null)return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const r=this.interiorRings[e].getGeom();r!==null&&t.push(r)}return t}}class ye{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const r=this.polys[e].getGeom();r!==null&&t.push(r)}return t}_composePolys(t){const e=[];for(let n=0,r=t.length;n<r;n++){const o=t[n];if(!o.poly)if(o.isExteriorRing())e.push(new $t(o));else{const u=o.enclosingRing();u.poly||e.push(new $t(u)),u.poly.addInterior(o)}}return e}}class de{constructor(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:q.compare;this.queue=t,this.tree=new lt(e),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const r=t.isLeft?this.tree.add(e):this.tree.find(e);if(!r)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let o=r,u=r,s,c;for(;s===void 0;)o=this.tree.prev(o),o===null?s=null:o.key.consumedBy===void 0&&(s=o.key);for(;c===void 0;)u=this.tree.next(u),u===null?c=null:u.key.consumedBy===void 0&&(c=u.key);if(t.isLeft){let f=null;if(s){const l=s.getIntersection(e);if(l!==null&&(e.isAnEndpoint(l)||(f=l),!s.isAnEndpoint(l))){const h=this._splitSafely(s,l);for(let a=0,d=h.length;a<d;a++)n.push(h[a])}}let g=null;if(c){const l=c.getIntersection(e);if(l!==null&&(e.isAnEndpoint(l)||(g=l),!c.isAnEndpoint(l))){const h=this._splitSafely(c,l);for(let a=0,d=h.length;a<d;a++)n.push(h[a])}}if(f!==null||g!==null){let l=null;f===null?l=g:g===null?l=f:l=R.comparePoints(f,g)<=0?f:g,this.queue.remove(e.rightSE),n.push(e.rightSE);const h=e.split(l);for(let a=0,d=h.length;a<d;a++)n.push(h[a])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=s)}else{if(s&&c){const f=s.getIntersection(c);if(f!==null){if(!s.isAnEndpoint(f)){const g=this._splitSafely(s,f);for(let l=0,h=g.length;l<h;l++)n.push(g[l])}if(!c.isAnEndpoint(f)){const g=this._splitSafely(c,f);for(let l=0,h=g.length;l<h;l++)n.push(g[l])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const r=t.split(e);return r.push(n),t.consumedBy===void 0&&this.tree.add(t),r}}const At=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,xe=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;class ve{run(t,e,n){C.type=t,W.reset();const r=[new It(e,!0)];for(let l=0,h=n.length;l<h;l++)r.push(new It(n[l],!1));if(C.numMultiPolys=r.length,C.type==="difference"){const l=r[0];let h=1;for(;h<r.length;)at(r[h].bbox,l.bbox)!==null?h++:r.splice(h,1)}if(C.type==="intersection")for(let l=0,h=r.length;l<h;l++){const a=r[l];for(let d=l+1,x=r.length;d<x;d++)if(at(a.bbox,r[d].bbox)===null)return[]}const o=new lt(R.compare);for(let l=0,h=r.length;l<h;l++){const a=r[l].getSweepEvents();for(let d=0,x=a.length;d<x;d++)if(o.insert(a[d]),o.size>At)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const u=new de(o);let s=o.size,c=o.pop();for(;c;){const l=c.key;if(o.size===s){const a=l.segment;throw new Error(`Unable to pop() ${l.isLeft?"left":"right"} SweepEvent [${l.point.x}, ${l.point.y}] from segment #${a.id} [${a.leftSE.point.x}, ${a.leftSE.point.y}] -> [${a.rightSE.point.x}, ${a.rightSE.point.y}] from queue.`)}if(o.size>At)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(u.segments.length>xe)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const h=u.process(l);for(let a=0,d=h.length;a<d;a++){const x=h[a];x.consumedBy===void 0&&o.insert(x)}s=o.size,c=o.pop()}W.reset();const f=nt.factory(u.segments);return new ye(f).getGeom()}}const C=new ve;var Ot={union:function(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return C.run("union",i,e)},intersection:function(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return C.run("intersection",i,e)},xor:function(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return C.run("xor",i,e)},difference:function(i){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return C.run("difference",i,e)}};function Nt(i,t,e){if(i!==null)for(var n,r,o,u,s,c,f,g=0,l=0,h,a=i.type,d=a==="FeatureCollection",x=a==="Feature",y=d?i.features.length:1,p=0;p<y;p++){f=d?i.features[p].geometry:x?i.geometry:i,h=f?f.type==="GeometryCollection":!1,s=h?f.geometries.length:1;for(var v=0;v<s;v++){var E=0,w=0;if(u=h?f.geometries[v]:f,u!==null){c=u.coordinates;var m=u.type;switch(g=0,m){case null:break;case"Point":if(t(c,l,p,E,w)===!1)return!1;l++,E++;break;case"LineString":case"MultiPoint":for(n=0;n<c.length;n++){if(t(c[n],l,p,E,w)===!1)return!1;l++,m==="MultiPoint"&&E++}m==="LineString"&&E++;break;case"Polygon":case"MultiLineString":for(n=0;n<c.length;n++){for(r=0;r<c[n].length-g;r++){if(t(c[n][r],l,p,E,w)===!1)return!1;l++}m==="MultiLineString"&&E++,m==="Polygon"&&w++}m==="Polygon"&&E++;break;case"MultiPolygon":for(n=0;n<c.length;n++){for(w=0,r=0;r<c[n].length;r++){for(o=0;o<c[n][r].length-g;o++){if(t(c[n][r][o],l,p,E,w)===!1)return!1;l++}w++}E++}break;case"GeometryCollection":for(n=0;n<u.geometries.length;n++)if(Nt(u.geometries[n],t)===!1)return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function gt(i,t){var e,n,r,o,u,s,c,f,g,l,h=0,a=i.type==="FeatureCollection",d=i.type==="Feature",x=a?i.features.length:1;for(e=0;e<x;e++){for(s=a?i.features[e].geometry:d?i.geometry:i,f=a?i.features[e].properties:d?i.properties:{},g=a?i.features[e].bbox:d?i.bbox:void 0,l=a?i.features[e].id:d?i.id:void 0,c=s?s.type==="GeometryCollection":!1,u=c?s.geometries.length:1,r=0;r<u;r++){if(o=c?s.geometries[r]:s,o===null){if(t(null,h,f,g,l)===!1)return!1;continue}switch(o.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":{if(t(o,h,f,g,l)===!1)return!1;break}case"GeometryCollection":{for(n=0;n<o.geometries.length;n++)if(t(o.geometries[n],h,f,g,l)===!1)return!1;break}default:throw new Error("Unknown Geometry Type")}}h++}}function we(i,t){gt(i,function(e,n,r,o,u){var s=e===null?null:e.type;switch(s){case null:case"Point":case"LineString":case"Polygon":return t(b(e,r,{bbox:o,id:u}),n,0)===!1?!1:void 0}var c;switch(s){case"MultiPoint":c="Point";break;case"MultiLineString":c="LineString";break;case"MultiPolygon":c="Polygon";break}for(var f=0;f<e.coordinates.length;f++){var g=e.coordinates[f],l={type:c,coordinates:g};if(t(b(l,r),n,f)===!1)return!1}})}function Ee(i,t={}){const e=[];if(gt(i,r=>{e.push(r.coordinates)}),e.length<2)throw new Error("Must have at least 2 geometries");const n=Ot.union(e[0],...e.slice(1));return n.length===0?null:n.length===1?T(n[0],t.properties):wt(n,t.properties)}var Bt=Ee;function J(){}function Tt(i){return i()}function zt(){return Object.create(null)}function it(i){i.forEach(Tt)}function Ft(i){return typeof i=="function"}function me(i,t){return i!=i?t==t:i!==t||i&&typeof i=="object"||typeof i=="function"}function be(i){return Object.keys(i).length===0}function _e(i,t){i.appendChild(t)}function Se(i,t,e){i.insertBefore(t,e||null)}function jt(i){i.parentNode&&i.parentNode.removeChild(i)}function qt(i){return document.createElementNS("http://www.w3.org/2000/svg",i)}function Q(i,t,e){e==null?i.removeAttribute(t):i.getAttribute(t)!==e&&i.setAttribute(t,e)}function Me(i){return Array.from(i.childNodes)}function rt(i,t,e){i.classList.toggle(t,!!e)}let pt;function K(i){pt=i}const Y=[],Qt=[];let D=[];const Ut=[],Pe=Promise.resolve();let yt=!1;function Le(){yt||(yt=!0,Pe.then(Yt))}function dt(i){D.push(i)}const xt=new Set;let X=0;function Yt(){if(X!==0)return;const i=pt;do{try{for(;X<Y.length;){const t=Y[X];X++,K(t),Re(t.$$)}}catch(t){throw Y.length=0,X=0,t}for(K(null),Y.length=0,X=0;Qt.length;)Qt.pop()();for(let t=0;t<D.length;t+=1){const e=D[t];xt.has(e)||(xt.add(e),e())}D.length=0}while(Y.length);for(;Ut.length;)Ut.pop()();yt=!1,xt.clear(),K(i)}function Re(i){if(i.fragment!==null){i.update(),it(i.before_update);const t=i.dirty;i.dirty=[-1],i.fragment&&i.fragment.p(i.ctx,t),i.after_update.forEach(dt)}}function ke(i){const t=[],e=[];D.forEach(n=>i.indexOf(n)===-1?t.push(n):e.push(n)),e.forEach(n=>n()),D=t}const Ce=new Set;function Ie(i,t){i&&i.i&&(Ce.delete(i),i.i(t))}function $e(i,t,e){const{fragment:n,after_update:r}=i.$$;n&&n.m(t,e),dt(()=>{const o=i.$$.on_mount.map(Tt).filter(Ft);i.$$.on_destroy?i.$$.on_destroy.push(...o):it(o),i.$$.on_mount=[]}),r.forEach(dt)}function Ae(i,t){const e=i.$$;e.fragment!==null&&(ke(e.after_update),it(e.on_destroy),e.fragment&&e.fragment.d(t),e.on_destroy=e.fragment=null,e.ctx=[])}function Oe(i,t){i.$$.dirty[0]===-1&&(Y.push(i),Le(),i.$$.dirty.fill(0)),i.$$.dirty[t/31|0]|=1<<t%31}function Ne(i,t,e,n,r,o,u=null,s=[-1]){const c=pt;K(i);const f=i.$$={fragment:null,ctx:[],props:o,update:J,not_equal:r,bound:zt(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(c?c.$$.context:[])),callbacks:zt(),dirty:s,skip_bound:!1,root:t.target||c.$$.root};u&&u(f.root);let g=!1;if(f.ctx=e?e(i,t.props||{},(l,h,...a)=>{const d=a.length?a[0]:h;return f.ctx&&r(f.ctx[l],f.ctx[l]=d)&&(!f.skip_bound&&f.bound[l]&&f.bound[l](d),g&&Oe(i,l)),h}):[],f.update(),g=!0,it(f.before_update),f.fragment=n?n(f.ctx):!1,t.target){if(t.hydrate){const l=Me(t.target);f.fragment&&f.fragment.l(l),l.forEach(jt)}else f.fragment&&f.fragment.c();t.intro&&Ie(i.$$.fragment),$e(i,t.target,t.anchor),Yt()}K(c)}class Be{constructor(){vt(this,"$$");vt(this,"$$set")}$destroy(){Ae(this,1),this.$destroy=J}$on(t,e){if(!Ft(e))return J;const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const r=n.indexOf(e);r!==-1&&n.splice(r,1)}}$set(t){this.$$set&&!be(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const Te="4";typeof window<"u"&&(window.__svelte||(window.__svelte={v:new Set})).v.add(Te);function ze(i){let t,e,n;return{c(){t=qt("svg"),e=qt("path"),Q(e,"stroke-width","4"),Q(e,"d","M 5,33.103579 C 5,17.607779 18.457,5 35,5 C 51.543,5 65,17.607779 65,33.103579 C 65,56.388679 40.4668,76.048179 36.6112,79.137779 C 36.3714,79.329879 36.2116,79.457979 36.1427,79.518879 C 35.8203,79.800879 35.4102,79.942779 35,79.942779 C 34.5899,79.942779 34.1797,79.800879 33.8575,79.518879 C 33.7886,79.457979 33.6289,79.330079 33.3893,79.138079 C 29.5346,76.049279 5,56.389379 5,33.103579 Z M 35.0001,49.386379 C 43.1917,49.386379 49.8323,42.646079 49.8323,34.331379 C 49.8323,26.016779 43.1917,19.276479 35.0001,19.276479 C 26.8085,19.276479 20.1679,26.016779 20.1679,34.331379 C 20.1679,42.646079 26.8085,49.386379 35.0001,49.386379 Z"),Q(e,"class","svelte-gzo3ar"),Q(t,"width",n=i[0]==="list"?20:void 0),Q(t,"viewBox","0 0 70 85"),Q(t,"fill","none"),Q(t,"class","svelte-gzo3ar"),rt(t,"in-map",i[0]!=="list"),rt(t,"list-icon",i[0]==="list")},m(r,o){Se(r,t,o),_e(t,e)},p(r,[o]){o&1&&n!==(n=r[0]==="list"?20:void 0)&&Q(t,"width",n),o&1&&rt(t,"in-map",r[0]!=="list"),o&1&&rt(t,"list-icon",r[0]==="list")},i:J,o:J,d(r){r&&jt(t)}}}function Fe(i,t,e){let{displayIn:n}=t;return i.$$set=r=>{"displayIn"in r&&e(0,n=r.displayIn)},[n]}class je extends Be{constructor(t){super(),Ne(this,t,Fe,ze,me,{displayIn:0})}}function qe(i,t={}){if(i.bbox!=null&&t.recompute!==!0)return i.bbox;const e=[1/0,1/0,-1/0,-1/0];return Nt(i,n=>{e[0]>n[0]&&(e[0]=n[0]),e[1]>n[1]&&(e[1]=n[1]),e[2]<n[0]&&(e[2]=n[0]),e[3]<n[1]&&(e[3]=n[1])}),e}var Dt=qe;function Qe(i){const t=[];if(gt(i,r=>{t.push(r.coordinates)}),t.length<2)throw new Error("Must have at least two features");const e=i.features[0].properties||{},n=Ot.difference(t[0],...t.slice(1));return n.length===0?null:n.length===1?T(n[0],e):wt(n,e)}var Ue=Qe;function Ye(i){if(!i)throw new Error("geojson is required");var t=[];return we(i,function(e){t.push(e)}),V(t)}var De=Ye;function Xt(i){const t=[...i];return t[2]<t[0]&&(Math.abs((t[0]+t[2]+360)/2)>Math.abs((t[0]-360+t[2])/2)?t[0]-=360:t[2]+=360),t}function Vt(i,t){const e=Ue(V([T([[[180,90],[-180,90],[-180,-90],[180,-90],[180,90]]]),i]));if(!e)return;e.properties={isMask:!0};const n=Xt(Dt(i)),r=(n[2]-n[0])/360/1e3,o=n[0]<-180,u=n[2]>180,s=De(i);if(s.features.length>1&&(o||u))for(const c of s.features){const f=Xt(Dt(c));if(u&&f[0]<-180+r)for(const g of c.geometry.coordinates)for(const l of g)l[0]+=360-r;if(o&&f[2]>180-r)for(const g of c.geometry.coordinates)for(const l of g)l[0]-=360-r}t(V([s.features.length<2?i:Bt(s)??i,e]))}const Gt=V([]);function Xe(i,t,e=!0,n=!0,r={},o={},u={fill:{paint:{"fill-color":"#000","fill-opacity":.1},filter:["all",["==",["geometry-type"],"Polygon"],["has","isMask"]]},line:{layout:{"line-cap":"square"},paint:{"line-width":["case",["==",["geometry-type"],"Polygon"],2,3],"line-dasharray":[1,1],"line-color":"#3170fe"},filter:["!",["has","isMask"]]}}){let s;const c=[];let f,g,l;function h(){!i.getSource("full-geom")&&(u!=null&&u.fill||u!=null&&u.line)&&i.addSource("full-geom",{type:"geojson",data:Gt}),!i.getLayer("full-geom-fill")&&(u!=null&&u.fill)&&i.addLayer({...u==null?void 0:u.fill,id:"full-geom-fill",type:"fill",source:"full-geom"}),!i.getLayer("full-geom-line")&&(u!=null&&u.line)&&i.addLayer({...u==null?void 0:u.line,id:"full-geom-line",type:"line",source:"full-geom"}),l&&x(l)}i.loaded()?h():i.once("load",()=>{h()}),i.on("styledata",()=>{h()});const a=y=>{s==null||s({type:"mapClick",coordinates:[y.lngLat.lng,y.lngLat.lat]})};function d(y=!1){if(!t)throw new Error;const p=document.createElement("div");return y&&p.classList.add("marker-interactive"),new je({props:{displayIn:"maplibre"},target:p}),new t.Marker({element:p,offset:[1,-13]})}function x(y){var p;l=y,y&&((p=i.getSource("full-geom"))==null||p.setData(y))}return{setEventHandler(y){y?(s=y,i.on("click",a)):(s=void 0,i.off("click",a))},flyTo(y,p){i.flyTo({center:y,...p?{zoom:p}:{},...r})},fitBounds(y,p,v){i.fitBounds([[y[0],y[1]],[y[2],y[3]]],{padding:p,...v?{maxZoom:v}:{},...o})},indicateReverse(y){i.getCanvasContainer().style.cursor=y?"crosshair":""},setReverseMarker(y){!t||!e||(g?y?g.setLngLat(y):(g.remove(),g=void 0):y&&(g=(typeof e=="object"?new t.Marker(e):d()).setLngLat(y).addTo(i),g.getElement().classList.add("marker-reverse")))},setMarkers(y,p){if(e){for(const v of c)v.remove();if(c.length=0,x(Gt),!!t){if(p){let v=!1;if(p.geometry.type==="GeometryCollection"){const E=p.geometry.geometries.filter(w=>w.type==="Polygon"||w.type==="MultiPolygon");t:if(E.length>0){const w=Bt(V(E.map(m=>b(m))));if(!w)break t;Vt({...p,geometry:w.geometry},x),v=!0}else{const w=p.geometry.geometries.filter(m=>m.type==="LineString"||m.type==="MultiLineString");w.length>0&&(x({...p,geometry:{type:"GeometryCollection",geometries:w}}),v=!0)}}if(!v){if(p.geometry.type==="Polygon"||p.geometry.type==="MultiPolygon")Vt(p,x);else if(p.geometry.type==="LineString"||p.geometry.type==="MultiLineString"){x(p);return}}e&&c.push((typeof e=="object"?new t.Marker(e):d()).setLngLat(p.center).addTo(i))}if(n)for(const v of y??[]){if(v===p)continue;const E=(typeof n=="object"?new t.Marker(n):d(!0)).setLngLat(v.center).setPopup(new t.Popup({offset:[1,-27],closeButton:!1,closeOnMove:!0,className:"maptiler-gc-popup"}).setText(v.place_type[0]==="reverse"?v.place_name:v.place_name.replace(/,.*/,""))).addTo(i),w=E.getElement();w.addEventListener("click",m=>{m.stopPropagation(),s==null||s({type:"markerClick",id:v.id})}),w.addEventListener("mouseenter",()=>{s==null||s({type:"markerMouseEnter",id:v.id}),E.togglePopup()}),w.addEventListener("mouseleave",()=>{s==null||s({type:"markerMouseLeave",id:v.id}),E.togglePopup()}),c.push(E)}}}},setSelectedMarker(y){f&&f.getElement().classList.toggle("marker-selected",!1),f=y>-1?c[y]:void 0,f==null||f.getElement().classList.toggle("marker-selected",!0)},getCenterAndZoom(){const y=i.getCenter();return[i.getZoom(),y.lng,y.lat]}}}L.createMapLibreGlMapController=Xe,Object.defineProperty(L,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=maplibregl-controller.umd.js.map
